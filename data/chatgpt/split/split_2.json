{
  "Weaknesses": [
    {
      "ID": "225",
      "Name": "DEPRECATED: General Information Management Problems",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness can be found at CWE-199.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "226",
      "Name": "Sensitive Information in Resource Not Removed Before Reuse",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear or \"zeroize\" the information contained in the resource before the product performs a critical state transition or makes the resource available for reuse by other entities.",
      "ExtendedDescription": "\n\nWhen resources are released, they can be made available for reuse. For example, after memory is de-allocated, an operating system may make the memory available to another process, or disk space may be reallocated when a file is deleted. As removing information requires time and additional resources, operating systems do not usually clear the previously written information.\n\n\nEven when the resource is reused by the same process, this weakness can arise when new data is not as large as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, the information may be read by less trustworthy parties when the memory is reallocated.\n\n\nThis weakness can apply in hardware, such as when a device or system switches between power, sleep, or debug states during normal operation, or when execution changes to different users or privilege levels.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "459",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "212",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "201",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Analysis",
          "Description": "Write a known pattern into each sensitive location. Trigger the release of the resource or cause the desired state transition to occur. Read data back from the sensitive locations. If the reads are successful, and the data is the same as the pattern that was originally written, the test fails and the product needs to be fixed. Note that this test can likely be automated.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "During critical state transitions, information not needed in the next state should be removed or overwritten with fixed patterns (such as all 0's) or random data, before the transition to the next state.",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "When releasing, de-allocating, or deleting a resource, overwrite its data and relevant metadata with fixed patterns or random data. Be cautious about complex resource types whose underlying representation might be non-contiguous or change at a low level, such as how a file might be split into different chunks on a file system, even though \"logical\" file positions are contiguous at the application layer. Such resource types might require invocation of special modes or APIs to tell the underlying operating system to perform the necessary clearing, such as SDelete (Secure Delete) on Windows, although the appropriate functionality might not be available at the application layer.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-147",
          "Entries": [
            {
              "IntroText": "This example shows how an attacker can take advantage of an incorrect state transition."
            },
            {
              "BodyText": "Suppose a device is transitioning from state A to state B. During state A, it can read certain private keys from the hidden fuses that are only accessible in state A but not in state B. The device reads the keys, performs operations using those keys, then transitions to state B, where those private keys should no longer be accessible."
            },
            {
              "Nature": "Bad",
              "ExampleCode": "During the transition from A to B, the device does not scrub the memory."
            },
            {
              "BodyText": "After the transition to state B, even though the private keys are no longer accessible directly from the fuses in state B, they can be accessed indirectly by reading the memory that contains the private keys."
            },
            {
              "Nature": "Good",
              "ExampleCode": "For transition from state A to state B, remove information which should not be available once the transition is complete."
            }
          ]
        },
        {
          "ID": "DX-148",
          "Entries": [
            {
              "IntroText": "The following code calls realloc() on a buffer containing sensitive data:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tcleartext_buffer = get_secret();...\n\tcleartext_buffer = realloc(cleartext_buffer, 1024);\n\t...\n\tscrub_memory(cleartext_buffer, 1024);\n```"
            },
            {
              "BodyText": "There is an attempt to scrub the sensitive data from memory, but realloc() is used, so it could return a pointer to a different part of memory. The memory that was originally allocated for cleartext_buffer could still contain an uncleared copy of the data."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following example code is excerpted from the AES wrapper/interface, aes0_wrapper, module of one of the AES engines (AES0) in the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Note that this SoC contains three distinct AES engines. Within this wrapper module, four 32-bit registers are utilized to store the message intended for encryption, referred to as p_c[i]. Using the AXI Lite interface, these registers are filled with the 128-bit message to be encrypted."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "module aes0_wrapper #(...)(...);\n ...\n always @(posedge clk_i)\n\n```\n\t begin\n\t\t if(~(rst_ni && ~rst_1)) //clear p_c[i] at reset\n\t\t\t begin\n\t\t\t\t start <= 0;\n\t\t\t\t p_c[0] <= 0;\n\t\t\t\t p_c[1] <= 0;\n\t\t\t\t p_c[2] <= 0;\n\t\t\t\t p_c[3] <= 0;\n\t\t\t\t ...\n\t\t\t end\n\t\t else if(en && we)\n\t\t\t case(address[8:3])\n\t\t\t\t 0:\n\t\t\t\t\t start <= reglk_ctrl_i[1] ? start : wdata[0];\n\t\t\t\t 1:\n```\np_c[3] <= reglk_ctrl_i[3] ? p_c[3] : wdata[31:0];** \n\t\t\t\t\t 2:\n\t\t\t\t\n\t\t\t\t```\n```\np_c[2] <= reglk_ctrl_i[3] ? p_c[2] : wdata[31:0];** \n\t\t\t\t\t 3:\n\t\t\t\t\n\t\t\t\t```\n```\np_c[1] <= reglk_ctrl_i[3] ? p_c[1] : wdata[31:0];** \n\t\t\t\t\t 4:\n\t\t\t\t\n\t\t\t\t```\n```\np_c[0] <= reglk_ctrl_i[3] ? p_c[0] : wdata[31:0];** \n\t\t\t\t\t ...\n\t\t\t\t endcase\n\t\t\t end // always @ (posedge wb_clk_i)\n\t\t endmodule"
            },
            {
              "BodyText": "The above code snippet [REF-1402] illustrates an instance of a vulnerable implementation of the AES wrapper module, where p_c[i] registers are cleared at reset. Otherwise, p_c[i]registers either maintain their old values (if reglk_ctrl_i[3]is true) or get filled through the AXI signal wdata. Note that p_c[i]registers can be read through the AXI Lite interface (not shown in snippet). However, p_c[i] registers are never cleared after their usage once the AES engine has completed the encryption process of the message. In a multi-user or multi-process environment, not clearing registers may result in the attacker process accessing data left by the victim, leading to data leakage or unintentional information disclosure.\n\n\nTo fix this issue, it is essential to ensure that these internal registers are cleared in a timely manner after their usage, i.e., the encryption process is complete. This is illustrated below by monitoring the assertion of the cipher text valid signal, ct_valid [REF-1403]."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "module aes0_wrapper #(...)(...);\n ...\n always @(posedge clk_i)\n\n```\n\t begin\n\t\t if(~(rst_ni && ~rst_1)) //clear p_c[i] at reset\n\t\t\t ...\n```\nelse if(ct_valid) //encryption process complete, clear p_c[i]** \n\t\t\n\t\t```\n```\nbegin** \n\t\t\t\n\t\t\t```\n```\np_c[0] <= 0;** \n\t\t\t\t\n\t\t\t\t **p_c[1] <= 0;** \n\t\t\t\t\n\t\t\t\t **p_c[2] <= 0;** \n\t\t\t\t\n\t\t\t\t **p_c[3] <= 0;** \n\t\t\t\t\n\t\t\t **end** \n\t\t\t else if(en && we)\n\t\t\n\t\t```\n\t\t\t case(address[8:3])\n\t\t\t ...\n\t\t\t endcase\n\t\t end // always @ (posedge wb_clk_i)\n\t endmodule\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-3733",
          "Description": "Cryptography library does not clear heap memory before release",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-3733"
        },
        {
          "Reference": "CVE-2003-0001",
          "Description": "Ethernet NIC drivers do not pad frames with null bytes, leading to infoleak from malformed packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0001"
        },
        {
          "Reference": "CVE-2003-0291",
          "Description": "router does not clear information from DHCP packets that have been previously used",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0291"
        },
        {
          "Reference": "CVE-2005-1406",
          "Description": "Products do not fully clear memory buffers when less data is stored into the buffer than previous.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1406"
        },
        {
          "Reference": "CVE-2005-1858",
          "Description": "Products do not fully clear memory buffers when less data is stored into the buffer than previous.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1858"
        },
        {
          "Reference": "CVE-2005-3180",
          "Description": "Products do not fully clear memory buffers when less data is stored into the buffer than previous.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3180"
        },
        {
          "Reference": "CVE-2005-3276",
          "Description": "Product does not clear a data structure before writing to part of it, yielding information leak of previously used memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3276"
        },
        {
          "Reference": "CVE-2002-2077",
          "Description": "Memory not properly cleared before reuse.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2077"
        }
      ],
      "FunctionalAreas": [
        "Memory Management",
        "Networking"
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Sensitive Information Uncleared Before Use"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM03-C",
          "EntryName": "Clear sensitive information stored in reusable resources returned for reuse"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "37"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1402",
          "Title": "aes0_wrapper.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/aes0/aes0_wrapper.sv#L84C2-L90C29",
          "URLDate": "2024-02-14"
        },
        {
          "ExternalReferenceID": "REF-1403",
          "Title": "Fix for aes0_wrapper",
          "PublicationYear": "2023",
          "PublicationMonth": "11",
          "PublicationDay": "29",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/0034dff6852365a8c4e36590a47ea8b088d725ae/piton/design/chip/tile/ariane/src/aes0/aes0_wrapper.sv#L96C1-L102C16",
          "URLDate": "2024-02-14"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is a close association between CWE-226 and CWE-212. The difference is partially that of perspective. CWE-226 is geared towards the final stage of the resource lifecycle, in which the resource is deleted, eliminated, expired, or otherwise released for reuse. Technically, this involves a transfer to a different control sphere, in which the original contents of the resource are no longer relevant. CWE-212, however, is intended for sensitive data in resources that are intentionally shared with others, so they are still active. This distinction is useful from the perspective of the CWE research view (CWE-1000)."
        },
        {
          "Type": "Maintenance",
          "Note": "This entry needs modification to clarify the differences with CWE-212. The description also combines two problems that are distinct from the CWE research perspective: the inadvertent transfer of information to another sphere, and improper initialization/shutdown. Some of the associated taxonomy mappings reflect these different uses."
        },
        {
          "Type": "Research Gap",
          "Note": "This is frequently found for network packets, but it can also exist in local memory allocation, files, etc."
        }
      ]
    },
    {
      "ID": "228",
      "Name": "Improper Handling of Syntactically Invalid Structure",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not handle or incorrectly handles input that is not syntactically well-formed with respect to the associated specification.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "707",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Unexpected State",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)"
          ],
          "Note": "If an input is syntactically invalid, then processing the input could place the system in an unexpected state that could lead to a crash, consume available system resources or other unintended behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-110",
          "Entries": [
            {
              "IntroText": "This Android application has registered to handle a URL when sent an intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\t\n\t *...* \n\t\n\tpublic class UrlHandlerReceiver extends BroadcastReceiver {\n\t```\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n\t\t\t\t\t\tString URL = intent.getStringExtra(\"URLToOpen\");\n\t\t\t\t\t\tint length = URL.length();\n```\n...* \n\t\t\t\t\t}}}"
            },
            {
              "BodyText": "The application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-0270",
          "Description": "Anti-virus product has assert error when line length is non-numeric.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0270"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Structure and Validity Problems"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A7",
          "EntryName": "Improper Error Handling",
          "MappingFit": "CWE More Specific"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry needs more investigation. Public vulnerability research generally focuses on the manipulations that generate invalid structure, instead of the weaknesses that are exploited by those manipulations. For example, a common attack involves making a request that omits a required field, which can trigger a crash in some cases. The crash could be due to a named chain such as CWE-690 (Unchecked Return Value to NULL Pointer Dereference), but public reports rarely cover this aspect of a vulnerability."
        },
        {
          "Type": "Theoretical",
          "Note": "The validity of input could be roughly classified along \"syntactic\", \"semantic\", and \"lexical\" dimensions. If the specification requires that an input value should be delimited with the \"[\" and \"]\" square brackets, then any input that does not follow this specification would be syntactically invalid. If the input between the brackets is expected to be a number, but the letters \"aaa\" are provided, then the input is syntactically invalid. If the input is a number and enclosed in brackets, but the number is outside of the allowable range, then it is semantically invalid. The inter-relationships between these properties - and their associated weaknesses- need further exploration."
        }
      ]
    },
    {
      "ID": "229",
      "Name": "Improper Handling of Values",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly handle when the expected number of values for parameters, fields, or arguments is not provided in input, or if those values are undefined.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "228",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "230",
      "Name": "Improper Handling of Missing Values",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when a parameter, field, or argument name is specified, but the associated value is missing, i.e. it is empty, blank, or null.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "229",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-110",
          "Entries": [
            {
              "IntroText": "This Android application has registered to handle a URL when sent an intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\t\n\t *...* \n\t\n\tpublic class UrlHandlerReceiver extends BroadcastReceiver {\n\t```\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n\t\t\t\t\t\tString URL = intent.getStringExtra(\"URLToOpen\");\n\t\t\t\t\t\tint length = URL.length();\n```\n...* \n\t\t\t\t\t}}}"
            },
            {
              "BodyText": "The application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0422",
          "Description": "Blank Host header triggers resultant infoleak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0422"
        },
        {
          "Reference": "CVE-2000-1006",
          "Description": "Blank \"charset\" attribute in MIME header triggers crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1006"
        },
        {
          "Reference": "CVE-2004-1504",
          "Description": "Blank parameter causes external error infoleak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1504"
        },
        {
          "Reference": "CVE-2005-2053",
          "Description": "Blank parameter causes external error infoleak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2053"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Value Error"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR08-J",
          "EntryName": "Do not catch NullPointerException or any of its ancestors"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Some \"crash by port scan\" bugs are probably due to this, but lack of diagnosis makes it difficult to be certain."
        }
      ]
    },
    {
      "ID": "231",
      "Name": "Improper Handling of Extra Values",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when more values are provided than expected.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "229",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "120",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This typically occurs in situations when only one value is expected."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Extra Value Error"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can overlap buffer overflows."
        }
      ]
    },
    {
      "ID": "232",
      "Name": "Improper Handling of Undefined Values",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when a value is not defined or supported for the associated parameter, field, or argument name.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "229",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, an address parameter is read and trimmed of whitespace."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString address = request.getParameter(\"address\");\n\taddress = address.trim();\n\tString updateString = \"UPDATE shippingInfo SET address='?' WHERE email='cwe@example.com'\";\n\temailAddress = con.prepareStatement(updateString);\n\temailAddress.setString(1, address);\n```"
            },
            {
              "BodyText": "If the value of the address parameter is null (undefined), the servlet will throw a NullPointerException when the trim() is attempted."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-1003",
          "Description": "Client crash when server returns unknown driver type.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1003"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Undefined Value Error"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR08-J",
          "EntryName": "Do not catch NullPointerException or any of its ancestors"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "233",
      "Name": "Improper Handling of Parameters",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly handle when the expected number of parameters, fields, or arguments is not provided in input, or if those parameters are undefined.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "228",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-110",
          "Entries": [
            {
              "IntroText": "This Android application has registered to handle a URL when sent an intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\t\n\t *...* \n\t\n\tpublic class UrlHandlerReceiver extends BroadcastReceiver {\n\t```\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n\t\t\t\t\t\tString URL = intent.getStringExtra(\"URLToOpen\");\n\t\t\t\t\t\tint length = URL.length();\n```\n...* \n\t\t\t\t\t}}}"
            },
            {
              "BodyText": "The application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Parameter Problems"
        }
      ],
      "RelatedAttackPatterns": [
        "39"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "234",
      "Name": "Failure to Handle Missing Parameter",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "If too few arguments are sent to a function, the function will still pop the expected number of arguments from the stack. Potentially, a variable number of arguments could be exhausted in a function as well.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "233",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "There is the potential for arbitrary code execution with privileges of the vulnerable program if function parameter list is exhausted."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Potentially a program could fail if it needs more arguments then are available."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Description": "This issue can be simply combated with the use of proper build process."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Forward declare all functions. This is the recommended solution. Properly forward declaration of all used functions will result in a compiler error if too few arguments are sent to a function."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tfoo_funct(one, two);\n\tvoid foo_funct(int one, int two, int three) {\n\t\tprintf(\"1) %d\\n2) %d\\n3) %d\\n\", one, two, three);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid some_function(int foo, ...) {\n\t\tint a[3], i;\n\t\tva_list ap;\n\t\tva_start(ap, foo);\n\t\tfor (i = 0; i < sizeof(a) / sizeof(int); i++) a[i] = va_arg(ap, int);\n\t\tva_end(ap);\n\t}\n\tint main(int argc, char *argv[]) {\n\t\tsome_function(17, 42);\n\t}\n```"
            },
            {
              "BodyText": "This can be exploited to disclose information with no work whatsoever. In fact, each time this function is run, it will print out the next 4 bytes on the stack after the two numbers sent to it."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-0276",
          "Description": "Server earlier allows remote attackers to cause a denial of service (crash) via an HTTP request with a sequence of \"%\" characters and a missing Host field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0276"
        },
        {
          "Reference": "CVE-2002-1488",
          "Description": "Chat client allows remote malicious IRC servers to cause a denial of service (crash) via a PART message with (1) a missing channel or (2) a channel that the user is not in.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1488"
        },
        {
          "Reference": "CVE-2002-1169",
          "Description": "Proxy allows remote attackers to cause a denial of service (crash) via an HTTP request to helpout.exe with a missing HTTP version numbers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1169"
        },
        {
          "Reference": "CVE-2000-0521",
          "Description": "Web server allows disclosure of CGI source code via an HTTP request without the version number.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0521"
        },
        {
          "Reference": "CVE-2001-0590",
          "Description": "Application server allows a remote attacker to read the source code to arbitrary 'jsp' files via a malformed URL request which does not end with an HTTP protocol specification.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0590"
        },
        {
          "Reference": "CVE-2003-0239",
          "Description": "Chat software allows remote attackers to cause a denial of service via malformed GIF89a headers that do not contain a GCT (Global Color Table) or an LCT (Local Color Table) after an Image Descriptor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0239"
        },
        {
          "Reference": "CVE-2002-1023",
          "Description": "Server allows remote attackers to cause a denial of service (crash) via an HTTP GET request without a URI.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1023"
        },
        {
          "Reference": "CVE-2002-1236",
          "Description": "CGI crashes when called without any arguments.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1236"
        },
        {
          "Reference": "CVE-2003-0422",
          "Description": "CGI crashes when called without any arguments.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0422"
        },
        {
          "Reference": "CVE-2002-1531",
          "Description": "Crash in HTTP request without a Content-Length field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1531"
        },
        {
          "Reference": "CVE-2002-1077",
          "Description": "Crash in HTTP request without a Content-Length field.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1077"
        },
        {
          "Reference": "CVE-2002-1358",
          "Description": "Empty elements/strings in protocol test suite affect many SSH2 servers/clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1358"
        },
        {
          "Reference": "CVE-2003-0477",
          "Description": "FTP server crashes in PORT command without an argument.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0477"
        },
        {
          "Reference": "CVE-2002-0107",
          "Description": "Resultant infoleak in web server via GET requests without HTTP/1.0 version string.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0107"
        },
        {
          "Reference": "CVE-2002-0596",
          "Description": "GET request with empty parameter leads to error message infoleak (path disclosure).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0596"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Parameter Error"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Missing parameter"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry could be deprecated in a future version of CWE.",
        "Comments": "See maintenance notes.",
        "Reasons": [
          "Potential Deprecation",
          "Multiple Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry will be deprecated in a future version of CWE. The term \"missing parameter\" was used in both PLOVER and CLASP, with completely different meanings. However, data from both taxonomies was merged into this entry. In PLOVER, it was meant to cover malformed inputs that do not contain required parameters, such as a missing parameter in a CGI request. This entry's observed examples and classification came from PLOVER. However, the description, demonstrative example, and other information are derived from CLASP. They are related to an incorrect number of function arguments, which is already covered by CWE-685."
        }
      ]
    },
    {
      "ID": "235",
      "Name": "Improper Handling of Extra Parameters",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when the number of parameters, fields, or arguments with the same name exceeds the expected amount.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "233",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This typically occurs in situations when only one element is expected to be specified."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-1014",
          "Description": "MIE. multiple gateway/security products allow restriction bypass using multiple MIME fields with the same name, which are interpreted differently by clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1014"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Extra Parameter Error"
        }
      ],
      "RelatedAttackPatterns": [
        "460"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This type of problem has a big role in multiple interpretation vulnerabilities and various HTTP attacks."
        }
      ]
    },
    {
      "ID": "236",
      "Name": "Improper Handling of Undefined Parameters",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when a particular parameter, field, or argument name is not defined or supported by the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "233",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1488",
          "Description": "Crash in IRC client via PART message from a channel the user is not in.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1488"
        },
        {
          "Reference": "CVE-2001-0650",
          "Description": "Router crash or bad route modification using BGP updates with invalid transitive attribute.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0650"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Undefined Parameter Error"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "237",
      "Name": "Improper Handling of Structural Elements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not handle or incorrectly handles inputs that are related to complex structures.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "228",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Element Problems"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "238",
      "Name": "Improper Handling of Incomplete Structural Elements",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when a particular structural element is not completely specified.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "237",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Element Error"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Can be primary to other problems."
        }
      ]
    },
    {
      "ID": "239",
      "Name": "Failure to Handle Incomplete Element",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly handle when a particular element is not completely specified.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "237",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "404",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1532",
          "Description": "HTTP GET without \\r\\n\\r\\n CRLF sequences causes product to wait indefinitely and prevents other users from accessing it.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1532"
        },
        {
          "Reference": "CVE-2003-0195",
          "Description": "Partial request is not timed out.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0195"
        },
        {
          "Reference": "CVE-2005-2526",
          "Description": "MFV. CPU exhaustion in printer via partial printing request then early termination of connection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2526"
        },
        {
          "Reference": "CVE-2002-1906",
          "Description": "CPU consumption by sending incomplete HTTP requests and leaving the connections open.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1906"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incomplete Element"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "240",
      "Name": "Improper Handling of Inconsistent Structural Elements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when two or more structural elements should be consistent, but are not.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "237",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "707",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-91",
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint processMessageFromSocket(int socket) {\n\t\t\tint success;\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tchar message[MESSAGE_SIZE];\n```\n// get message from socket and store into buffer* \n\t\t\t\n\t\t\t\n\t\t\t *//Ignoring possibliity that buffer > BUFFER_SIZE* \n\t\t\tif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n\t\t\t```\n```\n// place contents of the buffer into message structure* \n\t\t\t\t\tExMessage *msg = recastBuffer(buffer);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// copy message body into string for processing* \n\t\t\t\t\tint index;\n\t\t\t\t\tfor (index = 0; index < msg->msgLength; index++) {\n\t\t\t\t\t```\n\t\t\t\t\t\tmessage[index] = msg->msgBody[index];\n\t\t\t\t\t}\n\t\t\t\t\tmessage[index] = '\\0';\n```\n// process message* \n\t\t\t\t\tsuccess = processMessage(message);}\n\t\t\treturn success;}"
            },
            {
              "BodyText": "However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2014-0160",
          "Description": "Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-0160"
        },
        {
          "Reference": "CVE-2009-2299",
          "Description": "Web application firewall consumes excessive memory when an HTTP request contains a large Content-Length value but no POST data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2299"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Inconsistent Elements"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "241",
      "Name": "Improper Handling of Unexpected Data Type",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "228",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"
        },
        {
          "MitigationID": "MIT-20",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1156",
          "Description": "FTP server crash via PORT command with non-numeric character.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1156"
        },
        {
          "Reference": "CVE-2004-0270",
          "Description": "Anti-virus product has assert error when line length is non-numeric.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0270"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Wrong Data Type"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO37-C",
          "EntryName": "Do not assume that fgets() or fgetws() returns a nonempty string when successful",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "RelatedAttackPatterns": [
        "48"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Probably under-studied."
        }
      ]
    },
    {
      "ID": "242",
      "Name": "Use of Inherently Dangerous Function",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function that can never be guaranteed to work safely.",
      "ExtendedDescription": "Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the >> operator and overflow the destination buffer.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1177",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Requirements"
          ],
          "Description": "Ban the use of dangerous functions. Use their safe equivalent."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use grep or static analysis tools to spot usage of dangerous functions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The code below calls gets() to read information into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buf[BUFSIZE];\n\tgets(buf);\n```"
            },
            {
              "BodyText": "The gets() function in C is inherently unsafe."
            }
          ]
        },
        {
          "ID": "DX-5",
          "Entries": [
            {
              "IntroText": "The code below calls the gets() function to read in data from the command line."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t\tchar buf[24];\n\t\tprintf(\"Please enter your name and press <Enter>\\n\");\n\t\tgets(buf);\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "However, gets() is inherently unsafe, because it copies all input from STDIN to the buffer without checking size. This allows the user to provide a string that is larger than the buffer size, resulting in an overflow condition."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-4004",
          "Description": "FTP client uses inherently insecure gets() function and is setuid root on some systems, allowing buffer overflow",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4004"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Dangerous Functions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS33-C",
          "EntryName": "Do not use vfork()",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-194",
          "Section": "Chapter 5. Working with I/O",
          "Authors": [
            "Herbert Schildt"
          ],
          "Title": "Herb Schildt's C++ Programming Cookbook",
          "PublicationYear": "2008",
          "PublicationMonth": "04",
          "PublicationDay": "28",
          "Publisher": "McGraw-Hill Osborne Media"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 5, \"gets and fgets\" Page 163",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "243",
      "Name": "Creation of chroot Jail Without Changing Working Directory",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses the chroot() system call to create a jail, but does not change the working directory afterward. This does not prevent access to files outside of the jail.",
      "ExtendedDescription": "Improper use of chroot() may allow attackers to escape from the chroot jail. The chroot() function call does not change the process's current working directory, so relative paths may still refer to file system resources outside of the chroot jail after chroot() has been called.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Unix",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "The chroot() system call allows a process to change its perception of the root directory of the file system. After properly invoking chroot(), a process cannot access any files outside the directory tree defined by the new root directory. Such an environment is called a chroot jail and is commonly used to prevent the possibility that a processes could be subverted and used to access unauthorized files. For instance, many FTP servers run in chroot jails to prevent an attacker who discovers a new vulnerability in the server from being able to download the password file or other sensitive files on the system."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Consider the following source code from a (hypothetical) FTP server:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchroot(\"/var/ftproot\");\n\t...\n\tfgets(filename, sizeof(filename), network);\n\tlocalfile = fopen(filename, \"r\");\n\twhile ((len = fread(buf, 1, sizeof(buf), localfile)) != EOF) {\n\t\tfwrite(buf, 1, sizeof(buf), network);\n\t}\n\tfclose(localfile);\n```"
            },
            {
              "BodyText": "This code is responsible for reading a filename from the network, opening the corresponding file on the local machine, and sending the contents over the network. This code could be used to implement the FTP GET command. The FTP server calls chroot() in its initialization routines in an attempt to prevent access to files outside of /var/ftproot. But because the server does not change the current working directory by calling chdir(\"/\"), an attacker could request the file \"../../../../../etc/passwd\" and obtain a copy of the system password file."
            }
          ]
        }
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Directory Restriction"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP17",
          "EntryName": "Failed chroot jail"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "244",
      "Name": "Improper Clearing of Heap Memory Before Release ('Heap Inspection')",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.",
      "ExtendedDescription": "When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a \"heap inspection\" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "226",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "669",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Read Memory",
            "Other"
          ],
          "Note": "Be careful using vfork() and fork() in security sensitive code. The process state will not be cleaned up and will contain traces of data from past use."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-148",
          "Entries": [
            {
              "IntroText": "The following code calls realloc() on a buffer containing sensitive data:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tcleartext_buffer = get_secret();...\n\tcleartext_buffer = realloc(cleartext_buffer, 1024);\n\t...\n\tscrub_memory(cleartext_buffer, 1024);\n```"
            },
            {
              "BodyText": "There is an attempt to scrub the sensitive data from memory, but realloc() is used, so it could return a pointer to a different part of memory. The memory that was originally allocated for cleartext_buffer could still contain an uncleared copy of the data."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-3733",
          "Description": "Cryptography library does not clear heap memory before release",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-3733"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Heap Inspection"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM03-C",
          "EntryName": "Clear sensitive information stored in reusable resources returned for reuse"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "245",
      "Name": "J2EE Bad Practices: Direct Management of Connections",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The J2EE application directly manages connections, instead of using the container's connection management facilities.",
      "ExtendedDescription": "The J2EE standard forbids the direct management of connections. It requires that applications use the container's resource management facilities to obtain connections to resources. Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the J2EE standard.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, the class DatabaseConnection opens and manages a connection to a database for a J2EE application. The method openDatabaseConnection opens a connection to the database using a DriverManager to create the Connection object conn to the database specified in the string constant CONNECT_STRING."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class DatabaseConnection {\n\t\t\tprivate static final String CONNECT_STRING = \"jdbc:mysql://localhost:3306/mysqldb\";\n\t\t\tprivate Connection conn = null;\n\t\t\tpublic DatabaseConnection() {\n\t\t\t}\n\t\t\tpublic void openDatabaseConnection() {\n\t\t\t\ttry {\n\t\t\t\t\tconn = DriverManager.getConnection(CONNECT_STRING);\n\t\t\t\t} catch (SQLException ex) {...}\n\t\t\t}\n\t\t\t// Member functions for retrieving database connection and accessing database\n\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "The use of the DriverManager class to directly manage the connection to the database violates the J2EE restriction against the direct management of connections. The J2EE application should use the web application container's resource management facilities to obtain a connection to the database as shown in the following example."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tpublic class DatabaseConnection {\n\t\t\tprivate static final String DB_DATASRC_REF = \"jdbc:mysql://localhost:3306/mysqldb\";\n\t\t\tprivate Connection conn = null;\n\t\t\tpublic DatabaseConnection() {\n\t\t\t}\n\t\t\tpublic void openDatabaseConnection() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t\tInitialContext ctx = new InitialContext();\n\t\t\t\t\t\t\tDataSource datasource = (DataSource) ctx.lookup(DB_DATASRC_REF);\n\t\t\t\t\t\t\tconn = datasource.getConnection();\n\t\t\t\t\t} catch (NamingException ex) {...}\n\t\t\t\t\t} catch (SQLException ex) {...}\n\t\t\t}\n\t\t\t// Member functions for retrieving database connection and accessing database\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "J2EE Bad Practices: getConnection()"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "246",
      "Name": "J2EE Bad Practices: Direct Use of Sockets",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The J2EE application directly uses sockets instead of using framework method calls.",
      "ExtendedDescription": "\n\nThe J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no higher-level protocol is available. Authoring your own communication protocol requires wrestling with difficult security issues.\n\n\nWithout significant scrutiny by a security expert, chances are good that a custom communication protocol will suffer from security problems. Many of the same issues apply to a custom implementation of a standard protocol. While there are usually more resources available that address security concerns related to implementing a standard protocol, these resources are also available to attackers.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use framework method calls instead of using sockets directly."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-197",
          "Entries": [
            {
              "IntroText": "The following example opens a socket to connect to a remote server."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n```\n// Perform servlet tasks.* \n\t\t\t...\n\t\t\t\n\t\t\t\n\t\t\t *// Open a socket to a remote server (bad).* \n\t\t\tSocket sock = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t```\n\t\t\t\t\tsock = new Socket(remoteHostname, 3000);\n```\n// Do something with the socket.* \n\t\t\t\t\t...} catch (Exception e) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "A Socket object is created directly within the Java servlet, which is a dangerous way to manage remote connections."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "J2EE Bad Practices: Sockets"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "247",
      "Name": "DEPRECATED: Reliance on DNS Lookups in a Security Decision",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because it was a duplicate of CWE-350. All content has been transferred to CWE-350.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description for suggestions for other CWE IDs to use.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "248",
      "Name": "Uncaught Exception",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An exception is thrown from a function, but it is not caught.",
      "ExtendedDescription": "When an exception is not caught, it may cause the program to crash or expose sensitive information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Read Application Data"
          ],
          "Note": "An uncaught exception could cause the system to be placed in a state that could lead to a crash, exposure of sensitive information or other unintended behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-39",
          "Entries": [
            {
              "IntroText": "The following example attempts to resolve a hostname."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n\t\tString ip = req.getRemoteAddr();\n\t\tInetAddress addr = InetAddress.getByName(ip);\n\t\t...\n\t\tout.println(\"hello \" + addr.getHostName());\n\t}\n```"
            },
            {
              "BodyText": "A DNS lookup failure will cause the Servlet to throw an exception."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The _alloca() function allocates memory on the stack. If an allocation request is too large for the available stack space, _alloca() throws an exception. If the exception is not caught, the program will crash, potentially enabling a denial of service attack. _alloca() has been deprecated as of Microsoft Visual Studio 2005(R). It has been replaced with the more secure _alloca_s()."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "EnterCriticalSection() can raise an exception, potentially causing the program to crash. Under operating systems prior to Windows 2000, the EnterCriticalSection() function can raise an exception in low memory situations. If the exception is not caught, the program will crash, potentially enabling a denial of service attack."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-41151",
          "Description": "SDK for OPC Unified Architecture (OPC UA) server has uncaught exception when a socket is blocked for writing but the server tries to send an error",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-41151"
        },
        {
          "Reference": "CVE-2023-21087",
          "Description": "Java code in a smartphone OS can encounter a \"boot loop\" due to an uncaught exception",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-21087"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Often Misused: Exception Handling"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR05-J",
          "EntryName": "Do not let checked exceptions escape from a finally block"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR06-J",
          "EntryName": "Do not throw undeclared checked exceptions"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP31-PL",
          "EntryName": "Do not suppress or ignore exceptions",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "249",
      "Name": "DEPRECATED: Often Misused: Path Manipulation",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because of name\n\tconfusion and an accidental combination of multiple\n\tweaknesses. Most of its content has been transferred to\n\tCWE-785.",
      "ExtendedDescription": "\n\nThis entry was deprecated for several reasons. The primary reason is over-loading of the \"path manipulation\" term and the description. The original description for this entry was the same as that for the \"Often Misused: File System\" item in the original Seven Pernicious Kingdoms paper. However, Seven Pernicious Kingdoms also has a \"Path Manipulation\" phrase that is for external control of pathnames (CWE-73), which is a factor in symbolic link following and path traversal, neither of which is explicitly mentioned in 7PK. Fortify uses the phrase \"Often Misused: Path Manipulation\" for a broader range of problems, generally for issues related to buffer management. Given the multiple conflicting uses of this term, there is a chance that CWE users may have incorrectly mapped to this entry.\n\n\nThe second reason for deprecation is an implied combination of multiple weaknesses within buffer-handling functions. The focus of this entry was generally on the path-conversion functions and their association with buffer overflows. However, some of Fortify's Vulncat entries have the term \"path manipulation\" but describe a non-overflow weakness in which the buffer is not guaranteed to contain the entire pathname, i.e., there is information truncation (see CWE-222 for a similar concept). A new entry for this non-overflow weakness may be created in a future version of CWE.\n",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description for suggestions for other CWE IDs to use.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "250",
      "Name": "Execution with Unnecessary Privileges",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses.",
      "ExtendedDescription": "\n\nNew weaknesses can be exposed because running with extra privileges, such as root or Administrator, can disable the normal security checks being performed by the operating system or surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if they occur while operating at raised privileges.\n\n\nPrivilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-root user to another. Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as root when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "657",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "\n\nREALIZATION: This weakness is caused during implementation of an architectural security tactic.\n"
        },
        {
          "Phase": "Installation"
        },
        {
          "Phase": "Architecture and Design",
          "Note": "\n\nIf an application has this design problem, then it can be easier for the developer to make implementation-related errors such as CWE-271 (Privilege Dropping / Lowering Errors). In addition, the consequences of Privilege Chaining (CWE-268) can become more severe.\n"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands",
            "Read Application Data",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An attacker will be able to gain access to any resources that are allowed by the extra privileges. Common results include executing code, disabling services, and reading restricted data."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Analysis",
          "Description": "This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "DetectionMethodID": "DM-11.7",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and perform a login. Look for library functions and system calls that indicate when privileges are being raised or dropped. Look for accesses of resources that are restricted to normal users.\n",
          "EffectivenessNotes": "Note that this technique is only useful for privilege issues related to system resources. It is not likely to detect application-level business rules that are related to privileges, such as if a blog system allows a user to delete a blog entry without first checking that the user has administrator privileges."
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tCompare binary / bytecode to application permission manifest\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost Application Interface Scanner",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker\n\t\tPermission Manifest Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-18",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators."
        },
        {
          "MitigationID": "MIT-18",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements."
        },
        {
          "MitigationID": "MIT-19",
          "Phase": [
            "Implementation"
          ],
          "Description": "When dropping privileges, ensure that they have been dropped successfully to avoid CWE-273. As protection mechanisms in the environment get stronger, privilege-dropping calls may fail even if it seems like they would always succeed."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF-76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place."
        },
        {
          "MitigationID": "MIT-37",
          "Phase": [
            "Operation",
            "System Configuration"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-126",
          "Entries": [
            {
              "IntroText": "This code temporarily raises the program's privileges to allow creation of a new user folder."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef makeNewUserDir(username):\n\t\t\tif invalidUsername(username):\n```\n#avoid CWE-22 and CWE-78* \n\t\t\t\t\tprint('Usernames cannot contain invalid characters')\n\t\t\t\t\treturn False\n\t\t\ttry:\n\t\t\t```\n\t\t\t\traisePrivileges()\n\t\t\t\tos.mkdir('/home/' + username)\n\t\t\t\tlowerPrivileges()\n\t\t\texcept OSError:\n\t\t\t\tprint('Unable to create new user directory for user:' + username)\n\t\t\t\treturn False\n\t\t\treturn True\n```"
            },
            {
              "BodyText": "While the program only raises its privilege level to create the folder and immediately lowers it again, if the call to os.mkdir() throws an exception, the call to lowerPrivileges() will not occur. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code calls chroot() to restrict the application to a subset of the filesystem below APP_HOME in order to prevent an attacker from using the program to gain unauthorized access to files located elsewhere. The code then opens a file specified by the user and processes the contents of the file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchroot(APP_HOME);\n\tchdir(\"/\");\n\tFILE* data = fopen(argv[1], \"r+\");\n\t...\n```"
            },
            {
              "BodyText": "Constraining the process inside the application's home directory before opening any files is a valuable security measure. However, the absence of a call to setuid() with some non-zero value means the application is continuing to operate with unnecessary root privileges. Any successful exploit carried out by an attacker against the application can now result in a privilege escalation attack because any malicious operations will be performed with the privileges of the superuser. If the application drops to the privilege level of a non-root user, the potential for damage is substantially reduced."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This application intends to use a user's location to determine the timezone the user is in:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlocationClient = new LocationClient(this, this, this);\n\tlocationClient.connect();\n\tLocation userCurrLocation;\n\tuserCurrLocation = locationClient.getLastLocation();\n\tsetTimeZone(userCurrLocation);\n```"
            },
            {
              "BodyText": "This is unnecessary use of the location API, as this information is already available using the Android Time API. Always be sure there is not another way to obtain needed information before resorting to using the location API."
            }
          ]
        },
        {
          "ID": "DX-111",
          "Entries": [
            {
              "IntroText": "This code uses location to determine the user's current US State location."
            },
            {
              "BodyText": "First the application must declare that it requires the ACCESS_FINE_LOCATION permission in the application's manifest.xml:"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n```"
            },
            {
              "BodyText": "During execution, a call to getLastLocation() will return a location based on the application's location permissions. In this case the application has permission for the most accurate location possible:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlocationClient = new LocationClient(this, this, this);\n\tlocationClient.connect();\n\tLocation userCurrLocation;\n\tuserCurrLocation = locationClient.getLastLocation();\n\tderiveStateFromCoords(userCurrLocation);\n```"
            },
            {
              "BodyText": "While the application needs this information, it does not need to use the ACCESS_FINE_LOCATION permission, as the ACCESS_COARSE_LOCATION permission will be sufficient to identify which US state the user is in."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-4217",
          "Description": "FTP client program on a certain OS runs with setuid privileges and has a buffer overflow. Most clients do not need extra privileges, so an overflow is not a vulnerability for those clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4217"
        },
        {
          "Reference": "CVE-2008-1877",
          "Description": "Program runs with privileges and calls another program with the same privileges, which allows read of arbitrary files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1877"
        },
        {
          "Reference": "CVE-2007-5159",
          "Description": "OS incorrectly installs a program with setuid privileges, allowing users to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5159"
        },
        {
          "Reference": "CVE-2008-4638",
          "Description": "Composite: application running with high privileges (CWE-250) allows user to specify a restricted file to process, which generates a parsing error that leaks the contents of the file (CWE-209).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4638"
        },
        {
          "Reference": "CVE-2008-0162",
          "Description": "Program does not drop privileges before calling another program, allowing code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0162"
        },
        {
          "Reference": "CVE-2008-0368",
          "Description": "setuid root program allows creation of arbitrary files through command line argument.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0368"
        },
        {
          "Reference": "CVE-2007-3931",
          "Description": "Installation script installs some programs as setuid when they shouldn't be.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3931"
        },
        {
          "Reference": "CVE-2020-3812",
          "Description": "mail program runs as root but does not drop its privileges before attempting to access a file. Attacker can use a symlink from their home directory to a directory only readable by root, then determine whether the file exists based on the response.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-3812"
        },
        {
          "Reference": "CVE-2003-0908",
          "Description": "Product launches Help functionality while running with raised privileges, allowing command execution using Windows message to access \"open file\" dialog.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0908"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Often Misused: Privilege Management"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER09-J",
          "EntryName": "Minimize privileges before deserializing from a privilege context"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.05 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.08 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.08 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.05.07 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.09.02 RE(4)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.09.03 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.09.04 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.1 RE 1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CCSC 3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.1"
        }
      ],
      "RelatedAttackPatterns": [
        "104",
        "470",
        "69"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-196",
          "Authors": [
            "Jerome H. Saltzer",
            "Michael D. Schroeder"
          ],
          "Title": "The Protection of Information in Computer Systems",
          "Publication": "Proceedings of the IEEE 63",
          "PublicationYear": "1975",
          "PublicationMonth": "09",
          "URL": "http://web.mit.edu/Saltzer/www/publications/protection/"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 7, \"Running with Least Privilege\" Page 207",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-199",
          "Authors": [
            "NIST"
          ],
          "Title": "United States Government Configuration Baseline (USGCB)",
          "URL": "https://csrc.nist.gov/Projects/United-States-Government-Configuration-Baseline",
          "URLDate": "2023-03-28"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 16: Executing Code With Too Much Privilege.\" Page 243",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Privilege Vulnerabilities\", Page 477",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is a close association with CWE-653 (Insufficient Separation of Privileges). CWE-653 is about providing separate components for each privilege; CWE-250 is about ensuring that each component has the least amount of privileges possible."
        },
        {
          "Type": "Maintenance",
          "Note": "CWE-271, CWE-272, and CWE-250 are all closely related and possibly overlapping. CWE-271 is probably better suited as a category. Both CWE-272 and CWE-250 are in active use by the community. The \"least privilege\" phrase has multiple interpretations."
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "252",
      "Name": "Unchecked Return Value",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",
      "ExtendedDescription": "Two common programmer assumptions are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "476",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Many functions will return some value about the success of their actions. This will alert the program whether or not to handle any errors caused by that function."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An unexpected return value could place the system in a state that could lead to a crash or other unintended behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-53",
          "Phase": [
            "Implementation"
          ],
          "Description": "Check the results of all functions that return a value and verify that the value is expected.",
          "Effectiveness": "High",
          "EffectivenessNotes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that you account for all possible return values from the function."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When designing a function, make sure you return a value or throw an exception in case of an error."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-7",
          "Entries": [
            {
              "IntroText": "Consider the following code segment:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buf[10], cp_buf[10];\n\tfgets(buf, 10, stdin);\n\tstrcpy(cp_buf, buf);\n```"
            },
            {
              "BodyText": "The programmer expects that when fgets() returns, buf will contain a null-terminated string of length 9 or less. But if an I/O error occurs, fgets() will not null-terminate buf. Furthermore, if the end of the file is reached before any characters are read, fgets() returns without writing anything to buf. In both of these situations, fgets() signals that something unusual has happened by returning NULL, but in this code, the warning will not be noticed. The lack of a null terminator in buf can result in a buffer overflow in the subsequent call to strcpy()."
            }
          ]
        },
        {
          "ID": "DX-114",
          "Entries": [
            {
              "IntroText": "In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint returnChunkSize(void *) {\n```\n/* if chunk info is valid, return the size of usable memory,* \n\t\t\t\n\t\t\t\n\t\t\t ** else, return -1 to indicate an error* \n\t\t\t\n\t\t\t\n\t\t\t **/* \n\t\t\t...}\n\tint main() {\n\t```\n\t\t...\n\t\tmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
            }
          ]
        },
        {
          "ID": "DX-8",
          "Entries": [
            {
              "IntroText": "The following code does not check to see if memory allocation succeeded before attempting to use the pointer returned by malloc()."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tbuf = (char*) malloc(req_size);\n\tstrncpy(buf, xfer, req_size);\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"If my program runs out of memory, it will fail. It doesn't matter whether I handle the error or allow the program to die with a segmentation fault when it tries to dereference the null pointer.\" This argument ignores three important considerations:"
            },
            {
              "BodyText": "- Depending upon the type and size of the application, it may be possible to free memory that is being used elsewhere so that execution can continue.\n\n  - It is impossible for the program to perform a graceful exit if required. If the program is performing an atomic operation, it can leave the system in an inconsistent state.\n\n  - The programmer has lost the opportunity to record diagnostic information. Did the call to malloc() fail because req_size was too large or because there were too many requests being handled at the same time? Or was it caused by a memory leak that has built up over time? Without handling the error, there is no way to know."
            }
          ]
        },
        {
          "ID": "DX-9",
          "Entries": [
            {
              "IntroText": "The following examples read a file into a byte array."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tchar[] byteArray = new char[1024];\n\tfor (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {\n\t\tString userName = (String) i.Current();\n\t\tString pFileName = PFILE_ROOT + \"/\" + userName;\n\t\tStreamReader sr = new StreamReader(pFileName);\n\t\tsr.Read(byteArray,0,1024);//the file is always 1k bytes\n\t\tsr.Close();\n\t\tprocessPFile(userName, byteArray);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tFileInputStream fis;\n\tbyte[] byteArray = new byte[1024];\n\tfor (Iterator i=users.iterator(); i.hasNext();) {\n\t\t\tString userName = (String) i.next();\n\t\t\tString pFileName = PFILE_ROOT + \"/\" + userName;\n\t\t\tFileInputStream fis = new FileInputStream(pFileName);\n\t\t\tfis.read(byteArray); // the file is always 1k bytes\n\t\t\tfis.close();\n\t\t\tprocessPFile(userName, byteArray);\n```"
            },
            {
              "BodyText": "The code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always 1 kilobyte in size and therefore ignores the return value from Read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and treat it as though it belongs to the attacker."
            }
          ]
        },
        {
          "ID": "DX-10",
          "Entries": [
            {
              "IntroText": "The following code does not check to see if the string returned by getParameter() is null before calling the member function compareTo(), potentially causing a NULL dereference."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString itemName = request.getParameter(ITEM_NAME);\n\tif (itemName.compareTo(IMPORTANT_ITEM) == 0) {\n\t\t...\n\t}\n\t...\n```"
            },
            {
              "BodyText": "The following code does not check to see if the string returned by the Item property is null before calling the member function Equals(), potentially causing a NULL dereference."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString itemName = request.Item(ITEM_NAME);\n\tif (itemName.Equals(IMPORTANT_ITEM)) {\n\t\t...\n\t}\n\t...\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
            }
          ]
        },
        {
          "ID": "DX-11",
          "Entries": [
            {
              "IntroText": "The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tSystem.clearProperty(\"os.name\");\n\t...\n\tString os = System.getProperty(\"os.name\");\n\tif (os.equalsIgnoreCase(\"Windows 95\")) System.out.println(\"Not supported\");\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
            }
          ]
        },
        {
          "ID": "DX-12",
          "Entries": [
            {
              "IntroText": "The following VB.NET code does not check to make sure that it has read 50 bytes from myfile.txt. This can cause DoDangerousOperation() to operate on an unexpected value."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tDim MyFile As New FileStream(\"myfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read)\n\tDim MyArray(50) As Byte\n\tMyFile.Read(MyArray, 0, 50)\n\tDoDangerousOperation(MyArray(20))\n```"
            },
            {
              "BodyText": "In .NET, it is not uncommon for programmers to misunderstand Read() and related methods that are part of many System.IO classes. The stream and reader classes do not consider it to be unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "It is not uncommon for Java programmers to misunderstand read() and related methods that are part of many java.io classes. Most errors and unusual events in Java result in an exception being thrown. But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested. This behavior makes it important for programmers to examine the return value from read() and other IO methods to ensure that they receive the amount of data they expect."
            }
          ]
        },
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy()."
            },
            {
              "BodyText": "Note that this code is also vulnerable to a buffer overflow (CWE-119)."
            }
          ]
        },
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-17533",
          "Description": "Chain: unchecked return value (CWE-252) of some functions for policy enforcement leads to authorization bypass (CWE-862)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-17533"
        },
        {
          "Reference": "CVE-2020-6078",
          "Description": "Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6078"
        },
        {
          "Reference": "CVE-2019-15900",
          "Description": "Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-15900"
        },
        {
          "Reference": "CVE-2007-3798",
          "Description": "Unchecked return value leads to resultant integer overflow and code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3798"
        },
        {
          "Reference": "CVE-2006-4447",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4447"
        },
        {
          "Reference": "CVE-2006-2916",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2916"
        },
        {
          "Reference": "CVE-2008-5183",
          "Description": "chain: unchecked return value can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5183"
        },
        {
          "Reference": "CVE-2010-0211",
          "Description": "chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0211"
        },
        {
          "Reference": "CVE-2017-6964",
          "Description": "Linux-based device mapper encryption program does not check the return value of setuid and setgid allowing attackers to execute code with unintended privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-6964"
        },
        {
          "Reference": "CVE-2002-1372",
          "Description": "Chain: Return values of file/socket operations are not checked (CWE-252), allowing resultant consumption of file descriptors (CWE-772).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1372"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Unchecked Return Value"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Ignored function return value"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A7",
          "EntryName": "Improper Error Handling",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR33-C",
          "EntryName": "Detect and handle standard library errors",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS54-C",
          "EntryName": "Detect and handle POSIX library errors",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "EXP00-J",
          "EntryName": "Do not ignore values returned by methods"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP32-PL",
          "EntryName": "Do not ignore function return values",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-252-resource"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-252-data"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-252-resource"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Program Building Blocks\" Page 341",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 20, \"Checking Returns\" Page 624",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 11: Failure to Handle Errors Correctly.\" Page 183",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-252-data",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-252-resource",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-252-resource",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "253",
      "Name": "Incorrect Check of Function Return Value",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.",
      "ExtendedDescription": "Important and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An unexpected return value could place the system in a state that could lead to a crash or other unintended behaviors."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Language Selection",
          "Description": "Use a language or compiler that uses exceptions and requires the catching of those exceptions."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Properly check all functions which return a value."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When designing any function make sure you return a value or throw an exception in case of an error."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code attempts to allocate memory for 4 integers and checks if the allocation succeeds."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\ttmp = malloc(sizeof(int) * 4);\n\tif (tmp < 0 ) {\n\t\t\tperror(\"Failure\");\n```\n//should have checked if the call returned 0* \n\t\t\t}"
            },
            {
              "BodyText": "The code assumes that only a negative return value would indicate an error, but malloc() may return a null pointer when there is an error. The value of tmp could then be equal to 0, and the error would be missed."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-49286",
          "Description": "Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-49286"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Misinterpreted function return value"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR33-C",
          "EntryName": "Detect and handle standard library errors",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS54-C",
          "EntryName": "Detect and handle POSIX library errors",
          "MappingFit": "Imprecise"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Return Value Testing and Interpretation\", Page 340",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "256",
      "Name": "Plaintext Storage of a Password",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Storing a password in plaintext may result in a system compromise.",
      "ExtendedDescription": "Password management issues occur when a password is stored in plaintext in an application's properties, configuration file, or memory. Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource. In some contexts, even storage of a plaintext password in memory is considered a security risk if the password is not cleared immediately after it is used.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Architecture and Design",
          "Note": "Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this belief makes an attacker's job easier."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid storing passwords in easily accessible locations."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider storing cryptographic hashes of passwords as an alternative to storing in plaintext."
        },
        {
          "Description": "A programmer might attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password because the encoding can be detected and decoded easily.",
          "Effectiveness": "None"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-57",
          "Entries": [
            {
              "IntroText": "The following code reads a password from a properties file and uses the password to connect to a database."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tProperties prop = new Properties();\n\tprop.load(new FileInputStream(\"config.properties\"));\n\tString password = prop.getProperty(\"password\");\n\tDriverManager.getConnection(url, usr, password);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone who has access to config.properties can read the value of password. If a devious employee has access to this information, they can use it to break into the system."
            }
          ]
        },
        {
          "ID": "DX-58",
          "Entries": [
            {
              "IntroText": "The following code reads a password from the registry and uses the password to create a new network credential."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tString password = regKey.GetValue(passKey).toString();\n\tNetworkCredential netCred = new NetworkCredential(username,password,domain);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of password. If a devious employee has access to this information, they can use it to break into the system"
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "At least one OT product stored a password in plaintext."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30275",
          "Description": "Remote Terminal Unit (RTU) uses a driver that relies on a password stored in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30275"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Password Management"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.5"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "257",
      "Name": "Storing Passwords in a Recoverable Format",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The storage of passwords in a recoverable format makes them subject to password reuse attacks by malicious users. In fact, it should be noted that recoverable encrypted passwords provide no significant benefit over plaintext passwords since they are subject not only to reuse by malicious attackers but also by malicious insiders. If a system administrator can recover a password directly, or use a brute force search on the available information, the administrator can use the password on other accounts.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "259",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "User's passwords may be revealed."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Revealed passwords may be reused elsewhere to impersonate the users in question."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use strong, non-reversible encryption to protect stored passwords."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-59",
          "Entries": [
            {
              "IntroText": "Both of these examples verify a password by comparing it to a stored compressed version."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\tif (strcmp(compress(password), compressed_password)) {\n\t\t\tprintf(\"Incorrect Password!\\n\");\n\t\t\treturn(0);\n\t\t}\n\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (passwd.Equals(compress(password), compressed_password)) {\n\t\t\treturn(0);\n\t\t}\n```\n//Diagnostic Mode* \n\t\treturn(1);}"
            },
            {
              "BodyText": "Because a compression algorithm is used instead of a one way hashing algorithm, an attacker can recover compressed passwords stored in the database."
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30018",
          "Description": "A messaging platform serializes all elements of User/Group objects, making private information available to adversaries",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30018"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Storing passwords in a recoverable format"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "49"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The meaning of this entry needs to be investigated more closely, especially with respect to what is meant by \"recoverable.\""
        }
      ]
    },
    {
      "ID": "258",
      "Name": "Empty Password in Configuration File",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Using an empty string as a password is insecure.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "260",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "521",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Passwords should be at least eight characters long -- the longer the better. Avoid passwords that are in any way similar to other passwords you have. Avoid using words that may be found in a dictionary, names book, on a map, etc. Consider incorporating numbers and/or punctuation into your password. If you do use common words, consider replacing letters in that word with numbers and punctuation. However, do not use \"similar-looking\" punctuation. For example, it is not a good idea to change cat to c@t, ca+, (@+, or anything similar. Finally, it is never appropriate to use an empty string as a password."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but the password is provided as an empty string."
            },
            {
              "BodyText": "This Java example shows a properties file with an empty password string."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database and the password is provided as an empty string."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "An empty string should never be used as a password as this can allow unauthorized access to the application. Username and password information should not be included in a configuration file or a properties file in clear text. If possible, encrypt this information and avoid CWE-260 and CWE-13."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-26117",
          "Description": "Network access control (NAC) product has a configuration file with an empty password",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-26117"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Password Management: Empty Password in Configuration File"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "259",
      "Name": "Use of Hard-coded Password",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.",
      "ExtendedDescription": "\n\nA hard-coded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:\n\n```\n\t\tInbound: the product contains an authentication mechanism that checks for a hard-coded password.\n\t\tOutbound: the product connects to another system or component, and it contains hard-coded password for connecting to that component.\n```\nIn the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place.\n\nThe Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "321",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "257",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If hard-coded passwords are used, it is almost certain that malicious users will gain access through the account in question."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Analysis",
          "Description": "This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "DetectionMethodID": "DM-11.6",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and perform a login. Using disassembled code, look at the associated instructions and see if any of them appear to be comparing the input to a fixed string or value.\n"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For outbound authentication: store passwords outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For inbound authentication: Rather than hard-code a default username and password for first time logins, utilize a \"first login\" mode that requires the user to enter a unique strong password."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor inbound authentication: apply strong one-way hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved.\n\n\nUse randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor front-end to back-end connections: Three solutions are possible, although none are complete.\n\n```\n\t\tThe first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.\n\t\tNext, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.\n\t\tFinally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.\n```\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-13",
          "Entries": [
            {
              "IntroText": "The following code uses a hard-coded password to connect to a database:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tDriverManager.getConnection(url, \"scott\", \"tiger\");\n\t...\n```"
            },
            {
              "BodyText": "This is an example of an external hard-coded password on the client-side of a connection. This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tjavap -c ConnMngr.class\n\t\t22: ldc #36; //String jdbc:mysql://ixne.com/rxsql\n\t\t24: ldc #38; //String scott\n\t\t26: ldc #17; //String tiger\n```"
            }
          ]
        },
        {
          "ID": "DX-14",
          "Entries": [
            {
              "IntroText": "The following code is an example of an internal hard-coded password in the back-end:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password, \"Mew!\")) {\n\t\t\t\t\t printf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0)\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (!password.equals(\"Mew!\")) {\n\t\t\treturn(0)\n\t\t}\n\t\t//Diagnostic Mode\n\t\treturn(1);\n\t}\n```"
            },
            {
              "BodyText": "Every instance of this program can be placed into diagnostic mode with the same password. Even worse is the fact that if this program is distributed as a binary-only distribution, it is very difficult to change that password or disable this \"functionality.\""
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used hard-coded credentials in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29964",
          "Description": "Distributed Control System (DCS) has hard-coded passwords for local shell access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29964"
        },
        {
          "Reference": "CVE-2021-37555",
          "Description": "Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37555"
        },
        {
          "Reference": "CVE-2021-35033",
          "Description": "Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-35033"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Password Management: Hard-Coded Password"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Use of hard-coded password"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC03-J",
          "EntryName": "Never hard code sensitive information"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP33",
          "EntryName": "Hardcoded sensitive data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1288",
          "Authors": [
            "Julia Lokrantz"
          ],
          "Title": "Ethical hacking of a Smart Automatic Feed Dispenser",
          "PublicationYear": "2021",
          "PublicationMonth": "06",
          "PublicationDay": "07",
          "URL": "http://kth.diva-portal.org/smash/get/diva2:1561552/FULLTEXT01.pdf"
        },
        {
          "ExternalReferenceID": "REF-1304",
          "Authors": [
            "ICS-CERT"
          ],
          "Title": "ICS Alert (ICS-ALERT-13-164-01): Medical Devices Hard-Coded Passwords",
          "PublicationYear": "2013",
          "PublicationMonth": "06",
          "PublicationDay": "13",
          "URL": "https://www.cisa.gov/news-events/ics-alerts/ics-alert-13-164-01",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry could be split into multiple variants: an inbound variant (as seen in the second demonstrative example) and an outbound variant (as seen in the first demonstrative example). These variants are likely to have different consequences, detectability, etc. More importantly, from a vulnerability theory perspective, they could be characterized as different behaviors."
        }
      ]
    },
    {
      "ID": "260",
      "Name": "Password in Configuration File",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores a password in a configuration file that might be accessible to actors who do not know the password.",
      "ExtendedDescription": "This can result in compromise of the system for which the password is used. An attacker could gain access to this file and learn the stored password or worse yet, change the password to one of their choosing.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid storing passwords in easily accessible locations."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider storing cryptographic hashes of passwords as an alternative to storing in plaintext."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Below is a snippet from a Java properties file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twebapp.ldap.username = secretUsername\n\twebapp.ldap.password = secretPassword\n```"
            },
            {
              "BodyText": "Because the LDAP credentials are stored in plaintext, anyone with access to the file can gain access to the resource."
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-38665",
          "Description": "A continuous delivery pipeline management tool stores an unencypted password in a configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-38665"
        }
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Password Management: Password in Configuration File"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "261",
      "Name": "Weak Encoding for Password",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Obscuring a password with a trivial encoding does not protect the password.",
      "ExtendedDescription": "Password management issues occur when a password is stored in plaintext in an application's properties or configuration file. A programmer can attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "522",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Description": "Passwords should be encrypted with keys that are at least 128 bits in length for adequate security."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code reads a password from a properties file and uses the password to connect to a database."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tProperties prop = new Properties();\n\tprop.load(new FileInputStream(\"config.properties\"));\n\tString password = Base64.decode(prop.getProperty(\"password\"));\n\tDriverManager.getConnection(url, usr, password);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone with access to config.properties can read the value of password and easily determine that the value has been base 64 encoded. If a devious employee has access to this information, they can use it to break into the system."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code reads a password from the registry and uses the password to create a new network credential."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\tstring value = regKey.GetValue(passKey).ToString();\n\tbyte[] decVal = Convert.FromBase64String(value);\n\tNetworkCredential netCred = newNetworkCredential(username,decVal.toString(),domain);\n\t...\n```"
            },
            {
              "BodyText": "This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of password. If a devious employee has access to this information, they can use it to break into the system."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Password Management: Weak Cryptography"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "55"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "\n\nThe \"crypt\" family of functions uses weak cryptographic algorithms and should be avoided. It may be present in some projects for compatibility.\n"
        }
      ]
    },
    {
      "ID": "262",
      "Name": "Not Using Password Aging",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not have a mechanism in place for managing password aging.",
      "ExtendedDescription": "\n\nPassword aging (or password rotation) is a policy that forces users to change their passwords after a defined time period passes, such as every 30 or 90 days. Without mechanisms such as aging, users might not change their passwords in a timely manner.\n\n\nNote that while password aging was once considered an important security feature, it has since fallen out of favor by many, because it is not as effective against modern threats compared to other mechanisms such as slow hashes. In addition, forcing frequent changes can unintentionally encourage users to select less-secure passwords. However, password aging is still in use due to factors such as compliance requirements, e.g., Payment Card Industry Data Security Standard (PCI DSS).\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "309",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "324",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "As passwords age, the probability that they are compromised grows."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "As part of a product's design, require users to change their passwords regularly and avoid reusing previous passwords."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Developers might disable clipboard paste operations into password fields as a way to discourage users from pasting a password into a clipboard. However, this might encourage users to choose less-secure passwords that are easier to type, and it can reduce the usability of password managers [REF-1294].",
          "Effectiveness": "Discouraged Common Practice"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A system does not enforce the changing of passwords every certain period."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Not allowing password aging"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "49",
        "509",
        "55",
        "555",
        "560",
        "561",
        "565",
        "600",
        "652",
        "653",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1305",
          "Authors": [
            "Kurt Seifried and other members of the CWE-Research mailing list"
          ],
          "Title": "Discussion Thread: Time to retire CWE-262 and CWE-263",
          "PublicationYear": "2021",
          "PublicationMonth": "12",
          "PublicationDay": "03",
          "URL": "https://www.mail-archive.com/cwe-research-list@mitre.org/msg00018.html",
          "URLDate": "2022-10-11"
        },
        {
          "ExternalReferenceID": "REF-1289",
          "Authors": [
            "Lance Spitzner"
          ],
          "Title": "Time for Password Expiration to Die",
          "PublicationYear": "2021",
          "PublicationMonth": "06",
          "PublicationDay": "27",
          "URL": "https://www.sans.org/blog/time-for-password-expiration-to-die/"
        },
        {
          "ExternalReferenceID": "REF-1290",
          "Authors": [
            "Lorrie Cranor"
          ],
          "Title": "Time to rethink mandatory password changes",
          "PublicationYear": "2016",
          "PublicationMonth": "03",
          "PublicationDay": "02",
          "URL": "https://www.ftc.gov/policy/advocacy-research/tech-at-ftc/2016/03/time-rethink-mandatory-password-changes"
        },
        {
          "ExternalReferenceID": "REF-1291",
          "Authors": [
            "Eugene Spafford"
          ],
          "Title": "Security Myths and Passwords",
          "PublicationYear": "2006",
          "PublicationMonth": "04",
          "PublicationDay": "19",
          "URL": "https://www.cerias.purdue.edu/site/blog/post/password-change-myths/"
        },
        {
          "ExternalReferenceID": "REF-1292",
          "Authors": [
            "National Cyber Security Centre"
          ],
          "Title": "Password administration for system owners",
          "PublicationYear": "2018",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://www.ncsc.gov.uk/collection/passwords",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1293",
          "Authors": [
            "NIST"
          ],
          "Title": "Digital Identity Guidelines: Authentication and Lifecycle Management(SP 800-63B)",
          "PublicationYear": "2017",
          "PublicationMonth": "06",
          "URL": "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1294",
          "Authors": [
            "National Cyber Security Centre"
          ],
          "Title": "Let them paste passwords",
          "PublicationYear": "2017",
          "PublicationMonth": "01",
          "PublicationDay": "02",
          "URL": "https://www.ncsc.gov.uk/blog-post/let-them-paste-passwords",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "263",
      "Name": "Password Aging with Long Expiration",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product supports password aging, but the expiration period is too long.",
      "ExtendedDescription": "\n\nPassword aging (or password rotation) is a policy that forces users to change their passwords after a defined time period passes, such as every 30 or 90 days. A long expiration provides more time for attackers to conduct password cracking before users are forced to change to a new password.\n\n\nNote that while password aging was once considered an important security feature, it has since fallen out of favor by many, because it is not as effective against modern threats compared to other mechanisms such as slow hashes. In addition, forcing frequent changes can unintentionally encourage users to select less-secure passwords. However, password aging is still in use due to factors such as compliance requirements, e.g., Payment Card Industry Data Security Standard (PCI DSS).\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "As passwords age, the probability that they are compromised grows."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that password aging is limited so that there is a defined maximum age for passwords. Note that if the expiration window is too short, it can cause users to generate poor or predictable passwords."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that the user is notified several times leading up to the password expiration."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Create mechanisms to prevent users from reusing passwords or creating similar passwords."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Developers might disable clipboard paste operations into password fields as a way to discourage users from pasting a password into a clipboard. However, this might encourage users to choose less-secure passwords that are easier to type, and it can reduce the usability of password managers [REF-1294].",
          "Effectiveness": "Discouraged Common Practice"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A system requires the changing of passwords every five years."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Allowing password aging"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "49",
        "509",
        "55",
        "555",
        "560",
        "561",
        "565",
        "600",
        "652",
        "653",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 19: Use of Weak Password-Based Systems.\" Page 279",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1305",
          "Authors": [
            "Kurt Seifried and other members of the CWE-Research mailing list"
          ],
          "Title": "Discussion Thread: Time to retire CWE-262 and CWE-263",
          "PublicationYear": "2021",
          "PublicationMonth": "12",
          "PublicationDay": "03",
          "URL": "https://www.mail-archive.com/cwe-research-list@mitre.org/msg00018.html",
          "URLDate": "2022-10-11"
        },
        {
          "ExternalReferenceID": "REF-1289",
          "Authors": [
            "Lance Spitzner"
          ],
          "Title": "Time for Password Expiration to Die",
          "PublicationYear": "2021",
          "PublicationMonth": "06",
          "PublicationDay": "27",
          "URL": "https://www.sans.org/blog/time-for-password-expiration-to-die/"
        },
        {
          "ExternalReferenceID": "REF-1290",
          "Authors": [
            "Lorrie Cranor"
          ],
          "Title": "Time to rethink mandatory password changes",
          "PublicationYear": "2016",
          "PublicationMonth": "03",
          "PublicationDay": "02",
          "URL": "https://www.ftc.gov/policy/advocacy-research/tech-at-ftc/2016/03/time-rethink-mandatory-password-changes"
        },
        {
          "ExternalReferenceID": "REF-1291",
          "Authors": [
            "Eugene Spafford"
          ],
          "Title": "Security Myths and Passwords",
          "PublicationYear": "2006",
          "PublicationMonth": "04",
          "PublicationDay": "19",
          "URL": "https://www.cerias.purdue.edu/site/blog/post/password-change-myths/"
        },
        {
          "ExternalReferenceID": "REF-1292",
          "Authors": [
            "National Cyber Security Centre"
          ],
          "Title": "Password administration for system owners",
          "PublicationYear": "2018",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://www.ncsc.gov.uk/collection/passwords",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1293",
          "Authors": [
            "NIST"
          ],
          "Title": "Digital Identity Guidelines: Authentication and Lifecycle Management(SP 800-63B)",
          "PublicationYear": "2017",
          "PublicationMonth": "06",
          "URL": "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1294",
          "Authors": [
            "National Cyber Security Centre"
          ],
          "Title": "Let them paste passwords",
          "PublicationYear": "2017",
          "PublicationMonth": "01",
          "PublicationDay": "02",
          "URL": "https://www.ncsc.gov.uk/blog-post/let-them-paste-passwords",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "266",
      "Name": "Incorrect Privilege Assignment",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "286",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "A user can access restricted functionality and/or sensitive information that may include administrative functionality and user accounts."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-97",
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tseteuid(0);\n```\n/* do some stuff */* \n\t\n\tseteuid(getuid());"
            }
          ]
        },
        {
          "ID": "DX-142",
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tAccessController.doPrivileged(new PrivilegedAction() {\n\t\t\tpublic Object run() {\n```\n// privileged code goes here, for example:* \n\t\t\t\tSystem.loadLibrary(\"awt\");\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\t *// nothing to return* \n\t\t\t\t}"
            }
          ]
        },
        {
          "ID": "DX-108",
          "Entries": [
            {
              "IntroText": "This application sends a special intent with a flag that allows the receiving application to read a data file for backup purposes."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.example.BackupUserData\");\n\tintent.setData(file_uri);\n\tintent.addFlags(FLAG_GRANT_READ_URI_PERMISSION);\n\tsendBroadcast(intent);\n```"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class CallReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tUri userData = intent.getData();\n\t\t\tstealUserData(userData);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Any malicious application can register to receive this intent. Because of the FLAG_GRANT_READ_URI_PERMISSION included with the intent, the malicious receiver code can read the user's data."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1193",
          "Description": "untrusted user placed in unix \"wheel\" group",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1193"
        },
        {
          "Reference": "CVE-2005-2741",
          "Description": "Product allows users to grant themselves certain rights that can be used to escalate privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2741"
        },
        {
          "Reference": "CVE-2005-2496",
          "Description": "Product uses group ID of a user instead of the group, causing it to run with different privileges. This is resultant from some other unknown issue.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2496"
        },
        {
          "Reference": "CVE-2004-0274",
          "Description": "Product mistakenly assigns a particular status to an entity, leading to increased privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0274"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incorrect Privilege Assignment"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC00-J",
          "EntryName": "Do not allow privileged blocks to leak sensitive information across a trust boundary"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC01-J",
          "EntryName": "Do not allow tainted variables in privileged blocks"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "267",
      "Name": "Privilege Defined With Unsafe Actions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A particular privilege, role, capability, or right can be used to perform unsafe actions that were not intended, even when it is assigned to the correct entity.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "A user can access restricted functionality and/or sensitive information that may include administrative functionality and user accounts."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-127",
          "Entries": [
            {
              "IntroText": "This code intends to allow only Administrators to print debug information about a system."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic enum Roles {\n\t\tADMIN,USER,GUEST\n\t}\n\tpublic void printDebugInfo(User requestingUser){\n\t\t\tif(isAuthenticated(requestingUser)){\n\t\t\t\t\tswitch(requestingUser.role){\n\t\t\t\t\t\t\tcase GUEST:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tSystem.out.println(currentDebugState());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"You must be logged in to perform this command\");\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "While the intention was to only allow Administrators to print the debug information, the code as written only excludes those with the role of \"GUEST\". Someone with the role of \"ADMIN\" or \"USER\" will be allowed access, which goes against the original intent. An attacker may be able to use this debug information to craft an attack on the system."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1981",
          "Description": "Roles have access to dangerous procedures (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1981"
        },
        {
          "Reference": "CVE-2002-1671",
          "Description": "Untrusted object/method gets access to clipboard (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1671"
        },
        {
          "Reference": "CVE-2004-2204",
          "Description": "Gain privileges using functions/tags that should be restricted (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2204"
        },
        {
          "Reference": "CVE-2000-0315",
          "Description": "Traceroute program allows unprivileged users to modify source address of packet (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0315"
        },
        {
          "Reference": "CVE-2004-0380",
          "Description": "Bypass domain restrictions using a particular file that references unsafe URI schemes (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0380"
        },
        {
          "Reference": "CVE-2002-1154",
          "Description": "Script does not restrict access to an update command, leading to resultant disk consumption and filled error logs (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1154"
        },
        {
          "Reference": "CVE-2002-1145",
          "Description": "\"public\" database user can use stored procedure to modify data controlled by the database owner (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1145"
        },
        {
          "Reference": "CVE-2000-0506",
          "Description": "User with capability can prevent setuid program from dropping privileges (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0506"
        },
        {
          "Reference": "CVE-2002-2042",
          "Description": "Allows attachment to and modification of privileged processes (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2042"
        },
        {
          "Reference": "CVE-2000-1212",
          "Description": "User with privilege can edit raw underlying object using unprotected method (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1212"
        },
        {
          "Reference": "CVE-2005-1742",
          "Description": "Inappropriate actions allowed by a particular role(Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1742"
        },
        {
          "Reference": "CVE-2001-1480",
          "Description": "Untrusted entity allowed to access the system clipboard (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1480"
        },
        {
          "Reference": "CVE-2001-1551",
          "Description": "Extra Linux capability allows bypass of system-specified restriction (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1551"
        },
        {
          "Reference": "CVE-2001-1166",
          "Description": "User with debugging rights can read entire process (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1166"
        },
        {
          "Reference": "CVE-2005-1816",
          "Description": "Non-root admins can add themselves or others to the root admin group (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1816"
        },
        {
          "Reference": "CVE-2005-2173",
          "Description": "Users can change certain properties of objects to perform otherwise unauthorized actions (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2173"
        },
        {
          "Reference": "CVE-2005-2027",
          "Description": "Certain debugging commands not restricted to just the administrator, allowing registry modification and infoleak (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2027"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unsafe Privilege"
        }
      ],
      "RelatedAttackPatterns": [
        "58",
        "634",
        "637",
        "643",
        "648"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "\n\nNote: there are 2 separate sub-categories here:\n\n```\n\t\t- privilege incorrectly allows entities to perform certain actions\n\t\t- object is incorrectly accessible to entities with a given privilege\n```\n"
        }
      ]
    },
    {
      "ID": "268",
      "Name": "Privilege Chaining",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Two distinct privileges, roles, capabilities, or rights can be combined in a way that allows an entity to perform unsafe actions that would not be allowed without that combination.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "A user can be given or gain access rights of another user. This can give the user unauthorized access to sensitive information including the access information of another user."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-49",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
        },
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-128",
          "Entries": [
            {
              "IntroText": "This code allows someone with the role of \"ADMIN\" or \"OPERATOR\" to reset a user's password. The role of \"OPERATOR\" is intended to have less privileges than an \"ADMIN\", but still be able to help users with small issues such as forgotten passwords."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic enum Roles {\n\t\tADMIN,OPERATOR,USER,GUEST\n\t}\n\tpublic void resetPassword(User requestingUser, User user, String password ){\n\t\t\tif(isAuthenticated(requestingUser)){\n\t\t\t\t\tswitch(requestingUser.role){\n\t\t\t\t\t\t\tcase GUEST:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase USER:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tsetPassword(user,password);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"You must be logged in to perform this command\");\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code does not check the role of the user whose password is being reset. It is possible for an Operator to gain Admin privileges by resetting the password of an Admin account and taking control of that account."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1736",
          "Description": "Chaining of user rights.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1736"
        },
        {
          "Reference": "CVE-2002-1772",
          "Description": "Gain certain rights via privilege chaining in alternate channel.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1772"
        },
        {
          "Reference": "CVE-2005-1973",
          "Description": "Application is allowed to assign extra permissions to itself.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1973"
        },
        {
          "Reference": "CVE-2003-0640",
          "Description": "\"operator\" user can overwrite usernames and passwords to gain admin privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0640"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Privilege Chaining"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is some conceptual overlap with Unsafe Privilege."
        }
      ]
    },
    {
      "ID": "269",
      "Name": "Improper Privilege Management",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-269-Diagram.png",
      "Description": "The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-48",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Follow the principle of least privilege when assigning access rights to entities in a software system."
        },
        {
          "MitigationID": "MIT-49",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-126",
          "Entries": [
            {
              "IntroText": "This code temporarily raises the program's privileges to allow creation of a new user folder."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef makeNewUserDir(username):\n\t\t\tif invalidUsername(username):\n```\n#avoid CWE-22 and CWE-78* \n\t\t\t\t\tprint('Usernames cannot contain invalid characters')\n\t\t\t\t\treturn False\n\t\t\ttry:\n\t\t\t```\n\t\t\t\traisePrivileges()\n\t\t\t\tos.mkdir('/home/' + username)\n\t\t\t\tlowerPrivileges()\n\t\t\texcept OSError:\n\t\t\t\tprint('Unable to create new user directory for user:' + username)\n\t\t\t\treturn False\n\t\t\treturn True\n```"
            },
            {
              "BodyText": "While the program only raises its privilege level to create the folder and immediately lowers it again, if the call to os.mkdir() throws an exception, the call to lowerPrivileges() will not occur. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur."
            }
          ]
        },
        {
          "ID": "DX-97",
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tseteuid(0);\n```\n/* do some stuff */* \n\t\n\tseteuid(getuid());"
            }
          ]
        },
        {
          "ID": "DX-142",
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tAccessController.doPrivileged(new PrivilegedAction() {\n\t\t\tpublic Object run() {\n```\n// privileged code goes here, for example:* \n\t\t\t\tSystem.loadLibrary(\"awt\");\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\t *// nothing to return* \n\t\t\t\t}"
            }
          ]
        },
        {
          "ID": "DX-127",
          "Entries": [
            {
              "IntroText": "This code intends to allow only Administrators to print debug information about a system."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic enum Roles {\n\t\tADMIN,USER,GUEST\n\t}\n\tpublic void printDebugInfo(User requestingUser){\n\t\t\tif(isAuthenticated(requestingUser)){\n\t\t\t\t\tswitch(requestingUser.role){\n\t\t\t\t\t\t\tcase GUEST:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tSystem.out.println(currentDebugState());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"You must be logged in to perform this command\");\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "While the intention was to only allow Administrators to print the debug information, the code as written only excludes those with the role of \"GUEST\". Someone with the role of \"ADMIN\" or \"USER\" will be allowed access, which goes against the original intent. An attacker may be able to use this debug information to craft an attack on the system."
            }
          ]
        },
        {
          "ID": "DX-128",
          "Entries": [
            {
              "IntroText": "This code allows someone with the role of \"ADMIN\" or \"OPERATOR\" to reset a user's password. The role of \"OPERATOR\" is intended to have less privileges than an \"ADMIN\", but still be able to help users with small issues such as forgotten passwords."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic enum Roles {\n\t\tADMIN,OPERATOR,USER,GUEST\n\t}\n\tpublic void resetPassword(User requestingUser, User user, String password ){\n\t\t\tif(isAuthenticated(requestingUser)){\n\t\t\t\t\tswitch(requestingUser.role){\n\t\t\t\t\t\t\tcase GUEST:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase USER:\n\t\t\t\t\t\t\t\tSystem.out.println(\"You are not authorized to perform this command\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tsetPassword(user,password);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"You must be logged in to perform this command\");\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code does not check the role of the user whose password is being reset. It is possible for an Operator to gain Admin privileges by resetting the password of an Admin account and taking control of that account."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1555",
          "Description": "Terminal privileges are not reset when a user logs out.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1555"
        },
        {
          "Reference": "CVE-2001-1514",
          "Description": "Does not properly pass security context to child processes in certain cases, allows privilege escalation.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1514"
        },
        {
          "Reference": "CVE-2001-0128",
          "Description": "Does not properly compute roles.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0128"
        },
        {
          "Reference": "CVE-1999-1193",
          "Description": "untrusted user placed in unix \"wheel\" group",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1193"
        },
        {
          "Reference": "CVE-2005-2741",
          "Description": "Product allows users to grant themselves certain rights that can be used to escalate privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2741"
        },
        {
          "Reference": "CVE-2005-2496",
          "Description": "Product uses group ID of a user instead of the group, causing it to run with different privileges. This is resultant from some other unknown issue.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2496"
        },
        {
          "Reference": "CVE-2004-0274",
          "Description": "Product mistakenly assigns a particular status to an entity, leading to increased privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0274"
        },
        {
          "Reference": "CVE-2007-4217",
          "Description": "FTP client program on a certain OS runs with setuid privileges and has a buffer overflow. Most clients do not need extra privileges, so an overflow is not a vulnerability for those clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4217"
        },
        {
          "Reference": "CVE-2007-5159",
          "Description": "OS incorrectly installs a program with setuid privileges, allowing users to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5159"
        },
        {
          "Reference": "CVE-2008-4638",
          "Description": "Composite: application running with high privileges (CWE-250) allows user to specify a restricted file to process, which generates a parsing error that leaks the contents of the file (CWE-209).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4638"
        },
        {
          "Reference": "CVE-2007-3931",
          "Description": "Installation script installs some programs as setuid when they shouldn't be.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3931"
        },
        {
          "Reference": "CVE-2002-1981",
          "Description": "Roles have access to dangerous procedures (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1981"
        },
        {
          "Reference": "CVE-2002-1671",
          "Description": "Untrusted object/method gets access to clipboard (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1671"
        },
        {
          "Reference": "CVE-2000-0315",
          "Description": "Traceroute program allows unprivileged users to modify source address of packet (Accessible entities).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0315"
        },
        {
          "Reference": "CVE-2000-0506",
          "Description": "User with capability can prevent setuid program from dropping privileges (Unsafe privileged actions).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0506"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Privilege Management Error"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.08 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-2",
          "EntryName": "Req CR 3.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.1"
        }
      ],
      "RelatedAttackPatterns": [
        "122",
        "233",
        "58"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 16: Executing Code With Too Much Privilege.\" Page 243",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Dropping Privileges Permanently\", Page 479",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-1287",
          "Section": "Details of Problematic Mappings",
          "Authors": [
            "MITRE"
          ],
          "Title": "Supplemental Details - 2022 CWE Top 25",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "28",
          "URL": "https://cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-269 is commonly misused. It can be conflated with \"privilege escalation,\" which is a technical impact that is listed in many low-information vulnerability reports [REF-1287]. It is not useful for trend analysis.",
        "Comments": "If an error or mistake allows privilege escalation, then use the CWE ID for that mistake. Avoid using CWE-269 when only phrases such as \"privilege escalation\" or \"gain privileges\" are available, as these indicate technical impact of the vulnerability - not the root cause weakness. If the root cause seems to be directly related to privileges, then examine the children of CWE-269 for additional hints, such as Execution with Unnecessary Privileges (CWE-250) or Incorrect Privilege Assignment (CWE-266).",
        "Reasons": [
          "Frequent Misuse"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between privileges, permissions, and actors (e.g. users and groups) need further refinement within the Research view. One complication is that these concepts apply to two different pillars, related to control of resources (CWE-664) and protection mechanism failures (CWE-693)."
        }
      ]
    },
    {
      "ID": "270",
      "Name": "Privilege Context Switching Error",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly manage privileges while it is switching between different contexts that have different privileges or spheres of control.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "A user can assume the identity of another user with separate privileges in another context. This will give the user unauthorized access that may allow them to acquire the access information of other users."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-49",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1688",
          "Description": "Web browser cross domain problem when user hits \"back\" button.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1688"
        },
        {
          "Reference": "CVE-2003-1026",
          "Description": "Web browser cross domain problem when user hits \"back\" button.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1026"
        },
        {
          "Reference": "CVE-2002-1770",
          "Description": "Cross-domain issue - third party product passes code to web browser, which executes it in unsafe zone.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1770"
        },
        {
          "Reference": "CVE-2005-2263",
          "Description": "Run callback in different security context after it has been changed from untrusted to trusted. * note that \"context switch before actions are completed\" is one type of problem that happens frequently, espec. in browsers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2263"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Privilege Context Switching Error"
        }
      ],
      "RelatedAttackPatterns": [
        "17",
        "30",
        "35"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 7, \"Running with Least Privilege\" Page 207",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "This concept needs more study."
        }
      ]
    },
    {
      "ID": "271",
      "Name": "Privilege Dropping / Lowering Errors",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not drop privileges before passing control of a resource to an actor that does not have those privileges.",
      "ExtendedDescription": "In some contexts, a system executing with elevated permissions will hand off a process/file/etc. to another process or user. If the privileges of an entity are not reduced, then elevated privileges are spread throughout a system and possibly to an attacker.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If privileges are not dropped, neither are access rights of the user. Often these rights can be prevented from being dropped."
        },
        {
          "Scope": [
            "Access Control",
            "Non-Repudiation"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Hide Activities"
          ],
          "Note": "If privileges are not dropped, in some cases the system may record actions as the user which is being impersonated rather than the impersonator."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        },
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-49",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-98",
          "Entries": [
            {
              "IntroText": "The following code calls chroot() to restrict the application to a subset of the filesystem below APP_HOME in order to prevent an attacker from using the program to gain unauthorized access to files located elsewhere. The code then opens a file specified by the user and processes the contents of the file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchroot(APP_HOME);\n\tchdir(\"/\");\n\tFILE* data = fopen(argv[1], \"r+\");\n\t...\n```"
            },
            {
              "BodyText": "Constraining the process inside the application's home directory before opening any files is a valuable security measure. However, the absence of a call to setuid() with some non-zero value means the application is continuing to operate with unnecessary root privileges. Any successful exploit carried out by an attacker against the application can now result in a privilege escalation attack because any malicious operations will be performed with the privileges of the superuser. If the application drops to the privilege level of a non-root user, the potential for damage is substantially reduced."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-1213",
          "Description": "Program does not drop privileges after acquiring the raw socket.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1213"
        },
        {
          "Reference": "CVE-2001-0559",
          "Description": "Setuid program does not drop privileges after a parsing error occurs, then calls another program to handle the error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0559"
        },
        {
          "Reference": "CVE-2001-0787",
          "Description": "Does not drop privileges in related groups when lowering privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0787"
        },
        {
          "Reference": "CVE-2002-0080",
          "Description": "Does not drop privileges in related groups when lowering privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0080"
        },
        {
          "Reference": "CVE-2001-1029",
          "Description": "Does not drop privileges before determining access to certain files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1029"
        },
        {
          "Reference": "CVE-1999-0813",
          "Description": "Finger daemon does not drop privileges when executing programs on behalf of the user being fingered.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0813"
        },
        {
          "Reference": "CVE-1999-1326",
          "Description": "FTP server does not drop privileges if a connection is aborted during file transfer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1326"
        },
        {
          "Reference": "CVE-2000-0172",
          "Description": "Program only uses seteuid to drop privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0172"
        },
        {
          "Reference": "CVE-2004-2504",
          "Description": "Windows program running as SYSTEM does not drop privileges before executing other programs (many others like this, especially involving the Help facility).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2504"
        },
        {
          "Reference": "CVE-2004-0213",
          "Description": "Utility Manager launches winhlp32.exe while running with raised privileges, which allows local users to gain system privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0213"
        },
        {
          "Reference": "CVE-2004-0806",
          "Description": "Setuid program does not drop privileges before executing program specified in an environment variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0806"
        },
        {
          "Reference": "CVE-2004-0828",
          "Description": "Setuid program does not drop privileges before processing file specified on command line.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0828"
        },
        {
          "Reference": "CVE-2004-2070",
          "Description": "Service on Windows does not drop privileges before using \"view file\" option, allowing code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2070"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Privilege Dropping / Lowering Errors"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 16: Executing Code With Too Much Privilege.\" Page 243",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Dropping Privileges Permanently\", Page 479",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "CWE-271, CWE-272, and CWE-250 are all closely related and possibly overlapping. CWE-271 is probably better suited as a category."
        }
      ]
    },
    {
      "ID": "272",
      "Name": "Least Privilege Violation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "271",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Confidentiality"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "An attacker may be able to access resources with the elevated privilege that could not be accessed with the attacker's original privileges. This is particularly likely in conjunction with another flaw, such as a buffer overflow."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tCompare binary / bytecode to application permission manifest",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tPermission Manifest Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-48",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Follow the principle of least privilege when assigning access rights to entities in a software system."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsetuid(0);\n```\n// Do some important stuff* \n\tsetuid(old_uid);\n\t\n\t *// Do some non privileged stuff.*"
            }
          ]
        },
        {
          "ID": "DX-142",
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tAccessController.doPrivileged(new PrivilegedAction() {\n\t\t\tpublic Object run() {\n```\n// privileged code goes here, for example:* \n\t\t\t\tSystem.loadLibrary(\"awt\");\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\t *// nothing to return* \n\t\t\t\t}"
            }
          ]
        },
        {
          "ID": "DX-98",
          "Entries": [
            {
              "IntroText": "The following code calls chroot() to restrict the application to a subset of the filesystem below APP_HOME in order to prevent an attacker from using the program to gain unauthorized access to files located elsewhere. The code then opens a file specified by the user and processes the contents of the file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchroot(APP_HOME);\n\tchdir(\"/\");\n\tFILE* data = fopen(argv[1], \"r+\");\n\t...\n```"
            },
            {
              "BodyText": "Constraining the process inside the application's home directory before opening any files is a valuable security measure. However, the absence of a call to setuid() with some non-zero value means the application is continuing to operate with unnecessary root privileges. Any successful exploit carried out by an attacker against the application can now result in a privilege escalation attack because any malicious operations will be performed with the privileges of the superuser. If the application drops to the privilege level of a non-root user, the potential for damage is substantially reduced."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Least Privilege Violation"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to drop privileges when reasonable"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS02-C",
          "EntryName": "Follow the principle of least privilege"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC00-J",
          "EntryName": "Do not allow privileged blocks to leak sensitive information across a trust boundary"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC01-J",
          "EntryName": "Do not allow tainted variables in privileged blocks"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP36",
          "EntryName": "Privilege"
        }
      ],
      "RelatedAttackPatterns": [
        "17",
        "35",
        "76"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "CWE-271, CWE-272, and CWE-250 are all closely related and possibly overlapping. CWE-271 is probably better suited as a category."
        },
        {
          "Type": "Other",
          "Note": "\n\nIf system privileges are not dropped when it is reasonable to do so, this is not a vulnerability by itself. According to the principle of least privilege, access should be allowed only when it is absolutely necessary to the function of a given system, and only for the minimal necessary amount of time. Any further allowance of privilege widens the window of time during which a successful exploitation of the system will provide an attacker with that same privilege. If at all possible, limit the allowance of system privilege to small, simple sections of code that may be called atomically.\n\n\nWhen a program calls a privileged function, such as chroot(), it must first acquire root privilege. As soon as the privileged operation has completed, the program should drop root privilege and return to the privilege level of the invoking user.\n"
        }
      ]
    },
    {
      "ID": "273",
      "Name": "Improper Check for Dropped Privileges",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.",
      "ExtendedDescription": "If the drop fails, the product will continue to run with the raised privileges, which might provide additional access to unprivileged users.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "271",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "252",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "In Windows based environments that have access control, impersonation is used so that access checks can be performed on a client identity by a server with higher privileges. By impersonating the client, the server is restricted to client-level security -- although in different threads it may have much higher privileges."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "\n\nREALIZATION: This weakness is caused during implementation of an architectural security tactic.\n\n\nThis issue is likely to occur in restrictive environments in which the operating system or application provides fine-grained control over privilege management.\n"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If privileges are not dropped, neither are access rights of the user. Often these rights can be prevented from being dropped."
        },
        {
          "Scope": [
            "Access Control",
            "Non-Repudiation"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Hide Activities"
          ],
          "Note": "If privileges are not dropped, in some cases the system may record actions as the user which is being impersonated rather than the impersonator."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        },
        {
          "MitigationID": "MIT-53",
          "Phase": [
            "Implementation"
          ],
          "Description": "Check the results of all functions that return a value and verify that the value is expected.",
          "Effectiveness": "High",
          "EffectivenessNotes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "In Windows, make sure that the process token has the SeImpersonatePrivilege(Microsoft Server 2003). Code that relies on impersonation for security must ensure that the impersonation succeeded, i.e., that a proper privilege demotion happened."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code attempts to take on the privileges of a user before creating a file, thus avoiding performing the action with unnecessarily high privileges:"
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tbool DoSecureStuff(HANDLE hPipe) {\n\t\tbool fDataWritten = false;\n\t\tImpersonateNamedPipeClient(hPipe);\n\t\tHANDLE hFile = CreateFile(...);\n\t\t/../\n\t\tRevertToSelf()\n\t\t/../\n\t}\n```"
            },
            {
              "BodyText": "The call to ImpersonateNamedPipeClient may fail, but the return value is not checked. If the call fails, the code may execute with higher privileges than intended. In this case, an attacker could exploit this behavior to write a file to a location that the attacker does not have access to."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-4447",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4447"
        },
        {
          "Reference": "CVE-2006-2916",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2916"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to check whether privileges were dropped successfully"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS37-C",
          "EntryName": "Ensure that privilege relinquishment is successful",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "274",
      "Name": "Improper Handling of Insufficient Privileges",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when it has insufficient privileges to perform an operation, leading to resultant weaknesses.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "269",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "271",
          "ViewID": "1000"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "280",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1564",
          "Description": "System limits are not properly enforced after privileges are dropped.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1564"
        },
        {
          "Reference": "CVE-2005-3286",
          "Description": "Firewall crashes when it can't read a critical memory block that was protected by a malicious process.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3286"
        },
        {
          "Reference": "CVE-2005-1641",
          "Description": "Does not give admin sufficient privileges to overcome otherwise legitimate user actions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1641"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient privileges"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry could be deprecated in a future version of CWE.",
        "Comments": "See maintenance notes.",
        "Reasons": [
          "Potential Deprecation",
          "CWE Overlap"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "CWE-280 and CWE-274 are too similar. It is likely that CWE-274 will be deprecated in the future."
        },
        {
          "Type": "Relationship",
          "Note": "Overlaps dropped privileges, insufficient permissions."
        },
        {
          "Type": "Theoretical",
          "Note": "This has a layering relationship with Unchecked Error Condition and Unchecked Return Value."
        },
        {
          "Type": "Theoretical",
          "Note": "Within the context of vulnerability theory, privileges and permissions are two sides of the same coin. Privileges are associated with actors, and permissions are associated with resources. To perform access control, at some point the product makes a decision about whether the actor (and the privileges that have been assigned to that actor) is allowed to access the resource (based on the permissions that have been specified for that resource)."
        }
      ]
    },
    {
      "ID": "276",
      "Name": "Incorrect Default Permissions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "During installation, installed file permissions are set to allow anyone to modify those files.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Installation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInter-application Flow Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tHost Application Interface Scanner\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tAutomated Monitored Execution\n\t\tForced Path Execution",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "The architecture needs to access and modification attributes for files to only those users who actually require those actions."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1941",
          "Description": "Executables installed world-writable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1941"
        },
        {
          "Reference": "CVE-2002-1713",
          "Description": "Home directories installed world-readable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1713"
        },
        {
          "Reference": "CVE-2001-1550",
          "Description": "World-writable log files allow information loss; world-readable file has cleartext passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1550"
        },
        {
          "Reference": "CVE-2002-1711",
          "Description": "World-readable directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1711"
        },
        {
          "Reference": "CVE-2002-1844",
          "Description": "Windows product uses insecure permissions when installing on Solaris (genesis: port error).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1844"
        },
        {
          "Reference": "CVE-2001-0497",
          "Description": "Insecure permissions for a shared secret key file. Overlaps cryptographic problem.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0497"
        },
        {
          "Reference": "CVE-1999-0426",
          "Description": "Default permissions of a device allow IP spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0426"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insecure Default Permissions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO06-C",
          "EntryName": "Create files with appropriate access permissions"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO01-J",
          "EntryName": "Create files with appropriate access permission"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.08"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.1"
        }
      ],
      "RelatedAttackPatterns": [
        "1",
        "127",
        "81"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"Insecure Defaults\", Page 69",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "277",
      "Name": "Insecure Inherited Permissions",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A product defines a set of insecure permissions that are inherited by objects that are created by the program.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1841",
          "Description": "User's umask is used when creating temp files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1841"
        },
        {
          "Reference": "CVE-2002-1786",
          "Description": "Insecure umask for core dumps [is the umask preserved or assigned?].",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1786"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insecure inherited permissions"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "278",
      "Name": "Insecure Preserved Inherited Permissions",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A product inherits a set of insecure permissions for an object, e.g. when copying from an archive file, without user awareness or involvement.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1724",
          "Description": "Does not obey specified permissions when exporting.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1724"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insecure preserved inherited permissions"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "279",
      "Name": "Incorrect Execution-Assigned Permissions",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "While it is executing, the product sets the permissions of an object in a way that violates the intended permissions that have been specified by the user.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0265",
          "Description": "Log files opened read/write.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0265"
        },
        {
          "Reference": "CVE-2003-0876",
          "Description": "Log files opened read/write.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0876"
        },
        {
          "Reference": "CVE-2002-1694",
          "Description": "Log files opened read/write.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1694"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insecure execution-assigned permissions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO06-C",
          "EntryName": "Create files with appropriate access permissions"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO01-J",
          "EntryName": "Create files with appropriate access permission"
        }
      ],
      "RelatedAttackPatterns": [
        "81"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "280",
      "Name": "Improper Handling of Insufficient Permissions or Privileges ",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not handle or incorrectly handles when it has insufficient privileges to access resources or functionality as specified by their permissions. This may cause it to follow unexpected code paths that may leave the product in an invalid state.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always check to see if you have successfully accessed a resource or system functionality, and use proper error handling if it is unsuccessful. Do this even when you are operating in a highly privileged mode, because errors or environmental conditions might still cause a failure. For example, environments with highly granular permissions/privilege models, such as Windows or Linux capabilities, can cause unexpected failures."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0501",
          "Description": "Special file system allows attackers to prevent ownership/permission change of certain entries by opening the entries before calling a setuid program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0501"
        },
        {
          "Reference": "CVE-2004-0148",
          "Description": "FTP server places a user in the root directory when the user's permissions prevent access to the their own home directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0148"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Fails poorly due to insufficient permissions"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "17",
          "EntryName": "Improper Filesystem Permissions"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "CWE-280 and CWE-274 are too similar. It is likely that CWE-274 will be deprecated in the future."
        },
        {
          "Type": "Relationship",
          "Note": "This can be both primary and resultant. When primary, it can expose a variety of weaknesses because a resource might not have the expected state, and subsequent operations might fail. It is often resultant from Unchecked Error Condition (CWE-391)."
        },
        {
          "Type": "Theoretical",
          "Note": "Within the context of vulnerability theory, privileges and permissions are two sides of the same coin. Privileges are associated with actors, and permissions are associated with resources. To perform access control, at some point the software makes a decision about whether the actor (and the privileges that have been assigned to that actor) is allowed to access the resource (based on the permissions that have been specified for that resource)."
        },
        {
          "Type": "Research Gap",
          "Note": "This type of issue is under-studied, since researchers often concentrate on whether an object has too many permissions, instead of not enough. These weaknesses are likely to appear in environments with fine-grained models for permissions and privileges, which can include operating systems and other large-scale software packages. However, even highly simplistic permission/privilege models are likely to contain these issues if the developer has not considered the possibility of access failure."
        }
      ]
    },
    {
      "ID": "281",
      "Name": "Improper Preservation of Permissions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant",
          "Description": "This is resultant from errors that prevent the permissions from being preserved."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-2323",
          "Description": "Incorrect ACLs used when restoring backups from directories that use symbolic links.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2323"
        },
        {
          "Reference": "CVE-2001-1515",
          "Description": "Automatic modification of permissions inherited from another file system.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1515"
        },
        {
          "Reference": "CVE-2005-1920",
          "Description": "Permissions on backup file are created with defaults, possibly less secure than original file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1920"
        },
        {
          "Reference": "CVE-2001-0195",
          "Description": "File is made world-readable when being cloned.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0195"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Permission preservation failure"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "282",
      "Name": "Improper Ownership Management",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product assigns the wrong ownership, or does not properly verify the ownership, of an object or resource.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This function is part of a privileged program that takes input from users with potentially lower privileges."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef killProcess(processID):\n\t\tos.kill(processID, signal.SIGKILL)\n```"
            },
            {
              "BodyText": "This code does not confirm that the process to be killed is owned by the requesting user, thus allowing an attacker to kill arbitrary processes."
            },
            {
              "BodyText": "This function remedies the problem by checking the owner of the process before killing it:"
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tdef killProcess(processID):\n\t\t\tuser = getCurrentUser()\n```\n#Check process owner against requesting user* \n\t\t\tif getProcessOwner(processID) == user:\n\t\t\t```\n\t\t\t\tos.kill(processID, signal.SIGKILL)\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tprint(\"You cannot kill a process you don't own\")\n\t\t\t\treturn\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1125",
          "Description": "Program runs setuid root but relies on a configuration file owned by a non-root user.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1125"
        }
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Ownership errors"
        }
      ],
      "RelatedAttackPatterns": [
        "17",
        "35"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between privileges, permissions, and actors (e.g. users and groups) need further refinement within the Research view. One complication is that these concepts apply to two different pillars, related to control of resources (CWE-664) and protection mechanism failures (CWE-693)."
        }
      ]
    },
    {
      "ID": "283",
      "Name": "Unverified Ownership",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly verify that a critical resource is owned by the proper entity.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "282",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could gain unauthorized access to system resources."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-49",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This function is part of a privileged program that takes input from users with potentially lower privileges."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef killProcess(processID):\n\t\tos.kill(processID, signal.SIGKILL)\n```"
            },
            {
              "BodyText": "This code does not confirm that the process to be killed is owned by the requesting user, thus allowing an attacker to kill arbitrary processes."
            },
            {
              "BodyText": "This function remedies the problem by checking the owner of the process before killing it:"
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tdef killProcess(processID):\n\t\t\tuser = getCurrentUser()\n```\n#Check process owner against requesting user* \n\t\t\tif getProcessOwner(processID) == user:\n\t\t\t```\n\t\t\t\tos.kill(processID, signal.SIGKILL)\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tprint(\"You cannot kill a process you don't own\")\n\t\t\t\treturn\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-0178",
          "Description": "Program does not verify the owner of a UNIX socket that is used for sending a password.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0178"
        },
        {
          "Reference": "CVE-2004-2012",
          "Description": "Owner of special device not checked, allowing root.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2012"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unverified Ownership"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This overlaps insufficient comparison, verification errors, permissions, and privileges."
        }
      ]
    },
    {
      "ID": "284",
      "Name": "Improper Access Control",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.",
      "ExtendedDescription": "\n\nAccess control involves the use of several protection mechanisms such as:\n\n\n  - Authentication (proving the identity of an actor)\n\n  - Authorization (ensuring that a given actor can access a resource), and\n\n  - Accountability (tracking of activities that were performed)\n\nWhen any mechanism is not applied or otherwise fails, attackers can compromise the security of the product by gaining privileges, reading sensitive information, executing commands, evading detection, etc.\n\nThere are two distinct behaviors that can introduce access control weaknesses:\n\n\n  - Specification: incorrect privileges, permissions, ownership, etc. are explicitly specified for either the user or the resource (for example, setting a password file to be world-writable, or giving administrator capabilities to a guest user). This action could be performed by the program or the administrator.\n\n  - Enforcement: the mechanism contains errors that prevent it from properly enforcing the specified access control requirements (e.g., allowing the user to specify their own privileges, or allowing a syntactically-incorrect ACL to produce insecure settings). This problem occurs within the program itself, in that it does not actually enforce the intended security policy that the administrator specifies.\n\n",
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Authorization",
          "Description": "The terms \"access control\" and \"authorization\" are often used interchangeably, although many people have distinct definitions. The CWE usage of \"access control\" is intended as a general term for the various mechanisms that restrict which users can access which resources, and \"authorization\" is more narrowly defined. It is unlikely that there will be community consensus on the use of these terms."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-1",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software."
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24985",
          "Description": "A form hosting website only checks the session authentication status for a single form, making it possible to bypass authentication when there are multiple forms",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24985"
        },
        {
          "Reference": "CVE-2022-29238",
          "Description": "Access-control setting in web-based document collaboration tool is not properly implemented by the code, which prevents listing hidden directories but does not prevent direct requests to files in those directories.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29238"
        },
        {
          "Reference": "CVE-2022-23607",
          "Description": "Python-based HTTP library did not scope cookies to a particular domain such that \"supercookies\" could be sent to any domain on redirect",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-23607"
        },
        {
          "Reference": "CVE-2021-21972",
          "Description": "Chain: Cloud computing virtualization platform does not require authentication for upload of a tar format file (CWE-306), then uses .. path traversal sequences (CWE-23) in the file to access unexpected files, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21972"
        },
        {
          "Reference": "CVE-2021-37415",
          "Description": "IT management product does not perform authentication for some REST API requests, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37415"
        },
        {
          "Reference": "CVE-2021-35033",
          "Description": "Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-35033"
        },
        {
          "Reference": "CVE-2020-10263",
          "Description": "Bluetooth speaker does not require authentication for the debug functionality on the UART port, allowing root shell access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10263"
        },
        {
          "Reference": "CVE-2020-13927",
          "Description": "Default setting in workflow management product allows all API requests without authentication, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-13927"
        },
        {
          "Reference": "CVE-2010-4624",
          "Description": "Bulletin board applies restrictions on number of images during post creation, but does not enforce this on editing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4624"
        }
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Access Control List (ACL) errors"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "2",
          "EntryName": "Insufficient Authorization"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Missing Access Control"
        }
      ],
      "RelatedAttackPatterns": [
        "19",
        "441",
        "478",
        "479",
        "502",
        "503",
        "536",
        "546",
        "550",
        "551",
        "552",
        "556",
        "558",
        "562",
        "563",
        "564",
        "578"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 6, \"Determining Appropriate Access Control\" Page 171",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 17: Failure to Protect Stored Data.\" Page 253",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1287",
          "Section": "Details of Problematic Mappings",
          "Authors": [
            "MITRE"
          ],
          "Title": "Supplemental Details - 2022 CWE Top 25",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "28",
          "URL": "https://cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-284 is extremely high-level, a Pillar. Its name, \"Improper Access Control,\" is often misused in low-information vulnerability reports [REF-1287] or by active use of the OWASP Top Ten, such as \"A01:2021-Broken Access Control\". It is not useful for trend analysis.",
        "Comments": "Consider using descendants of CWE-284 that are more specific to the kind of access control involved, such as those involving authorization (Missing Authorization (CWE-862), Incorrect Authorization (CWE-863), Incorrect Permission Assignment for Critical Resource (CWE-732), etc.); authentication (Missing Authentication (CWE-306) or Weak Authentication (CWE-1390)); Incorrect User Management (CWE-286); Improper Restriction of Communication Channel to Intended Endpoints (CWE-923); etc.",
        "Reasons": [
          "Frequent Misuse",
          "Abstraction"
        ],
        "Suggestions": [
          {
            "CweID": "862",
            "Comment": "Missing Authorization"
          },
          {
            "CweID": "863",
            "Comment": "Incorrect Authorization"
          },
          {
            "CweID": "732",
            "Comment": "Incorrect Permission Assignment for Critical Resource"
          },
          {
            "CweID": "306",
            "Comment": "Missing Authentication"
          },
          {
            "CweID": "1390",
            "Comment": "Weak Authentication"
          },
          {
            "CweID": "923",
            "Comment": "Improper Restriction of Communication Channel to Intended Endpoints"
          }
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "\n\nThis entry needs more work. Possible sub-categories include:\n\n\n  - Trusted group includes undesired entities (partially covered by CWE-286)\n\n  - Group can perform undesired actions\n\n  - ACL parse error does not fail closed\n\n"
        }
      ]
    },
    {
      "ID": "285",
      "Name": "Improper Authorization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.",
      "ExtendedDescription": "\n\nAssuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.\n\n\nWhen access control checks are not applied consistently - or not at all - users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Often"
        },
        {
          "Type": "Technology",
          "Name": "Database Server",
          "Prevalence": "Often"
        }
      ],
      "BackgroundDetails": [
        "An access control list (ACL) represents who/what has permissions to a given object. Different operating systems implement (ACLs) in different ways. In UNIX, there are three types of permissions: read, write, and execute. Users are divided into three classes for file access: owner, group owner, and all other users where each class has a separate set of rights. In Windows NT, there are four basic types of permissions for files: \"No access\", \"Read access\", \"Change access\", and \"Full control\". Windows NT extends the concept of three types of users in UNIX to include a list of users and groups along with their associated permissions. A user can create an object (file) and assign specified permissions to that object."
      ],
      "AlternateTerms": [
        {
          "Term": "AuthZ",
          "Description": "\"AuthZ\" is typically used as an abbreviation of \"authorization\" within the web application security community. It is distinct from \"AuthN\" (or, sometimes, \"AuthC\") which is an abbreviation of \"authentication.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "\n\nREALIZATION: This weakness is caused during implementation of an architectural security tactic.\n\n\nA developer may introduce authorization weaknesses because of a lack of understanding about the underlying technologies. For example, a developer may assume that attackers cannot modify certain inputs such as headers or cookies.\n"
        },
        {
          "Phase": "Architecture and Design",
          "Note": "\n\nAuthorization weaknesses may arise when a single-user application is ported to a multi-user environment.\n"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "An attacker could read sensitive data, either by reading the data directly from a data store that is not properly restricted, or by accessing insufficiently-protected, privileged functionality to read the data."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories"
          ],
          "Note": "An attacker could modify sensitive data, either by writing the data directly to a data store that is not properly restricted, or by accessing insufficiently-protected, privileged functionality to write the data."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could gain privileges by modifying or reading critical data directly, or by accessing insufficiently-protected, privileged functionality."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-6",
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis is useful for detecting commonly-used idioms for authorization. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authorization libraries.\n\n\nGenerally, automated static analysis tools have difficulty detecting custom authorization schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an authorization check; an automated technique that detects the absence of authorization may report false positives.\n",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Automated dynamic analysis may find many or all possible interfaces that do not require authorization, but manual analysis is required to determine if the lack of authorization violates business logic"
        },
        {
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of custom authorization mechanisms.\n",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules. However, manual efforts might not achieve desired code coverage within limited time constraints."
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost Application Interface Scanner\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tForced Path Execution\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nDivide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries.\n\n\nNote that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor."
        },
        {
          "MitigationID": "MIT-4.4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.\n\n\nOne way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.\n"
        },
        {
          "Phase": [
            "System Configuration",
            "Installation"
          ],
          "Description": "Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a \"default deny\" policy when defining these ACLs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-95",
          "Entries": [
            {
              "IntroText": "This function runs an arbitrary SQL query on a given database, returning the result of the query."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction runEmployeeQuery($dbName, $name){\n\t\tmysql_select_db($dbName,$globalDbHandle) or die(\"Could not open Database\".$dbName);\n```\n//Use a prepared statement to avoid CWE-89* \n\t\t$preparedStatement = $globalDbHandle->prepare('SELECT * FROM employees WHERE name = :name');\n\t\t$preparedStatement->execute(array(':name' => $name));\n\t\treturn $preparedStatement->fetchAll();}\n\t\n\t */.../* \n\t\n\t$employeeRecord = runEmployeeQuery('EmployeeDB',$_GET['EmployeeName']);"
            },
            {
              "BodyText": "While this code is careful to avoid SQL Injection, the function does not confirm the user sending the query is authorized to do so. An attacker may be able to obtain sensitive employee information from the database."
            }
          ]
        },
        {
          "ID": "DX-96",
          "Entries": [
            {
              "IntroText": "The following program could be part of a bulletin board system that allows users to send private messages to each other. This program intends to authenticate the user before deciding whether a private message should be displayed. Assume that LookupMessageObject() ensures that the $id argument is numeric, constructs a filename based on that id, and reads the message details from that file. Also assume that the program stores all private messages for all users in the same directory."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tsub DisplayPrivateMessage {\n\t\tmy($id) = @_;\n\t\tmy $Message = LookupMessageObject($id);\n\t\tprint \"From: \" . encodeHTML($Message->{from}) . \"<br>\\n\";\n\t\tprint \"Subject: \" . encodeHTML($Message->{subject}) . \"\\n\";\n\t\tprint \"<hr>\\n\";\n\t\tprint \"Body: \" . encodeHTML($Message->{body}) . \"\\n\";\n\t}\n\tmy $q = new CGI;\n```\n# For purposes of this example, assume that CWE-309 and* \n\t\n\t\n\t\n\t *# CWE-523 do not apply.* \n\tif (! AuthenticateUser($q->param('username'), $q->param('password'))) {\n\t```\n\t\tExitError(\"invalid username or password\");\n\t}\n\tmy $id = $q->param('id');\n\tDisplayPrivateMessage($id);\n```"
            },
            {
              "BodyText": "While the program properly exits if authentication fails, it does not ensure that the message is addressed to the user. As a result, an authenticated attacker could provide any arbitrary identifier and read private messages that were intended for other users."
            },
            {
              "BodyText": "One way to avoid this problem would be to ensure that the \"to\" field in the message object matches the username of the authenticated user."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24730",
          "Description": "Go-based continuous deployment product does not check that a user has certain privileges to update or create an app, allowing adversaries to read sensitive repository information",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24730"
        },
        {
          "Reference": "CVE-2009-3168",
          "Description": "Web application does not restrict access to admin scripts, allowing authenticated users to reset administrative passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3168"
        },
        {
          "Reference": "CVE-2009-2960",
          "Description": "Web application does not restrict access to admin scripts, allowing authenticated users to modify passwords of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2960"
        },
        {
          "Reference": "CVE-2009-3597",
          "Description": "Web application stores database file under the web root with insufficient access control (CWE-219), allowing direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3597"
        },
        {
          "Reference": "CVE-2009-2282",
          "Description": "Terminal server does not check authorization for guest access.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2282"
        },
        {
          "Reference": "CVE-2009-3230",
          "Description": "Database server does not use appropriate privileges for certain sensitive operations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3230"
        },
        {
          "Reference": "CVE-2009-2213",
          "Description": "Gateway uses default \"Allow\" configuration for its authorization settings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2213"
        },
        {
          "Reference": "CVE-2009-0034",
          "Description": "Chain: product does not properly interpret a configuration option for a system group, allowing users to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0034"
        },
        {
          "Reference": "CVE-2008-6123",
          "Description": "Chain: SNMP product does not properly parse a configuration option for which hosts are allowed to connect, allowing unauthorized IP addresses to connect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6123"
        },
        {
          "Reference": "CVE-2008-5027",
          "Description": "System monitoring software allows users to bypass authorization by creating custom forms.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5027"
        },
        {
          "Reference": "CVE-2008-7109",
          "Description": "Chain: reliance on client-side security (CWE-602) allows attackers to bypass authorization using a custom client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-7109"
        },
        {
          "Reference": "CVE-2008-3424",
          "Description": "Chain: product does not properly handle wildcards in an authorization policy list, allowing unintended access.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3424"
        },
        {
          "Reference": "CVE-2009-3781",
          "Description": "Content management system does not check access permissions for private files, allowing others to view those files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3781"
        },
        {
          "Reference": "CVE-2008-4577",
          "Description": "ACL-based protection mechanism treats negative access rights as if they are positive, allowing bypass of intended restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4577"
        },
        {
          "Reference": "CVE-2008-6548",
          "Description": "Product does not check the ACL of a page accessed using an \"include\" directive, allowing attackers to read unauthorized files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6548"
        },
        {
          "Reference": "CVE-2007-2925",
          "Description": "Default ACL list for a DNS server does not set certain ACLs, allowing unauthorized DNS queries.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2925"
        },
        {
          "Reference": "CVE-2006-6679",
          "Description": "Product relies on the X-Forwarded-For HTTP header for authorization, allowing unintended access by spoofing the header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6679"
        },
        {
          "Reference": "CVE-2005-3623",
          "Description": "OS kernel does not check for a certain privilege before setting ACLs for files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3623"
        },
        {
          "Reference": "CVE-2005-2801",
          "Description": "Chain: file-system code performs an incorrect comparison (CWE-697), preventing default ACLs from being properly applied.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2801"
        },
        {
          "Reference": "CVE-2001-1155",
          "Description": "Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1155"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Missing Access Control"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A10",
          "EntryName": "Failure to Restrict URL Access",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A2",
          "EntryName": "Broken Access Control",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP35",
          "EntryName": "Insecure resource access"
        }
      ],
      "RelatedAttackPatterns": [
        "1",
        "104",
        "127",
        "13",
        "17",
        "39",
        "402",
        "45",
        "5",
        "51",
        "59",
        "60",
        "647",
        "668",
        "76",
        "77",
        "87"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-229",
          "Authors": [
            "NIST"
          ],
          "Title": "Role Based Access Control and Role Based Security",
          "URL": "https://csrc.nist.gov/projects/role-based-access-control",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 4, \"Authorization\" Page 114; Chapter 6, \"Determining\n                  Appropriate Access Control\" Page 171",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-231",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 5 - Improper Access Control (Authorization)",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "04",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-5-improper-access-control-authorization/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-233",
          "Authors": [
            "Rahul Bhattacharjee"
          ],
          "Title": "Authentication using JAAS",
          "URL": "https://javaranch.com/journal/2008/04/authentication-using-JAAS.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Authorization\", Page 39",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 11, \"ACL Inheritance\", Page 649",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-285 is high-level and lower-level CWEs can frequently be used instead. It is a level-1 Class (i.e., a child of a Pillar).",
        "Comments": "Look at CWE-285's children and consider mapping to CWEs such as CWE-862: Missing Authorization, CWE-863: Incorrect Authorization, CWE-732: Incorrect Permission Assignment for Critical Resource, or others.",
        "Reasons": [
          "Abstraction"
        ],
        "Suggestions": [
          {
            "CweID": "862",
            "Comment": "Missing Authorization"
          },
          {
            "CweID": "863",
            "Comment": "Incorrect Authorization"
          },
          {
            "CweID": "732",
            "Comment": "Incorrect Permission Assignment for Critical Resource"
          }
        ]
      }
    },
    {
      "ID": "286",
      "Name": "Incorrect User Management",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly manage a user within its environment.",
      "ExtendedDescription": "Users can be assigned to the wrong group (class) of permissions resulting in unintended access rights to sensitive objects.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-36109",
          "Description": "Containerization product does not record a user's supplementary group ID, allowing bypass of group restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-36109"
        },
        {
          "Reference": "CVE-1999-1193",
          "Description": "Operating system assigns user to privileged wheel group, allowing the user to gain root privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1193"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "User management errors"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between privileges, permissions, and actors (e.g. users and groups) need further refinement within the Research view. One complication is that these concepts apply to two different pillars, related to control of resources (CWE-664) and protection mechanism failures (CWE-693)."
        },
        {
          "Type": "Maintenance",
          "Note": "This item needs more work. Possible sub-categories include: user in wrong group, and user with insecure profile or \"configuration\". It also might be better expressed as a category than a weakness."
        }
      ]
    },
    {
      "ID": "287",
      "Name": "Improper Authentication",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-287-Diagram.png",
      "Description": "When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "authentification",
          "Description": "An alternate term is \"authentification\", which appears to be most commonly used by people from non-English-speaking countries."
        },
        {
          "Term": "AuthN",
          "Description": "\"AuthN\" is typically used as an abbreviation of \"authentication\" within the web application security community. It is also distinct from \"AuthZ,\" which is an abbreviation of \"authorization.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization."
        },
        {
          "Term": "AuthC",
          "Description": "\"AuthC\" is used as an abbreviation of \"authentication,\" but it appears to used less frequently than \"AuthN.\""
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-6",
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis is useful for detecting certain types of authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries.\n\n\nGenerally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives.\n",
          "Effectiveness": "Limited"
        },
        {
          "DetectionMethodID": "DM-7",
          "Method": "Manual Static Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nManual static analysis is useful for evaluating the correctness of custom authentication mechanisms.\n",
          "Effectiveness": "High",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use an authentication framework or library such as the OWASP ESAPI Authentication feature."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code intends to ensure that the user is already logged in. If not, the code performs authentication with the user-provided username and password. If successful, it sets the loggedin and user cookies to \"remember\" that the user has already logged in. Finally, the code performs administrator tasks if the logged-in user has the \"Administrator\" username, as recorded in the user cookie."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $q = new CGI;\n\tif ($q->cookie('loggedin') ne \"true\") {\n\t\t\tif (! AuthenticateUser($q->param('username'), $q->param('password'))) {\n\t\t\t\tExitError(\"Error: you need to log in first\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\t# Set loggedin and user cookies.\n\t\t\t\t\t$q->cookie(\n\t\t\t\t\t\t-name => 'loggedin',\n\t\t\t\t\t\t-value => 'true'\n\t\t\t\t\t\t);\n\t\t\t\t\t$q->cookie(\n\t\t\t\t\t\t-name => 'user',\n\t\t\t\t\t\t-value => $q->param('username')\n\t\t\t\t\t\t);\n\t\t\t}\n\t}\n\tif ($q->cookie('user') eq \"Administrator\") {\n\t\tDoAdministratorTasks();\n\t}\n```"
            },
            {
              "BodyText": "Unfortunately, this code can be bypassed. The attacker can set the cookies independently so that the code does not check the username and password. The attacker could do this with an HTTP request containing headers such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tGET /cgi-bin/vulnerable.cgi HTTP/1.1\n\tCookie: user=Administrator\n\tCookie: loggedin=true\n\t[body of request]\n```"
            },
            {
              "BodyText": "By setting the loggedin cookie to \"true\", the attacker bypasses the entire authentication check. By using the \"Administrator\" value in the user cookie, the attacker also gains privileges to administer the software."
            }
          ]
        },
        {
          "ID": "DX-117",
          "Entries": [
            {
              "IntroText": "In January 2009, an attacker was able to gain administrator access to a Twitter server because the server did not restrict the number of login attempts [REF-236]. The attacker targeted a member of Twitter's support team and was able to successfully guess the member's password using a brute force attack by guessing a large number of common words. After gaining access as the member of the support staff, the attacker used the administrator panel to gain access to 33 accounts that belonged to celebrities and politicians. Ultimately, fake Twitter messages were sent that appeared to come from the compromised accounts."
            },
            {
              "Reference": "REF-236"
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors did not use any authentication or used client-side authentication for critical functionality in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-35248",
          "Description": "Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35248"
        },
        {
          "Reference": "CVE-2022-36436",
          "Description": "Python-based authentication proxy does not enforce password authentication during the initial handshake, allowing the client to bypass authentication by specifying a 'None' authentication type.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-36436"
        },
        {
          "Reference": "CVE-2022-30034",
          "Description": "Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30034"
        },
        {
          "Reference": "CVE-2022-29951",
          "Description": "TCP-based protocol in Programmable Logic Controller (PLC) has no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29951"
        },
        {
          "Reference": "CVE-2022-29952",
          "Description": "Condition Monitor uses a protocol that does not require authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29952"
        },
        {
          "Reference": "CVE-2022-30313",
          "Description": "Safety Instrumented System uses proprietary TCP protocols with no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30313"
        },
        {
          "Reference": "CVE-2022-30317",
          "Description": "Distributed Control System (DCS) uses a protocol that has no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30317"
        },
        {
          "Reference": "CVE-2022-33139",
          "Description": "SCADA system only uses client-side authentication, allowing adversaries to impersonate other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-33139"
        },
        {
          "Reference": "CVE-2021-3116",
          "Description": "Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3116"
        },
        {
          "Reference": "CVE-2021-21972",
          "Description": "Chain: Cloud computing virtualization platform does not require authentication for upload of a tar format file (CWE-306), then uses .. path traversal sequences (CWE-23) in the file to access unexpected files, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21972"
        },
        {
          "Reference": "CVE-2021-37415",
          "Description": "IT management product does not perform authentication for some REST API requests, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37415"
        },
        {
          "Reference": "CVE-2021-35033",
          "Description": "Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-35033"
        },
        {
          "Reference": "CVE-2020-10263",
          "Description": "Bluetooth speaker does not require authentication for the debug functionality on the UART port, allowing root shell access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10263"
        },
        {
          "Reference": "CVE-2020-13927",
          "Description": "Default setting in workflow management product allows all API requests without authentication, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-13927"
        },
        {
          "Reference": "CVE-2021-35395",
          "Description": "Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-35395"
        },
        {
          "Reference": "CVE-2021-34523",
          "Description": "Mail server does not properly check an access token before executing a Powershell command, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-34523"
        },
        {
          "Reference": "CVE-2020-12812",
          "Description": "Chain: user is not prompted for a second authentication factor (CWE-287) when changing the case of their username (CWE-178), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-12812"
        },
        {
          "Reference": "CVE-2020-10148",
          "Description": "Authentication bypass by appending specific parameters and values to a URI, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10148"
        },
        {
          "Reference": "CVE-2020-0688",
          "Description": "Mail server does not generate a unique key during installation, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0688"
        },
        {
          "Reference": "CVE-2017-14623",
          "Description": "LDAP Go package allows authentication bypass using an empty password, causing an unauthenticated LDAP bind",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-14623"
        },
        {
          "Reference": "CVE-2009-3421",
          "Description": "login script for guestbook allows bypassing authentication by setting a \"login_ok\" parameter to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3421"
        },
        {
          "Reference": "CVE-2009-2382",
          "Description": "admin script allows authentication bypass by setting a cookie value to \"LOGGEDIN\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2382"
        },
        {
          "Reference": "CVE-2009-1048",
          "Description": "VOIP product allows authentication bypass using 127.0.0.1 in the Host header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1048"
        },
        {
          "Reference": "CVE-2009-2213",
          "Description": "product uses default \"Allow\" action, instead of default deny, leading to authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2213"
        },
        {
          "Reference": "CVE-2009-2168",
          "Description": "chain: redirect without exit (CWE-698) leads to resultant authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2168"
        },
        {
          "Reference": "CVE-2009-3107",
          "Description": "product does not restrict access to a listening port for a critical service, allowing authentication to be bypassed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3107"
        },
        {
          "Reference": "CVE-2009-1596",
          "Description": "product does not properly implement a security-related configuration setting, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1596"
        },
        {
          "Reference": "CVE-2009-2422",
          "Description": "authentication routine returns \"nil\" instead of \"false\" in some situations, allowing authentication bypass using an invalid username.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2422"
        },
        {
          "Reference": "CVE-2009-3232",
          "Description": "authentication update script does not properly handle when admin does not select any authentication modules, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3232"
        },
        {
          "Reference": "CVE-2009-3231",
          "Description": "use of LDAP authentication with anonymous binds causes empty password to result in successful authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3231"
        },
        {
          "Reference": "CVE-2005-3435",
          "Description": "product authentication succeeds if user-provided MD5 hash matches the hash in its database; this can be subjected to replay attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"
        },
        {
          "Reference": "CVE-2005-0408",
          "Description": "chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0408"
        }
      ],
      "FunctionalAreas": [
        "Authentication"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication Error"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A7",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "1",
          "EntryName": "Insufficient Authentication"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.2"
        }
      ],
      "RelatedAttackPatterns": [
        "114",
        "115",
        "151",
        "194",
        "22",
        "57",
        "593",
        "633",
        "650",
        "94"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-236",
          "Authors": [
            "Kim Zetter"
          ],
          "Title": "Weak Password Brings 'Happiness' to Twitter Hacker",
          "PublicationYear": "2009",
          "PublicationMonth": "01",
          "PublicationDay": "09",
          "URL": "https://www.wired.com/2009/01/professed-twitt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-237",
          "Authors": [
            "OWASP"
          ],
          "Title": "Top 10 2007-Broken Authentication and Session Management",
          "PublicationYear": "2007",
          "URL": "http://www.owasp.org/index.php/Top_10_2007-A7"
        },
        {
          "ExternalReferenceID": "REF-238",
          "Authors": [
            "OWASP"
          ],
          "Title": "Guide to Authentication",
          "URL": "http://www.owasp.org/index.php/Guide_to_Authentication"
        },
        {
          "ExternalReferenceID": "REF-239",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Authentication",
          "URL": "http://msdn.microsoft.com/en-us/library/aa374735(VS.85).aspx"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 4, \"Authentication\" Page 109",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry might be misused when lower-level CWE entries are likely to be applicable. It is a level-1 Class (i.e., a child of a Pillar).",
        "Comments": "Consider children or descendants, beginning with CWE-1390: Weak Authentication or CWE-306: Missing Authentication for Critical Function.",
        "Reasons": [
          "Frequent Misuse"
        ],
        "Suggestions": [
          {
            "CweID": "1390",
            "Comment": "Weak Authentication"
          },
          {
            "CweID": "306",
            "Comment": "Missing Authentication for Critical Function"
          }
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be resultant from SQL injection vulnerabilities and other issues."
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "288",
      "Name": "Authentication Bypass Using an Alternate Path or Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A product requires authentication, but the product has an alternate path or channel that does not require authentication.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "306",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "420",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Architecture and Design",
          "Note": "This is often seen in web applications that assume that access to a particular CGI program can only be obtained through a \"front\" screen, when the supporting programs are directly accessible. But this problem is not just in web apps."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Funnel all access through a single choke point to simplify how users can access a resource. For every access, perform a check to determine if the user has permissions to access the resource."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-176",
          "Entries": [
            {
              "IntroText": "Register SECURE_ME is located at address 0xF00. A mirror of this register called COPY_OF_SECURE_ME is at location 0x800F00. The register SECURE_ME is protected from malicious agents and only allows access to select, while COPY_OF_SECURE_ME is not. \n\n\n Access control is implemented using an allowlist (as indicated by acl_oh_allowlist). The identity of the initiator of the transaction is indicated by the one hot input, incoming_id. This is checked against the acl_oh_allowlist (which contains a list of initiators that are allowed to access the asset). \n\n\n Though this example is shown in Verilog, it will apply to VHDL as well."
            },
            {
              "Nature": "Informative",
              "Language": "Verilog",
              "ExampleCode": "module foo_bar(data_out, data_in, incoming_id, address, clk, rst_n);\n output [31:0] data_out;\n input [31:0] data_in, incoming_id, address;\n input clk, rst_n;\n wire write_auth, addr_auth;\n reg [31:0] data_out, acl_oh_allowlist, q;\n assign write_auth = | (incoming_id & acl_oh_allowlist) ? 1 : 0; \n always @*\n\n```\n\t acl_oh_allowlist <= 32'h8312; \n assign addr_auth = (address == 32'hF00) ? 1: 0;\n always @ (posedge clk or negedge rst_n)\n\t if (!rst_n)\n\t\t begin\n\t\t\t q <= 32'h0;\n\t\t\t data_out <= 32'h0;\n\t\t end\n\t else\n\t\t begin\n\t\t\t q <= (addr_auth & write_auth) ? data_in: q;\n\t\t\t data_out <= q;\n\t\t end\n\t end\n endmodule\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "assign addr_auth = (address == 32'hF00) ? 1: 0;"
            },
            {
              "BodyText": "The bugged line of code is repeated in the Bad example above. Weakness arises from the fact that the SECURE_ME register can be modified by writing to the shadow register COPY_OF_SECURE_ME, the address of COPY_OF_SECURE_ME should also be included in the check. That buggy line of code should instead be replaced as shown in the Good Code Snippet below."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "assign addr_auth = (address == 32'hF00 || address == 32'h800F00) ? 1: 0;"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-1179",
          "Description": "Router allows remote attackers to read system logs without authentication by directly connecting to the login screen and typing certain control characters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1179"
        },
        {
          "Reference": "CVE-1999-1454",
          "Description": "Attackers with physical access to the machine may bypass the password prompt by pressing the ESC (Escape) key.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1454"
        },
        {
          "Reference": "CVE-1999-1077",
          "Description": "OS allows local attackers to bypass the password protection of idled sessions via the programmer's switch or CMD-PWR keyboard sequence, which brings up a debugger that the attacker can use to disable the lock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1077"
        },
        {
          "Reference": "CVE-2003-0304",
          "Description": "Direct request of installation file allows attacker to create administrator accounts.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0304"
        },
        {
          "Reference": "CVE-2002-0870",
          "Description": "Attackers may gain additional privileges by directly requesting the web management URL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0870"
        },
        {
          "Reference": "CVE-2002-0066",
          "Description": "Bypass authentication via direct request to named pipe.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0066"
        },
        {
          "Reference": "CVE-2003-1035",
          "Description": "User can avoid lockouts by using an API instead of the GUI to conduct brute force password guessing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1035"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication Bypass by Alternate Path/Channel"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A10",
          "EntryName": "Failure to Restrict URL Access",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "127",
        "665"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "overlaps Unprotected Alternate Channel"
        }
      ]
    },
    {
      "ID": "289",
      "Name": "Authentication Bypass by Alternate Name",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs authentication based on the name of a resource being accessed, or the name of the actor performing the access, but it does not properly check all possible names for that resource or actor.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-44",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Input Validation",
          "Description": "Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names."
        },
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"
        },
        {
          "MitigationID": "MIT-20",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0317",
          "Description": "Protection mechanism that restricts URL access can be bypassed using URL encoding.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0317"
        },
        {
          "Reference": "CVE-2004-0847",
          "Description": "Bypass of authentication for files using \"\\\" (backslash) or \"%5C\" (encoded backslash).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0847"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication bypass by alternate name"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "IDS01-J",
          "EntryName": "Normalize strings before validating them",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "SEI CERT Oracle Coding Standard for Java",
          "EntryID": "IDS01-J",
          "EntryName": "Normalize strings before validating them",
          "MappingFit": "CWE More Specific"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps equivalent encodings, canonicalization, authorization, multiple trailing slash, trailing space, mixed case, and other equivalence issues."
        },
        {
          "Type": "Theoretical",
          "Note": "Alternate names are useful in data driven manipulation attacks, not just for authentication."
        }
      ]
    },
    {
      "ID": "290",
      "Name": "Authentication Bypass by Spoofing",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "This attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "This weakness can allow an attacker to access resources which are not otherwise accessible without proper authentication."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code authenticates users."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString sourceIP = request.getRemoteAddr();\n\tif (sourceIP != null && sourceIP.equals(APPROVED_IP)) {\n\t\tauthenticated = true;\n\t}\n```"
            },
            {
              "BodyText": "The authentication mechanism implemented relies on an IP address for source validation. If an attacker is able to spoof the IP, they may be able to bypass the authentication mechanism."
            }
          ]
        },
        {
          "ID": "DX-99",
          "Entries": [
            {
              "IntroText": "Both of these examples check if a request is from a trusted address before responding to the request."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsd = socket(AF_INET, SOCK_DGRAM, 0);\n\tserv.sin_family = AF_INET;\n\tserv.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservr.sin_port = htons(1008);\n\tbind(sd, (struct sockaddr *) & serv, sizeof(serv));\n\twhile (1) {\n\t\tmemset(msg, 0x0, MAX_MSG);\n\t\tclilen = sizeof(cli);\n\t\tif (inet_ntoa(cli.sin_addr)==getTrustedAddress()) {\n\t\t\tn = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twhile(true) {\n\t\t\tDatagramPacket rp=new DatagramPacket(rData,rData.length);\n\t\t\toutSock.receive(rp);\n\t\t\tString in = new String(p.getData(),0, rp.getLength());\n\t\t\tInetAddress clientIPAddress = rp.getAddress();\n\t\t\tint port = rp.getPort();\n\t\t\tif (isTrustedAddress(clientIPAddress) & secretKey.equals(in)) {\n\t\t\t\tout = secret.getBytes();\n\t\t\t\tDatagramPacket sp =new DatagramPacket(out,out.length, IPAddress, port); outSock.send(sp);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The code only verifies the address as stored in the request packet. An attacker can spoof this address, thus impersonating a trusted client."
            }
          ]
        },
        {
          "ID": "DX-93",
          "Entries": [
            {
              "IntroText": "The following code samples use a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct hostent *hp;struct in_addr myaddr;\n\tchar* tHost = \"trustme.example.com\";\n\tmyaddr.s_addr=inet_addr(ip_addr_string);\n\thp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\n\tif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {\n\t\ttrusted = true;\n\t} else {\n\t\ttrusted = false;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString ip = request.getRemoteAddr();\n\tInetAddress addr = InetAddress.getByName(ip);\n\tif (addr.getCanonicalHostName().endsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tIPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);\n\tIPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);\n\tif (hostInfo.HostName.EndsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "BodyText": "IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30319",
          "Description": "S-bus functionality in a home automation product performs access control using an IP allowlist, which can be bypassed by a forged IP address.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30319"
        },
        {
          "Reference": "CVE-2009-1048",
          "Description": "VOIP product allows authentication bypass using 127.0.0.1 in the Host header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1048"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication bypass by spoofing"
        }
      ],
      "RelatedAttackPatterns": [
        "21",
        "22",
        "459",
        "461",
        "473",
        "476",
        "59",
        "60",
        "667",
        "94"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"Spoofing and Identification\", Page 72",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be resultant from insufficient verification."
        }
      ]
    },
    {
      "ID": "291",
      "Name": "Reliance on IP Address for Authentication",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an IP address for authentication.",
      "ExtendedDescription": "IP addresses can be easily spoofed. Attackers can forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "290",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "471",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Malicious users can fake authentication information, impersonating any IP address."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use other means of identity verification that cannot be simply spoofed. Possibilities include a username/password or certificate."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-99",
          "Entries": [
            {
              "IntroText": "Both of these examples check if a request is from a trusted address before responding to the request."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsd = socket(AF_INET, SOCK_DGRAM, 0);\n\tserv.sin_family = AF_INET;\n\tserv.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservr.sin_port = htons(1008);\n\tbind(sd, (struct sockaddr *) & serv, sizeof(serv));\n\twhile (1) {\n\t\tmemset(msg, 0x0, MAX_MSG);\n\t\tclilen = sizeof(cli);\n\t\tif (inet_ntoa(cli.sin_addr)==getTrustedAddress()) {\n\t\t\tn = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twhile(true) {\n\t\t\tDatagramPacket rp=new DatagramPacket(rData,rData.length);\n\t\t\toutSock.receive(rp);\n\t\t\tString in = new String(p.getData(),0, rp.getLength());\n\t\t\tInetAddress clientIPAddress = rp.getAddress();\n\t\t\tint port = rp.getPort();\n\t\t\tif (isTrustedAddress(clientIPAddress) & secretKey.equals(in)) {\n\t\t\t\tout = secret.getBytes();\n\t\t\t\tDatagramPacket sp =new DatagramPacket(out,out.length, IPAddress, port); outSock.send(sp);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The code only verifies the address as stored in the request packet. An attacker can spoof this address, thus impersonating a trusted client."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30319",
          "Description": "S-bus functionality in a home automation product performs access control using an IP allowlist, which can be bypassed by a forged IP address.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30319"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Trusting self-reported IP address"
        }
      ],
      "RelatedAttackPatterns": [
        "4"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1371",
          "Title": "IP address spoofing",
          "PublicationYear": "2006",
          "PublicationMonth": "04",
          "PublicationDay": "07",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/IP_address_spoofing",
          "URLDate": "2023-10-21"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "292",
      "Name": "DEPRECATED: Trusting Self-reported DNS Name",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because it was a duplicate of CWE-350. All content has been transferred to CWE-350.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "293",
      "Name": "Using Referer Field for Authentication",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The referer field in HTTP requests can be easily modified and, as such, is not a valid means of message integrity checking.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "290",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "The referer field in HTML requests can be simply modified by malicious users, rendering it useless as a means of checking the validity of the request in question."
      ],
      "AlternateTerms": [
        {
          "Term": "referrer",
          "Description": "While the proper spelling might be regarded as \"referrer,\" the HTTP RFCs and their implementations use \"referer,\" so this is regarded as the correct spelling."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Actions, which may not be authorized otherwise, can be carried out as if they were validated by the server referred to."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "In order to usefully check if a given action is authorized, some means of strong authentication and method protection must be used. Use other means of authorization that cannot be simply spoofed. Possibilities include a username/password or certificate."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code samples check a packet's referer in order to decide whether or not an inbound request is from a trusted host."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tString trustedReferer = \"http://www.example.com/\"\n\twhile(true){\n\t\tn = read(newsock, buffer, BUFSIZE);\n\t\trequestPacket = processPacket(buffer, n);\n\t\tif (requestPacket.referer == trustedReferer){\n\t\t\topenNewSecureSession(requestPacket);\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tboolean processConnectionRequest(HttpServletRequest request){\n\t\tString referer = request.getHeader(\"referer\")\n\t\tString trustedReferer = \"http://www.example.com/\"\n\t\tif(referer.equals(trustedReferer)){\n\t\t\topenPrivilegedConnection(request);\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tsendPrivilegeError(request);\n\t\t\treturn false;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "These examples check if a request is from a trusted referer before responding to a request, but the code only verifies the referer name as stored in the request packet. An attacker can spoof the referer, thus impersonating a trusted client."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using referrer field for authentication"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP29",
          "EntryName": "Faulty endpoint authentication"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 17, \"Referer Request Header\", Page 1030",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "294",
      "Name": "Authentication Bypass by Capture-replay",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A capture-replay flaw exists when the design of the product makes it possible for a malicious user to sniff network traffic and bypass authentication by replaying it to the server in question to the same effect as the original message (or with minor changes).",
      "ExtendedDescription": "Capture-replay attacks are common and can be difficult to defeat without cryptography. They are a subset of network injection attacks that rely on observing previously-sent valid commands, then changing them slightly if necessary and resending the same commands to the server.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Messages sent with a capture-relay attack allow access to resources which are not otherwise accessible without proper authentication."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-3435",
          "Description": "product authentication succeeds if user-provided MD5 hash matches the hash in its database; this can be subjected to replay attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"
        },
        {
          "Reference": "CVE-2007-4961",
          "Description": "Chain: cleartext transmission of the MD5 hash of password (CWE-319) enables attacks against a server that is susceptible to replay (CWE-294).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4961"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication bypass by replay"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Capture-replay"
        }
      ],
      "RelatedAttackPatterns": [
        "102",
        "509",
        "555",
        "561",
        "60",
        "644",
        "645",
        "652",
        "701",
        "94"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "295",
      "Name": "Improper Certificate Validation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not validate, or incorrectly validates, a certificate.",
      "ExtendedDescription": "When a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The product might connect to a malicious host while believing it is a trusted host, or the product might be deceived into accepting spoofed data that appears to originate from a trusted host.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "322",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "A certificate is a token that associates an identity (principal) to a cryptographic key. Certificates can be used to check if a public key belongs to the assumed owner."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Implementation",
          "Note": "When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Authentication"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tMan-in-the-middle attack tool",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-121",
          "Entries": [
            {
              "IntroText": "This code checks the certificate of a connected peer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif ((cert = SSL_get_peer_certificate(ssl)) && host)\n\t\tfoo=SSL_get_verify_result(ssl);\n\tif ((X509_V_OK==foo) || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN==foo))\n```\n// certificate looks good, host can be trusted*"
            },
            {
              "BodyText": "In this case, because the certificate is self-signed, there was no external authority that could prove the identity of the host. The program could be communicating with a different system that is spoofing the host, e.g. by poisoning the DNS cache or using an Adversary-in-the-Middle (AITM) attack to modify the traffic from server to client."
            }
          ]
        },
        {
          "ID": "DX-122",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code obtains a certificate and verifies it."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tcert = SSL_get_peer_certificate(ssl);\n\tif (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {\n```\n// do secret things* \n\t\t\t}"
            },
            {
              "BodyText": "Even though the \"verify\" step returns X509_V_OK, this step does not include checking the Common Name against the name of the host. That is, there is no guarantee that the certificate is for the desired host. The SSL connection could have been established with a malicious host that provided a valid certificate."
            }
          ]
        },
        {
          "ID": "DX-123",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that there is a certificate and allows the use of expired certificates."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer(certificate(ssl)) {\n\t\t\tfoo=SSL_get_verify_result(ssl);\n\t\t\tif ((X509_V_OK==foo) || (X509_V_ERR_CERT_HAS_EXPIRED==foo))\n```\n//do stuff*"
            },
            {
              "BodyText": "If the call to SSL_get_verify_result() returns X509_V_ERR_CERT_HAS_EXPIRED, this means that the certificate has expired. As time goes on, there is an increasing chance for attackers to compromise the certificate."
            }
          ]
        },
        {
          "ID": "DX-124",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that there is a certificate before continuing execution."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n```\n// got a certificate, do secret things*"
            },
            {
              "BodyText": "Because this code does not use SSL_get_verify_results() to check the certificate, it could accept certificates that have been revoked (X509_V_ERR_CERT_REVOKED). The software could be communicating with a malicious host."
            }
          ]
        },
        {
          "ID": "DX-125",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that the host has a certificate."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n```\n// got certificate, host can be trusted* \n\t\t\t\n\t\t\t\n\t\t\t *//foo=SSL_get_verify_result(ssl);* \n\t\t\t\n\t\t\t\n\t\t\t *//if (X509_V_OK==foo) ...* \n\t\t\t}"
            },
            {
              "BodyText": "Note that the code does not call SSL_get_verify_result(ssl), which effectively disables the validation step that checks the certificate."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-12496",
          "Description": "A Go framework for robotics, drones, and IoT devices skips verification of root CA certificates by default.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-12496"
        },
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        },
        {
          "Reference": "CVE-2021-22909",
          "Description": "Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-22909"
        },
        {
          "Reference": "CVE-2008-4989",
          "Description": "Verification function trusts certificate chains in which the last certificate is self-signed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4989"
        },
        {
          "Reference": "CVE-2012-5821",
          "Description": "Web browser uses a TLS-related function incorrectly, preventing it from verifying that a server's certificate is signed by a trusted certification authority (CA)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5821"
        },
        {
          "Reference": "CVE-2009-3046",
          "Description": "Web browser does not check if any intermediate certificates are revoked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3046"
        },
        {
          "Reference": "CVE-2011-0199",
          "Description": "Operating system does not check Certificate Revocation List (CRL) in some cases, allowing spoofing using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0199"
        },
        {
          "Reference": "CVE-2012-5810",
          "Description": "Mobile banking application does not verify hostname, leading to financial loss.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5810"
        },
        {
          "Reference": "CVE-2012-3446",
          "Description": "Cloud-support library written in Python uses incorrect regular expression when matching hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3446"
        },
        {
          "Reference": "CVE-2009-2408",
          "Description": "Web browser does not correctly handle '\\0' character (NUL) in Common Name, allowing spoofing of https sites.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2408"
        },
        {
          "Reference": "CVE-2012-2993",
          "Description": "Smartphone device does not verify hostname, allowing spoofing of mail services.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2993"
        },
        {
          "Reference": "CVE-2012-5822",
          "Description": "Application uses third-party library that does not validate hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5822"
        },
        {
          "Reference": "CVE-2012-5819",
          "Description": "Cloud storage management application does not validate hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5819"
        },
        {
          "Reference": "CVE-2012-5817",
          "Description": "Java library uses JSSE SSLSocket and SSLEngine classes, which do not verify the hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5817"
        },
        {
          "Reference": "CVE-2010-1378",
          "Description": "chain: incorrect calculation allows attackers to bypass certificate checks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1378"
        },
        {
          "Reference": "CVE-2005-3170",
          "Description": "LDAP client accepts certificates even if they are not from a trusted CA.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3170"
        },
        {
          "Reference": "CVE-2009-0265",
          "Description": "chain: DNS server does not correctly check return value from the OpenSSL EVP_VerifyFinal function allows bypass of validation of the certificate chain.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0265"
        },
        {
          "Reference": "CVE-2003-1229",
          "Description": "chain: product checks if client is trusted when it intended to check if the server is trusted, allowing validation of signed code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1229"
        },
        {
          "Reference": "CVE-2002-0862",
          "Description": "Cryptographic API, as used in web browsers, mail clients, and other software, does not properly validate Basic Constraints.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0862"
        },
        {
          "Reference": "CVE-2009-1358",
          "Description": "chain: OS package manager does not check properly check the return value, allowing bypass using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1358"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A10",
          "EntryName": "Insecure Configuration Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "459",
        "475"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-243",
          "Authors": [
            "Sascha Fahl, Marian Harbach, Thomas Muders, Matthew Smith",
            "Lars Baumg\u00e4rtner, Bernd Freisleben"
          ],
          "Title": "Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security",
          "PublicationYear": "2012",
          "PublicationMonth": "10",
          "PublicationDay": "16",
          "URL": "http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf"
        },
        {
          "ExternalReferenceID": "REF-244",
          "Authors": [
            "M. Bishop"
          ],
          "Title": "Computer Security: Art and Science",
          "PublicationYear": "2003",
          "Publisher": "Addison-Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "296",
      "Name": "Improper Following of a Certificate's Chain of Trust",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not follow, or incorrectly follows, the chain of trust for a certificate back to a trusted root certificate, resulting in incorrect trust of any resource that is associated with that certificate.",
      "ExtendedDescription": "\n\nIf a system does not follow the chain of trust of a certificate to a root server, the certificate loses all usefulness as a metric of trust. Essentially, the trust gained from a certificate is derived from a chain of trust -- with a reputable trusted entity at the end of that list. The end user must trust that reputable source, and this reputable source must vouch for the resource in question through the medium of the certificate.\n\n\nIn some cases, this trust traverses several entities who vouch for one another. The entity trusted by the end user is at one end of this trust chain, while the certificate-wielding resource is at the other end of the chain. If the user receives a certificate at the end of one of these trust chains and then proceeds to check only that the first link in the chain, no real trust has been derived, since the entire chain must be traversed back to a trusted source to verify the certificate.\n\n\nThere are several ways in which the chain of trust might be broken, including but not limited to:\n\n\n  - Any certificate in the chain is self-signed, unless it the root.\n\n  - Not every intermediate certificate is checked, starting from the original certificate all the way up to the root certificate.\n\n  - An intermediate, CA-signed certificate does not have the expected Basic Constraints or other important extensions.\n\n  - The root certificate has been compromised or authorized to the wrong party.\n\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "295",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete."
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "Exploitation of this flaw can lead to the trust of data that may have originated with a spoofed source."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Data, requests, or actions taken by the attacking entity can be carried out as a spoofed benign entity."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that proper certificate checking is included in the system design."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Understand, and properly implement all checks necessary to ensure the integrity of certificate trust integrity."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the full chain of trust."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-121",
          "Entries": [
            {
              "IntroText": "This code checks the certificate of a connected peer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif ((cert = SSL_get_peer_certificate(ssl)) && host)\n\t\tfoo=SSL_get_verify_result(ssl);\n\tif ((X509_V_OK==foo) || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN==foo))\n```\n// certificate looks good, host can be trusted*"
            },
            {
              "BodyText": "In this case, because the certificate is self-signed, there was no external authority that could prove the identity of the host. The program could be communicating with a different system that is spoofing the host, e.g. by poisoning the DNS cache or using an Adversary-in-the-Middle (AITM) attack to modify the traffic from server to client."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2016-2402",
          "Description": "Server allows bypass of certificate pinning by sending a chain of trust that includes a trusted CA that is not pinned.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-2402"
        },
        {
          "Reference": "CVE-2008-4989",
          "Description": "Verification function trusts certificate chains in which the last certificate is self-signed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4989"
        },
        {
          "Reference": "CVE-2012-5821",
          "Description": "Chain: Web browser uses a TLS-related function incorrectly, preventing it from verifying that a server's certificate is signed by a trusted certification authority (CA).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5821"
        },
        {
          "Reference": "CVE-2009-3046",
          "Description": "Web browser does not check if any intermediate certificates are revoked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3046"
        },
        {
          "Reference": "CVE-2009-0265",
          "Description": "chain: DNS server does not correctly check return value from the OpenSSL EVP_VerifyFinal function allows bypass of validation of the certificate chain.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0265"
        },
        {
          "Reference": "CVE-2009-0124",
          "Description": "chain: incorrect check of return value from the OpenSSL EVP_VerifyFinal function allows bypass of validation of the certificate chain.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0124"
        },
        {
          "Reference": "CVE-2002-0970",
          "Description": "File-transfer software does not validate Basic Constraints of an intermediate CA-signed certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0970"
        },
        {
          "Reference": "CVE-2002-0862",
          "Description": "Cryptographic API, as used in web browsers, mail clients, and other software, does not properly validate Basic Constraints.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0862"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to follow chain of trust in certificate validation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-245",
          "Authors": [
            "Martin Georgiev",
            "Subodh Iyengar",
            "Suman Jana",
            "Rishita Anubhai",
            "Dan Boneh",
            "Vitaly Shmatikov"
          ],
          "Title": "The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software",
          "PublicationYear": "2012",
          "PublicationMonth": "10",
          "PublicationDay": "25",
          "URL": "http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "297",
      "Name": "Improper Validation of Certificate with Host Mismatch",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product communicates with a host that provides a certificate, but the product does not properly ensure that the certificate is actually associated with that host.",
      "ExtendedDescription": "\n\nEven if a certificate is well-formed, signed, and follows the chain of trust, it may simply be a valid certificate for a different site than the site that the product is interacting with. If the certificate's host-specific data is not properly checked - such as the Common Name (CN) in the Subject or the Subject Alternative Name (SAN) extension of an X.509 certificate - it may be possible for a redirection or spoofing attack to allow a malicious host with a valid certificate to provide data, impersonating a trusted host. In order to ensure data integrity, the certificate must be valid and it must pertain to the site that is being accessed.\n\n\nEven if the product attempts to check the hostname, it is still possible to incorrectly check the hostname. For example, attackers could create a certificate with a name that begins with a trusted name followed by a NUL byte, which could cause some string-based comparisons to only examine the portion that contains the trusted name.\n\n\nThis weakness can occur even when the product uses Certificate Pinning, if the product does not verify the hostname at the time a certificate is pinned.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "295",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete."
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The data read from the system vouched for by the certificate may not be from the expected system."
        },
        {
          "Scope": [
            "Authentication",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Trust afforded to the system in question - based on the malicious certificate - may allow for spoofing or redirection attacks."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "Set up an untrusted endpoint (e.g. a server) with which the product will connect. Create a test certificate that uses an invalid hostname but is signed by a trusted CA and provide this certificate from the untrusted endpoint. If the product performs any operations instead of disconnecting and reporting an error, then this indicates that the hostname is not being checked and the test certificate has been accepted."
        },
        {
          "Method": "Black Box",
          "Description": "When Certificate Pinning is being used in a mobile application, consider using a tool such as Spinner [REF-955]. This methodology might be extensible to other technologies."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Fully check the hostname of the certificate and provide the user with adequate information about the nature of the problem and how to proceed."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-122",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code obtains a certificate and verifies it."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tcert = SSL_get_peer_certificate(ssl);\n\tif (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {\n```\n// do secret things* \n\t\t\t}"
            },
            {
              "BodyText": "Even though the \"verify\" step returns X509_V_OK, this step does not include checking the Common Name against the name of the host. That is, there is no guarantee that the certificate is for the desired host. The SSL connection could have been established with a malicious host that provided a valid certificate."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2012-5810",
          "Description": "Mobile banking application does not verify hostname, leading to financial loss.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5810"
        },
        {
          "Reference": "CVE-2012-5811",
          "Description": "Mobile application for printing documents does not verify hostname, allowing attackers to read sensitive documents.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5811"
        },
        {
          "Reference": "CVE-2012-5807",
          "Description": "Software for electronic checking does not verify hostname, leading to financial loss.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5807"
        },
        {
          "Reference": "CVE-2012-3446",
          "Description": "Cloud-support library written in Python uses incorrect regular expression when matching hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3446"
        },
        {
          "Reference": "CVE-2009-2408",
          "Description": "Web browser does not correctly handle '\\0' character (NUL) in Common Name, allowing spoofing of https sites.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2408"
        },
        {
          "Reference": "CVE-2012-0867",
          "Description": "Database program truncates the Common Name during hostname verification, allowing spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0867"
        },
        {
          "Reference": "CVE-2010-2074",
          "Description": "Incorrect handling of '\\0' character (NUL) in hostname verification allows spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2074"
        },
        {
          "Reference": "CVE-2009-4565",
          "Description": "Mail server's incorrect handling of '\\0' character (NUL) in hostname verification allows spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4565"
        },
        {
          "Reference": "CVE-2009-3767",
          "Description": "LDAP server's incorrect handling of '\\0' character (NUL) in hostname verification allows spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3767"
        },
        {
          "Reference": "CVE-2012-5806",
          "Description": "Payment processing module does not verify hostname when connecting to PayPal using PHP fsockopen function.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5806"
        },
        {
          "Reference": "CVE-2012-2993",
          "Description": "Smartphone device does not verify hostname, allowing spoofing of mail services.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2993"
        },
        {
          "Reference": "CVE-2012-5804",
          "Description": "E-commerce module does not verify hostname when connecting to payment site.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5804"
        },
        {
          "Reference": "CVE-2012-5824",
          "Description": "Chat application does not validate hostname, leading to loss of privacy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5824"
        },
        {
          "Reference": "CVE-2012-5822",
          "Description": "Application uses third-party library that does not validate hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5822"
        },
        {
          "Reference": "CVE-2012-5819",
          "Description": "Cloud storage management application does not validate hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5819"
        },
        {
          "Reference": "CVE-2012-5817",
          "Description": "Java library uses JSSE SSLSocket and SSLEngine classes, which do not verify the hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5817"
        },
        {
          "Reference": "CVE-2012-5784",
          "Description": "SOAP platform does not verify the hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5784"
        },
        {
          "Reference": "CVE-2012-5782",
          "Description": "PHP library for payments does not verify the hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5782"
        },
        {
          "Reference": "CVE-2012-5780",
          "Description": "Merchant SDK for payments does not verify the hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5780"
        },
        {
          "Reference": "CVE-2003-0355",
          "Description": "Web browser does not validate Common Name, allowing spoofing of https sites.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0355"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to validate host-specific certificate data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-245",
          "Authors": [
            "Martin Georgiev",
            "Subodh Iyengar",
            "Suman Jana",
            "Rishita Anubhai",
            "Dan Boneh",
            "Vitaly Shmatikov"
          ],
          "Title": "The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software",
          "PublicationYear": "2012",
          "PublicationMonth": "10",
          "PublicationDay": "25",
          "URL": "http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf"
        },
        {
          "ExternalReferenceID": "REF-243",
          "Authors": [
            "Sascha Fahl, Marian Harbach, Thomas Muders, Matthew Smith",
            "Lars Baumg\u00e4rtner, Bernd Freisleben"
          ],
          "Title": "Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security",
          "PublicationYear": "2012",
          "PublicationMonth": "10",
          "PublicationDay": "16",
          "URL": "http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf"
        },
        {
          "ExternalReferenceID": "REF-249",
          "Authors": [
            "Kenneth Ballard"
          ],
          "Title": "Secure programming with the OpenSSL API, Part 2: Secure handshake",
          "PublicationYear": "2005",
          "PublicationMonth": "05",
          "PublicationDay": "03",
          "URL": "https://developer.ibm.com/tutorials/l-openssl/?mhsrc=ibmsearch_a&mhq=secure%20programming%20with%20the%20openssl%20API",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-250",
          "Authors": [
            "Eric Rescorla"
          ],
          "Title": "An Introduction to OpenSSL Programming (Part I)",
          "PublicationYear": "2001",
          "PublicationMonth": "10",
          "PublicationDay": "05",
          "URL": "https://www.linuxjournal.com/article/4822",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-955",
          "Authors": [
            "Chris McMahon Stone",
            "Tom Chothia",
            "Flavio D. Garcia"
          ],
          "Title": "Spinner: Semi-Automatic Detection of Pinning without Hostname Verification",
          "URL": "http://www.cs.bham.ac.uk/~garciaf/publications/spinner.pdf",
          "URLDate": "2018-01-16"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "298",
      "Name": "Improper Validation of Certificate Expiration",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A certificate expiration is not validated or is incorrectly validated, so trust may be assigned to certificates that have been abandoned due to age.",
      "ExtendedDescription": "When the expiration of a certificate is not taken into account, no trust has necessarily been conveyed through it. Therefore, the validity of the certificate cannot be verified and all benefit of the certificate is lost.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "295",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "When the software uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete."
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "The data read from the system vouched for by the expired certificate may be flawed due to malicious spoofing."
        },
        {
          "Scope": [
            "Authentication",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Trust afforded to the system in question - based on the expired certificate - may allow for spoofing attacks."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Check for expired certificates and provide the user with adequate information about the nature of the problem and how to proceed."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the expiration."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-123",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that there is a certificate and allows the use of expired certificates."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer(certificate(ssl)) {\n\t\t\tfoo=SSL_get_verify_result(ssl);\n\t\t\tif ((X509_V_OK==foo) || (X509_V_ERR_CERT_HAS_EXPIRED==foo))\n```\n//do stuff*"
            },
            {
              "BodyText": "If the call to SSL_get_verify_result() returns X509_V_ERR_CERT_HAS_EXPIRED, this means that the certificate has expired. As time goes on, there is an increasing chance for attackers to compromise the certificate."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to validate certificate expiration"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "299",
      "Name": "Improper Check for Certificate Revocation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not check or incorrectly checks the revocation status of a certificate, which may cause it to use a certificate that has been compromised.",
      "ExtendedDescription": "An improper check for certificate revocation is a far more serious flaw than related certificate failures. This is because the use of any revoked certificate is almost certainly malicious. The most common reason for certificate revocation is compromise of the system in question, with the result that no legitimate servers will be using a revoked certificate, unless they are sorely out of sync.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "295",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete."
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Trust may be assigned to an entity who is not who it claims to be."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Data from an untrusted (and possibly malicious) source may be integrated."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Data may be disclosed to an entity impersonating a trusted entity, resulting in information disclosure."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that certificates are checked for revoked status."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the revoked status."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-124",
          "Entries": [
            {
              "IntroText": "The following OpenSSL code ensures that there is a certificate before continuing execution."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n```\n// got a certificate, do secret things*"
            },
            {
              "BodyText": "Because this code does not use SSL_get_verify_results() to check the certificate, it could accept certificates that have been revoked (X509_V_ERR_CERT_REVOKED). The product could be communicating with a malicious host."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2011-2014",
          "Description": "LDAP-over-SSL implementation does not check Certificate Revocation List (CRL), allowing spoofing using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2014"
        },
        {
          "Reference": "CVE-2011-0199",
          "Description": "Operating system does not check Certificate Revocation List (CRL) in some cases, allowing spoofing using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0199"
        },
        {
          "Reference": "CVE-2010-5185",
          "Description": "Antivirus product does not check whether certificates from signed executables have been revoked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-5185"
        },
        {
          "Reference": "CVE-2009-3046",
          "Description": "Web browser does not check if any intermediate certificates are revoked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3046"
        },
        {
          "Reference": "CVE-2009-0161",
          "Description": "chain: Ruby module for OCSP misinterprets a response, preventing detection of a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0161"
        },
        {
          "Reference": "CVE-2011-2701",
          "Description": "chain: incorrect parsing of replies from OCSP responders allows bypass using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2701"
        },
        {
          "Reference": "CVE-2011-0935",
          "Description": "Router can permanently cache certain public keys, which would allow bypass if the certificate is later revoked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0935"
        },
        {
          "Reference": "CVE-2009-1358",
          "Description": "chain: OS package manager does not properly check the return value, allowing bypass using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1358"
        },
        {
          "Reference": "CVE-2009-0642",
          "Description": "chain: language interpreter does not properly check the return value from an OSCP function, allowing bypass using a revoked certificate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0642"
        },
        {
          "Reference": "CVE-2008-4679",
          "Description": "chain: web service component does not call the expected method, which prevents a check for revoked certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4679"
        },
        {
          "Reference": "CVE-2006-4410",
          "Description": "Certificate revocation list not searched for certain certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4410"
        },
        {
          "Reference": "CVE-2006-4409",
          "Description": "Product cannot access certificate revocation list when an HTTP proxy is being used.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4409"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to check for certificate revocation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "300",
      "Name": "Channel Accessible by Non-Endpoint",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not adequately verify the identity of actors at both ends of a communication channel, or does not adequately ensure the integrity of the channel, in a way that allows the channel to be accessed or influenced by an actor that is not an endpoint.",
      "ExtendedDescription": "In order to establish secure communication between two parties, it is often important to adequately verify the identity of entities at each end of the communication channel. Inadequate or inconsistent verification may result in insufficient or incorrect identification of either communicating entity. This can have negative consequences such as misplaced trust in the entity at the other end of the channel. An attacker can leverage this by interposing between the communicating entities and masquerading as the original entity. In the absence of sufficient verification of identity, such an attacker can eavesdrop and potentially modify the communication between the original entities.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Adversary-in-the-Middle / AITM"
        },
        {
          "Term": "Man-in-the-Middle / MITM"
        },
        {
          "Term": "Person-in-the-Middle / PITM"
        },
        {
          "Term": "Monkey-in-the-Middle"
        },
        {
          "Term": "Monster-in-the-Middle"
        },
        {
          "Term": "Manipulator-in-the-Middle"
        },
        {
          "Term": "On-path attack"
        },
        {
          "Term": "Interception attack"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could pose as one of the entities and read or possibly modify the communication."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always fully authenticate both ends of any communications channel."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Adhere to the principle of complete mediation."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the Java snippet below, data is sent over an unencrypted channel to a remote server."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tSocket sock;\n\tPrintWriter out;\n\ttry {\n\t\t\tsock = new Socket(REMOTE_HOST, REMOTE_PORT);\n\t\t\tout = new PrintWriter(echoSocket.getOutputStream(), true);\n```\n// Write data to remote host via socket output stream.* \n\t\t\t...}"
            },
            {
              "BodyText": "By eavesdropping on the communication channel or posing as the endpoint, an attacker would be able to read all of the transmitted data."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversry-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Man-in-the-middle (MITM)"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "32",
          "EntryName": "Routing Detour"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC06-J",
          "EntryName": "Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar"
        }
      ],
      "RelatedAttackPatterns": [
        "466",
        "57",
        "589",
        "590",
        "612",
        "613",
        "615",
        "662",
        "94"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-244",
          "Authors": [
            "M. Bishop"
          ],
          "Title": "Computer Security: Art and Science",
          "PublicationYear": "2003",
          "Publisher": "Addison-Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-300 is commonly misused for vulnerabilities in which the prerequisites for exploitation require the adversary to be in a privileged \"in-the-middle\" position.",
        "Comments": "Consider root-cause weaknesses that allow adversary-in-the-middle attacks to happen, such as CWEs involving poor integrity protection.",
        "Reasons": [
          "Frequent Misuse"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The summary identifies multiple distinct possibilities, suggesting that this is a category that must be broken into more specific weaknesses."
        }
      ]
    },
    {
      "ID": "301",
      "Name": "Reflection Attack in an Authentication Protocol",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Simple authentication protocols are subject to reflection attacks if a malicious user can use the target machine to impersonate a trusted user.",
      "ExtendedDescription": "\n\nA mutual authentication protocol requires each party to respond to a random challenge by the other party by encrypting it with a pre-shared key. Often, however, such protocols employ the same pre-shared key for communication with a number of different entities. A malicious user or an attacker can easily compromise this protocol without possessing the correct key by employing a reflection attack on the protocol.\n\n\nReflection attacks capitalize on mutual authentication schemes in order to trick the target into revealing the secret shared between it and another valid user. In a basic mutual-authentication scheme, a secret is known to both the valid user and the server; this allows them to authenticate. In order that they may verify this shared secret without sending it plainly over the wire, they utilize a Diffie-Hellman-style scheme in which they each pick a value, then request the hash of that value as keyed by the shared secret. In a reflection attack, the attacker claims to be a valid user and requests the hash of a random value from the server. When the server returns this value and requests its own value to be hashed, the attacker opens another connection to the server. This time, the hash requested by the attacker is the value which the server requested in the first connection. When the server returns this hashed value, it is used in the first connection, authenticating the attacker successfully as the impersonated valid user.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "327",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The primary result of reflection attacks is successful authentication with a target machine -- as an impersonated user."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use different keys for the initiator and responder or of a different type of challenge for the initiator and responder."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Let the initiator prove its identity before proceeding."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned char *simple_digest(char *alg,char *buf,unsigned int len, int *olen) {\n\t\tconst EVP_MD *m;\n\t\tEVP_MD_CTX ctx;\n\t\tunsigned char *ret;\n\t\tOpenSSL_add_all_digests();\n\t\tif (!(m = EVP_get_digestbyname(alg))) return NULL;\n\t\tif (!(ret = (unsigned char*)malloc(EVP_MAX_MD_SIZE))) return NULL;\n\t\tEVP_DigestInit(&ctx, m);\n\t\tEVP_DigestUpdate(&ctx,buf,len);\n\t\tEVP_DigestFinal(&ctx,ret,olen);\n\t\treturn ret;\n\t}\n\tunsigned char *generate_password_and_cmd(char *password_and_cmd) {\n\t\tsimple_digest(\"sha1\",password,strlen(password_and_cmd)\n\t\t...\n\t\t);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString command = new String(\"some cmd to execute & the password\") MessageDigest encer = MessageDigest.getInstance(\"SHA\");\n\tencer.update(command.getBytes(\"UTF-8\"));\n\tbyte[] digest = encer.digest();\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-3435",
          "Description": "product authentication succeeds if user-provided MD5 hash matches the hash in its database; this can be subjected to replay attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Reflection attack in an auth protocol"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A7",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "90"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Insufficient Validation\", Page 38",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The term \"reflection\" is used in multiple ways within CWE and the community, so its usage should be reviewed."
        }
      ]
    },
    {
      "ID": "302",
      "Name": "Authentication Bypass by Assumed-Immutable Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The authentication scheme or implementation uses key data elements that are assumed to be immutable, but can be controlled or modified by the attacker.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "807",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Operation",
            "Implementation"
          ],
          "Description": "Implement proper protection for immutable data (e.g. environment variable, hidden form fields, etc.)"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, an \"authenticated\" cookie is used to determine whether or not a user should be granted access to a system."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tboolean authenticated = new Boolean(getCookieValue(\"authenticated\")).booleanValue();\n\tif (authenticated) {\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "Modifying the value of a cookie on the client-side is trivial, but many developers assume that cookies are essentially immutable."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0367",
          "Description": "DebPloit",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0367"
        },
        {
          "Reference": "CVE-2004-0261",
          "Description": "Web auth",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0261"
        },
        {
          "Reference": "CVE-2002-1730",
          "Description": "Authentication bypass by setting certain cookies to \"true\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1730"
        },
        {
          "Reference": "CVE-2002-1734",
          "Description": "Authentication bypass by setting certain cookies to \"true\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1734"
        },
        {
          "Reference": "CVE-2002-2064",
          "Description": "Admin access by setting a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2064"
        },
        {
          "Reference": "CVE-2002-2054",
          "Description": "Gain privileges by setting cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2054"
        },
        {
          "Reference": "CVE-2004-1611",
          "Description": "Product trusts authentication information in cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1611"
        },
        {
          "Reference": "CVE-2005-1708",
          "Description": "Authentication bypass by setting admin-testing variable to true.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1708"
        },
        {
          "Reference": "CVE-2005-1787",
          "Description": "Bypass auth and gain privileges by setting a variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1787"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication Bypass via Assumed-Immutable Data"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A1",
          "EntryName": "Unvalidated Input",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC02-J",
          "EntryName": "Do not base security checks on untrusted sources"
        }
      ],
      "RelatedAttackPatterns": [
        "10",
        "13",
        "21",
        "274",
        "31",
        "39",
        "45",
        "77"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "303",
      "Name": "Incorrect Implementation of Authentication Algorithm",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",
      "ExtendedDescription": "This incorrect implementation may allow authentication to be bypassed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0750",
          "Description": "Conditional should have been an 'or' not an 'and'.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0750"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication Logic Error"
        }
      ],
      "RelatedAttackPatterns": [
        "90"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "304",
      "Name": "Missing Critical Step in Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product implements an authentication technique, but it skips a step that weakens the technique.",
      "ExtendedDescription": "Authentication techniques should follow the algorithms that define them exactly, otherwise authentication can be bypassed or more easily subjected to brute force attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "303",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity",
            "Read Application Data",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or allowing attackers to execute arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-2163",
          "Description": "Shared secret not verified in a RADIUS response packet, allowing authentication bypass by spoofing server replies.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2163"
        },
        {
          "Reference": "CVE-2005-3327",
          "Description": "Chain: Authentication bypass by skipping the first startup step as required by the protocol.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3327"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Critical Step in Authentication"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "305",
      "Name": "Authentication Bypass by Primary Weakness",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The authentication algorithm is sound, but the implemented mechanism can be bypassed as the result of a separate weakness that is primary to the authentication error.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1374",
          "Description": "The provided password is only compared against the first character of the real password.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1374"
        },
        {
          "Reference": "CVE-2000-0979",
          "Description": "The password is not properly checked, which allows remote attackers to bypass access controls by sending a 1-byte password that matches the first character of the real password.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0979"
        },
        {
          "Reference": "CVE-2001-0088",
          "Description": "Chain: Forum software does not properly initialize an array, which inadvertently sets the password to a single character, allowing remote attackers to easily guess the password and gain administrative privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0088"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Authentication Bypass by Primary Weakness"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Most \"authentication bypass\" errors are resultant, not primary."
        }
      ]
    },
    {
      "ID": "306",
      "Name": "Missing Authentication for Critical Function",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-306-Diagram.png",
      "Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Architecture and Design",
          "Note": "Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port."
        },
        {
          "Phase": "Operation",
          "Note": "When migrating data to the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), there is a risk of losing the protections that were originally provided by hosting on internal networks. If access does not require authentication, it can be easier for attackers to access the data from anywhere on the Internet."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Varies by Context"
          ],
          "Note": "Exposing critical functionality essentially provides an attacker with the privilege level of that functionality. The consequences will depend on the associated functionality, but they can range from reading or modifying sensitive data, accessing administrative or other privileged functionality, or possibly even executing arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-7.2",
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of custom authentication mechanisms.\n",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "DetectionMethodID": "DM-6.1",
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis is useful for detecting commonly-used idioms for authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries.\n\n\nGenerally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives.\n",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost Application Interface Scanner\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nDivide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.\n\n\nIdentify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.\n\n\nIn general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.\n"
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nWhere possible, avoid implementing custom, \"grow-your-own\" authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks.\n\n\nIn environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.\n"
        },
        {
          "MitigationID": "MIT-4.5",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].\n"
        },
        {
          "Phase": [
            "Implementation",
            "System Configuration",
            "Operation"
          ],
          "Description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302]."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the method createBankAccount is used to create a BankAccount object for a bank management application."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic BankAccount createBankAccount(String accountNumber, String accountType,\n\tString accountName, String accountSSN, double balance) {\n\t\t\tBankAccount account = new BankAccount();\n\t\t\taccount.setAccountNumber(accountNumber);\n\t\t\taccount.setAccountType(accountType);\n\t\t\taccount.setAccountOwnerName(accountName);\n\t\t\taccount.setAccountOwnerSSN(accountSSN);\n\t\t\taccount.setBalance(balance);\n\t\t\treturn account;\n\t}\n```"
            },
            {
              "BodyText": "However, there is no authentication mechanism to ensure that the user creating this bank account object has the authority to create new bank accounts. Some authentication mechanisms should be used to verify that the user has the authority to create bank account objects."
            },
            {
              "BodyText": "The following Java code includes a boolean variable and method for authenticating a user. If the user has not been authenticated then the createBankAccount will not create the bank account object."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate boolean isUserAuthentic = false;\n```\n// authenticate user,* \n\t\n\t\n\t *// if user is authenticated then set variable to true* \n\t\n\t\n\t *// otherwise set variable to false* \n\tpublic boolean authenticateUser(String username, String password) {\n\t```\n\t\t...\n\t}\n\tpublic BankAccount createNewBankAccount(String accountNumber, String accountType,\n\tString accountName, String accountSSN, double balance) {\n\t\t\tBankAccount account = null;\n\t\t\tif (isUserAuthentic) {\n\t\t\t\taccount = new BankAccount();\n\t\t\t\taccount.setAccountNumber(accountNumber);\n\t\t\t\taccount.setAccountType(accountType);\n\t\t\t\taccount.setAccountOwnerName(accountName);\n\t\t\t\taccount.setAccountOwnerSSN(accountSSN);\n\t\t\t\taccount.setBalance(balance);\n\t\t\t}\n\t\t\treturn account;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors did not use any authentication for critical functionality in their OT products."
            }
          ]
        },
        {
          "ID": "DX-155",
          "Entries": [
            {
              "IntroText": "In 2021, a web site operated by PeopleGIS stored data of US municipalities in Amazon Web Service (AWS) Simple Storage Service (S3) buckets."
            },
            {
              "Nature": "Bad",
              "Language": "Other",
              "ExampleCode": "```\n\tA security researcher found 86 S3 buckets that could be accessed without authentication (CWE-306) and stored data unencrypted (CWE-312). These buckets exposed over 1000 GB of data and 1.6 million files including physical addresses, phone numbers, tax documents, pictures of driver's license IDs, etc. [REF-1296] [REF-1295]\n```"
            },
            {
              "BodyText": "While it was not publicly disclosed how the data was protected after discovery, multiple options could have been considered."
            },
            {
              "Nature": "Good",
              "Language": "Other",
              "ExampleCode": "```\n\tThe sensitive information could have been protected by ensuring that the buckets did not have public read access, e.g., by enabling the s3-account-level-public-access-blocks-periodic rule to Block Public Access. In addition, the data could have been encrypted at rest using the appropriate S3 settings, e.g., by enabling server-side encryption using the s3-bucket-server-side-encryption-enabled setting. Other settings are available to further prevent bucket data from being leaked. [REF-1297]\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-31260",
          "Description": "Chain: a digital asset management program has an undisclosed backdoor in the legacy version of a PHP script (CWE-912) that could allow an unauthenticated user to export metadata (CWE-306)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-31260"
        },
        {
          "Reference": "CVE-2022-29951",
          "Description": "TCP-based protocol in Programmable Logic Controller (PLC) has no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29951"
        },
        {
          "Reference": "CVE-2022-29952",
          "Description": "Condition Monitor firmware uses a protocol that does not require authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29952"
        },
        {
          "Reference": "CVE-2022-30276",
          "Description": "SCADA-based protocol for bridging WAN and LAN traffic has no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30276"
        },
        {
          "Reference": "CVE-2022-30313",
          "Description": "Safety Instrumented System uses proprietary TCP protocols with no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30313"
        },
        {
          "Reference": "CVE-2022-30317",
          "Description": "Distributed Control System (DCS) uses a protocol that has no authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30317"
        },
        {
          "Reference": "CVE-2021-21972",
          "Description": "Chain: Cloud computing virtualization platform does not require authentication for upload of a tar format file (CWE-306), then uses .. path traversal sequences (CWE-23) in the file to access unexpected files, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21972"
        },
        {
          "Reference": "CVE-2020-10263",
          "Description": "Bluetooth speaker does not require authentication for the debug functionality on the UART port, allowing root shell access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10263"
        },
        {
          "Reference": "CVE-2021-23147",
          "Description": "WiFi router does not require authentication for its UART port, allowing adversaries with physical access to execute commands as root",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-23147"
        },
        {
          "Reference": "CVE-2021-37415",
          "Description": "IT management product does not perform authentication for some REST API requests, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37415"
        },
        {
          "Reference": "CVE-2020-13927",
          "Description": "Default setting in workflow management product allows all API requests without authentication, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-13927"
        },
        {
          "Reference": "CVE-2002-1810",
          "Description": "MFV. Access TFTP server without authentication and obtain configuration file with sensitive plaintext information.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1810"
        },
        {
          "Reference": "CVE-2008-6827",
          "Description": "Agent software running at privileges does not authenticate incoming requests over an unprotected channel, allowing a Shatter\" attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6827"
        },
        {
          "Reference": "CVE-2004-0213",
          "Description": "Product enforces restrictions through a GUI but not through privileged APIs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0213"
        },
        {
          "Reference": "CVE-2020-15483",
          "Description": "monitor device allows access to physical UART debug port without authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-15483"
        },
        {
          "Reference": "CVE-2019-9201",
          "Description": "Programmable Logic Controller (PLC) does not have an authentication feature on its communication protocols.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9201"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "No Authentication for Critical Function"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP31",
          "EntryName": "Missing authentication"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SR-2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-3"
        }
      ],
      "RelatedAttackPatterns": [
        "12",
        "166",
        "216",
        "36",
        "62"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Authentication,\" Page 36",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-257",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 19 - Missing Authentication for Critical Function",
          "PublicationYear": "2010",
          "PublicationMonth": "02",
          "PublicationDay": "23",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-19-missing-authentication-for-critical-function/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1295",
          "Authors": [
            "WizCase"
          ],
          "Title": "Over 80 US Municipalities' Sensitive Information, Including Resident's Personal Data, Left Vulnerable in Massive Data Breach",
          "PublicationYear": "2021",
          "PublicationMonth": "07",
          "PublicationDay": "20",
          "URL": "https://www.wizcase.com/blog/us-municipality-breach-report/"
        },
        {
          "ExternalReferenceID": "REF-1296",
          "Authors": [
            "Jonathan Greig"
          ],
          "Title": "1,000 GB of local government data exposed by Massachusetts software company",
          "PublicationYear": "2021",
          "PublicationMonth": "07",
          "PublicationDay": "22",
          "URL": "https://www.zdnet.com/article/1000-gb-of-local-government-data-exposed-by-massachusetts-software-company/"
        },
        {
          "ExternalReferenceID": "REF-1297",
          "Authors": [
            "Amazon"
          ],
          "Title": "AWS Foundational Security Best Practices controls",
          "PublicationYear": "2022",
          "URL": "https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-controls-reference.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1298",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Authentication and authorization in Azure App Service and Azure Functions",
          "PublicationYear": "2021",
          "PublicationMonth": "11",
          "PublicationDay": "23",
          "URL": "https://learn.microsoft.com/en-us/azure/app-service/overview-authentication-authorization",
          "URLDate": "2022-10-11"
        },
        {
          "ExternalReferenceID": "REF-1302",
          "Authors": [
            "Google Cloud"
          ],
          "Title": "Authentication and authorization use cases",
          "PublicationYear": "2022",
          "PublicationMonth": "10",
          "PublicationDay": "11",
          "URL": "https://cloud.google.com/docs/authentication/use-cases",
          "URLDate": "2022-10-11"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "307",
      "Name": "Improper Restriction of Excessive Authentication Attempts",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame, making it more susceptible to brute force attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "799",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "An attacker could perform an arbitrary number of authentication attempts using different passwords, and eventually gain access to the targeted account."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tForced Path Execution",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nCommon protection mechanisms include:\n\n\n  - Disconnecting the user after a small number of failed attempts\n\n  - Implementing a timeout\n\n  - Locking out a targeted account\n\n  - Requiring a computational task on the user's part.\n\n"
        },
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nConsider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator. [REF-45]\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-117",
          "Entries": [
            {
              "IntroText": "In January 2009, an attacker was able to gain administrator access to a Twitter server because the server did not restrict the number of login attempts [REF-236]. The attacker targeted a member of Twitter's support team and was able to successfully guess the member's password using a brute force attack by guessing a large number of common words. After gaining access as the member of the support staff, the attacker used the administrator panel to gain access to 33 accounts that belonged to celebrities and politicians. Ultimately, fake Twitter messages were sent that appeared to come from the compromised accounts."
            },
            {
              "Reference": "REF-236"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code, extracted from a servlet's doPost() method, performs an authentication lookup every time the servlet is invoked."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString username = request.getParameter(\"username\");\n\tString password = request.getParameter(\"password\");\n\tint authResult = authenticateUser(username, password);\n```"
            },
            {
              "BodyText": "However, the software makes no attempt to restrict excessive authentication attempts."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code attempts to limit the number of login attempts by causing the process to sleep before completing the authentication."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$username = $_POST['username'];\n\t$password = $_POST['password'];\n\tsleep(2000);\n\t$isAuthenticated = authenticateUser($username, $password);\n```"
            },
            {
              "BodyText": "However, there is no limit on parallel connections, so this does not increase the amount of time an attacker needs to complete an attack."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the validateUser method opens a socket connection, reads a username and password from the socket and attempts to authenticate the username and password."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint validateUser(char *host, int port)\n\t{\n\t\t\tint socket = openSocketConnection(host, port);\n\t\t\tif (socket < 0) {\n\t\t\t\tprintf(\"Unable to open socket connection\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t\t\tint isValidUser = 0;\n\t\t\tchar username[USERNAME_SIZE];\n\t\t\tchar password[PASSWORD_SIZE];\n\t\t\twhile (isValidUser == 0) {\n\t\t\t\t\tif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {\n\t\t\t\t\t\tif (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {\n\t\t\t\t\t\t\tisValidUser = AuthenticateUser(username, password);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn(SUCCESS);\n\t}\n```"
            },
            {
              "BodyText": "The validateUser method will continuously check for a valid username and password without any restriction on the number of authentication attempts made. The method should limit the number of authentication attempts made to prevent brute force attacks as in the following example code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint validateUser(char *host, int port)\n\t{\n\t\t\t...\n\t\t\tint count = 0;\n\t\t\twhile ((isValidUser == 0) && (count < MAX_ATTEMPTS)) {\n\t\t\t\t\tif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {\n\t\t\t\t\t\tif (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {\n\t\t\t\t\t\t\tisValidUser = AuthenticateUser(username, password);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (isValidUser) {\n\t\t\t\treturn(SUCCESS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Consider this example from a real-world attack against the iPhone [REF-1218]. An attacker can use brute force methods; each time there is a failed guess, the attacker quickly cuts the power before the failed entry is recorded, effectively bypassing the intended limit on the number of failed authentication attempts. Note that this attack requires removal of the cell phone battery and connecting directly to the phone's power source, and the brute force attack is still time-consuming."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-0039",
          "Description": "the REST API for a network OS has a high limit for number of connections, allowing brute force password guessing",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-0039"
        },
        {
          "Reference": "CVE-1999-1152",
          "Description": "Product does not disconnect or timeout after multiple failed logins.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1152"
        },
        {
          "Reference": "CVE-2001-1291",
          "Description": "Product does not disconnect or timeout after multiple failed logins.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1291"
        },
        {
          "Reference": "CVE-2001-0395",
          "Description": "Product does not disconnect or timeout after multiple failed logins.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0395"
        },
        {
          "Reference": "CVE-2001-1339",
          "Description": "Product does not disconnect or timeout after multiple failed logins.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1339"
        },
        {
          "Reference": "CVE-2002-0628",
          "Description": "Product does not disconnect or timeout after multiple failed logins.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0628"
        },
        {
          "Reference": "CVE-1999-1324",
          "Description": "User accounts not disabled when they exceed a threshold; possibly a resultant problem.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1324"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryID": "AUTHENT.MULTFAIL",
          "EntryName": "Multiple Failed Authentication Attempts not Prevented"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP34",
          "EntryName": "Unrestricted authentication"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "49",
        "560",
        "565",
        "600",
        "652",
        "653"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-236",
          "Authors": [
            "Kim Zetter"
          ],
          "Title": "Weak Password Brings 'Happiness' to Twitter Hacker",
          "PublicationYear": "2009",
          "PublicationMonth": "01",
          "PublicationDay": "09",
          "URL": "https://www.wired.com/2009/01/professed-twitt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1218",
          "Authors": [
            "Graham Cluley"
          ],
          "Title": "This Black Box Can Brute Force Crack iPhone PIN Passcodes",
          "Publication": "The Mac Security Blog",
          "PublicationYear": "2015",
          "PublicationMonth": "03",
          "PublicationDay": "16",
          "URL": "https://www.intego.com/mac-security-blog/iphone-pin-pass-code/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "308",
      "Name": "Use of Single-factor Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The use of single-factor authentication can lead to unnecessary risk of compromise when compared with the benefits of a dual-factor authentication scheme.",
      "ExtendedDescription": "While the use of multiple authentication schemes is simply piling on more complexity on top of authentication, it is inestimably valuable to have such measures of redundancy. The use of weak, reused, and common passwords is rampant on the internet. Without the added protection of multiple authentication schemes, a single mistake can result in the compromise of an account. For this reason, if multiple schemes are possible and also easy to use, they should be implemented and required.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "654",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "309",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "If the secret in a single-factor authentication scheme gets compromised, full authentication is possible."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use multiple independent authentication schemes, which ensures that -- if one of the methods is compromised -- the system itself is still likely safe from compromise."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-101",
          "Entries": [
            {
              "IntroText": "In both of these examples, a user is logged in if their given password matches a stored password:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned char *check_passwd(char *plaintext) {\n\t\tctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n```\n//Login if hash matches stored hash* \n\t\tif (equal(ctext, secret_password())) {\n\t\t```\n\t\t\tlogin_user();\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString plainText = new String(plainTextIn);\n\tMessageDigest encer = MessageDigest.getInstance(\"SHA\");\n\tencer.update(plainTextIn);\n\tbyte[] digest = password.digest();\n```\n//Login if hash matches stored hash* \n\tif (equal(digest,secret_password())) {\n\t```\n\t\tlogin_user();\n\t}\n```"
            },
            {
              "BodyText": "This code relies exclusively on a password mechanism (CWE-309) using only one factor of authentication (CWE-308). If an attacker can steal or guess a user's password, they are given full access to their account. Note this code also uses SHA-1, which is a weak hash (CWE-328). It also does not use a salt (CWE-759)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-35248",
          "Description": "Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35248"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using single-factor authentication"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "49",
        "509",
        "55",
        "555",
        "560",
        "561",
        "565",
        "600",
        "644",
        "645",
        "652",
        "653",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "309",
      "Name": "Use of Password System for Primary Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The use of password systems as the primary means of authentication may be subject to several flaws or shortcomings, each reducing the effectiveness of the mechanism.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "654",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "308",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Password systems are the simplest and most ubiquitous authentication mechanisms. However, they are subject to such well known attacks,and such frequent compromise that their use in the most simple implementation is not practical."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "A password authentication mechanism error will almost always result in attackers being authorized as valid users."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nIn order to protect password systems from compromise, the following should be noted:\n\n\n  - Passwords should be stored safely to prevent insider attack and to ensure that -- if a system is compromised -- the passwords are not retrievable. Due to password reuse, this information may be useful in the compromise of other systems these users work with. In order to protect these passwords, they should be stored encrypted, in a non-reversible state, such that the original text password cannot be extracted from the stored value.\n\n  - Password aging should be strictly enforced to ensure that passwords do not remain unchanged for long periods of time. The longer a password remains in use, the higher the probability that it has been compromised. For this reason, passwords should require refreshing periodically, and users should be informed of the risk of passwords which remain in use for too long.\n\n  - Password strength should be enforced intelligently. Rather than restrict passwords to specific content, or specific length, users should be encouraged to use upper and lower case letters, numbers, and symbols in their passwords. The system should also ensure that no passwords are derived from dictionary words.\n\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a zero-knowledge password protocol, such as SRP."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that passwords are stored safely and are not reversible."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Implement password aging functionality that requires passwords be changed after a certain point."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a mechanism for determining the strength of a password and notify the user of weak password use."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Inform the user of why password protections are in place, how they work to protect data integrity, and why it is important to heed their warnings."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-101",
          "Entries": [
            {
              "IntroText": "In both of these examples, a user is logged in if their given password matches a stored password:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned char *check_passwd(char *plaintext) {\n\t\tctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n```\n//Login if hash matches stored hash* \n\t\tif (equal(ctext, secret_password())) {\n\t\t```\n\t\t\tlogin_user();\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString plainText = new String(plainTextIn);\n\tMessageDigest encer = MessageDigest.getInstance(\"SHA\");\n\tencer.update(plainTextIn);\n\tbyte[] digest = password.digest();\n```\n//Login if hash matches stored hash* \n\tif (equal(digest,secret_password())) {\n\t```\n\t\tlogin_user();\n\t}\n```"
            },
            {
              "BodyText": "This code relies exclusively on a password mechanism (CWE-309) using only one factor of authentication (CWE-308). If an attacker can steal or guess a user's password, they are given full access to their account. Note this code also uses SHA-1, which is a weak hash (CWE-328). It also does not use a salt (CWE-759)."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using password systems"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "16",
        "49",
        "509",
        "55",
        "555",
        "560",
        "561",
        "565",
        "600",
        "652",
        "653",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "311",
      "Name": "Missing Encryption of Sensitive Data",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not encrypt sensitive or critical information before storage or transmission.",
      "ExtendedDescription": "The lack of proper data encryption passes up the guarantees of confidentiality, integrity, and accountability that properly implemented encryption conveys.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "If the application does not use a secure channel, such as SSL, to exchange sensitive information, it is possible for an attacker with access to the network traffic to sniff packets from the connection and uncover the data. This attack is not technically difficult, but does require physical access to some portion of the network over which the sensitive data travels. This access is usually somewhere near where the user is connected to the network (such as a colleague on the company network) but can be anywhere along the path from the user to the end server."
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Omitting the use of encryption in any program which transfers data over a network of any kind should be considered on par with delivering the data sent to each user on the local networks of both the sender and receiver. Worse, this omission allows for the injection of data into a stream of communication between two parties -- with no means for the victims to separate valid data from invalid. In this day of widespread network attacks and password collection sniffers, it is an unnecessary risk to omit encryption from the design of any system which might benefit from it."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Analysis",
          "Description": "The characterizaton of sensitive data often requires domain-specific understanding, so manual methods are useful. However, manual efforts might not achieve desired code coverage within limited time constraints. Black box methods may produce artifacts (e.g. stored data or unencrypted network transfer) that require manual evaluation.",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Analysis",
          "Description": "Automated measurement of the entropy of an input/output source may indicate the use or lack of encryption, but human analysis is still required to distinguish intentionally-unencrypted data (e.g. metadata) from sensitive data."
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tNetwork Sniffer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tAutomated Monitored Execution\n\t\tMan-in-the-middle attack tool",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Clearly specify which data or resources are valuable enough that they should be protected by encryption. Require that any transmission or storage of this data/resource should use well-vetted encryption algorithms."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nEnsure that encryption is properly integrated into the system design, including but not necessarily limited to:\n\n\n  - Encryption that is needed to store or transmit private data of the users of the system\n\n  - Encryption that is needed to protect the system itself from unauthorized disclosure or tampering\n\nIdentify the separate needs and contexts for encryption:\n\n  - One-way (i.e., only the user or recipient needs to have the key). This can be achieved using public key cryptography, or other techniques in which the encrypting party (i.e., the product) does not need to have access to a private key.\n\n  - Two-way (i.e., the encryption can be automatically performed on behalf of a user, but the key must be available so that the plaintext can be automatically recoverable by that user). This requires storage of the private key in a format that is recoverable only by the user (or perhaps by the operating system) in a way that cannot be recovered by others.\n\nUsing threat modeling or other techniques, assume that data can be compromised through a separate vulnerability or weakness, and determine where encryption will be most effective. Ensure that data that should be private is not being inadvertently exposed using weaknesses such as insecure permissions (CWE-732). [REF-7]"
        },
        {
          "MitigationID": "MIT-24",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nWhen there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.\n\n\nFor example, US government systems require FIPS 140-2 certification.\n\n\nDo not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.\n\n\nPeriodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]\n"
        },
        {
          "MitigationID": "MIT-46",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"
        },
        {
          "MitigationID": "MIT-25",
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks."
        },
        {
          "MitigationID": "MIT-33",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "This makes it easier to spot places in the code where data is being used that is unencrypted."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-40",
          "Entries": [
            {
              "IntroText": "This code writes a user's login information to a cookie so the user does not have to login again later."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction persistLogin($username, $password){\n\t\t$data = array(\"username\" => $username, \"password\"=> $password);\n\t\tsetcookie (\"userdata\", $data);\n\t}\n```"
            },
            {
              "BodyText": "The code stores the user's username and password in plaintext in a cookie on the user's machine. This exposes the user's login information if their computer is compromised by an attacker. Even if the user's machine is not compromised, this weakness combined with cross-site scripting (CWE-79) could allow an attacker to remotely copy the cookie."
            },
            {
              "BodyText": "Also note this example code also exhibits Plaintext Storage in a Cookie (CWE-315)."
            }
          ]
        },
        {
          "ID": "DX-41",
          "Entries": [
            {
              "IntroText": "The following code attempts to establish a connection, read in a password, then store it to a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tserver.sin_family = AF_INET; hp = gethostbyname(argv[1]);\n\tif (hp==NULL) error(\"Unknown host\");\n\tmemcpy( (char *)&server.sin_addr,(char *)hp->h_addr,hp->h_length);\n\tif (argc < 3) port = 80;\n\telse port = (unsigned short)atoi(argv[3]);\n\tserver.sin_port = htons(port);\n\tif (connect(sock, (struct sockaddr *)&server, sizeof server) < 0) error(\"Connecting\");\n\t...\n\twhile ((n=read(sock,buffer,BUFSIZE-1))!=-1) {\n\t\t\twrite(dfd,password_buffer,n);\n\t\t\t...\n```"
            },
            {
              "BodyText": "While successful, the program does not encrypt the data before writing it to a buffer, possibly exposing it to unauthorized actors."
            }
          ]
        },
        {
          "ID": "DX-42",
          "Entries": [
            {
              "IntroText": "The following code attempts to establish a connection to a site to communicate sensitive information."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tURL u = new URL(\"http://www.secret.example.org/\");\n\t\tHttpURLConnection hu = (HttpURLConnection) u.openConnection();\n\t\thu.setRequestMethod(\"PUT\");\n\t\thu.connect();\n\t\tOutputStream os = hu.getOutputStream();\n\t\thu.disconnect();\n\t}\n\tcatch (IOException e) {\n```\n//...* \n\t\t\t}"
            },
            {
              "BodyText": "Though a connection is successfully made, the connection is unencrypted and it is possible that all sensitive data sent to or received from the server will be read by unintended actors."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-2272",
          "Description": "password and username stored in cleartext in a cookie",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2272"
        },
        {
          "Reference": "CVE-2009-1466",
          "Description": "password stored in cleartext in a file with insecure permissions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1466"
        },
        {
          "Reference": "CVE-2009-0152",
          "Description": "chat program disables SSL in some circumstances even when the user says to use SSL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0152"
        },
        {
          "Reference": "CVE-2009-1603",
          "Description": "Chain: product uses an incorrect public exponent when generating an RSA key, which effectively disables the encryption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1603"
        },
        {
          "Reference": "CVE-2009-0964",
          "Description": "storage of unencrypted passwords in a database",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0964"
        },
        {
          "Reference": "CVE-2008-6157",
          "Description": "storage of unencrypted passwords in a database",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6157"
        },
        {
          "Reference": "CVE-2008-6828",
          "Description": "product stores a password in cleartext in memory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6828"
        },
        {
          "Reference": "CVE-2008-1567",
          "Description": "storage of a secret key in cleartext in a temporary file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1567"
        },
        {
          "Reference": "CVE-2008-0174",
          "Description": "SCADA product uses HTTP Basic Authentication, which is not encrypted",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0174"
        },
        {
          "Reference": "CVE-2007-5778",
          "Description": "login credentials stored unencrypted in a registry key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5778"
        },
        {
          "Reference": "CVE-2002-1949",
          "Description": "Passwords transmitted in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1949"
        },
        {
          "Reference": "CVE-2008-4122",
          "Description": "Chain: Use of HTTPS cookie without \"secure\" flag causes it to be transmitted across unencrypted HTTP.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4122"
        },
        {
          "Reference": "CVE-2008-3289",
          "Description": "Product sends password hash in cleartext in violation of intended policy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3289"
        },
        {
          "Reference": "CVE-2008-4390",
          "Description": "Remote management feature sends sensitive information including passwords in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4390"
        },
        {
          "Reference": "CVE-2007-5626",
          "Description": "Backup routine sends password in cleartext in email.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5626"
        },
        {
          "Reference": "CVE-2004-1852",
          "Description": "Product transmits Blowfish encryption key in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1852"
        },
        {
          "Reference": "CVE-2008-0374",
          "Description": "Printer sends configuration information, including administrative password, in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0374"
        },
        {
          "Reference": "CVE-2007-4961",
          "Description": "Chain: cleartext transmission of the MD5 hash of password enables attacks against a server that is susceptible to replay (CWE-294).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4961"
        },
        {
          "Reference": "CVE-2007-4786",
          "Description": "Product sends passwords in cleartext to a log server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4786"
        },
        {
          "Reference": "CVE-2005-3140",
          "Description": "Product sends file with cleartext passwords in e-mail message intended for diagnostic purposes.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3140"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to encrypt data"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A8",
          "EntryName": "Insecure Cryptographic Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A9",
          "EntryName": "Insecure Communications",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "4",
          "EntryName": "Insufficient Transport Layer Protection"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC00-J",
          "EntryName": "Use SSLSocket rather than Socket for secure data exchange"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 4.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.5"
        }
      ],
      "RelatedAttackPatterns": [
        "157",
        "158",
        "204",
        "31",
        "37",
        "383",
        "384",
        "385",
        "386",
        "387",
        "388",
        "477",
        "609",
        "65"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"Protecting Secret Data\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 17: Failure to Protect Stored Data.\" Page 253",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-265",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 10 - Missing Encryption of Sensitive Data",
          "PublicationYear": "2010",
          "PublicationMonth": "02",
          "PublicationDay": "26",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-10-missing-encryption-of-sensitive-data/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Encryption\", Page 43",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-311 is high-level with more precise children available. It is a level-1 Class (i.e., a child of a Pillar).",
        "Comments": "Consider children CWE-312: Cleartext Storage of Sensitive Information or CWE-319: Cleartext Transmission of Sensitive Information.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is an overlapping relationship between insecure storage of sensitive information (CWE-922) and missing encryption of sensitive information (CWE-311). Encryption is often used to prevent an attacker from reading the sensitive data. However, encryption does not prevent the attacker from erasing or overwriting the data."
        }
      ]
    },
    {
      "ID": "312",
      "Name": "Cleartext Storage of Sensitive Information",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext within a resource that might be accessible to another control sphere.",
      "ExtendedDescription": "\n\nBecause the information is stored in cleartext (i.e., unencrypted), attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.\n\n\nWhen organizations adopt cloud services, it can be easier for attackers to access the data from anywhere on the Internet.\n\n\nIn some systems/environments such as cloud, the use of \"double encryption\" (at both the software and hardware layer) might be required, and the developer might be solely responsible for both layers, instead of shared responsibility with the administrator of the broader system/environment.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "311",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "311",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "922",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "An attacker with access to the system could read sensitive information stored in cleartext."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "System Configuration",
            "Operation"
          ],
          "Description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to encrypt the data at rest. [REF-1297] [REF-1299] [REF-1301]"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-44",
          "Entries": [
            {
              "IntroText": "The following code excerpt stores a plaintext user account ID in a browser cookie."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tresponse.addCookie( new Cookie(\"userAccountID\", acctID);\n```"
            },
            {
              "BodyText": "Because the account ID is in plaintext, the user's account information is exposed if their computer is compromised by an attacker."
            }
          ]
        },
        {
          "ID": "DX-40",
          "Entries": [
            {
              "IntroText": "This code writes a user's login information to a cookie so the user does not have to login again later."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction persistLogin($username, $password){\n\t\t$data = array(\"username\" => $username, \"password\"=> $password);\n\t\tsetcookie (\"userdata\", $data);\n\t}\n```"
            },
            {
              "BodyText": "The code stores the user's username and password in plaintext in a cookie on the user's machine. This exposes the user's login information if their computer is compromised by an attacker. Even if the user's machine is not compromised, this weakness combined with cross-site scripting (CWE-79) could allow an attacker to remotely copy the cookie."
            },
            {
              "BodyText": "Also note this example code also exhibits Plaintext Storage in a Cookie (CWE-315)."
            }
          ]
        },
        {
          "ID": "DX-41",
          "Entries": [
            {
              "IntroText": "The following code attempts to establish a connection, read in a password, then store it to a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tserver.sin_family = AF_INET; hp = gethostbyname(argv[1]);\n\tif (hp==NULL) error(\"Unknown host\");\n\tmemcpy( (char *)&server.sin_addr,(char *)hp->h_addr,hp->h_length);\n\tif (argc < 3) port = 80;\n\telse port = (unsigned short)atoi(argv[3]);\n\tserver.sin_port = htons(port);\n\tif (connect(sock, (struct sockaddr *)&server, sizeof server) < 0) error(\"Connecting\");\n\t...\n\twhile ((n=read(sock,buffer,BUFSIZE-1))!=-1) {\n\t\t\twrite(dfd,password_buffer,n);\n\t\t\t...\n```"
            },
            {
              "BodyText": "While successful, the program does not encrypt the data before writing it to a buffer, possibly exposing it to unauthorized actors."
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "At least one OT product stored a password in plaintext."
            }
          ]
        },
        {
          "ID": "DX-155",
          "Entries": [
            {
              "IntroText": "In 2021, a web site operated by PeopleGIS stored data of US municipalities in Amazon Web Service (AWS) Simple Storage Service (S3) buckets."
            },
            {
              "Nature": "Bad",
              "Language": "Other",
              "ExampleCode": "```\n\tA security researcher found 86 S3 buckets that could be accessed without authentication (CWE-306) and stored data unencrypted (CWE-312). These buckets exposed over 1000 GB of data and 1.6 million files including physical addresses, phone numbers, tax documents, pictures of driver's license IDs, etc. [REF-1296] [REF-1295]\n```"
            },
            {
              "BodyText": "While it was not publicly disclosed how the data was protected after discovery, multiple options could have been considered."
            },
            {
              "Nature": "Good",
              "Language": "Other",
              "ExampleCode": "```\n\tThe sensitive information could have been protected by ensuring that the buckets did not have public read access, e.g., by enabling the s3-account-level-public-access-blocks-periodic rule to Block Public Access. In addition, the data could have been encrypted at rest using the appropriate S3 settings, e.g., by enabling server-side encryption using the s3-bucket-server-side-encryption-enabled setting. Other settings are available to further prevent bucket data from being leaked. [REF-1297]\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Consider the following PowerShell command examples for encryption scopes of Azure storage objects. In the first example, an encryption scope is set for the storage account."
            },
            {
              "Nature": "Bad",
              "Language": "Shell",
              "ExampleCode": "```\n\tNew-AzStorageEncryptionScope -ResourceGroupName \"MyResourceGroup\" -AccountName \"MyStorageAccount\" -EncryptionScopeName testscope -StorageEncryption\n```"
            },
            {
              "BodyText": "The result (edited and formatted for readability) might be:"
            },
            {
              "Nature": "Bad",
              "Language": "Other",
              "ExampleCode": "```\n\tResourceGroupName: MyResourceGroup, StorageAccountName: MyStorageAccount\n```\n\n```\n```\n\n\t\t\n\t\t\tName\n\t\t\tState\n\t\t\tSource\n\t\t\tRequireInfrastructureEncryption\n\t\t\n\t\t\ttestscope\n\t\t\tEnabled\n\t\t\tMicrosoft.Storage"
            },
            {
              "BodyText": "However, the empty string under RequireInfrastructureEncryption indicates this service was not enabled at the time of creation, because the -RequireInfrastructureEncryption argument was not specified in the command."
            },
            {
              "BodyText": "Including the -RequireInfrastructureEncryption argument addresses the issue:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\tNew-AzStorageEncryptionScope -ResourceGroupName \"MyResourceGroup\" -AccountName \"MyStorageAccount\" -EncryptionScopeName testscope -StorageEncryption -RequireInfrastructureEncryption\n```"
            },
            {
              "BodyText": "This produces the report:"
            },
            {
              "Nature": "Result",
              "Language": "Other",
              "ExampleCode": "```\n\tResourceGroupName: MyResourceGroup, StorageAccountName: MyStorageAccount\n```\n\n```\n```\n\n\t\t\n\t\t\tName\n\t\t\tState\n\t\t\tSource\n\t\t\tRequireInfrastructureEncryption\n\t\t\n\t\t\ttestscope\n\t\t\tEnabled\n\t\t\tMicrosoft.Keyvault\n\t\t\tTrue"
            },
            {
              "BodyText": "In a scenario where both software and hardware layer encryption is required (\"double encryption\"), Azure's infrastructure encryption setting can be enabled via the CLI or Portal. An important note is that infrastructure hardware encryption cannot be enabled or disabled after a blob is created. Furthermore, the default value for infrastructure encryption is disabled in blob creations."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30275",
          "Description": "Remote Terminal Unit (RTU) uses a driver that relies on a password stored in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30275"
        },
        {
          "Reference": "CVE-2009-2272",
          "Description": "password and username stored in cleartext in a cookie",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2272"
        },
        {
          "Reference": "CVE-2009-1466",
          "Description": "password stored in cleartext in a file with insecure permissions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1466"
        },
        {
          "Reference": "CVE-2009-0152",
          "Description": "chat program disables SSL in some circumstances even when the user says to use SSL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0152"
        },
        {
          "Reference": "CVE-2009-1603",
          "Description": "Chain: product uses an incorrect public exponent when generating an RSA key, which effectively disables the encryption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1603"
        },
        {
          "Reference": "CVE-2009-0964",
          "Description": "storage of unencrypted passwords in a database",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0964"
        },
        {
          "Reference": "CVE-2008-6157",
          "Description": "storage of unencrypted passwords in a database",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6157"
        },
        {
          "Reference": "CVE-2008-6828",
          "Description": "product stores a password in cleartext in memory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6828"
        },
        {
          "Reference": "CVE-2008-1567",
          "Description": "storage of a secret key in cleartext in a temporary file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1567"
        },
        {
          "Reference": "CVE-2008-0174",
          "Description": "SCADA product uses HTTP Basic Authentication, which is not encrypted",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0174"
        },
        {
          "Reference": "CVE-2007-5778",
          "Description": "login credentials stored unencrypted in a registry key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5778"
        },
        {
          "Reference": "CVE-2001-1481",
          "Description": "Plaintext credentials in world-readable file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1481"
        },
        {
          "Reference": "CVE-2005-1828",
          "Description": "Password in cleartext in config file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1828"
        },
        {
          "Reference": "CVE-2005-2209",
          "Description": "Password in cleartext in config file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2209"
        },
        {
          "Reference": "CVE-2002-1696",
          "Description": "Decrypted copy of a message written to disk given a combination of options and when user replies to an encrypted message.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1696"
        },
        {
          "Reference": "CVE-2004-2397",
          "Description": "Plaintext storage of private key and passphrase in log file when user imports the key.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2397"
        },
        {
          "Reference": "CVE-2002-1800",
          "Description": "Admin password in plaintext in a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1800"
        },
        {
          "Reference": "CVE-2001-1537",
          "Description": "Default configuration has cleartext usernames/passwords in cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1537"
        },
        {
          "Reference": "CVE-2001-1536",
          "Description": "Usernames/passwords in cleartext in cookies.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1536"
        },
        {
          "Reference": "CVE-2005-2160",
          "Description": "Authentication information stored in cleartext in a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2160"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage of Sensitive Information"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 4.1 a)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.1"
        }
      ],
      "RelatedAttackPatterns": [
        "37"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"Protecting Secret Data\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Encryption\", Page 43",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-172",
          "Authors": [
            "Chris Wysopal"
          ],
          "Title": "Mobile App Top 10 List",
          "PublicationYear": "2010",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://www.veracode.com/blog/2010/12/mobile-app-top-10-list",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1295",
          "Authors": [
            "WizCase"
          ],
          "Title": "Over 80 US Municipalities' Sensitive Information, Including Resident's Personal Data, Left Vulnerable in Massive Data Breach",
          "PublicationYear": "2021",
          "PublicationMonth": "07",
          "PublicationDay": "20",
          "URL": "https://www.wizcase.com/blog/us-municipality-breach-report/"
        },
        {
          "ExternalReferenceID": "REF-1296",
          "Authors": [
            "Jonathan Greig"
          ],
          "Title": "1,000 GB of local government data exposed by Massachusetts software company",
          "PublicationYear": "2021",
          "PublicationMonth": "07",
          "PublicationDay": "22",
          "URL": "https://www.zdnet.com/article/1000-gb-of-local-government-data-exposed-by-massachusetts-software-company/"
        },
        {
          "ExternalReferenceID": "REF-1297",
          "Authors": [
            "Amazon"
          ],
          "Title": "AWS Foundational Security Best Practices controls",
          "PublicationYear": "2022",
          "URL": "https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-controls-reference.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1299",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Azure encryption overview",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "18",
          "URL": "https://learn.microsoft.com/en-us/azure/security/fundamentals/encryption-overview",
          "URLDate": "2022-10-11"
        },
        {
          "ExternalReferenceID": "REF-1301",
          "Authors": [
            "Google Cloud"
          ],
          "Title": "Default encryption at rest",
          "PublicationYear": "2022",
          "PublicationMonth": "10",
          "PublicationDay": "11",
          "URL": "https://cloud.google.com/docs/security/encryption/default-encryption",
          "URLDate": "2022-10-11"
        },
        {
          "ExternalReferenceID": "REF-1307",
          "Section": "Section 3.2",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Microsoft Azure Foundations Benchmark version 1.5.0",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "16",
          "URL": "https://www.cisecurity.org/benchmark/azure",
          "URLDate": "2023-01-19"
        },
        {
          "ExternalReferenceID": "REF-1310",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Enable infrastructure encryption for double encryption of data",
          "PublicationYear": "2022",
          "PublicationMonth": "07",
          "PublicationDay": "14",
          "URL": "https://learn.microsoft.com/en-us/azure/storage/common/infrastructure-encryption-enable",
          "URLDate": "2023-01-24"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "313",
      "Name": "Cleartext Storage in a File or on Disk",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext in a file, or on disk.",
      "ExtendedDescription": "The sensitive information could be read by attackers with access to the file, or with physical or administrator access to the raw disk. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1481",
          "Description": "Cleartext credentials in world-readable file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1481"
        },
        {
          "Reference": "CVE-2005-1828",
          "Description": "Password in cleartext in config file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1828"
        },
        {
          "Reference": "CVE-2005-2209",
          "Description": "Password in cleartext in config file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2209"
        },
        {
          "Reference": "CVE-2002-1696",
          "Description": "Decrypted copy of a message written to disk given a combination of options and when user replies to an encrypted message.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1696"
        },
        {
          "Reference": "CVE-2004-2397",
          "Description": "Cleartext storage of private key and passphrase in log file when user imports the key.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2397"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in File or on Disk"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "314",
      "Name": "Cleartext Storage in the Registry",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext in the registry.",
      "ExtendedDescription": "Attackers can read the information by accessing the registry key. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-2227",
          "Description": "Cleartext passwords in registry key.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2227"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in Registry"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "37"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "315",
      "Name": "Cleartext Storage of Sensitive Information in a Cookie",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext in a cookie.",
      "ExtendedDescription": "Attackers can use widely-available tools to view the cookie and read the sensitive information. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-44",
          "Entries": [
            {
              "IntroText": "The following code excerpt stores a plaintext user account ID in a browser cookie."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tresponse.addCookie( new Cookie(\"userAccountID\", acctID);\n```"
            },
            {
              "BodyText": "Because the account ID is in plaintext, the user's account information is exposed if their computer is compromised by an attacker."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1800",
          "Description": "Admin password in cleartext in a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1800"
        },
        {
          "Reference": "CVE-2001-1537",
          "Description": "Default configuration has cleartext usernames/passwords in cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1537"
        },
        {
          "Reference": "CVE-2001-1536",
          "Description": "Usernames/passwords in cleartext in cookies.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1536"
        },
        {
          "Reference": "CVE-2005-2160",
          "Description": "Authentication information stored in cleartext in a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2160"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in Cookie"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "RelatedAttackPatterns": [
        "31",
        "37",
        "39",
        "74"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "316",
      "Name": "Cleartext Storage of Sensitive Information in Memory",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext in memory.",
      "ExtendedDescription": "\n\nThe sensitive memory might be saved to disk, stored in a core dump, or remain uncleared if the product crashes, or if the programmer does not properly clear the memory before freeing it.\n\n\nIt could be argued that such problems are usually only exploitable by those with administrator privileges. However, swapping could cause the memory to be written to disk and leave it accessible to physical attack afterwards. Core dump files might have insecure permissions or be stored in archive files that are accessible to untrusted people. Or, uncleared sensitive memory might be inadvertently exposed to attackers due to another weakness.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1517",
          "Description": "Sensitive authentication information in cleartext in memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1517"
        },
        {
          "Reference": "CVE-2001-0984",
          "Description": "Password protector leaves passwords in memory when window is minimized, even when \"clear password when minimized\" is set.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0984"
        },
        {
          "Reference": "CVE-2003-0291",
          "Description": "SSH client does not clear credentials from memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0291"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in Memory"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This could be a resultant weakness, e.g. if the compiler removes code that was intended to wipe memory."
        },
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "317",
      "Name": "Cleartext Storage of Sensitive Information in GUI",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext within the GUI.",
      "ExtendedDescription": "An attacker can often obtain data from a GUI, even if hidden, by using an API to directly access GUI objects such as windows and menus. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Windows",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Read Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1848",
          "Description": "Unencrypted passwords stored in GUI dialog may allow local users to access the passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1848"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in GUI"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "318",
      "Name": "Cleartext Storage of Sensitive Information in Executable",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores sensitive information in cleartext in an executable.",
      "ExtendedDescription": "Attackers can reverse engineer binary code to obtain secret data. This is especially easy when the cleartext is plain ASCII. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "312",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1794",
          "Description": "Product stores RSA private key in a DLL and uses it to sign a certificate, allowing spoofing of servers and Adversary-in-the-Middle (AITM) attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1794"
        },
        {
          "Reference": "CVE-2001-1527",
          "Description": "administration passwords in cleartext in executable",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1527"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Storage in Executable"
        }
      ],
      "RelatedAttackPatterns": [
        "37",
        "65"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Terminology",
          "Note": "Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding)."
        }
      ]
    },
    {
      "ID": "319",
      "Name": "Cleartext Transmission of Sensitive Information",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.",
      "ExtendedDescription": "\n\nMany communication channels can be \"sniffed\" (monitored) by adversaries during data transmission. For example, in networking, packets can traverse many intermediary nodes from the source to the destination, whether across the internet, an internal network, the cloud, etc. Some actors might have privileged access to a network interface or any link along the channel, such as a router, but they might not be authorized to collect the underlying data. As a result, network traffic could be sniffed by adversaries, spilling security-critical data.\n\n\nApplicable communication channels are not limited to software products. Applicable channels include hardware-specific technologies such as internal hardware networks and external debug channels, supporting remote JTAG debugging. When mitigations are not applied to combat adversaries within the product's threat model, this weakness significantly lowers the difficulty of exploitation by such adversaries.\n\n\nWhen full communications are recorded or logged, such as with a packet dump, an adversary could attempt to obtain the dump long after the transmission has occurred and try to \"sniff\" the cleartext from the recorded communications in the dump itself. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information. \n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "311",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "311",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        },
        {
          "Type": "Technology",
          "Class": "System on Chip",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Test/Debug Hardware",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Architecture and Design",
          "Note": "For hardware, this may be introduced when design does not plan for an attacker having physical access while a legitimate user is remotely operating the device."
        },
        {
          "Phase": "Operation"
        },
        {
          "Phase": "System Configuration"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Files or Directories"
          ],
          "Note": "Anyone can read the information by gaining access to the channel being used for communication."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-11",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process, trigger the feature that sends the data, and look for the presence or absence of common cryptographic functions in the call tree. Monitor the network and determine if the data packets contain readable commands. Tools exist for detecting if certain encodings are in use. If the traffic contains high entropy, this might indicate the usage of encryption.\n"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-42",
          "Entries": [
            {
              "IntroText": "The following code attempts to establish a connection to a site to communicate sensitive information."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tURL u = new URL(\"http://www.secret.example.org/\");\n\t\tHttpURLConnection hu = (HttpURLConnection) u.openConnection();\n\t\thu.setRequestMethod(\"PUT\");\n\t\thu.connect();\n\t\tOutputStream os = hu.getOutputStream();\n\t\thu.disconnect();\n\t}\n\tcatch (IOException e) {\n```\n//...* \n\t\t}"
            },
            {
              "BodyText": "Though a connection is successfully made, the connection is unencrypted and it is possible that all sensitive data sent to or received from the server will be read by unintended actors."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used cleartext transmission of sensitive information in their OT products."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "A TAP accessible register is read/written by a JTAG based tool, for internal use by authorized users. However, an adversary can connect a probing device and collect the values from the unencrypted channel connecting the JTAG interface to the authorized user, if no additional protections are employed."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following Azure CLI command lists the properties of a particular storage account:"
            },
            {
              "Nature": "Informative",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account show -g {ResourceGroupName} -n {StorageAccountName}\n```"
            },
            {
              "BodyText": "The JSON result might be:"
            },
            {
              "Nature": "Bad",
              "Language": "JSON",
              "ExampleCode": "```\n\t {\n\t\t \"name\": \"{StorageAccountName}\",\n\t\t \"enableHttpsTrafficOnly\": false,\n\t\t \"type\": \"Microsoft.Storage/storageAccounts\"\n\t } \n```"
            },
            {
              "BodyText": "The enableHttpsTrafficOnly value is set to false, because the default setting for Secure transfer is set to Disabled. This allows cloud storage resources to successfully connect and transfer data without the use of encryption (e.g., HTTP, SMB 2.1, SMB 3.0, etc.)."
            },
            {
              "BodyText": "Azure's storage accounts can be configured to only accept requests from secure connections made over HTTPS. The secure transfer setting can be enabled using Azure's Portal (GUI) or programmatically by setting the enableHttpsTrafficOnly property to True on the storage account, such as:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account update -g {ResourceGroupName} -n {StorageAccountName} --https-only true\n```"
            },
            {
              "BodyText": "The change can be confirmed from the result by verifying that the enableHttpsTrafficOnly value is true:"
            },
            {
              "Nature": "Good",
              "Language": "JSON",
              "ExampleCode": "```\n\t {\n\t\t \"name\": \"{StorageAccountName}\",\n\t\t \"enableHttpsTrafficOnly\": true,\n\t\t \"type\": \"Microsoft.Storage/storageAccounts\"\n\t } \n```"
            },
            {
              "BodyText": "Note: to enable secure transfer using Azure's Portal instead of the command line:\n\n\n  1. Open the Create storage account pane in the Azure portal.\n\n  1. In the Advanced page, select the Enable secure transfer checkbox."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29519",
          "Description": "Programmable Logic Controller (PLC) sends sensitive information in plaintext, including passwords and session tokens.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29519"
        },
        {
          "Reference": "CVE-2022-30312",
          "Description": "Building Controller uses a protocol that transmits authentication credentials in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30312"
        },
        {
          "Reference": "CVE-2022-31204",
          "Description": "Programmable Logic Controller (PLC) sends password in plaintext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-31204"
        },
        {
          "Reference": "CVE-2002-1949",
          "Description": "Passwords transmitted in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1949"
        },
        {
          "Reference": "CVE-2008-4122",
          "Description": "Chain: Use of HTTPS cookie without \"secure\" flag causes it to be transmitted across unencrypted HTTP.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4122"
        },
        {
          "Reference": "CVE-2008-3289",
          "Description": "Product sends password hash in cleartext in violation of intended policy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3289"
        },
        {
          "Reference": "CVE-2008-4390",
          "Description": "Remote management feature sends sensitive information including passwords in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4390"
        },
        {
          "Reference": "CVE-2007-5626",
          "Description": "Backup routine sends password in cleartext in email.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5626"
        },
        {
          "Reference": "CVE-2004-1852",
          "Description": "Product transmits Blowfish encryption key in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1852"
        },
        {
          "Reference": "CVE-2008-0374",
          "Description": "Printer sends configuration information, including administrative password, in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0374"
        },
        {
          "Reference": "CVE-2007-4961",
          "Description": "Chain: cleartext transmission of the MD5 hash of password enables attacks against a server that is susceptible to replay (CWE-294).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4961"
        },
        {
          "Reference": "CVE-2007-4786",
          "Description": "Product sends passwords in cleartext to a log server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4786"
        },
        {
          "Reference": "CVE-2005-3140",
          "Description": "Product sends file with cleartext passwords in e-mail message intended for diagnostic purposes.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3140"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Plaintext Transmission of Sensitive Information"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC06-J",
          "EntryName": "Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER02-J",
          "EntryName": "Sign then seal sensitive objects before sending them outside a trust boundary"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 4.1B"
        }
      ],
      "RelatedAttackPatterns": [
        "102",
        "117",
        "383",
        "477",
        "65"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-271",
          "Authors": [
            "OWASP"
          ],
          "Title": "Top 10 2007-Insecure Communications",
          "PublicationYear": "2007",
          "URL": "http://www.owasp.org/index.php/Top_10_2007-A9"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"Protecting Secret Data\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 22: Failing to Protect Network Traffic.\" Page 337",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-172",
          "Authors": [
            "Chris Wysopal"
          ],
          "Title": "Mobile App Top 10 List",
          "PublicationYear": "2010",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://www.veracode.com/blog/2010/12/mobile-app-top-10-list",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1307",
          "Section": "Sections 3.1 and 3.10",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Microsoft Azure Foundations Benchmark version 1.5.0",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "16",
          "URL": "https://www.cisecurity.org/benchmark/azure",
          "URLDate": "2023-01-19"
        },
        {
          "ExternalReferenceID": "REF-1309",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Require secure transfer to ensure secure connections",
          "PublicationYear": "2022",
          "PublicationMonth": "07",
          "PublicationDay": "24",
          "URL": "https://learn.microsoft.com/en-us/azure/storage/common/storage-require-secure-transfer",
          "URLDate": "2023-01-24"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "321",
      "Name": "Use of Hard-coded Cryptographic Key",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "798",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If hard-coded cryptographic keys are used, it is almost certain that malicious users will gain access through the account in question."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Prevention schemes mirror that of hard-coded password storage."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-92",
          "Entries": [
            {
              "IntroText": "The following code examples attempt to verify a password using a hard-coded cryptographic key."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password,\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\t\t\tprintf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean VerifyAdmin(String password) {\n\t\tif (password.equals(\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\tSystem.out.println(\"Entering Diagnostic Mode...\");\n\t\t\treturn true;\n\t\t}\n\t\tSystem.out.println(\"Incorrect Password!\");\n\t\treturn false;\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (password.Equals(\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\tConsole.WriteLine(\"Entering Diagnostic Mode...\");\n\t\t\treturn(1);\n\t\t}\n\t\tConsole.WriteLine(\"Incorrect Password!\");\n\t\treturn(0);\n\t}\n```"
            },
            {
              "BodyText": "The cryptographic key is within a hard-coded string value that is compared to the password. It is likely that an attacker will be able to read the key and compromise the system."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used hard-coded keys for critical functionality in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29960",
          "Description": "Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29960"
        },
        {
          "Reference": "CVE-2022-30271",
          "Description": "Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used by default.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30271"
        },
        {
          "Reference": "CVE-2020-10884",
          "Description": "WiFi router service has a hard-coded encryption key, allowing root access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10884"
        },
        {
          "Reference": "CVE-2014-2198",
          "Description": "Communications / collaboration product has a hardcoded SSH private key, allowing access to root account",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-2198"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Use of hard-coded cryptographic key"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A8",
          "EntryName": "Insecure Cryptographic Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A9",
          "EntryName": "Insecure Communications",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP33",
          "EntryName": "Hardcoded sensitive data"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.10 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.10 RE(3)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req SR 4.3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.3"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "The main difference between the use of hard-coded passwords and the use of hard-coded cryptographic keys is the false sense of security that the former conveys. Many people believe that simply hashing a hard-coded password before storage will protect the information from malicious users. However, many hashes are reversible (or at least vulnerable to brute force attacks) -- and further, many authentication protocols simply request the hash itself, making it no better than a password."
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "322",
      "Name": "Key Exchange without Entity Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs a key exchange with an actor without verifying the identity of that actor.",
      "ExtendedDescription": "Performing a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable an attacker to impersonate an actor by modifying traffic between the two entities. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim's credentials, sniff traffic between the victim and trusted server, etc.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "306",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "923",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "295",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "No authentication takes place in this process, bypassing an assumed protection of encryption."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The encrypted communication between a user and a trusted host may be subject to sniffing by any actor in the communication path."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that proper authentication is included in the system design."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Understand and properly implement all checks necessary to ensure the identity of entities involved in encrypted communications."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Many systems have used Diffie-Hellman key exchange without authenticating the entities exchanging keys, allowing attackers to influence communications by redirecting or interfering with the communication path. Many people using SSL/TLS skip the authentication (often unknowingly)."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Key exchange without entity authentication"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Untrustworthy Credentials\", Page 37",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "323",
      "Name": "Reusing a Nonce, Key Pair in Encryption",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Nonces should be used for the present occasion and only once.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "344",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Nonces are often bundled with a key in a communication exchange to produce a new session key for each exchange."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Potentially a replay attack, in which an attacker could send the same data twice, could be crafted if nonces are allowed to be reused. This could allow a user to send a message which masquerades as a valid message from a valid user."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Refuse to reuse nonce values."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use techniques such as requiring incrementing, time based and/or challenge response to assure uniqueness of nonces."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code takes a password, concatenates it with a nonce, then encrypts it before sending over a network:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid encryptAndSendPassword(char *password){\n\t\tchar *nonce = \"bad\";\n\t\t...\n\t\tchar *data = (unsigned char*)malloc(20);\n\t\tint para_size = strlen(nonce) + strlen(password);\n\t\tchar *paragraph = (char*)malloc(para_size);\n\t\tSHA1((const unsigned char*)paragraph,parsize,(unsigned char*)data);\n\t\tsendEncryptedData(data)\n\t}\n```"
            },
            {
              "BodyText": "Because the nonce used is always the same, an attacker can impersonate a trusted party by intercepting and resending the encrypted password. This attack avoids the need to learn the unencrypted password."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code sends a command to a remote server, using an encrypted password and nonce to prove the command is from a trusted party:"
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tString command = new String(\"some command to execute\");\n\tMessageDigest nonce = MessageDigest.getInstance(\"SHA\");\n\tnonce.update(String.valueOf(\"bad nonce\"));\n\tbyte[] nonce = nonce.digest();\n\tMessageDigest password = MessageDigest.getInstance(\"SHA\");\n\tpassword.update(nonce + \"secretPassword\");\n\tbyte[] digest = password.digest();\n\tsendCommand(digest, command)\n```"
            },
            {
              "BodyText": "Once again the nonce used is always the same. An attacker may be able to replay previous legitimate commands or execute new arbitrary commands."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Reusing a nonce, key pair in encryption"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "324",
      "Name": "Use of a Key Past its Expiration Date",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key.",
      "ExtendedDescription": "While the expiration of keys does not necessarily ensure that they are compromised, it is a significant concern that keys which remain in use for prolonged periods of time have a decreasing probability of integrity. For this reason, it is important to replace keys within a period of time proportional to their strength.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "298",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The cryptographic key in question may be compromised, providing a malicious user with a method for authenticating as the victim."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Adequate consideration should be put in to the user interface in order to notify users previous to the key's expiration, to explain the importance of new key generation and to walk users through the process as painlessly as possible."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code attempts to verify that a certificate is valid."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n\t\t\tfoo=SSL_get_verify_result(ssl);\n\t\t\tif ((X509_V_OK==foo) || (X509_V_ERRCERT_NOT_YET_VALID==foo))\n```\n//do stuff* \n\t\t\t\t\t}"
            },
            {
              "BodyText": "The code checks if the certificate is not yet valid, but it fails to check if a certificate is past its expiration date, thus treating expired certificates as valid."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-33020",
          "Description": "Picture Archiving and Communication System (PACS) system for hospitals uses a cryptographic key or password past its expiration date",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33020"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using a key past its expiration date"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 23: Improper Use of PKI, Especially SSL.\" Page 347",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "325",
      "Name": "Missing Cryptographic Step",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by the algorithm.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "358",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "Developers sometimes omit \"expensive\" (resource-intensive) steps in order to improve performance, especially in devices with limited memory or slower CPUs. This step may be taken under a mistaken impression that the step is unnecessary for the cryptographic algorithm."
        },
        {
          "Phase": "Requirements",
          "Note": "This issue may happen when the requirements for the cryptographic algorithm are not clearly stated."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        },
        {
          "Scope": [
            "Accountability",
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The example code is taken from the HMAC engine inside the buggy OpenPiton SoC of HACK@DAC'21 [REF-1358]. HAMC is a message authentication code (MAC) that uses both a hash and a secret crypto key. The HMAC engine in HACK@DAC SoC uses the SHA-256 module for the calculation of the HMAC for 512 bits messages."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "**logic [511:0] bigData;** \n ...\n\n hmac hmac(\n\n```\n\t .clk_i(clk_i),\n\t .rst_ni(rst_ni && ~rst_4),\n\t .init_i(startHash && ~startHash_r),\n\t .key_i(key),\n\t .ikey_hash_i(ikey_hash), \n\t .okey_hash_i(okey_hash), \n\t .key_hash_bypass_i(key_hash_bypass),\n```\n.message_i(bigData),** \n\t .hash_o(hash),\n\t .ready_o(ready),\n\t .hash_valid_o(hashValid)"
            },
            {
              "BodyText": "However, this HMAC engine cannot handle messages that are longer than 512 bits. Moreover, a complete HMAC will contain an iterate hash function that breaks up a message into blocks of a fixed size and iterates over them with a compression function (e.g., SHA-256). Therefore, the implementation of the HMAC in OpenPiton SoC is incomplete. Such HMAC engines will not be used in real-world applications as the messages will usually be longer than 512 bits. For instance, OpenTitan offers a comprehensive HMAC implementation that utilizes a FIFO for temporarily storing the truncated message, as detailed in [REF-1359]."
            },
            {
              "BodyText": "To mitigate this, implement the iterative function to break up a message into blocks of a fixed size."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1585",
          "Description": "Missing challenge-response step allows authentication bypass using public key.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1585"
        }
      ],
      "FunctionalAreas": [
        "Cryptography"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Required Cryptographic Step"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A8",
          "EntryName": "Insecure Cryptographic Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A9",
          "EntryName": "Insecure Communications",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "68"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1358",
          "Title": "hmac_wrapper.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/main/piton/design/chip/tile/ariane/src/hmac/hmac_wrapper.sv#L41",
          "URLDate": "2023-07-15"
        },
        {
          "ExternalReferenceID": "REF-1359",
          "Title": "HMAC HWIP Technical Specification",
          "PublicationYear": "2023",
          "URL": "https://opentitan.org/book/hw/ip/hmac/",
          "URLDate": "2023-10-05"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps incomplete/missing security check."
        },
        {
          "Type": "Relationship",
          "Note": "Can be resultant."
        }
      ]
    },
    {
      "ID": "326",
      "Name": "Inadequate Encryption Strength",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.",
      "ExtendedDescription": "A weak encryption scheme can be subjected to brute force attacks that have a reasonable chance of succeeding using current attack methods and resources.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Confidentiality"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Read Application Data"
          ],
          "Note": "An attacker may be able to decrypt the data using brute force attacks."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an encryption scheme that is currently considered to be strong by experts in the field."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1546",
          "Description": "Weak encryption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1546"
        },
        {
          "Reference": "CVE-2004-2172",
          "Description": "Weak encryption (chosen plaintext attack)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2172"
        },
        {
          "Reference": "CVE-2002-1682",
          "Description": "Weak encryption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1682"
        },
        {
          "Reference": "CVE-2002-1697",
          "Description": "Weak encryption produces same ciphertext from the same plaintext blocks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1697"
        },
        {
          "Reference": "CVE-2002-1739",
          "Description": "Weak encryption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1739"
        },
        {
          "Reference": "CVE-2005-2281",
          "Description": "Weak encryption scheme",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2281"
        },
        {
          "Reference": "CVE-2002-1872",
          "Description": "Weak encryption (XOR)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1872"
        },
        {
          "Reference": "CVE-2002-1910",
          "Description": "Weak encryption (reversible algorithm).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1910"
        },
        {
          "Reference": "CVE-2002-1946",
          "Description": "Weak encryption (one-to-one mapping).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1946"
        },
        {
          "Reference": "CVE-2002-1975",
          "Description": "Encryption error uses fixed salt, simplifying brute force / dictionary attacks (overlaps randomness).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1975"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Weak Encryption"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A8",
          "EntryName": "Insecure Cryptographic Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A9",
          "EntryName": "Insecure Communications",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        }
      ],
      "RelatedAttackPatterns": [
        "112",
        "192",
        "20"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 8, \"Cryptographic Foibles\" Page 259",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 21: Using the Wrong Cryptography.\" Page 315",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "327",
      "Name": "Use of a Broken or Risky Cryptographic Algorithm",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a broken or risky cryptographic algorithm or protocol.",
      "ExtendedDescription": "\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "311",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Verilog",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "VHDL",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation",
          "Note": "With hardware, the Architecture or Design Phase might start with compliant cryptography, but it is replaced with a non-compliant crypto during the later Implementation phase due to implementation constraints (e.g., not enough entropy to make it function properly, or not enough silicon real estate available to implement). Or, in rare cases (especially for long projects that span over years), the Architecture specifications might start with cryptography that was originally compliant at the time the Architectural specs were written, but over the time it became non-compliant due to progress made in attacking the crypto."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "The confidentiality of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "The integrity of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm."
        },
        {
          "Scope": [
            "Accountability",
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "If the cryptographic algorithm is used to ensure the identity of the source of the data (such as digital signatures), then a broken algorithm will compromise this scheme and the source of the data cannot be proven."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Analysis",
          "Description": "Automated methods may be useful for recognizing commonly-used libraries or features that have become obsolete.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "False negatives may occur if the tool is not aware of the cryptographic libraries in use, or if custom cryptography is being used."
        },
        {
          "DetectionMethodID": "DM-7",
          "Method": "Manual Analysis",
          "Description": "This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary / Bytecode simple extractor - strings, ELF readers, etc.",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tMan-in-the-middle attack tool\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFramework-based Fuzzer\n\t\tAutomated Monitored Execution\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-24",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nWhen there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.\n\n\nFor example, US government systems require FIPS 140-2 certification [REF-1192].\n\n\nDo not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.\n\n\nPeriodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]\n"
        },
        {
          "MitigationID": "MIT-52",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.",
          "Effectiveness": "Defense in Depth"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant."
        },
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nIndustry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.\n"
        },
        {
          "MitigationID": "MIT-25",
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "These code examples use the Data Encryption Standard (DES)."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tEVP_des_ecb();\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCipher des=Cipher.getInstance(\"DES...\");\n\tdes.initEncrypt(key2);\n```"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction encryptPassword($password){\n\t\t$iv_size = mcrypt_get_iv_size(MCRYPT_DES, MCRYPT_MODE_ECB);\n\t\t$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);\n\t\t$key = \"This is a password encryption key\";\n\t\t$encryptedPassword = mcrypt_encrypt(MCRYPT_DES, $key, $password, MCRYPT_MODE_ECB, $iv);\n\t\treturn $encryptedPassword;\n\t}\n```"
            },
            {
              "BodyText": "Once considered a strong algorithm, DES now regarded as insufficient for many applications. It has been replaced by Advanced Encryption Standard (AES)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Suppose a chip manufacturer decides to implement a hashing scheme for verifying integrity property of certain bitstream, and it chooses to implement a SHA1 hardware accelerator for to implement the scheme."
            },
            {
              "Nature": "Bad",
              "Language": "Other",
              "ExampleCode": "```\n\tThe manufacturer chooses a SHA1 hardware accelerator for to implement the scheme because it already has a working SHA1 Intellectual Property (IP) that the manufacturer had created and used earlier, so this reuse of IP saves design cost.\n```"
            },
            {
              "BodyText": "However, SHA1 was theoretically broken in 2005 and practically broken in 2017 at a cost of $110K. This means an attacker with access to cloud-rented computing power will now be able to provide a malicious bitstream with the same hash value, thereby defeating the purpose for which the hash was used."
            },
            {
              "BodyText": "This issue could have been avoided with better design."
            },
            {
              "Nature": "Good",
              "Language": "Other",
              "ExampleCode": "```\n\tThe manufacturer could have chosen a cryptographic solution that is recommended by the wide security community (including standard-setting bodies like NIST) and is not expected to be broken (or even better, weakened) within the reasonable life expectancy of the hardware product. In this case, the architects could have used SHA-2 or SHA-3, even if it meant that such choice would cost extra.\n```"
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple OT products used weak cryptography."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30273",
          "Description": "SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30273"
        },
        {
          "Reference": "CVE-2022-30320",
          "Description": "Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30320"
        },
        {
          "Reference": "CVE-2008-3775",
          "Description": "Product uses \"ROT-25\" to obfuscate the password in the registry.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3775"
        },
        {
          "Reference": "CVE-2007-4150",
          "Description": "product only uses \"XOR\" to obfuscate sensitive data",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4150"
        },
        {
          "Reference": "CVE-2007-5460",
          "Description": "product only uses \"XOR\" and a fixed key to obfuscate sensitive data",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5460"
        },
        {
          "Reference": "CVE-2005-4860",
          "Description": "Product substitutes characters with other characters in a fixed way, and also leaves certain input characters unchanged.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4860"
        },
        {
          "Reference": "CVE-2002-2058",
          "Description": "Attackers can infer private IP addresses by dividing each octet by the MD5 hash of '20'.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2058"
        },
        {
          "Reference": "CVE-2008-3188",
          "Description": "Product uses DES when MD5 has been specified in the configuration, resulting in weaker-than-expected password hashes.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3188"
        },
        {
          "Reference": "CVE-2005-2946",
          "Description": "Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2946"
        },
        {
          "Reference": "CVE-2007-6013",
          "Description": "Product uses the hash of a hash for authentication, allowing attackers to gain privileges if they can obtain the original hash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6013"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using a broken or risky cryptographic algorithm"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A8",
          "EntryName": "Insecure Storage",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC30-C",
          "EntryName": "Do not use the rand() function for generating pseudorandom numbers",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC32-C",
          "EntryName": "Properly seed pseudorandom number generators",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-327"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 4.3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 4.3"
        }
      ],
      "RelatedAttackPatterns": [
        "20",
        "459",
        "473",
        "475",
        "608",
        "614",
        "97"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-280",
          "Authors": [
            "Bruce Schneier"
          ],
          "Title": "Applied Cryptography",
          "PublicationYear": "1996",
          "Publisher": "John Wiley & Sons",
          "URL": "https://www.schneier.com/books/applied-cryptography",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-281",
          "Authors": [
            "Alfred J. Menezes",
            "Paul C. van Oorschot",
            "Scott A. Vanstone"
          ],
          "Title": "Handbook of Applied Cryptography",
          "PublicationYear": "1996",
          "PublicationMonth": "10",
          "URL": "https://cacr.uwaterloo.ca/hac/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-282",
          "Authors": [
            "C Matthew Curtin"
          ],
          "Title": "Avoiding bogus encryption products: Snake Oil FAQ",
          "PublicationYear": "1998",
          "PublicationMonth": "04",
          "PublicationDay": "10",
          "URL": "http://www.faqs.org/faqs/cryptography-faq/snake-oil/"
        },
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-284",
          "Authors": [
            "Paul F. Roberts"
          ],
          "Title": "Microsoft Scraps Old Encryption in New Code",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "15",
          "URL": "https://www.eweek.com/security/microsoft-scraps-old-encryption-in-new-code/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 8, \"Cryptographic Foibles\" Page 259",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 21: Using the Wrong Cryptography.\" Page 315",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-287",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "Top 25 Series - Rank 24 - Use of a Broken or Risky Cryptographic Algorithm",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "25",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-use-of-a-broken-or-risky-cryptographic-algorithm/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Insufficient or Obsolete Encryption\", Page 44",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-327",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1192",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "FIPS PUB 140-3: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2019",
          "PublicationMonth": "03",
          "PublicationDay": "22",
          "URL": "https://csrc.nist.gov/publications/detail/fips/140/3/final"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing."
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "328",
      "Name": "Use of Weak Hash",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).",
      "ExtendedDescription": "\n\nA hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold:\n\n\n  1. The algorithm is not invertible (also called \"one-way\" or \"not reversible\")\n\n  1. The algorithm is deterministic; the same input produces the same digest every time\n\n Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following:\n\n  1. the original input (preimage attack), given only the digest\n\n  1. another input that can produce the same digest (2nd preimage attack), given the original input\n\n  1. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times\n\nWhat is regarded as \"reasonable\" varies by context and threat model, but in general, \"reasonable\" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world.\n\nAny algorithm that does not meet the above conditions will generally be considered weak for general use in hashing.\n\n\nIn addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a \"rainbow table\" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "326",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "327",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-51",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (\"stretching\") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.\n\n\nSome hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.\n\n\nNote that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.\n",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-101",
          "Entries": [
            {
              "IntroText": "In both of these examples, a user is logged in if their given password matches a stored password:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned char *check_passwd(char *plaintext) {\n\t\tctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n```\n//Login if hash matches stored hash* \n\t\tif (equal(ctext, secret_password())) {\n\t\t```\n\t\t\tlogin_user();\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString plainText = new String(plainTextIn);\n\tMessageDigest encer = MessageDigest.getInstance(\"SHA\");\n\tencer.update(plainTextIn);\n\tbyte[] digest = password.digest();\n```\n//Login if hash matches stored hash* \n\tif (equal(digest,secret_password())) {\n\t```\n\t\tlogin_user();\n\t}\n```"
            },
            {
              "BodyText": "This code relies exclusively on a password mechanism (CWE-309) using only one factor of authentication (CWE-308). If an attacker can steal or guess a user's password, they are given full access to their account. Note this code also uses SHA-1, which is a weak hash (CWE-328). It also does not use a salt (CWE-759)."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "At least one OT product used weak hashes."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The example code below is taken from the JTAG access control mechanism of the Hack@DAC'21 buggy OpenPiton SoC [REF-1360]. Access to JTAG allows users to access sensitive information in the system. Hence, access to JTAG is controlled using cryptographic authentication of the users. In this example (see the vulnerable code source), the password checker uses HMAC-SHA256 for authentication. It takes a 512-bit secret message from the user, hashes it using HMAC, and compares its output with the expected output to determine the authenticity of the user."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "...\n\n **logic [31:0] data_d,**  data_q\n\n **logic [512-1:0] pass_data;** \n ...\n\n```\n\t Write: begin\n\t\t ...\n\t\t\t if (pass_mode) begin\n```\npass_data = { {60{8'h00}}, data_d};** \n\t\t\t\t state_d = PassChk;\n\t\t\t\t pass_mode = 1'b0;\n\t\t\t\t ...\n\t\t\t end\n\t ..."
            },
            {
              "BodyText": "The vulnerable code shows an incorrect implementation of the HMAC authentication where it only uses the least significant 32 bits of the secret message for the authentication (the remaining 480 bits are hard coded as zeros). As a result, the system is susceptible to brute-force attacks where the attacker only needs to determine 32 bits of the secret message instead of 512 bits, weakening the cryptographic protocol."
            },
            {
              "BodyText": "To mitigate, remove the zero padding and use all 512 bits of the secret message for HMAC authentication [REF-1361]."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "...\n\n **logic [512-1:0] data_d,**  data_q\n logic [512-1:0] pass_data;\n ...\n\n```\n\t Write: begin\n\t\t ...\n\t\t\t if (pass_mode) begin\n```\npass_data = data_d;** \n\t\t\t\t state_d = PassChk;\n\t\t\t\t pass_mode = 1'b0;\n\t\t\t\t ...\n\t\t\t end\n\t ..."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30320",
          "Description": "Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30320"
        },
        {
          "Reference": "CVE-2005-4900",
          "Description": "SHA-1 algorithm is not collision-resistant.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4900"
        },
        {
          "Reference": "CVE-2020-25685",
          "Description": "DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-25685"
        },
        {
          "Reference": "CVE-2012-6707",
          "Description": "blogging product uses MD5-based algorithm for passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-6707"
        },
        {
          "Reference": "CVE-2019-14855",
          "Description": "forging of certificate signatures using SHA-1 collisions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-14855"
        },
        {
          "Reference": "CVE-2017-15999",
          "Description": "mobile app for backup sends SHA-1 hash of password in cleartext.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-15999"
        },
        {
          "Reference": "CVE-2006-4068",
          "Description": "Hard-coded hashed values for username and password contained in client-side script, allowing brute-force offline attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4068"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Reversible One-Way Hash"
        }
      ],
      "RelatedAttackPatterns": [
        "461",
        "68"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-289",
          "Authors": [
            "Alexander Sotirov et al."
          ],
          "Title": "MD5 considered harmful today",
          "URL": "http://www.phreedom.org/research/rogue-ca/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Integrity\", Page 47",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-291",
          "Authors": [
            "Johnny Shelley"
          ],
          "Title": "bcrypt",
          "URL": "http://bcrypt.sourceforge.net/"
        },
        {
          "ExternalReferenceID": "REF-292",
          "Authors": [
            "Colin Percival"
          ],
          "Title": "Tarsnap - The scrypt key derivation function and encryption utility",
          "URL": "http://www.tarsnap.com/scrypt.html"
        },
        {
          "ExternalReferenceID": "REF-293",
          "Section": "5.2 PBKDF2",
          "Authors": [
            "B. Kaliski"
          ],
          "Title": "RFC2898 - PKCS #5: Password-Based Cryptography Specification Version 2.0",
          "PublicationYear": "2000",
          "URL": "https://www.rfc-editor.org/rfc/rfc2898",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-294",
          "Authors": [
            "Coda Hale"
          ],
          "Title": "How To Safely Store A Password",
          "PublicationYear": "2010",
          "PublicationMonth": "01",
          "PublicationDay": "31",
          "URL": "https://codahale.com/how-to-safely-store-a-password/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-295",
          "Authors": [
            "Brian Krebs"
          ],
          "Title": "How Companies Can Beef Up Password Security (interview with Thomas H. Ptacek)",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "11",
          "URL": "https://krebsonsecurity.com/2012/06/how-companies-can-beef-up-password-security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-296",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "Password security: past, present, future",
          "PublicationYear": "2012",
          "URL": "https://www.openwall.com/presentations/PHDays2012-Password-Security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-297",
          "Authors": [
            "Troy Hunt"
          ],
          "Title": "Our password hashing has no clothes",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "26",
          "URL": "https://www.troyhunt.com/our-password-hashing-has-no-clothes/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-298",
          "Authors": [
            "Joshbw"
          ],
          "Title": "Should we really use bcrypt/scrypt?",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "08",
          "URL": "https://web.archive.org/web/20120629144851/http://www.analyticalengine.net/2012/06/should-we-really-use-bcryptscrypt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-637",
          "Title": "Rainbow table",
          "PublicationYear": "2009",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Rainbow_table",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1243",
          "Authors": [
            "Bruce Schneier"
          ],
          "Title": "Cryptanalysis of SHA-1",
          "PublicationYear": "2005",
          "PublicationMonth": "02",
          "PublicationDay": "18",
          "URL": "https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html",
          "URLDate": "2021-10-25"
        },
        {
          "ExternalReferenceID": "REF-1244",
          "Authors": [
            "Dan Goodin"
          ],
          "Title": "At death's door for years, widely used SHA1 function is now dead",
          "PublicationYear": "2017",
          "PublicationMonth": "02",
          "PublicationDay": "23",
          "Publisher": "Ars Technica",
          "URL": "https://arstechnica.com/information-technology/2017/02/at-deaths-door-for-years-widely-used-sha1-function-is-now-dead/",
          "URLDate": "2021-10-25"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1360",
          "Title": "dmi_jtag.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L82",
          "URLDate": "2023-07-15"
        },
        {
          "ExternalReferenceID": "REF-1361",
          "Title": "fix cwe_1205 in dmi_jtag.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/c4f4b832218b50c406dbf9f425d3b654117c1355/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L82",
          "URLDate": "2023-07-22"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing."
        }
      ]
    },
    {
      "ID": "329",
      "Name": "Generation of Predictable IV with CBC Mode",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product generates and uses a predictable initialization Vector (IV) with Cipher Block Chaining (CBC) Mode, which causes algorithms to be susceptible to dictionary attacks when they are encrypted under the same key.",
      "ExtendedDescription": "\n\nCBC mode eliminates a weakness of Electronic Code Book (ECB) mode by allowing identical plaintext blocks to be encrypted to different ciphertext blocks. This is possible by the XOR-ing of an IV with the initial plaintext block so that every plaintext block in the chain is XOR'd with a different value before encryption. If IVs are reused, then identical plaintexts would be encrypted to identical ciphertexts. However, even if IVs are not identical but are predictable, then they still break the security of CBC mode against Chosen Plaintext Attacks (CPA).\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1204",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "\n\nCBC mode is a commonly used mode of operation for a block cipher. It works by XOR-ing an IV with the initial block of a plaintext prior to encryption and then XOR-ing each successive block of plaintext with the previous block of ciphertext before encryption.\n\n```\n\t C_0 = IV\n\t C_i = E_k{M_i XOR C_{i-1}} \n```\n When used properly, CBC mode provides security against chosen plaintext attacks. Having an unpredictable IV is a crucial underpinning of this. See [REF-1171]."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "Developers might dismiss the importance of an unpredictable IV and choose an easier implementation to save effort, weakening the scheme in the process."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "If the IV is not properly initialized, data that is encrypted can be compromised and leak information."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "NIST recommends two methods of generating unpredictable IVs for CBC mode [REF-1172]. The first is to generate the IV randomly. The second method is to encrypt a nonce with the same key and cipher to be used to encrypt the plaintext. In this case the nonce must be unique but can be predictable, since the block cipher will act as a pseudo random permutation."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-143",
          "Entries": [
            {
              "IntroText": "In the following examples, CBC mode is used when encrypting data:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tEVP_CIPHER_CTX ctx;\n\tchar key[EVP_MAX_KEY_LENGTH];\n\tchar iv[EVP_MAX_IV_LENGTH];\n\tRAND_bytes(key, b);\n\tmemset(iv,0,EVP_MAX_IV_LENGTH);\n\tEVP_EncryptInit(&ctx,EVP_bf_cbc(), key,iv);\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class SymmetricCipherTest {\n\t\t\tpublic static void main() {\n\t\t\t\t\tbyte[] text =\"Secret\".getBytes();\n\t\t\t\t\tbyte[] iv ={\n\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n\t\t\t\t\t};\n\t\t\t\t\tKeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n\t\t\t\t\tkg.init(56);\n\t\t\t\t\tSecretKey key = kg.generateKey();\n\t\t\t\t\tCipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\t\t\t\t\tIvParameterSpec ips = new IvParameterSpec(iv);\n\t\t\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key, ips);\n\t\t\t\t\treturn cipher.doFinal(inpBytes);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "In both of these examples, the initialization vector (IV) is always a block of zeros. This makes the resulting cipher text much more predictable and susceptible to a dictionary attack."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-5408",
          "Description": "encryption functionality in an authentication framework uses a fixed null IV with CBC mode, allowing attackers to decrypt traffic in applications that use this functionality",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5408"
        },
        {
          "Reference": "CVE-2017-17704",
          "Description": "messages for a door-unlocking product use a fixed IV in CBC mode, which is the same after each restart",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-17704"
        },
        {
          "Reference": "CVE-2017-11133",
          "Description": "application uses AES in CBC mode, but the pseudo-random secret and IV are generated using math.random, which is not cryptographically strong.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-11133"
        },
        {
          "Reference": "CVE-2007-3528",
          "Description": "Blowfish-CBC implementation constructs an IV where each byte is calculated modulo 8 instead of modulo 256, resulting in less than 12 bits for the effective IV length, and less than 4096 possible IV values.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3528"
        },
        {
          "Reference": "CVE-2011-3389",
          "Description": "BEAST attack in SSL 3.0 / TLS 1.0. In CBC mode, chained initialization vectors are non-random, allowing decryption of HTTPS traffic using a chosen plaintext attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-3389"
        }
      ],
      "FunctionalAreas": [
        "Cryptography"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Not using a random IV with CBC mode"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Initialization Vectors\", Page 42",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1171",
          "Authors": [
            "Matthew Green"
          ],
          "Title": "Why IND-CPA implies randomized encryption",
          "PublicationYear": "2018",
          "PublicationMonth": "08",
          "PublicationDay": "24",
          "URL": "https://blog.cryptographyengineering.com/why-ind-cpa-implies-randomized-encryption/"
        },
        {
          "ExternalReferenceID": "REF-1172",
          "Section": "Appendix C",
          "Authors": [
            "NIST"
          ],
          "Title": "Recommendation for Block Cipher Modes of Operation",
          "PublicationYear": "2001",
          "PublicationMonth": "12",
          "URL": "https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "330",
      "Name": "Use of Insufficiently Random Values",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Stable",
      "Description": "The product uses insufficiently random numbers or values in a security context that depends on unpredictable numbers.",
      "ExtendedDescription": "When product generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "804",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated. There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it and a truly random value."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "When a protection mechanism relies on random values to restrict access to a sensitive resource, such as a session ID or a seed for generating a cryptographic key, then the resource being protected could be accessed by guessing the ID or key."
        },
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "If product relies on unique, unguessable IDs to identify a resource, an attacker might be able to guess an ID for a resource that is owned by another user. The attacker could then read the resource, or pre-create a resource with the same ID to prevent the legitimate program from properly sending the resource to the intended user. For example, a product might maintain session information in a file whose name is based on a username. An attacker could pre-create this file for a victim user, then set the permissions so that the application cannot generate the session for the victim, preventing the victim from using the application."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "When an authorization or authentication mechanism relies on random values to restrict access to restricted functionality, such as a session ID or a seed for generating a cryptographic key, then an attacker may access the restricted functionality by guessing the ID or key."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-11.4",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and look for library functions that indicate when randomness is being used. Run the process multiple times to see if the seed changes. Look for accesses of devices or equivalent resources that are commonly used for strong (or weak) randomness, such as /dev/urandom on Linux. Look for library or system calls that access predictable information such as process IDs and system time.\n"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tMan-in-the-middle attack tool",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.\n\n\nIn general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.\n\n\nPseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a \"random enough\" number.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-45",
          "Entries": [
            {
              "IntroText": "This code attempts to generate a unique random identifier for a user's session."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction generateSessionID($userID){\n\t\tsrand($userID);\n\t\treturn rand();\n\t}\n```"
            },
            {
              "BodyText": "Because the seed for the PRNG is always the user's ID, the session ID will always be the same. An attacker could thus predict any user's session ID and potentially hijack the session."
            },
            {
              "BodyText": "This example also exhibits a Small Seed Space (CWE-339)."
            }
          ]
        },
        {
          "ID": "DX-46",
          "Entries": [
            {
              "IntroText": "The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString GenerateReceiptURL(String baseUrl) {\n\t\tRandom ranGen = new Random();\n\t\tranGen.setSeed((new Date()).getTime());\n\t\treturn(baseUrl + ranGen.nextInt(400000000) + \".html\");\n\t}\n```"
            },
            {
              "BodyText": "This code uses the Random.nextInt() function to generate \"unique\" identifiers for the receipt pages it generates. Because Random.nextInt() is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-3692",
          "Description": "PHP framework uses mt_rand() function (Marsenne Twister) when generating tokens",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3692"
        },
        {
          "Reference": "CVE-2020-7010",
          "Description": "Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-7010"
        },
        {
          "Reference": "CVE-2009-3278",
          "Description": "Crypto product uses rand() library function to generate a recovery key, making it easier to conduct brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3278"
        },
        {
          "Reference": "CVE-2009-3238",
          "Description": "Random number generator can repeatedly generate the same value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3238"
        },
        {
          "Reference": "CVE-2009-2367",
          "Description": "Web application generates predictable session IDs, allowing session hijacking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2367"
        },
        {
          "Reference": "CVE-2009-2158",
          "Description": "Password recovery utility generates a relatively small number of random passwords, simplifying brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2158"
        },
        {
          "Reference": "CVE-2009-0255",
          "Description": "Cryptographic key created with a seed based on the system time.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0255"
        },
        {
          "Reference": "CVE-2008-5162",
          "Description": "Kernel function does not have a good entropy source just after boot.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5162"
        },
        {
          "Reference": "CVE-2008-4905",
          "Description": "Blogging software uses a hard-coded salt when calculating a password hash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4905"
        },
        {
          "Reference": "CVE-2008-4929",
          "Description": "Bulletin board application uses insufficiently random names for uploaded files, allowing other users to access private files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4929"
        },
        {
          "Reference": "CVE-2008-3612",
          "Description": "Handheld device uses predictable TCP sequence numbers, allowing spoofing or hijacking of TCP connections.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3612"
        },
        {
          "Reference": "CVE-2008-2433",
          "Description": "Web management console generates session IDs based on the login time, making it easier to conduct session hijacking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2433"
        },
        {
          "Reference": "CVE-2008-0166",
          "Description": "SSL library uses a weak random number generator that only generates 65,536 unique keys.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0166"
        },
        {
          "Reference": "CVE-2008-2108",
          "Description": "Chain: insufficient precision causes extra zero bits to be assigned, reducing entropy for an API function that generates random numbers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2108"
        },
        {
          "Reference": "CVE-2008-2108",
          "Description": "Chain: insufficient precision (CWE-1339) in random-number generator causes some zero bits to be reliably generated, reducing the amount of entropy (CWE-331)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2108"
        },
        {
          "Reference": "CVE-2008-2020",
          "Description": "CAPTCHA implementation does not produce enough different images, allowing bypass using a database of all possible checksums.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2020"
        },
        {
          "Reference": "CVE-2008-0087",
          "Description": "DNS client uses predictable DNS transaction IDs, allowing DNS spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0087"
        },
        {
          "Reference": "CVE-2008-0141",
          "Description": "Application generates passwords that are based on the time of day.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0141"
        }
      ],
      "FunctionalAreas": [
        "Cryptography",
        "Authentication",
        "Session Management"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Randomness and Predictability"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Insecure Randomness"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A2",
          "EntryName": "Broken Access Control",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON33-C",
          "EntryName": "Avoid race conditions when using library functions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC30-C",
          "EntryName": "Do not use the rand() function for generating pseudorandom numbers",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC32-C",
          "EntryName": "Properly seed pseudorandom number generators",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "11",
          "EntryName": "Brute Force"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "18",
          "EntryName": "Credential/Session Prediction"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        }
      ],
      "RelatedAttackPatterns": [
        "112",
        "485",
        "59"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 8, \"Using Poor Random Numbers\" Page 259",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be primary to many other weaknesses such as cryptographic errors, authentication errors, symlink following, information leaks, and others."
        },
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.3, CWE-330 and its descendants are being investigated by the CWE crypto team to identify gaps related to randomness and unpredictability, as well as the relationships between randomness and cryptographic primitives. This \"subtree analysis\" might result in the addition or deprecation of existing entries; the reorganization of relationships in some views, e.g. the research view (CWE-1000); more consistent use of terminology; and/or significant modifications to related entries."
        },
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "331",
      "Name": "Insufficient Entropy",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "An attacker could guess the random numbers generated and could gain unauthorized access to a system if the random numbers are used for authentication and authorization."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Determine the necessary entropy to adequately provide for randomness and predictability. This can be achieved by increasing the number of bits of objects such as keys and seeds."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-45",
          "Entries": [
            {
              "IntroText": "This code generates a unique random identifier for a user's session."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction generateSessionID($userID){\n\t\tsrand($userID);\n\t\treturn rand();\n\t}\n```"
            },
            {
              "BodyText": "Because the seed for the PRNG is always the user's ID, the session ID will always be the same. An attacker could thus predict any user's session ID and potentially hijack the session."
            },
            {
              "BodyText": "This example also exhibits a Small Seed Space (CWE-339)."
            }
          ]
        },
        {
          "ID": "DX-46",
          "Entries": [
            {
              "IntroText": "The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString GenerateReceiptURL(String baseUrl) {\n\t\tRandom ranGen = new Random();\n\t\tranGen.setSeed((new Date()).getTime());\n\t\treturn(baseUrl + ranGen.nextInt(400000000) + \".html\");\n\t}\n```"
            },
            {
              "BodyText": "This code uses the Random.nextInt() function to generate \"unique\" identifiers for the receipt pages it generates. Because Random.nextInt() is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-0950",
          "Description": "Insufficiently random data used to generate session tokens using C rand(). Also, for certificate/key generation, uses a source that does not block when entropy is low.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0950"
        },
        {
          "Reference": "CVE-2008-2108",
          "Description": "Chain: insufficient precision (CWE-1339) in random-number generator causes some zero bits to be reliably generated, reducing the amount of entropy (CWE-331)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2108"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient Entropy"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "11",
          "EntryName": "Brute Force"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC32-C",
          "EntryName": "Properly seed pseudorandom number generators",
          "MappingFit": "Exact"
        }
      ],
      "RelatedAttackPatterns": [
        "59"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-207",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "332",
      "Name": "Insufficient Entropy in PRNG",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The lack of entropy available for, or used by, a Pseudo-Random Number Generator (PRNG) can be a stability and security threat.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "331",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If a pseudo-random number generator is using a limited entropy source which runs out (if the generator fails closed), the program may pause or crash."
        },
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "If a PRNG is using a limited entropy source which runs out, and the generator fails open, the generator could produce predictable random numbers. Potentially a weak source of random numbers could weaken the encryption method used for authentication of users."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Consider a PRNG that re-seeds itself as needed from high-quality pseudo-random output, such as hardware devices."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "When deciding which PRNG to use, look at its sources of entropy. Depending on what your security needs are, you may need to use a random number generator that always uses strong random data -- i.e., a random number generator that attempts to be strong but will fail in a weak way or will always provide some middle ground of protection through techniques like re-seeding. Generally, something that always provides a predictable amount of strength is preferable."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "[REF-1374]",
          "Description": "Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)",
          "Link": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards"
        },
        {
          "Reference": "CVE-2019-1715",
          "Description": "security product has insufficient entropy in the DRBG, allowing collisions and private key discovery",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1715"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Insufficient entropy in PRNG"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1374",
          "Authors": [
            "Unciphered"
          ],
          "Title": "Randstorm: You Can't Patch a House of Cards",
          "PublicationYear": "2023",
          "PublicationMonth": "11",
          "PublicationDay": "14",
          "URL": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards",
          "URLDate": "2023-11-15"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "333",
      "Name": "Improper Handling of Insufficient Entropy in TRNG",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "True random number generators (TRNG) generally have a limited source of entropy and therefore can fail or block.",
      "ExtendedDescription": "The rate at which true random numbers can be generated is limited. It is important that one uses them only when they are needed for security.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "331",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "A program may crash or block if it runs out of random numbers."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Rather than failing on a lack of random numbers, it is often preferable to wait for more numbers to be created."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code uses a TRNG to generate a unique session id for new connections to a server:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\twhile (1){\n\t\t\tif (haveNewConnection()){\n\t\t\t\tif (hwRandom()){\n\t\t\t\t\tint sessionID = hwRandom();\n\t\t\t\t\tcreateNewConnection(sessionID);\n\t\t\t\t} } }\n```"
            },
            {
              "BodyText": "This code does not attempt to limit the number of new connections or make sure the TRNG can successfully generate a new random number. An attacker may be able to create many new connections and exhaust the entropy of the TRNG. The TRNG may then block and cause the program to crash or hang."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure of TRNG"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "334",
      "Name": "Small Space of Random Values",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "An attacker could easily guess the values used. This could lead to unauthorized access to a system if the seed is used for authentication and authorization."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-47",
          "Entries": [
            {
              "IntroText": "The following XML example code is a deployment descriptor for a Java web application deployed on a Sun Java Application Server. This deployment descriptor includes a session configuration property for configuring the session ID length."
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<sun-web-app>\n\t\t\t...\n\t\t\t<session-config>\n\t\t\t\t\t<session-properties>\n\t\t\t\t\t\t<property name=\"idLengthBytes\" value=\"8\">\n\t\t\t\t\t\t\t<description>The number of bytes in this web module's session ID.</description>\n\t\t\t\t\t\t</property>\n\t\t\t\t\t</session-properties>\n\t\t\t</session-config>\n\t\t\t...\n\t</sun-web-app>\n```"
            },
            {
              "BodyText": "This deployment descriptor has set the session ID length for this Java web application to 8 bytes (or 64 bits). The session ID length for Java web applications should be set to 16 bytes (128 bits) to prevent attackers from guessing and/or stealing a session ID and taking over a user's session."
            },
            {
              "BodyText": "Note for most application servers including the Sun Java Application Server the session ID length is by default set to 128 bits and should not be changed. And for many application servers the session ID length cannot be changed from this default setting. Check your application server documentation for the session ID length default setting and configuration options to ensure that the session ID length is set to 128 bits."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0583",
          "Description": "Product uses 5 alphanumeric characters for filenames of expense claim reports, stored under web root.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0583"
        },
        {
          "Reference": "CVE-2002-0903",
          "Description": "Product uses small number of random numbers for a code to approve an action, and also uses predictable new user IDs, allowing attackers to hijack new accounts.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0903"
        },
        {
          "Reference": "CVE-2003-1230",
          "Description": "SYN cookies implementation only uses 32-bit keys, making it easier to brute force ISN.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1230"
        },
        {
          "Reference": "CVE-2004-0230",
          "Description": "Complex predictability / randomness (reduced space).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0230"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Small Space of Random Values"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "335",
      "Name": "Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds.",
      "ExtendedDescription": "\n\n PRNGs are deterministic and, while their output appears random, they cannot actually create entropy. They rely on cryptographically secure and unique seeds for entropy so proper seeding is critical to the secure operation of the PRNG.\n\n\n Management of seeds could be broken down into two main areas: \n\n\n  -  (1) protecting seeds as cryptographic material (such as a cryptographic key); \n\n  -  (2) whenever possible, using a uniquely generated seed from a cryptographically secure source \n\n PRNGs require a seed as input to generate a stream of numbers that are functionally indistinguishable from random numbers. While the output is, in many cases, sufficient for cryptographic uses, the output of any PRNG is directly determined by the seed provided as input. If the seed can be ascertained by a third party, the entire output of the PRNG can be made known to them. As such, the seed should be kept secret and should ideally not be able to be guessed. For example, the current time may be a poor seed. Knowing the approximate time the PRNG was seeded greatly reduces the possible key space. \n\n Seeds do not necessarily need to be unique, but reusing seeds may open up attacks if the seed is discovered. \n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "If a PRNG is used incorrectly, such as using the same seed for each initialization or using a predictable seed, then an attacker may be able to easily guess the seed and thus the random numbers. This could lead to unauthorized access to a system if the seed is used for authentication and authorization."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-177",
          "Entries": [
            {
              "IntroText": "The following code uses a statistical PRNG to generate account IDs."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate static final long SEED = 1234567890;\n\tpublic int generateAccountID() {\n\t\tRandom random = new Random(SEED);\n\t\treturn random.nextInt();\n\t}\n```"
            },
            {
              "BodyText": "Because the program uses the same seed value for every invocation of the PRNG, its values are predictable, making the system vulnerable to attack."
            }
          ]
        },
        {
          "ID": "DX-102",
          "Entries": [
            {
              "IntroText": "Both of these examples use a statistical PRNG seeded with the current value of the system clock to generate a random number:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tRandom random = new Random(System.currentTimeMillis());\n\tint accountID = random.nextInt();\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsrand(time());\n\tint randNum = rand();\n```"
            },
            {
              "BodyText": "An attacker can easily predict the seed used by these PRNGs, and so also predict the stream of random numbers generated. Note these examples also exhibit CWE-338 (Use of Cryptographically Weak PRNG)."
            }
          ]
        },
        {
          "ID": "DX-178",
          "Entries": [
            {
              "IntroText": "This code grabs some random bytes and uses them for a seed in a PRNG, in order to generate a new cryptographic key."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n```\n# getting 2 bytes of randomness for the seeding the PRNG * \n\t seed = os.urandom(2)\n\t random.seed(a=seed)\n\t key = random.getrandbits(128)"
            },
            {
              "BodyText": "Since only 2 bytes are used as a seed, an attacker will only need to guess 2^16 (65,536) values before being able to replicate the state of the PRNG."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-7010",
          "Description": "Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-7010"
        },
        {
          "Reference": "CVE-2019-11495",
          "Description": "server uses erlang:now() to seed the PRNG, which results in a small search space for potential random seeds",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-11495"
        },
        {
          "Reference": "CVE-2018-12520",
          "Description": "Product's PRNG is not seeded for the generation of session IDs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-12520"
        },
        {
          "Reference": "CVE-2016-10180",
          "Description": "Router's PIN generation is based on rand(time(0)) seeding.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-10180"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "PRNG Seed Error"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "336",
      "Name": "Same Seed in Pseudo-Random Number Generator (PRNG)",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A Pseudo-Random Number Generator (PRNG) uses the same seed each time the product is initialized.",
      "ExtendedDescription": "Given the deterministic nature of PRNGs, using the same seed for each initialization will lead to the same output in the same order. If an attacker can guess (or knows) the seed, then the attacker may be able to determine the random numbers that will be produced from the PRNG.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "335",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Access Control"
          ],
          "Impact": [
            "Other",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not reuse PRNG seeds. Consider a PRNG that periodically re-seeds itself as needed from a high quality pseudo-random output, such as hardware devices."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems, or use the more recent FIPS 140-3 [REF-1192] if possible."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-177",
          "Entries": [
            {
              "IntroText": "The following code uses a statistical PRNG to generate account IDs."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate static final long SEED = 1234567890;\n\tpublic int generateAccountID() {\n\t\tRandom random = new Random(SEED);\n\t\treturn random.nextInt();\n\t}\n```"
            },
            {
              "BodyText": "Because the program uses the same seed value for every invocation of the PRNG, its values are predictable, making the system vulnerable to attack."
            }
          ]
        },
        {
          "ID": "DX-45",
          "Entries": [
            {
              "IntroText": "This code attempts to generate a unique random identifier for a user's session."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction generateSessionID($userID){\n\t\tsrand($userID);\n\t\treturn rand();\n\t}\n```"
            },
            {
              "BodyText": "Because the seed for the PRNG is always the user's ID, the session ID will always be the same. An attacker could thus predict any user's session ID and potentially hijack the session."
            },
            {
              "BodyText": "If the user IDs are generated sequentially, or otherwise restricted to a narrow range of values, then this example also exhibits a Small Seed Space (CWE-339)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-39218",
          "Description": "SDK for JavaScript app builder for serverless code uses the same fixed seed for a PRNG, allowing cryptography bypass",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-39218"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Same Seed in PRNG"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Section": "Annex C, Approved Random Number Generators",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1192",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "FIPS PUB 140-3: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2019",
          "PublicationMonth": "03",
          "PublicationDay": "22",
          "URL": "https://csrc.nist.gov/publications/detail/fips/140/3/final"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "337",
      "Name": "Predictable Seed in Pseudo-Random Number Generator (PRNG)",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A Pseudo-Random Number Generator (PRNG) is initialized from a predictable seed, such as the process ID or system time.",
      "ExtendedDescription": "The use of predictable seeds significantly reduces the number of possible seeds that an attacker would need to test in order to predict which random numbers will be generated by the PRNG.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "335",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Description": "Use non-predictable inputs for seed generation."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems, or use the more recent FIPS 140-3 [REF-1192] if possible."
        },
        {
          "MitigationID": "MIT-50",
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a PRNG that periodically re-seeds itself using input from high-quality sources, such as hardware devices with high entropy. However, do not re-seed too frequently, or else the entropy source might block."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-102",
          "Entries": [
            {
              "IntroText": "Both of these examples use a statistical PRNG seeded with the current value of the system clock to generate a random number:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tRandom random = new Random(System.currentTimeMillis());\n\tint accountID = random.nextInt();\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsrand(time());\n\tint randNum = rand();\n```"
            },
            {
              "BodyText": "An attacker can easily predict the seed used by these PRNGs, and so also predict the stream of random numbers generated. Note these examples also exhibit CWE-338 (Use of Cryptographically Weak PRNG)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-7010",
          "Description": "Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-7010"
        },
        {
          "Reference": "CVE-2019-11495",
          "Description": "server uses erlang:now() to seed the PRNG, which results in a small search space for potential random seeds",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-11495"
        },
        {
          "Reference": "CVE-2008-0166",
          "Description": "The removal of a couple lines of code caused Debian's OpenSSL Package to only use the current process ID for seeding a PRNG",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0166"
        },
        {
          "Reference": "CVE-2016-10180",
          "Description": "Router's PIN generation is based on rand(time(0)) seeding.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-10180"
        },
        {
          "Reference": "CVE-2018-9057",
          "Description": "cloud provider product uses a non-cryptographically secure PRNG and seeds it with the current time",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-9057"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Predictable Seed in PRNG"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC02-J",
          "EntryName": "Generate strong random numbers"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Section": "Annex C, Approved Random Number Generators",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1192",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "FIPS PUB 140-3: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2019",
          "PublicationMonth": "03",
          "PublicationDay": "22",
          "URL": "https://csrc.nist.gov/publications/detail/fips/140/3/final"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "338",
      "Name": "Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a Pseudo-Random Number Generator (PRNG) in a security context, but the PRNG's algorithm is not cryptographically strong.",
      "ExtendedDescription": "\n\nWhen a non-cryptographic PRNG is used in a cryptographic context, it can expose the cryptography to certain types of attacks.\n\n\nOften a pseudo-random number generator (PRNG) is not designed for cryptography. Sometimes a mediocre source of randomness is sufficient or preferable for algorithms that use random numbers. Weak generators generally take less processing power and/or do not use the precious, finite, entropy sources on a system. While such PRNGs might have very useful features, these same features could be used to break the cryptography.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "If a PRNG is used for authentication and authorization, such as a session ID or a seed for generating a cryptographic key, then an attacker may be able to easily guess the ID or cryptographic key and gain access to restricted functionality."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use functions or hardware which use a hardware-based random number generation for all crypto. This is the recommended solution. Use CyptGenRandom on Windows, or hw_rand() on Linux."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-102",
          "Entries": [
            {
              "IntroText": "Both of these examples use a statistical PRNG seeded with the current value of the system clock to generate a random number:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tRandom random = new Random(System.currentTimeMillis());\n\tint accountID = random.nextInt();\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsrand(time());\n\tint randNum = rand();\n```"
            },
            {
              "BodyText": "The random number functions used in these examples, rand() and Random.nextInt(), are not considered cryptographically strong. An attacker may be able to predict the random numbers generated by these functions. Note that these example also exhibit CWE-337 (Predictable Seed in PRNG)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-3692",
          "Description": "PHP framework uses mt_rand() function (Marsenne Twister) when generating tokens",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3692"
        },
        {
          "Reference": "CVE-2009-3278",
          "Description": "Crypto product uses rand() library function to generate a recovery key, making it easier to conduct brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3278"
        },
        {
          "Reference": "CVE-2009-3238",
          "Description": "Random number generator can repeatedly generate the same value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3238"
        },
        {
          "Reference": "CVE-2009-2367",
          "Description": "Web application generates predictable session IDs, allowing session hijacking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2367"
        },
        {
          "Reference": "CVE-2008-0166",
          "Description": "SSL library uses a weak random number generator that only generates 65,536 unique keys.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0166"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Non-cryptographic PRNG"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC30-C",
          "EntryName": "Do not use the rand() function for generating pseudorandom numbers",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "339",
      "Name": "Small Seed Space in PRNG",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A Pseudo-Random Number Generator (PRNG) uses a relatively small seed space, which makes it more susceptible to brute force attacks.",
      "ExtendedDescription": "PRNGs are entirely deterministic once seeded, so it should be extremely difficult to guess the seed. If an attacker can collect the outputs of a PRNG and then brute force the seed by trying every possibility to see which seed matches the observed output, then the attacker will know the output of any subsequent calls to the PRNG. A small seed space implies that the attacker will have far fewer possible values to try to exhaust all possibilities.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "335",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "341",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use well vetted pseudo-random number generating algorithms with adequate length seeds. Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a \"random enough\" number."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems, or use the more recent FIPS 140-3 [REF-1192] if possible."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-178",
          "Entries": [
            {
              "IntroText": "This code grabs some random bytes and uses them for a seed in a PRNG, in order to generate a new cryptographic key."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n```\n# getting 2 bytes of randomness for the seeding the PRNG * \n\t seed = os.urandom(2)\n\t random.seed(a=seed)\n\t key = random.getrandbits(128)"
            },
            {
              "BodyText": "Since only 2 bytes are used as a seed, an attacker will only need to guess 2^16 (65,536) values before being able to replicate the state of the PRNG."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-10908",
          "Description": "product generates passwords via org.apache.commons.lang.RandomStringUtils, which uses java.util.Random internally. This PRNG has only a 48-bit seed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-10908"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Small Seed Space in PRNG"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Section": "Annex C, Approved Random Number Generators",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1192",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "FIPS PUB 140-3: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2019",
          "PublicationMonth": "03",
          "PublicationDay": "22",
          "URL": "https://csrc.nist.gov/publications/detail/fips/140/3/final"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry may have a chaining relationship with predictable from observable state (CWE-341)."
        },
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "340",
      "Name": "Generation of Predictable Numbers or Identifiers",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a scheme that generates numbers or identifiers that are more predictable than required.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "384",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-45",
          "Entries": [
            {
              "IntroText": "This code generates a unique random identifier for a user's session."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction generateSessionID($userID){\n\t\tsrand($userID);\n\t\treturn rand();\n\t}\n```"
            },
            {
              "BodyText": "Because the seed for the PRNG is always the user's ID, the session ID will always be the same. An attacker could thus predict any user's session ID and potentially hijack the session."
            },
            {
              "BodyText": "This example also exhibits a Small Seed Space (CWE-339)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29330",
          "Description": "Product for administering PBX systems uses predictable identifiers and timestamps for filenames (CWE-340) which allows attackers to access files via direct request (CWE-425).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29330"
        },
        {
          "Reference": "CVE-2001-1141",
          "Description": "PRNG allows attackers to use the output of small PRNG requests to determine the internal state information, which could be used by attackers to predict future pseudo-random numbers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1141"
        },
        {
          "Reference": "CVE-1999-0074",
          "Description": "Listening TCP ports are sequentially allocated, allowing spoofing attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0074"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Predictability problems"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "11",
          "EntryName": "Brute Force"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "341",
      "Name": "Predictable from Observable State",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A number or object is predictable based on observations that the attacker can make about the state of the system or network, such as time, process ID, etc.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "340",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "This weakness could be exploited by an attacker in a number ways depending on the context. If a predictable number is used to generate IDs or keys that are used within protection mechanisms, then an attacker could gain unauthorized access to the system. If predictable filenames are used for storing sensitive information, then an attacker might gain access to the system and may be able to gain access to the information in the file."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Increase the entropy used to seed a PRNG."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        },
        {
          "MitigationID": "MIT-50",
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a PRNG that periodically re-seeds itself using input from high-quality sources, such as hardware devices with high entropy. However, do not re-seed too frequently, or else the entropy source might block."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-45",
          "Entries": [
            {
              "IntroText": "This code generates a unique random identifier for a user's session."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction generateSessionID($userID){\n\t\tsrand($userID);\n\t\treturn rand();\n\t}\n```"
            },
            {
              "BodyText": "Because the seed for the PRNG is always the user's ID, the session ID will always be the same. An attacker could thus predict any user's session ID and potentially hijack the session."
            },
            {
              "BodyText": "This example also exhibits a Small Seed Space (CWE-339)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0389",
          "Description": "Mail server stores private mail messages with predictable filenames in a world-executable directory, which allows local users to read private mailing list archives.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0389"
        },
        {
          "Reference": "CVE-2001-1141",
          "Description": "PRNG allows attackers to use the output of small PRNG requests to determine the internal state information, which could be used by attackers to predict future pseudo-random numbers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1141"
        },
        {
          "Reference": "CVE-2000-0335",
          "Description": "DNS resolver library uses predictable IDs, which allows a local attacker to spoof DNS query results.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0335"
        },
        {
          "Reference": "CVE-2005-1636",
          "Description": "MFV. predictable filename and insecure permissions allows file modification to execute SQL queries.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1636"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Predictable from Observable State"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "342",
      "Name": "Predictable Exact Value from Previous Values",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An exact value or random number can be precisely predicted by observing previous values.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "340",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Description": "Increase the entropy used to seed a PRNG."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        },
        {
          "MitigationID": "MIT-50",
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a PRNG that periodically re-seeds itself using input from high-quality sources, such as hardware devices with high entropy. However, do not re-seed too frequently, or else the entropy source might block."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1463",
          "Description": "Firewall generates easily predictable initial sequence numbers (ISN), which allows remote attackers to spoof connections.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1463"
        },
        {
          "Reference": "CVE-1999-0074",
          "Description": "Listening TCP ports are sequentially allocated, allowing spoofing attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0074"
        },
        {
          "Reference": "CVE-1999-0077",
          "Description": "Predictable TCP sequence numbers allow spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0077"
        },
        {
          "Reference": "CVE-2000-0335",
          "Description": "DNS resolver uses predictable IDs, allowing a local user to spoof DNS query results.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0335"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Predictable Exact Value from Previous Values"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "343",
      "Name": "Predictable Value Range from Previous Values",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product's random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.",
      "ExtendedDescription": "The output of a random number generator should not be predictable based on observations of previous values. In some cases, an attacker cannot predict the exact value that will be produced next, but can narrow down the possibilities significantly. This reduces the amount of effort to perform a brute force attack. For example, suppose the product generates random numbers between 1 and 100, but it always produces a larger value until it reaches 100. If the generator produces an 80, then the attacker knows that the next value will be somewhere between 81 and 100. Instead of 100 possibilities, the attacker only needs to consider 20.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "340",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Description": "Increase the entropy used to seed a PRNG."
        },
        {
          "MitigationID": "MIT-2",
          "Phase": [
            "Architecture and Design",
            "Requirements"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (\"Approved Random Number Generators\")."
        },
        {
          "MitigationID": "MIT-50",
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a PRNG that periodically re-seeds itself using input from high-quality sources, such as hardware devices with high entropy. However, do not re-seed too frequently, or else the entropy source might block."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Predictable Value Range from Previous Values"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-320",
          "Authors": [
            "Michal Zalewski"
          ],
          "Title": "Strange Attractors and TCP/IP Sequence Number Analysis",
          "PublicationYear": "2001",
          "URL": "https://lcamtuf.coredump.cx/oldtcp/tcpseq.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 20: Weak Random Numbers.\" Page 299",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "344",
      "Name": "Use of Invariant Value in Dynamically Changing Context",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a constant value, name, or reference, but this value can (or should) vary across different environments.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "330",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-14",
          "Entries": [
            {
              "IntroText": "The following code is an example of an internal hard-coded password in the back-end:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password, \"Mew!\")) {\n\t\t\t\t\t printf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0)\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (!password.equals(\"Mew!\")) {\n\t\t\treturn(0)\n\t\t}\n\t\t//Diagnostic Mode\n\t\treturn(1);\n\t}\n```"
            },
            {
              "BodyText": "Every instance of this program can be placed into diagnostic mode with the same password. Even worse is the fact that if this program is distributed as a binary-only distribution, it is very difficult to change that password or disable this \"functionality.\""
            }
          ]
        },
        {
          "ID": "DX-192",
          "Entries": [
            {
              "IntroText": "This code assumes a particular function will always be found at a particular address. It assigns a pointer to that address and calls the function."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint (*pt2Function) (float, char, char)=0x08040000;\n\tint result2 = (*pt2Function) (12, 'a', 'b');\n```\n// Here we can inject code to execute.*"
            },
            {
              "BodyText": "The same function may not always be found at the same memory address. This could lead to a crash, or an attacker may alter the memory at the expected address, leading to arbitrary code execution."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0980",
          "Description": "Component for web browser writes an error message to a known location, which can then be referenced by attackers to process HTML/script in a less restrictive context",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0980"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Static Value in Unpredictable Context"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "overlaps default configuration."
        }
      ]
    },
    {
      "ID": "345",
      "Name": "Insufficient Verification of Data Authenticity",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not sufficiently verify the origin or authenticity of data, in a way that causes it to accept invalid data.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors did not sign firmware images."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30260",
          "Description": "Distributed Control System (DCS) does not sign firmware images and only relies on insecure checksums for integrity checks",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30260"
        },
        {
          "Reference": "CVE-2022-30267",
          "Description": "Distributed Control System (DCS) does not sign firmware images and only relies on insecure checksums for integrity checks",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30267"
        },
        {
          "Reference": "CVE-2022-30272",
          "Description": "Remote Terminal Unit (RTU) does not use signatures for firmware images and relies on insecure checksums",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30272"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient Verification of Data"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "12",
          "EntryName": "Content Spoofing"
        }
      ],
      "RelatedAttackPatterns": [
        "111",
        "141",
        "142",
        "148",
        "218",
        "384",
        "385",
        "386",
        "387",
        "388",
        "665",
        "701"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 15: Not Updating Easily.\" Page 231",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "\"origin validation\" could fall under this."
        },
        {
          "Type": "Maintenance",
          "Note": "The specific ways in which the origin is not properly identified should be laid out as separate weaknesses. In some sense, this is more like a category."
        }
      ]
    },
    {
      "ID": "346",
      "Name": "Origin Validation Error",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly verify that the source of data or communication is valid.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Varies by Context"
          ],
          "Note": "An attacker can access any functionality that is inadvertently accessible to the source."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-112",
          "Entries": [
            {
              "IntroText": "This Android application will remove a user account when it receives an intent to do so:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntentFilter filter = new IntentFilter(\"com.example.RemoveUser\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\tpublic class DeleteReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tint userID = intent.getIntExtra(\"userID\");\n\t\t\tdestroyUserData(userID);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This application does not check the origin of the intent, thus allowing any malicious application to remove a user. Always check the origin of an intent, or create an allowlist of trusted applications using the manifest.xml file."
            }
          ]
        },
        {
          "ID": "DX-109",
          "Entries": [
            {
              "IntroText": "These Android and iOS applications intercept URL loading within a WebView and perform special actions if a particular URL scheme is used, thus allowing the Javascript within the WebView to communicate with the application:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n// Android* \n\t@Override\n\tpublic boolean shouldOverrideUrlLoading(WebView view, String url){\n\t```\n\t\t\tif (url.substring(0,14).equalsIgnoreCase(\"examplescheme:\")){\n\t\t\t\tif(url.substring(14,25).equalsIgnoreCase(\"getUserInfo\")){\n\t\t\t\t\twriteDataToView(view, UserData);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Objective-C",
              "ExampleCode": "```\n```\n// iOS* \n\t-(BOOL) webView:(UIWebView *)exWebView shouldStartLoadWithRequest:(NSURLRequest *)exRequest navigationType:(UIWebViewNavigationType)exNavigationType\n\t{\n\t```\n\t\t\tNSURL *URL = [exRequest URL];\n\t\t\tif ([[URL scheme] isEqualToString:@\"exampleScheme\"])\n\t\t\t{\n\t\t\t\t\tNSString *functionString = [URL resourceSpecifier];\n\t\t\t\t\tif ([functionString hasPrefix:@\"specialFunction\"])\n\t\t\t\t\t{\n```\n// Make data available back in webview.* \n\t\t\t\t\t\t\tUIWebView *webView = [self writeDataToView:[URL query]];}\n\t\t\t\t\treturn NO;}\n\t\t\treturn YES;}"
            },
            {
              "BodyText": "A call into native code can then be initiated by passing parameters within the URL:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\twindow.location = examplescheme://method?parameter=value\n```"
            },
            {
              "BodyText": "Because the application does not check the source, a malicious website loaded within this WebView has the same access to the API as a trusted site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-1218",
          "Description": "DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1218"
        },
        {
          "Reference": "CVE-2005-0877",
          "Description": "DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0877"
        },
        {
          "Reference": "CVE-2001-1452",
          "Description": "DNS server caches glue records received from non-delegated name servers",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1452"
        },
        {
          "Reference": "CVE-2005-2188",
          "Description": "user ID obtained from untrusted source (URL)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2188"
        },
        {
          "Reference": "CVE-2003-0174",
          "Description": "LDAP service does not verify if a particular attribute was set by the LDAP server",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0174"
        },
        {
          "Reference": "CVE-1999-1549",
          "Description": "product does not sufficiently distinguish external HTML from internal, potentially dangerous HTML, allowing bypass using special strings in the page title. Overlaps special elements.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1549"
        },
        {
          "Reference": "CVE-2003-0981",
          "Description": "product records the reverse DNS name of a visitor in the logs, allowing spoofing and resultant XSS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0981"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Origin Validation Error"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.12 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SR-2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.12 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 3.1 RE(1)"
        }
      ],
      "RelatedAttackPatterns": [
        "111",
        "141",
        "142",
        "160",
        "21",
        "384",
        "385",
        "386",
        "387",
        "388",
        "510",
        "59",
        "60",
        "75",
        "76",
        "89"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-324",
          "Authors": [
            "Taimur Aslam"
          ],
          "Title": "A Taxonomy of Security Faults in the UNIX Operating System",
          "PublicationYear": "1995",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "http://cwe.mitre.org/documents/sources/ATaxonomyofSecurityFaultsintheUNIXOperatingSystem%5BAslam95%5D.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry has some significant overlap with other CWE entries and may need some clarification. See terminology notes."
        },
        {
          "Type": "Terminology",
          "Note": "The \"Origin Validation Error\" term was originally used in a 1995 thesis [REF-324]. Although not formally defined, an issue is considered to be an origin validation error if either (1) \"an object [accepts] input from an unauthorized subject,\" or (2) \"the system [fails] to properly or completely authenticate a subject.\" A later section says that an origin validation error can occur when the system (1) \"does not properly authenticate a user or process\" or (2) \"does not properly authenticate the shared data or libraries.\" The only example provided in the thesis (covered by OSVDB:57615) involves a setuid program running command-line arguments without dropping privileges. So, this definition (and its examples in the thesis) effectively cover other weaknesses such as CWE-287 (Improper Authentication), CWE-285 (Improper Authorization), and CWE-250 (Execution with Unnecessary Privileges). There appears to be little usage of this term today, except in the SecurityFocus vulnerability database, where the term is used for a variety of issues, including web-browser problems that allow violation of the Same Origin Policy and improper validation of the source of an incoming message."
        }
      ]
    },
    {
      "ID": "347",
      "Name": "Improper Verification of Cryptographic Signature",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Modify Application Data",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker could gain access to sensitive data and possibly execute unauthorized code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following code, a JarFile object is created from a downloaded file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tFile f = new File(downloadedFilePath);\n\tJarFile jf = new JarFile(f);\n```"
            },
            {
              "BodyText": "The JAR file that was potentially downloaded from an untrusted source is created without verifying the signature (if present). An alternate constructor that accepts a boolean verify parameter should be used instead."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1796",
          "Description": "Does not properly verify signatures for \"trusted\" entities.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1796"
        },
        {
          "Reference": "CVE-2005-2181",
          "Description": "Insufficient verification allows spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2181"
        },
        {
          "Reference": "CVE-2005-2182",
          "Description": "Insufficient verification allows spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2182"
        },
        {
          "Reference": "CVE-2002-1706",
          "Description": "Accepts a configuration file without a Message Integrity Check (MIC) signature.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1706"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Improperly Verified Signature"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC06-J",
          "EntryName": "Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.9"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SM-6"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req EDR 3.12"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req NDR 3.12"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req HDR 3.12"
        }
      ],
      "RelatedAttackPatterns": [
        "463",
        "475"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "348",
      "Name": "Use of Less Trusted Source",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product has two different sources of the same data or information, but it uses the source that has less support for verification, is less trusted, or is less resistant to attack.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could utilize the untrusted data source to bypass protection mechanisms and gain access to sensitive data."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code attempts to limit the access of a page to certain IP Addresses. It checks the 'HTTP_X_FORWARDED_FOR' header in case an authorized user is sending the request through a proxy."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$requestingIP = '0.0.0.0';\n\tif (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {\n\t\t$requestingIP = $_SERVER['HTTP_X_FORWARDED_FOR'];\n\telse{\n\t\t$requestingIP = $_SERVER['REMOTE_ADDR'];\n\t}\n\tif(in_array($requestingIP,$ipAllowlist)){\n\t\tgeneratePage();\n\t\treturn;\n\t}\n\telse{\n\t\techo \"You are not authorized to view this page\";\n\t\treturn;\n\t}\n```"
            },
            {
              "BodyText": "The 'HTTP_X_FORWARDED_FOR' header can be user controlled and so should never be trusted. An attacker can falsify the header to gain access to the page."
            },
            {
              "BodyText": "This fixed code only trusts the 'REMOTE_ADDR' header and so avoids the issue:"
            },
            {
              "Nature": "Good",
              "Language": "PHP",
              "ExampleCode": "```\n\t$requestingIP = '0.0.0.0';\n\tif (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {\n\t\techo \"This application cannot be accessed through a proxy.\";\n\t\treturn;\n\telse{\n\t\t$requestingIP = $_SERVER['REMOTE_ADDR'];\n\t}\n```\n...*"
            },
            {
              "BodyText": "Be aware that 'REMOTE_ADDR' can still be spoofed. This may seem useless because the server will send the response to the fake address and not the attacker, but this may still be enough to conduct an attack. For example, if the generatePage() function in this code is resource intensive, an attacker could flood the server with fake requests using an authorized IP and consume significant resources. This could be a serious DoS attack even though the attacker would never see the page's sensitive content."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-0860",
          "Description": "Product uses IP address provided by a client, instead of obtaining it from the packet headers, allowing easier spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0860"
        },
        {
          "Reference": "CVE-2004-1950",
          "Description": "Web product uses the IP address in the X-Forwarded-For HTTP header instead of a server variable that uses the connecting IP address, allowing filter bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1950"
        },
        {
          "Reference": "CVE-2001-0908",
          "Description": "Product logs IP address specified by the client instead of obtaining it from the packet headers, allowing information hiding.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0908"
        },
        {
          "Reference": "CVE-2006-1126",
          "Description": "PHP application uses IP address from X-Forwarded-For HTTP header, instead of REMOTE_ADDR.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1126"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Use of Less Trusted Source"
        }
      ],
      "RelatedAttackPatterns": [
        "141",
        "142",
        "73",
        "76",
        "85"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "349",
      "Name": "Acceptance of Extraneous Untrusted Data With Trusted Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product, when processing trusted data, accepts any untrusted data that is also included with the trusted data, treating the untrusted data as if it were trusted.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Integrity"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Modify Application Data"
          ],
          "Note": "An attacker could package untrusted data with trusted data to bypass protection mechanisms to gain access to and possibly modify sensitive data."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0018",
          "Description": "Does not verify that trusted entity is authoritative for all entities in its response.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0018"
        },
        {
          "Reference": "CVE-2006-5462",
          "Description": "use of extra data in a signature allows certificate signature forging",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5462"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Untrusted Data Appended with Trusted Data"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ENV01-J",
          "EntryName": "Place all security-sensitive code in a single JAR and sign and seal it"
        }
      ],
      "RelatedAttackPatterns": [
        "141",
        "142",
        "75"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "350",
      "Name": "Reliance on Reverse DNS Resolution for a Security-Critical Action",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.",
      "ExtendedDescription": "\n\nSince DNS names can be easily spoofed or misreported, and it may be difficult for the product to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism.\n\n\nWhen the product performs a reverse DNS resolution for an IP address, if an attacker controls the DNS server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks.\n\n\nAttackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "290",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "807",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "923",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ],
          "Note": "Malicious users can fake authentication information by providing false DNS information."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use other means of identity verification that cannot be simply spoofed. Possibilities include a username/password or certificate."
        },
        {
          "MitigationID": "MIT-42",
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform proper forward and reverse DNS lookups to detect DNS spoofing."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-93",
          "Entries": [
            {
              "IntroText": "The following code samples use a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct hostent *hp;struct in_addr myaddr;\n\tchar* tHost = \"trustme.example.com\";\n\tmyaddr.s_addr=inet_addr(ip_addr_string);\n\thp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\n\tif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {\n\t\ttrusted = true;\n\t} else {\n\t\ttrusted = false;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString ip = request.getRemoteAddr();\n\tInetAddress addr = InetAddress.getByName(ip);\n\tif (addr.getCanonicalHostName().endsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tIPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);\n\tIPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);\n\tif (hostInfo.HostName.EndsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "BodyText": "IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In these examples, a connection is established if a request is made by a trusted host."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsd = socket(AF_INET, SOCK_DGRAM, 0);\n\tserv.sin_family = AF_INET;\n\tserv.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservr.sin_port = htons(1008);\n\tbind(sd, (struct sockaddr *) & serv, sizeof(serv));\n\twhile (1) {\n\t\t\tmemset(msg, 0x0, MAX_MSG);\n\t\t\tclilen = sizeof(cli);\n\t\t\th=gethostbyname(inet_ntoa(cliAddr.sin_addr));\n\t\t\tif (h->h_name==...) n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twhile(true) {\n\t\t\tDatagramPacket rp=new DatagramPacket(rData,rData.length);\n\t\t\toutSock.receive(rp);\n\t\t\tString in = new String(p.getData(),0, rp.getLength());\n\t\t\tInetAddress IPAddress = rp.getAddress();\n\t\t\tint port = rp.getPort();\n\t\t\tif ((rp.getHostName()==...) & (in==...)) {\n\t\t\t\t\tout = secret.getBytes();\n\t\t\t\t\tDatagramPacket sp =new DatagramPacket(out,out.length, IPAddress, port);\n\t\t\t\t\toutSock.send(sp);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "These examples check if a request is from a trusted host before responding to a request, but the code only verifies the hostname as stored in the request packet. An attacker can spoof the hostname, thus impersonating a trusted client."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1488",
          "Description": "Does not do double-reverse lookup to prevent DNS spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1488"
        },
        {
          "Reference": "CVE-2001-1500",
          "Description": "Does not verify reverse-resolved hostnames in DNS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1500"
        },
        {
          "Reference": "CVE-2000-1221",
          "Description": "Authentication bypass using spoofed reverse-resolved DNS hostnames.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1221"
        },
        {
          "Reference": "CVE-2002-0804",
          "Description": "Authentication bypass using spoofed reverse-resolved DNS hostnames.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0804"
        },
        {
          "Reference": "CVE-2001-1155",
          "Description": "Filter does not properly check the result of a reverse DNS lookup, which could allow remote attackers to bypass intended access restrictions via DNS spoofing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1155"
        },
        {
          "Reference": "CVE-2004-0892",
          "Description": "Reverse DNS lookup used to spoof trusted content in intermediary.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0892"
        },
        {
          "Reference": "CVE-2003-0981",
          "Description": "Product records the reverse DNS name of a visitor in the logs, allowing spoofing and resultant XSS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0981"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Improperly Trusted Reverse DNS"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Trusting self-reported DNS name"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP29",
          "EntryName": "Faulty endpoint authentication"
        }
      ],
      "RelatedAttackPatterns": [
        "142",
        "275",
        "73",
        "89"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 15: Not Updating Easily.\" Page 231",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 24: Trusting Network Name Resolution.\" Page 361",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 16, \"DNS Spoofing\", Page 1002",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "CWE-350, CWE-247, and CWE-292 were merged into CWE-350 in CWE 2.5. CWE-247 was originally derived from Seven Pernicious Kingdoms, CWE-350 from PLOVER, and CWE-292 from CLASP. All taxonomies focused closely on the use of reverse DNS for authentication of incoming requests."
        }
      ]
    },
    {
      "ID": "351",
      "Name": "Insufficient Type Distinction",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly distinguish between different types of elements in a way that leads to insecure behavior.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "436",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-2260",
          "Description": "Browser user interface does not distinguish between user-initiated and synthetic events.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2260"
        },
        {
          "Reference": "CVE-2005-2801",
          "Description": "Product does not compare all required data in two separate elements, causing it to think they are the same, leading to loss of ACLs. Similar to Same Name error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2801"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient Type Distinction"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps others, e.g. Multiple Interpretation Errors."
        }
      ]
    },
    {
      "ID": "352",
      "Name": "Cross-Site Request Forgery (CSRF)",
      "Abstraction": "Compound",
      "Structure": "Composite",
      "Status": "Stable",
      "Description": "The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.",
      "ExtendedDescription": "When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "Requires",
          "CweID": "346",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "441",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "642",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "613",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Session Riding"
        },
        {
          "Term": "Cross Site Reference Forgery"
        },
        {
          "Term": "XSRF"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Non-Repudiation",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Modify Application Data",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The consequences will vary depending on the nature of the functionality that is vulnerable to CSRF. An attacker could effectively perform any operations as the victim. If the victim is an administrator or privileged user, the consequences may include obtaining complete control over the web application - deleting or stealing data, uninstalling the product, or using it to launch other attacks against all of the product's users. Because the attacker has the identity of the victim, the scope of CSRF is limited only by the victim's privileges."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-7",
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual analysis can be useful for finding this weakness, and for minimizing false positives assuming an understanding of business logic. However, it might not achieve desired code coverage within limited time constraints. For black-box analysis, if credentials are not known for privileged accounts, then the most security-critical portions of the application may not receive sufficient attention.\n\n\nConsider using OWASP CSRFTester to identify potential issues and aid in manual analysis.\n",
          "Effectiveness": "High",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "CSRF is currently difficult to detect reliably using automated techniques. This is because each application has its own implicit security policy that dictates which requests can be influenced by an outsider and automatically performed on behalf of a user, versus which requests require strong confidence that the user intends to make the request. For example, a keyword search of the public portion of a web site is typically expected to be encoded within a link that can be launched automatically when the user clicks on the link.",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tWeb Application Scanner",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "SOAR Partial"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]\n\n\nAnother example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]",
          "EffectivenessNotes": "Note that this can be bypassed using XSS (CWE-79)."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.",
          "EffectivenessNotes": "Note that this can be bypassed using XSS (CWE-79)."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse the \"double-submitted cookie\" method as described by Felten and Zeller:\n\n\nWhen a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.\n\n\nBecause of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.\n\n\nThis technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]\n",
          "EffectivenessNotes": "Note that this can probably be bypassed using XSS (CWE-79), or when using web technologies that enable the attacker to read raw headers from HTTP requests."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not use the GET method for any request that triggers a state change."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",
          "EffectivenessNotes": "Note that this can be bypassed using XSS (CWE-79). An attacker could use XSS to generate a spoofed Referer, or to generate a malicious request from a page whose Referer would be allowed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This example PHP code attempts to secure the form submission process by validating that the user submitting the form has a valid session. A CSRF attack would not be prevented by this countermeasure because the attacker forges a request through the user's web browser in which a valid session already exists."
            },
            {
              "BodyText": "The following HTML is intended to allow a user to update a profile."
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<form action=\"/url/profile.php\" method=\"post\">\n\t<input type=\"text\" name=\"firstname\"/>\n\t<input type=\"text\" name=\"lastname\"/>\n\t<br/>\n\t<input type=\"text\" name=\"email\"/>\n\t<input type=\"submit\" name=\"submit\" value=\"Update\"/>\n\t</form>\n```"
            },
            {
              "BodyText": "profile.php contains the following code."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t// initiate the session in order to validate sessions\n\tsession_start();\n```\n//if the session is registered to a valid user then allow update* \n\t\n\tif (! session_is_registered(\"username\")) {\n\t```\n\t\t\techo \"invalid session detected!\";\n```\n// Redirect user to login page* \n\t\t\t[...]\n\t\t\t\n\t\t\texit;}\n\t\n\t\n\t *// The user session is valid, so process the request* \n\t\n\t\n\t *// and update the information* \n\t\n\tupdate_profile();\n\t\n\tfunction update_profile {\n\t```\n```\n// read in the data from $POST and send an update* \n\t\t\t\n\t\t\t\n\t\t\t *// to the database* \n\t\t\tSendUpdateToDatabase($_SESSION['username'], $_POST['email']);\n\t\t\t[...]\n\t\t\techo \"Your profile has been successfully updated.\";}"
            },
            {
              "BodyText": "This code may look protected since it checks for a valid session. However, CSRF attacks can be staged from virtually any tag or HTML construct, including image tags, links, embed or object tags, or other attributes that load background images."
            },
            {
              "BodyText": "The attacker can then host code that will silently change the username and email address of any user that visits the page while remaining logged in to the target web application. The code might be an innocent-looking web page such as:"
            },
            {
              "Nature": "Attack",
              "Language": "HTML",
              "ExampleCode": "```\n\t<SCRIPT>\n\tfunction SendAttack () {\n\t\tform.email = \"attacker@example.com\";\n```\n// send to profile.php* \n\t\tform.submit();}\n\t</SCRIPT>\n\t\n\t<BODY onload=\"javascript:SendAttack();\">\n\t\n\t<form action=\"http://victim.example.com/profile.php\" id=\"form\" method=\"post\">\n\t<input type=\"hidden\" name=\"firstname\" value=\"Funny\">\n\t<input type=\"hidden\" name=\"lastname\" value=\"Joke\">\n\t<br/>\n\t<input type=\"hidden\" name=\"email\">\n\t</form>"
            },
            {
              "BodyText": "Notice how the form contains hidden fields, so when it is loaded into the browser, the user will not notice it. Because SendAttack() is defined in the body's onload attribute, it will be automatically called when the victim loads the web page."
            },
            {
              "BodyText": "Assuming that the user is already logged in to victim.example.com, profile.php will see that a valid user session has been established, then update the email address to the attacker's own address. At this stage, the user's identity has been compromised, and messages sent through this profile could be sent to the attacker's address."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-1703",
          "Description": "Add user accounts via a URL in an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1703"
        },
        {
          "Reference": "CVE-2004-1995",
          "Description": "Add user accounts via a URL in an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1995"
        },
        {
          "Reference": "CVE-2004-1967",
          "Description": "Arbitrary code execution by specifying the code in a crafted img tag or URL",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1967"
        },
        {
          "Reference": "CVE-2004-1842",
          "Description": "Gain administrative privileges via a URL in an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1842"
        },
        {
          "Reference": "CVE-2005-1947",
          "Description": "Delete a victim's information via a URL or an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1947"
        },
        {
          "Reference": "CVE-2005-2059",
          "Description": "Change another user's settings via a URL or an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2059"
        },
        {
          "Reference": "CVE-2005-1674",
          "Description": "Perform actions as administrator via a URL or an img tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1674"
        },
        {
          "Reference": "CVE-2009-3520",
          "Description": "modify password for the administrator",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3520"
        },
        {
          "Reference": "CVE-2009-3022",
          "Description": "CMS allows modification of configuration via CSRF attack against the administrator",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3022"
        },
        {
          "Reference": "CVE-2009-3759",
          "Description": "web interface allows password changes or stopping a virtual machine via CSRF",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3759"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Cross-Site Request Forgery (CSRF)"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A5",
          "EntryName": "Cross Site Request Forgery (CSRF)",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "9",
          "EntryName": "Cross-site Request Forgery"
        }
      ],
      "RelatedAttackPatterns": [
        "111",
        "462",
        "467",
        "62"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 2: Web-Server Related Vulnerabilities (XSS, XSRF, and\n Response Splitting).\" Page 37",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-329",
          "Authors": [
            "Peter W"
          ],
          "Title": "Cross-Site Request Forgeries (Re: The Dangers of Allowing Users to Post Images)",
          "Publication": "Bugtraq",
          "URL": "http://marc.info/?l=bugtraq&m=99263135911884&w=2"
        },
        {
          "ExternalReferenceID": "REF-330",
          "Authors": [
            "OWASP"
          ],
          "Title": "Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet",
          "URL": "http://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet"
        },
        {
          "ExternalReferenceID": "REF-331",
          "Authors": [
            "Edward W. Felten",
            "William Zeller"
          ],
          "Title": "Cross-Site Request Forgeries: Exploitation and Prevention",
          "PublicationYear": "2008",
          "PublicationMonth": "10",
          "PublicationDay": "18",
          "URL": "https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.147.1445",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-332",
          "Authors": [
            "Robert Auger"
          ],
          "Title": "CSRF - The Cross-Site Request Forgery (CSRF/XSRF) FAQ",
          "URL": "https://www.cgisecurity.com/csrf-faq.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-333",
          "Title": "Cross-site request forgery",
          "PublicationYear": "2008",
          "PublicationMonth": "12",
          "PublicationDay": "22",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Cross-site_request_forgery",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-334",
          "Authors": [
            "Jason Lam"
          ],
          "Title": "Top 25 Series - Rank 4 - Cross Site Request Forgery",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "Publisher": "SANS Software Security Institute",
          "URL": "http://software-security.sans.org/blog/2010/03/03/top-25-series-rank-4-cross-site-request-forgery"
        },
        {
          "ExternalReferenceID": "REF-335",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Preventing CSRF and XSRF Attacks",
          "PublicationYear": "2008",
          "PublicationMonth": "10",
          "PublicationDay": "14",
          "URL": "https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-956",
          "Authors": [
            "Wikipedia"
          ],
          "Title": "Samy (computer worm)",
          "URL": "https://en.wikipedia.org/wiki/Samy_(computer_worm)",
          "URLDate": "2018-01-16"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.",
        "Comments": "While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.",
        "Reasons": [
          "Other"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "\n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n"
        },
        {
          "Type": "Theoretical",
          "Note": "\n\nThe CSRF topology is multi-channel:\n\n\n  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.\n\n  - Intermediary (as user) to server (as victim). The activation point is an internal channel.\n\n"
        }
      ]
    },
    {
      "ID": "353",
      "Name": "Missing Support for Integrity Check",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a transmission protocol that does not include a mechanism for verifying the integrity of the data during transmission, such as a checksum.",
      "ExtendedDescription": "If integrity check values or \"checksums\" are omitted from a protocol, there is no way of determining if data has been corrupted in transmission. The lack of checksum functionality in a protocol removes the first application-level check of data that can be used. The end-to-end philosophy of checks states that integrity checks should be performed at the lowest level that they can be completely implemented. Excluding further sanity checks and input validation performed by applications, the protocol's checksum is the most important level of checksum, since it can be performed more completely than at any previous level and takes into account entire messages, as opposed to single packets.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "354",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Data that is parsed and used may be corrupted."
        },
        {
          "Scope": [
            "Non-Repudiation",
            "Other"
          ],
          "Impact": [
            "Hide Activities",
            "Other"
          ],
          "Note": "Without a checksum it is impossible to determine if any changes have been made to the data after it was sent."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Add an appropriately sized checksum to the protocol, ensuring that data received may be simply validated before it is parsed and used."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that the checksums present in the protocol design are properly implemented and added to each message before it is sent."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, a request packet is received, and privileged information is sent to the requester:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twhile(true) {\n\t\tDatagramPacket rp = new DatagramPacket(rData,rData.length);\n\t\toutSock.receive(rp);\n\t\tInetAddress IPAddress = rp.getAddress();\n\t\tint port = rp.getPort();\n\t\tout = secret.getBytes();\n\t\tDatagramPacket sp =new DatagramPacket(out, out.length, IPAddress, port);\n\t\toutSock.send(sp);\n\t}\n```"
            },
            {
              "BodyText": "The response containing secret data has no integrity check associated with it, allowing an attacker to alter the message without detection."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to add integrity check value"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.03 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.04.02 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.11.06 RE(2)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 3.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 3.1"
        }
      ],
      "RelatedAttackPatterns": [
        "13",
        "14",
        "389",
        "39",
        "665",
        "74",
        "75"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 15: Not Updating Easily.\" Page 231",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "354",
      "Name": "Improper Validation of Integrity Check Value",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not validate or incorrectly validates the integrity check values or \"checksums\" of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.",
      "ExtendedDescription": "Improper validation of checksums before use results in an unnecessary risk that can easily be mitigated. The protocol specification describes the algorithm used for calculating the checksum. It is then a simple matter of implementing the calculation and verifying that the calculated checksum and the received checksum match. Improper verification of the calculated checksum and the received checksum can lead to far greater consequences.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "353",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Other"
          ],
          "Note": "Integrity checks usually use a secret key that helps authenticate the data origin. Skipping integrity checking generally opens up the possibility that new data from an invalid source can be injected."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Data that is parsed and used may be corrupted."
        },
        {
          "Scope": [
            "Non-Repudiation",
            "Other"
          ],
          "Impact": [
            "Hide Activities",
            "Other"
          ],
          "Note": "Without a checksum check, it is impossible to determine if any changes have been made to the data after it was sent."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that the checksums present in messages are properly checked in accordance with the protocol specification before they are parsed and used."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsd = socket(AF_INET, SOCK_DGRAM, 0); serv.sin_family = AF_INET;\n\tserv.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservr.sin_port = htons(1008);\n\tbind(sd, (struct sockaddr *) & serv, sizeof(serv));\n\twhile (1) {\n\t\t\tmemset(msg, 0x0, MAX_MSG);\n\t\t\tclilen = sizeof(cli);\n\t\t\tif (inet_ntoa(cli.sin_addr)==...) n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\twhile(true) {\n\t\tDatagramPacket packet = new DatagramPacket(data,data.length,IPAddress, port);\n\t\tsocket.send(sendPacket);\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 3.1"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to check integrity check value"
        }
      ],
      "RelatedAttackPatterns": [
        "145",
        "463",
        "75"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "356",
      "Name": "Product UI does not Warn User of Unsafe Actions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product's user interface does not warn the user before undertaking an unsafe action on behalf of that user. This makes it easier for attackers to trick users into inflicting damage to their system.",
      "ExtendedDescription": "Product systems should warn users that a potentially dangerous action may occur if the user proceeds. For example, if the user downloads a file from an unknown source and attempts to execute the file on their machine, then the application's GUI can indicate that the file is unsafe.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "221",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1055",
          "Description": "Product does not warn user when document contains certain dangerous functions or macros.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1055"
        },
        {
          "Reference": "CVE-1999-0794",
          "Description": "Product does not warn user when document contains certain dangerous functions or macros.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0794"
        },
        {
          "Reference": "CVE-2000-0277",
          "Description": "Product does not warn user when document contains certain dangerous functions or macros.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0277"
        },
        {
          "Reference": "CVE-2000-0517",
          "Description": "Product does not warn user about a certificate if it has already been accepted for a different site. Possibly resultant.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0517"
        },
        {
          "Reference": "CVE-2005-0602",
          "Description": "File extractor does not warn user if setuid/setgid files could be extracted. Overlaps privileges/permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0602"
        },
        {
          "Reference": "CVE-2000-0342",
          "Description": "E-mail client allows bypass of warning for dangerous attachments via a Windows .LNK file that refers to the attachment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0342"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Product UI does not warn user of unsafe actions"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Often resultant, e.g. in unhandled error conditions."
        },
        {
          "Type": "Relationship",
          "Note": "Can overlap privilege errors, conceptually at least."
        }
      ]
    },
    {
      "ID": "357",
      "Name": "Insufficient UI Warning of Dangerous Operations",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The user interface provides a warning to a user regarding dangerous or sensitive operations, but the warning is not noticeable enough to warrant attention.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-1099",
          "Description": "User not sufficiently warned if host key mismatch occurs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1099"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient UI warning of dangerous operations"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "358",
      "Name": "Improperly Implemented Security Check for Standard",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not implement or incorrectly implements one or more security-relevant checks as specified by the design of a standardized algorithm, protocol, or technique.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "345",
          "ViewID": "1000"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "290",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "\n\nThis is an implementation error, in which the algorithm/technique requires certain security-related behaviors or conditions that are not implemented or checked properly, thus causing a vulnerability.\n"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0862",
          "Description": "Browser does not verify Basic Constraints of a certificate, even though it is required, allowing spoofing of trusted certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0862"
        },
        {
          "Reference": "CVE-2002-0970",
          "Description": "Browser does not verify Basic Constraints of a certificate, even though it is required, allowing spoofing of trusted certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0970"
        },
        {
          "Reference": "CVE-2002-1407",
          "Description": "Browser does not verify Basic Constraints of a certificate, even though it is required, allowing spoofing of trusted certificates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1407"
        },
        {
          "Reference": "CVE-2005-0198",
          "Description": "Logic error prevents some required conditions from being enforced during Challenge-Response Authentication Mechanism with MD5 (CRAM-MD5).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0198"
        },
        {
          "Reference": "CVE-2004-2163",
          "Description": "Shared secret not verified in a RADIUS response packet, allowing authentication bypass by spoofing server replies.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2163"
        },
        {
          "Reference": "CVE-2005-2181",
          "Description": "Insufficient verification in VoIP implementation, in violation of standard, allows spoofed messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2181"
        },
        {
          "Reference": "CVE-2005-2182",
          "Description": "Insufficient verification in VoIP implementation, in violation of standard, allows spoofed messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2182"
        },
        {
          "Reference": "CVE-2005-2298",
          "Description": "Security check not applied to all components, allowing bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2298"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Improperly Implemented Security Check for Standard"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is a \"missing step\" error on the product side, which can overlap weaknesses such as insufficient verification and spoofing. It is frequently found in cryptographic and authentication errors. It is sometimes resultant."
        }
      ]
    },
    {
      "ID": "359",
      "Name": "Exposure of Private Personal Information to an Unauthorized Actor",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly prevent a person's private, personal information from being accessed by actors who either (1) are not explicitly authorized to access the information or (2) do not have the implicit consent of the person about whom the information is collected.",
      "ExtendedDescription": "\n\nThere are many types of sensitive information that products must protect from attackers, including system data, communications, configuration, business secrets, intellectual property, and an individual's personal (private) information. Private personal information may include a password, phone number, geographic location, personal messages, credit card number, etc. Private information is important to consider whether the person is a user of the product, or part of a data set that is processed by the product. An exposure of private information does not necessarily prevent the product from working properly, and in fact the exposure might be intended by the developer, e.g. as part of data sharing with other organizations. However, the exposure of personal private information can still be undesirable or explicitly prohibited by law or regulation.\n\n\nSome types of private information include:\n\n\n  - Government identifiers, such as Social Security Numbers\n\n  - Contact information, such as home addresses and telephone numbers\n\n  - Geographic location - where the user is (or was)\n\n  - Employment history\n\n  - Financial data - such as credit card numbers, salary, bank accounts, and debts\n\n  - Pictures, video, or audio\n\n  - Behavioral patterns - such as web surfing history, when certain activities are performed, etc.\n\n  - Relationships (and types of relationships) with others - family, friends, contacts, etc.\n\n  - Communications - e-mail addresses, private messages, text messages, chat logs, etc.\n\n  - Health - medical conditions, insurance status, prescription records\n\n  - Account passwords and other credentials\n\nSome of this information may be characterized as PII (Personally Identifiable Information), Protected Health Information (PHI), etc. Categories of private information may overlap or vary based on the intended usage or the policies and practices of a particular industry.\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "200",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Privacy violation"
        },
        {
          "Term": "Privacy leak"
        },
        {
          "Term": "Privacy leakage"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nPrivate personal data can enter a program in a variety of ways:\n\n\n  - Directly from the user in the form of a password or personal information\n\n  - Accessed from a database or other data store by the application\n\n  - Indirectly from a partner or other third party\n\nIf the data is written to an external location - such as the console, file system, or network - a privacy violation may occur.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "\n\nIdentify and consult all relevant regulations for personal privacy. An organization may be required to comply with certain federal and state regulations, depending on its location, the type of business it conducts, and the nature of any private data it handles. Regulations may include Safe Harbor Privacy Framework [REF-340], Gramm-Leach Bliley Act (GLBA) [REF-341], Health Insurance Portability and Accountability Act (HIPAA) [REF-342], General Data Protection Regulation (GDPR) [REF-1047], California Consumer Privacy Act (CCPA) [REF-1048], and others.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nCarefully evaluate how secure design may interfere with privacy, and vice versa. Security and privacy concerns often seem to compete with each other. From a security perspective, all important operations should be recorded so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tpass = GetPassword();\n\t...\n\tdbmsLog.WriteLine(id + \":\" + pass + \":\" + type + \":\" + tstamp);\n```"
            },
            {
              "BodyText": "The code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern."
            }
          ]
        },
        {
          "ID": "DX-111",
          "Entries": [
            {
              "IntroText": "This code uses location to determine the user's current US State location."
            },
            {
              "BodyText": "First the application must declare that it requires the ACCESS_FINE_LOCATION permission in the application's manifest.xml:"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n```"
            },
            {
              "BodyText": "During execution, a call to getLastLocation() will return a location based on the application's location permissions. In this case the application has permission for the most accurate location possible:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tlocationClient = new LocationClient(this, this, this);\n\tlocationClient.connect();\n\tLocation userCurrLocation;\n\tuserCurrLocation = locationClient.getLastLocation();\n\tderiveStateFromCoords(userCurrLocation);\n```"
            },
            {
              "BodyText": "While the application needs this information, it does not need to use the ACCESS_FINE_LOCATION permission, as the ACCESS_COARSE_LOCATION permission will be sufficient to identify which US state the user is in."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In 2004, an employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [REF-338]. In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Privacy Violation"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO13-J",
          "EntryName": "Do not log sensitive information outside a trust boundary"
        }
      ],
      "RelatedAttackPatterns": [
        "464",
        "467",
        "498",
        "508"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-338",
          "Authors": [
            "J. Oates"
          ],
          "Title": "AOL man pleads guilty to selling 92m email addies",
          "Publication": "The Register",
          "PublicationYear": "2005",
          "URL": "https://www.theregister.com/2005/02/07/aol_email_theft/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-339",
          "Authors": [
            "NIST"
          ],
          "Title": "Guide to Protecting the Confidentiality of Personally Identifiable Information (SP 800-122)",
          "PublicationYear": "2010",
          "PublicationMonth": "04",
          "URL": "https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-122.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-340",
          "Authors": [
            "U.S. Department of Commerce"
          ],
          "Title": "Safe Harbor Privacy Framework",
          "URL": "https://web.archive.org/web/20010223203241/http://www.export.gov/safeharbor/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-341",
          "Authors": [
            "Federal Trade Commission"
          ],
          "Title": "Financial Privacy: The Gramm-Leach Bliley Act (GLBA)",
          "URL": "https://www.ftc.gov/business-guidance/privacy-security/gramm-leach-bliley-act",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-342",
          "Authors": [
            "U.S. Department of Human Services"
          ],
          "Title": "Health Insurance Portability and Accountability Act (HIPAA)",
          "URL": "https://www.hhs.gov/hipaa/index.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-343",
          "Authors": [
            "Government of the State of California"
          ],
          "Title": "California SB-1386",
          "PublicationYear": "2002",
          "URL": "http://info.sen.ca.gov/pub/01-02/bill/sen/sb_1351-1400/sb_1386_bill_20020926_chaptered.html"
        },
        {
          "ExternalReferenceID": "REF-267",
          "Authors": [
            "Information Technology Laboratory, National Institute of Standards and Technology"
          ],
          "Title": "SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES",
          "PublicationYear": "2001",
          "PublicationMonth": "05",
          "PublicationDay": "25",
          "URL": "https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-172",
          "Authors": [
            "Chris Wysopal"
          ],
          "Title": "Mobile App Top 10 List",
          "PublicationYear": "2010",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://www.veracode.com/blog/2010/12/mobile-app-top-10-list",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1047",
          "Authors": [
            "Wikipedia"
          ],
          "Title": "General Data Protection Regulation",
          "URL": "https://en.wikipedia.org/wiki/General_Data_Protection_Regulation"
        },
        {
          "ExternalReferenceID": "REF-1048",
          "Authors": [
            "State of California Department of Justice, Office of the Attorney General"
          ],
          "Title": "California Consumer Privacy Act (CCPA)",
          "URL": "https://oag.ca.gov/privacy/ccpa"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry overlaps many other entries that are not organized around the kind of sensitive information that is exposed. However, because privacy is treated with such importance due to regulations and other factors, and it may be useful for weakness-finding tools to highlight capabilities that detect personal private information instead of system information, it is not clear whether - and how - this entry should be deprecated."
        }
      ]
    },
    {
      "ID": "360",
      "Name": "Trust of System Event Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Security based on event locations are insecure and can be spoofed.",
      "ExtendedDescription": "Events are a messaging system which may provide control data to programs listening for events. Events often do not have any type of authentication framework to allow them to be verified from a trusted source. Any application, in Windows, on a given desktop can send a message to any window on the same desktop. There is no authentication framework for these messages. Therefore, any message can be used to manipulate any process on the desktop if the process does not check the validity and safeness of those messages.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If one trusts the system-event information and executes commands based on it, one could potentially take actions based on a spoofed identity."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Never trust or rely any of the information in an Event for security."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This example code prints out secret information when an authorized user activates a button:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tif (e.getSource() == button) {\n\t\t\tSystem.out.println(\"print out secret information\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code does not attempt to prevent unauthorized users from activating the button. Even if the button is rendered non-functional to unauthorized users in the application UI, an attacker can easily send a false button press event to the application window and expose the secret information."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-0213",
          "Description": "Attacker uses Shatter attack to bypass GUI-enforced protection for CVE-2003-0908.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0213"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Trust of system event data"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP29",
          "EntryName": "Faulty endpoint authentication"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "362",
      "Name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
      "ExtendedDescription": "\n\nThis can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider.\n\n\nA race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.\n\n\nA race condition violates these properties, which are closely related:\n\n\n  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.\n\n  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.\n\nA race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single \"x++\" statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x).\n\nThe interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "416",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "476",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion (CWE-400)."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "DoS: Instability"
          ],
          "Note": "When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash."
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Files or Directories",
            "Read Application Data"
          ],
          "Note": "When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59)."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Black Box",
          "Description": "Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable."
        },
        {
          "Method": "White Box",
          "Description": "Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609)."
        },
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "\n\nThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n\n\nRace conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior.\n\n\nInsert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect.\n",
          "Effectiveness": "Moderate"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFramework-based Fuzzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use thread-safe capabilities such as the data access abstraction in Spring."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nMinimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.\n\n\nAdditionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When using multithreading and operating on shared variables, only use thread-safe functions."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use atomic operations on shared variables. Be wary of innocent-looking constructs such as \"x++\". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code could be used in an e-commerce application that supports transfers between accounts. It takes the total amount of the transfer, sends it to the new account, and deducts the amount from the original account."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$transfer_amount = GetTransferAmount();\n\t$balance = GetBalanceFromDatabase();\n\tif ($transfer_amount < 0) {\n\t\tFatalError(\"Bad Transfer Amount\");\n\t}\n\t$newbalance = $balance - $transfer_amount;\n\tif (($balance - $transfer_amount) < 0) {\n\t\tFatalError(\"Insufficient Funds\");\n\t}\n\tSendNewBalanceToDatabase($newbalance);\n\tNotifyUser(\"Transfer of $transfer_amount succeeded.\");\n\tNotifyUser(\"New balance: $newbalance\");\n```"
            },
            {
              "BodyText": "A race condition could occur between the calls to GetBalanceFromDatabase() and SendNewBalanceToDatabase()."
            },
            {
              "BodyText": "Suppose the balance is initially 100.00. An attack could be constructed as follows:"
            },
            {
              "Nature": "Attack",
              "Language": "Other",
              "ExampleCode": "```\n\tIn the following pseudocode, the attacker makes two simultaneous calls of the program, CALLER-1 and CALLER-2. Both callers are for the same user account.\n\tCALLER-1 (the attacker) is associated with PROGRAM-1 (the instance that handles CALLER-1). CALLER-2 is associated with PROGRAM-2.\n\tCALLER-1 makes a transfer request of 80.00.\n\tPROGRAM-1 calls GetBalanceFromDatabase and sets $balance to 100.00\n\tPROGRAM-1 calculates $newbalance as 20.00, then calls SendNewBalanceToDatabase().\n\tDue to high server load, the PROGRAM-1 call to SendNewBalanceToDatabase() encounters a delay.\n\tCALLER-2 makes a transfer request of 1.00.\n\tPROGRAM-2 calls GetBalanceFromDatabase() and sets $balance to 100.00. This happens because the previous PROGRAM-1 request was not processed yet.\n\tPROGRAM-2 determines the new balance as 99.00.\n\tAfter the initial delay, PROGRAM-1 commits its balance to the database, setting it to 20.00.\n\tPROGRAM-2 sends a request to update the database, setting the balance to 99.00\n```"
            },
            {
              "BodyText": "At this stage, the attacker should have a balance of 19.00 (due to 81.00 worth of transfers), but the balance is 99.00, as recorded in the database."
            },
            {
              "BodyText": "To prevent this weakness, the programmer has several options, including using a lock to prevent multiple simultaneous requests to the web application, or using a synchronization mechanism that includes all the code between GetBalanceFromDatabase() and SendNewBalanceToDatabase()."
            }
          ]
        },
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        },
        {
          "ID": "DX-132",
          "Entries": [
            {
              "IntroText": "Suppose a processor's Memory Management Unit (MMU) has 5 other shadow MMUs to distribute its workload for its various cores. Each MMU has the start address and end address of \"accessible\" memory. Any time this accessible range changes (as per the processor's boot status), the main MMU sends an update message to all the shadow MMUs."
            },
            {
              "BodyText": "Suppose the interconnect fabric does not prioritize such \"update\" packets over other general traffic packets. This introduces a race condition. If an attacker can flood the target with enough messages so that some of those attack packets reach the target before the new access ranges gets updated, then the attacker can leverage this scenario."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29527",
          "Description": "Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29527"
        },
        {
          "Reference": "CVE-2021-1782",
          "Description": "Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-1782"
        },
        {
          "Reference": "CVE-2021-0920",
          "Description": "Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-0920"
        },
        {
          "Reference": "CVE-2020-6819",
          "Description": "Chain: race condition (CWE-362) leads to use-after-free (CWE-416), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6819"
        },
        {
          "Reference": "CVE-2019-18827",
          "Description": "chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-18827"
        },
        {
          "Reference": "CVE-2019-1161",
          "Description": "Chain: race condition (CWE-362) in anti-malware product allows deletion of files by creating a junction (CWE-1386) and using hard links during the time window in which a temporary file is created and deleted.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1161"
        },
        {
          "Reference": "CVE-2015-1743",
          "Description": "TOCTOU in sandbox process allows installation of untrusted browser add-ons by replacing a file after it has been verified, but before it is executed",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-1743"
        },
        {
          "Reference": "CVE-2014-8273",
          "Description": "Chain: chipset has a race condition (CWE-362) between when an interrupt handler detects an attempt to write-enable the BIOS (in violation of the lock bit), and when the handler resets the write-enable bit back to 0, allowing attackers to issue BIOS writes during the timing window [REF-1237].",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-8273"
        },
        {
          "Reference": "CVE-2008-5044",
          "Description": "Race condition leading to a crash by calling a hook removal procedure while other activities are occurring at the same time.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5044"
        },
        {
          "Reference": "CVE-2008-2958",
          "Description": "chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2958"
        },
        {
          "Reference": "CVE-2008-1570",
          "Description": "chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1570"
        },
        {
          "Reference": "CVE-2008-0058",
          "Description": "Unsynchronized caching operation enables a race condition that causes messages to be sent to a deallocated object.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0058"
        },
        {
          "Reference": "CVE-2008-0379",
          "Description": "Race condition during initialization triggers a buffer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0379"
        },
        {
          "Reference": "CVE-2007-6599",
          "Description": "Daemon crash by quickly performing operations and undoing them, which eventually leads to an operation that does not acquire a lock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6599"
        },
        {
          "Reference": "CVE-2007-6180",
          "Description": "chain: race condition triggers NULL pointer dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6180"
        },
        {
          "Reference": "CVE-2007-5794",
          "Description": "Race condition in library function could cause data to be sent to the wrong process.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5794"
        },
        {
          "Reference": "CVE-2007-3970",
          "Description": "Race condition in file parser leads to heap corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3970"
        },
        {
          "Reference": "CVE-2008-5021",
          "Description": "chain: race condition allows attacker to access an object while it is still being initialized, causing software to access uninitialized memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5021"
        },
        {
          "Reference": "CVE-2009-4895",
          "Description": "chain: race condition for an argument value, possibly resulting in NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4895"
        },
        {
          "Reference": "CVE-2009-3547",
          "Description": "chain: race condition might allow resource to be released before operating on it, leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3547"
        },
        {
          "Reference": "CVE-2006-5051",
          "Description": "Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5051"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Race Conditions"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA03-J",
          "EntryName": "Do not assume that a group of calls to independently atomic methods is atomic"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-349",
          "Authors": [
            "Andrei Alexandrescu"
          ],
          "Title": "volatile - Multithreaded Programmer's Best Friend",
          "Publication": "Dr. Dobb's",
          "PublicationYear": "2008",
          "PublicationMonth": "02",
          "PublicationDay": "01",
          "URL": "https://drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-350",
          "Authors": [
            "Steven Devijver"
          ],
          "Title": "Thread-safe webapps using Spring",
          "URL": "https://web.archive.org/web/20170609174845/http://www.javalobby.org/articles/thread-safe/index.jsp",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-351",
          "Authors": [
            "David Wheeler"
          ],
          "Title": "Prevent race conditions",
          "PublicationYear": "2007",
          "PublicationMonth": "10",
          "PublicationDay": "04",
          "URL": "https://www.ida.liu.se/~TDDC90/literature/papers/SP-race-conditions.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-352",
          "Authors": [
            "Matt Bishop"
          ],
          "Title": "Race Conditions, Files, and Security Flaws; or the Tortoise and the Hare Redux",
          "PublicationYear": "1995",
          "PublicationMonth": "09",
          "URL": "https://seclab.cs.ucdavis.edu/projects/vulnerabilities/scriv/ucd-ecs-95-08.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-353",
          "Authors": [
            "David Wheeler"
          ],
          "Title": "Secure Programming for Linux and Unix HOWTO",
          "PublicationYear": "2003",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "URL": "https://dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-race.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-354",
          "Authors": [
            "Blake Watts"
          ],
          "Title": "Discovering and Exploiting Named Pipe Security Flaws for Fun and Profit",
          "PublicationYear": "2002",
          "PublicationMonth": "04",
          "URL": "https://www.blakewatts.com/blog/discovering-and-exploiting-named-pipe-security-flaws-for-fun-and-profit",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-355",
          "Authors": [
            "Roberto Paleari",
            "Davide Marrone",
            "Danilo Bruschi",
            "Mattia Monga"
          ],
          "Title": "On Race Vulnerabilities in Web Applications",
          "URL": "http://security.dico.unimi.it/~roberto/pubs/dimva08-web.pdf"
        },
        {
          "ExternalReferenceID": "REF-356",
          "Title": "Avoiding Race Conditions and Insecure File Operations",
          "Publication": "Apple Developer Connection",
          "URL": "https://web.archive.org/web/20081010155022/http://developer.apple.com/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-357",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "Top 25 Series - Rank 25 - Race Conditions",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "26",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://web.archive.org/web/20100530231203/http://blogs.sans.org:80/appsecstreetfighter/2010/03/26/top-25-series-rank-25-race-conditions/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1237",
          "Authors": [
            "CERT Coordination Center"
          ],
          "Title": "Intel BIOS locking mechanism contains race condition that enables write protection bypass",
          "PublicationYear": "2015",
          "PublicationMonth": "01",
          "PublicationDay": "05",
          "URL": "https://www.kb.cert.org/vuls/id/766164/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention."
        },
        {
          "Type": "Research Gap",
          "Note": "Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area."
        },
        {
          "Type": "Research Gap",
          "Note": "Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check."
        },
        {
          "Type": "Research Gap",
          "Note": "From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues."
        }
      ]
    },
    {
      "ID": "363",
      "Name": "Race Condition Enabling Link Following",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product checks the status of a file or directory before accessing it, which produces a race condition in which the file can be replaced with a link before the access is performed, causing the product to access the wrong file.",
      "ExtendedDescription": "While developers might expect that there is a very narrow time window between the time of check and time of use, there is still a race condition. An attacker could cause the product to slow down (e.g. with memory consumption), causing the time window to become larger. Alternately, in some situations, the attacker could win the race by performing a large number of attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "367",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "59",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Files or Directories",
            "Modify Files or Directories"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-49",
          "Entries": [
            {
              "IntroText": "This code prints the contents of a file if a user has permission."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction readFile($filename){\n\t\t\t$user = getCurrentUser();\n```\n//resolve file if its a symbolic link* \n\t\t\tif(is_link($filename)){\n\t\t\t```\n\t\t\t\t$filename = readlink($filename);\n\t\t\t}\n\t\t\tif(fileowner($filename) == $user){\n\t\t\t\techo file_get_contents($realFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'Access denied';\n\t\t\t\treturn false;\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code attempts to resolve symbolic links before checking the file and printing its contents. However, an attacker may be able to change the file from a real file to a symbolic link between the calls to is_link() and file_get_contents(), allowing the reading of arbitrary files. Note that this code fails to log the attempted access (CWE-778)."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Race condition enabling link following"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS35-C",
          "EntryName": "Avoid race conditions while checking for the existence of a symbolic link",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP20",
          "EntryName": "Race Condition Window"
        }
      ],
      "RelatedAttackPatterns": [
        "26"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Race Conditions\", Page 526",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is already covered by the \"Link Following\" weakness (CWE-59). It is included here because so many people associate race conditions with link problems; however, not all link following issues involve race conditions."
        }
      ]
    },
    {
      "ID": "364",
      "Name": "Signal Handler Race Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a signal handler that introduces a race condition.",
      "ExtendedDescription": "\n\nRace conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the product state to be corrupted, possibly leading to a denial of service or even code execution.\n\n\nThese issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the \"regular\" code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered.\n\n\nThere are several known behaviors related to signal handlers that have received the label of \"signal handler race condition\":\n\n\n  - Shared state (e.g. global data or static variables) that are accessible to both a signal handler and \"regular\" code\n\n  - Shared state between a signal handler and other signal handlers\n\n  - Use of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution.\n\n  - Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses.\n\n  - Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionality\n\n  - While not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses.\n\nSignal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code:\n\n  - Avoiding shared state\n\n  - Using synchronization in the signal handler\n\n  - Using synchronization in the regular code\n\n  - Disabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)\n\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "415",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "416",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "123",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "It may be possible to cause data corruption and possibly execute arbitrary code by modifying global variables or data structures at unexpected times, violating the assumptions of code that uses this global data."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If a signal handler interrupts code that is executing with privileges, it may be possible that the signal handler will also be executed with elevated privileges, possibly making subsequent exploits more severe."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Design signal handlers to only set flags, rather than perform complex functionality. These flags can then be checked and acted upon within the main program loop."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Only use reentrant functions within signal handlers. Also, use validation to ensure that state is consistent while performing asynchronous actions that affect the state of execution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-26",
          "Entries": [
            {
              "IntroText": "This code registers the same signal handler function with two different signals (CWE-831). If those signals are sent to the process, the handler creates a log message (specified in the first argument to the program) and exits."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *logMessage;\n\tvoid handler (int sigNum) {\n\t\t\tsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\n\t\t\tfree(logMessage);\n```\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc, char* argv[]) {\n\t```\n\t\t\tlogMessage = strdup(argv[1]);\n```\n/* Register signal handlers. */* \n\t\t\t\n\t\t\tsignal(SIGHUP, handler);\n\t\t\tsignal(SIGTERM, handler);\n\t\t\t\n\t\t\t */* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);}"
            },
            {
              "BodyText": "The handler function uses global state (globalVar and logMessage), and it can be called by both the SIGHUP and SIGTERM signals. An attack scenario might follow these lines:"
            },
            {
              "BodyText": "- The program begins execution, initializes logMessage, and registers the signal handlers for SIGHUP and SIGTERM.\n\n  - The program begins its \"normal\" functionality, which is simplified as sleep(), but could be any functionality that consumes some time.\n\n  - The attacker sends SIGHUP, which invokes handler (call this \"SIGHUP-handler\").\n\n  - SIGHUP-handler begins to execute, calling syslog().\n\n  - syslog() calls malloc(), which is non-reentrant. malloc() begins to modify metadata to manage the heap.\n\n  - The attacker then sends SIGTERM.\n\n  - SIGHUP-handler is interrupted, but syslog's malloc call is still executing and has not finished modifying its metadata.\n\n  - The SIGTERM handler is invoked.\n\n  - SIGTERM-handler records the log message using syslog(), then frees the logMessage variable."
            },
            {
              "BodyText": "At this point, the state of the heap is uncertain, because malloc is still modifying the metadata for the heap; the metadata might be in an inconsistent state. The SIGTERM-handler call to free() is assuming that the metadata is inconsistent, possibly causing it to write data to the wrong location while managing the heap. The result is memory corruption, which could lead to a crash or even code execution, depending on the circumstances under which the code is running."
            },
            {
              "BodyText": "Note that this is an adaptation of a classic example as originally presented by Michal Zalewski [REF-360]; the original example was shown to be exploitable for code execution."
            },
            {
              "BodyText": "Also note that the strdup(argv[1]) call contains a potential buffer over-read (CWE-126) if the program is called without any arguments, because argc would be 0, and argv[1] would point outside the bounds of the array."
            }
          ]
        },
        {
          "ID": "DX-48",
          "Entries": [
            {
              "IntroText": "The following code registers a signal handler with multiple signals in order to log when a specific event occurs and to free associated memory before exiting."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#include <signal.h>\n\t#include <syslog.h>\n\t#include <string.h>\n\t#include <stdlib.h>\n\tvoid *global1, *global2;\n\tchar *what;\n\tvoid sh (int dummy) {\n\t\t\tsyslog(LOG_NOTICE,\"%s\\n\",what);\n\t\t\tfree(global2);\n\t\t\tfree(global1);\n```\n/* Sleep statements added to expand timing window for race condition */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc,char* argv[]) {\n\t```\n\t\t\twhat=argv[1];\n\t\t\tglobal1=strdup(argv[2]);\n\t\t\tglobal2=malloc(340);\n\t\t\tsignal(SIGHUP,sh);\n\t\t\tsignal(SIGTERM,sh);\n```\n/* Sleep statements added to expand timing window for race condition */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}"
            },
            {
              "BodyText": "However, the following sequence of events may result in a double-free (CWE-415):"
            },
            {
              "BodyText": "1. a SIGHUP is delivered to the process\n\n  1. sh() is invoked to process the SIGHUP\n\n  1. This first invocation of sh() reaches the point where global1 is freed\n\n  1. At this point, a SIGTERM is sent to the process\n\n  1. the second invocation of sh() might do another free of global1\n\n  1. this results in a double-free (CWE-415)"
            },
            {
              "BodyText": "This is just one possible exploitation of the above code. As another example, the syslog call may use malloc calls which are not async-signal safe. This could cause corruption of the heap management structures. For more details, consult the example within \"Delivering Signals for Fun and Profit\" [REF-360]."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-0035",
          "Description": "Signal handler does not disable other signal handlers, allowing it to be interrupted, causing other functionality to access files/etc. with raised privileges",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0035"
        },
        {
          "Reference": "CVE-2001-0905",
          "Description": "Attacker can send a signal while another signal handler is already running, leading to crash or execution with root privileges",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0905"
        },
        {
          "Reference": "CVE-2001-1349",
          "Description": "unsafe calls to library functions from signal handler",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1349"
        },
        {
          "Reference": "CVE-2004-0794",
          "Description": "SIGURG can be used to remotely interrupt signal handler; other variants exist",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0794"
        },
        {
          "Reference": "CVE-2004-2259",
          "Description": "SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2259"
        }
      ],
      "FunctionalAreas": [
        "Signals",
        "Interprocess Communication"
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Signal handler race condition"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Signal Handling Race Conditions"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Race condition in signal handler"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-360",
          "Authors": [
            "Michal Zalewski"
          ],
          "Title": "Delivering Signals for Fun and Profit",
          "URL": "https://lcamtuf.coredump.cx/signals.txt",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-361",
          "Title": "Race Condition: Signal Handling",
          "URL": "https://vulncat.fortify.com/en/detail?id=desc.structural.cpp.race_condition_signal_handling#:~:text=Signal%20handling%20race%20conditions%20can,installed%20to%20handle%20multiple%20signals.s",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 13, \"Signal Vulnerabilities\", Page 791",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "365",
      "Name": "DEPRECATED: Race Condition in Switch",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated. There are no documented cases in which a switch's control expression is evaluated more than once.",
      "ExtendedDescription": "It is likely that this entry was initially created based on a misinterpretation of the original source material. The original source intended to explain how switches could be unpredictable when using threads, if the control expressions used data or variables that could change between execution of different threads. That weakness is already covered by CWE-367. Despite the ambiguity in the documentation for some languages and compilers, in practice, they all evaluate the switch control expression only once. If future languages state that the code explicitly evaluates the control expression more than once, then this would not be a weakness, but the language performing as designed.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "366",
      "Name": "Race Condition within a Thread",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Unexpected State"
          ],
          "Note": "The main problem is that -- if a lock is overcome -- data could be altered in a bad state."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use locking functionality. This is the recommended solution. Implement some form of locking mechanism around code which alters or reads persistent data in a multithreaded environment."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Create resource-locking validation checks. If no inherent locking mechanisms exist, use flags and signals to enforce your own blocking scheme when resources are being used by other threads of execution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint foo = 0;\n\tint storenum(int num) {\n\t\tstatic int counter = 0;\n\t\tcounter++;\n\t\tif (num > foo) foo = num;\n\t\treturn foo;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic classRace {\n\t\t\tstatic int foo = 0;\n\t\t\tpublic static void main() {\n\t\t\t\t\tnew Threader().start();\n\t\t\t\t\tfoo = 1;\n\t\t\t}\n\t\t\tpublic static class Threader extends Thread {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tSystem.out.println(foo);\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-2621",
          "Description": "Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2621"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Race condition within a thread"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON32-C",
          "EntryName": "Prevent data races when accessing bit-fields from multiple threads",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON40-C",
          "EntryName": "Do not refer to an atomic variable twice in an expression",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON43-C",
          "EntryName": "Do not allow data races in multithreaded code",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA02-J",
          "EntryName": "Ensure that compound operations on shared variables are atomic"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA03-J",
          "EntryName": "Do not assume that a group of calls to independently atomic methods is atomic"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 13, \"Race Conditions\", Page 759",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "367",
      "Name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.",
      "ExtendedDescription": "This weakness can be security-relevant when an attacker can influence the state of the resource between check and use. This can happen with shared resources such as files, memory, or even variables in multithreaded programs.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "TOCTTOU",
          "Description": "The TOCTTOU acronym expands to \"Time Of Check To Time Of Use\"."
        },
        {
          "Term": "TOCCTOU",
          "Description": "The TOCCTOU acronym is most likely a typo of TOCTTOU, but it has been used in some influential documents, so the typo is repeated fairly frequently."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Unexpected State"
          ],
          "Note": "The attacker can gain access to otherwise unauthorized resources."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories",
            "Modify Memory",
            "Other"
          ],
          "Note": "Race conditions such as this kind may be employed to gain read or write access to resources which are not normally readable or writable by the user in question."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "The resource in question, or other resources (through the corrupted one), may be changed in undesirable ways by a malicious user."
        },
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "If a file or other resource is written in this method, as opposed to in a valid way, logging of the activity may not occur."
        },
        {
          "Scope": [
            "Non-Repudiation",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "In some cases it may be possible to delete files a malicious user might not otherwise have access to, such as log files."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "The most basic advice for TOCTOU vulnerabilities is to not perform a check before the use. This does not resolve the underlying issue of the execution of a function on a resource whose state and identity cannot be assured, but it does help to limit the false sense of security given by the check."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When the file being altered is owned by the current user and group, set the effective gid and uid to that of the current user and group when executing this statement."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Limit the interleaving of operations on files from multiple processes."
        },
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "If you cannot perform operations atomically and you must share access to the resource between multiple processes or threads, then try to limit the amount of time (CPU cycles) between the check and use of the resource. This will not fix the problem, but it could make it more difficult for an attack to succeed."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Recheck the resource after the use call to verify that the action was taken appropriately."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that some environmental locking mechanism can be used to protect resources effectively."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that locking occurs before the check, as opposed to afterwards, such that the resource, as checked, is the same as it is when in use."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code checks a file, then updates its contents."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct stat *sb;\n\t...\n\tlstat(\"...\",sb); // it has not been updated since the last time it was read\n\tprintf(\"stated file\\n\");\n\tif (sb->st_mtimespec==...){\n\t\tprint(\"Now updating things\\n\");\n\t\tupdateThings();\n\t}\n```"
            },
            {
              "BodyText": "Potentially the file could have been updated between the time of the check and the lstat, especially since the printf has latency."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code is from a program installed setuid root. The program performs certain file operations on behalf of non-privileged users, and uses access checks to ensure that it does not use its root privileges to perform operations that should otherwise be unavailable the current user. The program uses the access() system call to check if the person running the program has permission to access the specified file before it opens the file and performs the necessary operations."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif(!access(file,W_OK)) {\n\t\tf = fopen(file,\"w+\");\n\t\toperate(f);\n\t\t...\n\t}\n\telse {\n\t\t\tfprintf(stderr,\"Unable to open file %s.\\n\",file);\n\t}\n```"
            },
            {
              "BodyText": "The call to access() behaves as expected, and returns 0 if the user running the program has the necessary permissions to write to the file, and -1 otherwise. However, because both access() and fopen() operate on filenames rather than on file handles, there is no guarantee that the file variable still refers to the same file on disk when it is passed to fopen() that it did when it was passed to access(). If an attacker replaces file after the call to access() with a symbolic link to a different file, the program will use its root privileges to operate on the file even if it is a file that the attacker would otherwise be unable to modify. By tricking the program into performing an operation that would otherwise be impermissible, the attacker has gained elevated privileges. This type of vulnerability is not limited to programs with root privileges. If the application is capable of performing any operation that the attacker would not otherwise be allowed perform, then it is a possible target."
            }
          ]
        },
        {
          "ID": "DX-49",
          "Entries": [
            {
              "IntroText": "This code prints the contents of a file if a user has permission."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction readFile($filename){\n\t\t\t$user = getCurrentUser();\n```\n//resolve file if its a symbolic link* \n\t\t\tif(is_link($filename)){\n\t\t\t```\n\t\t\t\t$filename = readlink($filename);\n\t\t\t}\n\t\t\tif(fileowner($filename) == $user){\n\t\t\t\techo file_get_contents($realFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'Access denied';\n\t\t\t\treturn false;\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code attempts to resolve symbolic links before checking the file and printing its contents. However, an attacker may be able to change the file from a real file to a symbolic link between the calls to is_link() and file_get_contents(), allowing the reading of arbitrary files. Note that this code fails to log the attempted access (CWE-778)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This example is adapted from [REF-18]. Assume that this code block is invoked from multiple threads. The switch statement will execute different code depending on the time when MYFILE.txt was last changed."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t #include <sys/types.h>\n\t #include <sys/stat.h>\n\t ...\n\t struct stat sb;\n\t stat(\"MYFILE.txt\",&sb);\n\t printf(\"file change time: %d\\n\",sb->st_ctime);\n\t switch(sb->st_ctime % 2){\n\t\t case 0: printf(\"Option 1\\n\"); break;\n\t\t case 1: printf(\"Option 2\\n\"); break;\n\t\t default: printf(\"this should be unreachable?\\n\"); break;\n\t}\n```"
            },
            {
              "BodyText": "If this code block were executed within multiple threads, and MYFILE.txt changed between the operation of one thread and another, then the switch could produce different, possibly unexpected results."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2015-1743",
          "Description": "TOCTOU in sandbox process allows installation of untrusted browser add-ons by replacing a file after it has been verified, but before it is executed",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-1743"
        },
        {
          "Reference": "CVE-2003-0813",
          "Description": "A multi-threaded race condition allows remote attackers to cause a denial of service (crash or reboot) by causing two threads to process the same RPC request, which causes one thread to use memory after it has been freed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0813"
        },
        {
          "Reference": "CVE-2004-0594",
          "Description": "PHP flaw allows remote attackers to execute arbitrary code by aborting execution before the initialization of key data structures is complete.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0594"
        },
        {
          "Reference": "CVE-2008-2958",
          "Description": "chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2958"
        },
        {
          "Reference": "CVE-2008-1570",
          "Description": "chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1570"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Time-of-check Time-of-use race condition"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "File Access Race Conditions: TOCTOU"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Time of check, time of use race condition"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Race condition in switch"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO01-C",
          "EntryName": "Be careful using functions that use file names for identification"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP20",
          "EntryName": "Race Condition Window"
        }
      ],
      "RelatedAttackPatterns": [
        "27",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Section": "5.4.6 Race condition in switch",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-367",
          "Authors": [
            "Dan Tsafrir",
            "Tomer Hertz",
            "David Wagner",
            "Dilma Da Silva"
          ],
          "Title": "Portably Solving File TOCTTOU Races with Hardness Amplification",
          "PublicationYear": "2008",
          "PublicationMonth": "02",
          "PublicationDay": "28",
          "URL": "https://www.usenix.org/legacy/events/fast08/tech/tsafrir.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"TOCTOU\", Page 527",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "TOCTOU issues do not always involve symlinks, and not every symlink issue is a TOCTOU problem."
        },
        {
          "Type": "Research Gap",
          "Note": "Non-symlink TOCTOU issues are not reported frequently, but they are likely to occur in code that attempts to be secure."
        }
      ]
    },
    {
      "ID": "368",
      "Name": "Context Switching Race Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A product performs a series of non-atomic actions to switch between contexts that cross privilege or other security boundaries, but a race condition allows an attacker to modify or misrepresent the product's behavior during the switch.",
      "ExtendedDescription": "This is commonly seen in web browser vulnerabilities in which the attacker can perform certain actions while the browser is transitioning from a trusted to an untrusted domain, or vice versa, and the browser performs the actions on one domain using the trust level and resources of the other domain.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "364",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This weakness can be primary to almost anything, depending on the context of the race condition."
        },
        {
          "Ordinality": "Resultant",
          "Description": "This weakness can be resultant from insufficient compartmentalization (CWE-653), incorrect locking, improper initialization or shutdown, or a number of other weaknesses."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-1837",
          "Description": "Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1837"
        },
        {
          "Reference": "CVE-2004-2260",
          "Description": "Browser updates address bar as soon as user clicks on a link instead of when the page has loaded, allowing spoofing by redirecting to another page using onUnload method. ** this is one example of the role of \"hooks\" and context switches, and should be captured somehow - also a race condition of sorts **",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2260"
        },
        {
          "Reference": "CVE-2004-0191",
          "Description": "XSS when web browser executes Javascript events in the context of a new page while it's being loaded, allowing interaction with previous page in different domain.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0191"
        },
        {
          "Reference": "CVE-2004-2491",
          "Description": "Web browser fills in address bar of clicked-on link before page has been loaded, and doesn't update afterward.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2491"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Context Switching Race Condition"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Can overlap signal handler race conditions."
        },
        {
          "Type": "Research Gap",
          "Note": "Under-studied as a concept. Frequency unknown; few vulnerability reports give enough detail to know when a context switching race condition is a factor."
        }
      ]
    },
    {
      "ID": "369",
      "Name": "Divide By Zero",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product divides a value by zero.",
      "ExtendedDescription": "This weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "682",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "A Divide by Zero results in a crash."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following Java example contains a function to compute an average but does not validate that the input value used as the denominator is not zero. This will create an exception for attempting to divide by zero. If this error is not handled by Java exception handling, unexpected results can occur."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic int computeAverageResponseTime (int totalTime, int numRequests) {\n\t\treturn totalTime / numRequests;\n\t}\n```"
            },
            {
              "BodyText": "By validating the input value used as the denominator the following code will ensure that a divide by zero error will not cause unexpected results. The following Java code example will validate the input value, output an error message, and throw an exception."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tpublic int computeAverageResponseTime (int totalTime, int numRequests) throws ArithmeticException {\n\t\tif (numRequests == 0) {\n\t\t\tSystem.out.println(\"Division by zero attempted!\");\n\t\t\tthrow ArithmeticException;\n\t\t}\n\t\treturn totalTime / numRequests;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following C/C++ example contains a function that divides two numeric values without verifying that the input value used as the denominator is not zero. This will create an error for attempting to divide by zero, if this error is not caught by the error handling capabilities of the language, unexpected results can occur."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tdouble divide(double x, double y){\n\t\treturn x/y;\n\t}\n```"
            },
            {
              "BodyText": "By validating the input value used as the denominator the following code will ensure that a divide by zero error will not cause unexpected results. If the method is called and a zero is passed as the second argument a DivideByZero error will be thrown and should be caught by the calling block with an output message indicating the error."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tconst int DivideByZero = 10;\n\tdouble divide(double x, double y){\n\t\tif ( 0 == y ){\n\t\t\tthrow DivideByZero;\n\t\t}\n\t\treturn x/y;\n\t}\n\t...\n\ttry{\n\t\tdivide(10, 0);\n\t}\n\tcatch( int i ){\n\t\tif(i==DivideByZero) {\n\t\t\tcerr<<\"Divide by zero error\";\n\t\t}\n\t}\n```"
            },
            {
              "Reference": "REF-371"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following C# example contains a function that divides two numeric values without verifying that the input value used as the denominator is not zero. This will create an error for attempting to divide by zero, if this error is not caught by the error handling capabilities of the language, unexpected results can occur."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tint Division(int x, int y){\n\t\treturn (x / y);\n\t}\n```"
            },
            {
              "BodyText": "The method can be modified to raise, catch and handle the DivideByZeroException if the input value used as the denominator is zero."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tint SafeDivision(int x, int y){\n\t\ttry{\n\t\t\treturn (x / y);\n\t\t}\n\t\tcatch (System.DivideByZeroException dbz){\n\t\t\tSystem.Console.WriteLine(\"Division by zero attempted!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n```"
            },
            {
              "Reference": "REF-372"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-3268",
          "Description": "Invalid size value leads to divide by zero.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3268"
        },
        {
          "Reference": "CVE-2007-2723",
          "Description": "\"Empty\" content triggers divide by zero.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2723"
        },
        {
          "Reference": "CVE-2007-2237",
          "Description": "Height value of 0 triggers divide by zero.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2237"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FLP03-C",
          "EntryName": "Detect and handle floating point errors"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT33-C",
          "EntryName": "Ensure that division and remainder operations do not result in divide-by-zero errors",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "NUM02-J",
          "EntryName": "Ensure that division and modulo operations do not result in divide-by-zero errors"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-371",
          "Authors": [
            "Alex Allain"
          ],
          "Title": "Handling Errors Exceptionally Well in C++",
          "URL": "https://www.cprogramming.com/tutorial/exceptions.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-372",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Exceptions and Exception Handling (C# Programming Guide)",
          "URL": "https://msdn.microsoft.com/pl-pl/library/ms173160(v=vs.100).aspx"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "370",
      "Name": "Missing Check for Certificate Revocation after Initial Check",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not check the revocation status of a certificate after its initial revocation check, which can cause the product to perform privileged actions even after the certificate is revoked at a later time.",
      "ExtendedDescription": "If the revocation status of a certificate is not checked before each action that requires privileges, the system may be subject to a race condition. If a certificate is revoked after the initial check, all subsequent actions taken with the owner of the revoked certificate will lose all benefits guaranteed by the certificate. In fact, it is almost certain that the use of a revoked certificate indicates malicious activity.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "299",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "296",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "297",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "298",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Trust may be assigned to an entity who is not who it claims to be."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "Data from an untrusted (and possibly malicious) source may be integrated."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Data may be disclosed to an entity impersonating a trusted entity, resulting in information disclosure."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that certificates are checked for revoked status before each use of a protected resource. If the certificate is checked before each access of a protected resource, the delay subject to a possible race condition becomes almost negligible and significantly reduces the risk associated with this issue."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code checks a certificate before performing an action."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (cert = SSL_get_peer_certificate(ssl)) {\n\t\t\tfoo=SSL_get_verify_result(ssl);\n\t\t\tif (X509_V_OK==foo)\n```\n//do stuff* \n\t\t\t\t\tfoo=SSL_get_verify_result(ssl);\n\t\t\t\t\t\n\t\t\t\t\t *//do more stuff without the check.*"
            },
            {
              "BodyText": "While the code performs the certificate verification before each action, it does not check the result of the verification after the initial attempt. The certificate may have been revoked in the time between the privileged actions."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Race condition in checking for certificate revocation"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP20",
          "EntryName": "Race Condition Window"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "29"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "372",
      "Name": "Incomplete Internal State Distinction",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly determine which state it is in, causing it to assume it is in state X when in fact it is in state Y, causing it to perform incorrect operations in a security-relevant manner.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Incomplete Internal State Distinction"
        }
      ],
      "RelatedAttackPatterns": [
        "140",
        "74"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry could be deprecated in a future version of CWE.",
        "Comments": "See maintenance notes.",
        "Reasons": [
          "Potential Deprecation",
          "CWE Overlap"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This conceptually overlaps other categories such as insufficient verification, but this entry refers to the product's incorrect perception of its own state."
        },
        {
          "Type": "Relationship",
          "Note": "This is probably resultant from other weaknesses such as unhandled error conditions, inability to handle out-of-order steps, multiple interpretation errors, etc."
        },
        {
          "Type": "Maintenance",
          "Note": "This entry is being considered for deprecation. It was poorly-defined in PLOVER and is not easily described using the behavior/resource/property model of vulnerability theory."
        }
      ]
    },
    {
      "ID": "373",
      "Name": "DEPRECATED: State Synchronization Error",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry was deprecated because it overlapped the same concepts as race condition (CWE-362) and Improper Synchronization (CWE-662).",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "374",
      "Name": "Passing Mutable Objects to an Untrusted Method",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product sends non-cloned mutable data as an argument to a method or function.",
      "ExtendedDescription": "The function or method that has been called can alter or delete the mutable data. This could violate assumptions that the calling function has made about its state. In situations where unknown code is called with references to mutable data, this external code could make changes to the data sent. If this data was not previously cloned, the modified data might not be valid in the context of execution.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory"
          ],
          "Note": "Potentially data could be tampered with by another function which should not have been tampered with."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Pass in data which should not be altered as constant or immutable."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Clone all mutable data before passing it into an external function . This is the preferred mitigation. This way, regardless of what changes are made to the data, a valid copy is retained for use by the class."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tprivate:\n\t\tint foo;\n\t\tcomplexType bar;\n\t\tString baz;\n\t\totherClass externalClass;\n\tpublic:\n\t\tvoid doStuff() {\n\t\t\texternalClass.doOtherStuff(foo, bar, baz)\n\t\t}\n```"
            },
            {
              "BodyText": "In this example, bar and baz will be passed by reference to doOtherStuff() which may change them."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example, the BookStore class manages the sale of books in a bookstore, this class includes the member objects for the bookstore inventory and sales database manager classes. The BookStore class includes a method for updating the sales database and inventory when a book is sold. This method retrieves a Book object from the bookstore inventory object using the supplied ISBN number for the book class, then calls a method for the sales object to update the sales information and then calls a method for the inventory object to update inventory for the BookStore."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BookStore {\n\t\t\tprivate BookStoreInventory inventory;\n\t\t\tprivate SalesDBManager sales;\n\t\t\t...\n```\n// constructor for BookStore* \n\t\t\tpublic BookStore() {\n\t\t\t```\n\t\t\t\tthis.inventory = new BookStoreInventory();\n\t\t\t\tthis.sales = new SalesDBManager();\n\t\t\t\t...\n\t\t\t}\n\t\t\tpublic void updateSalesAndInventoryForBookSold(String bookISBN) {\n```\n// Get book object from inventory using ISBN* \n\t\t\t\t\tBook book = inventory.getBookWithISBN(bookISBN);\n\t\t\t\t\t\n\t\t\t\t\t *// update sales information for book sold* \n\t\t\t\t\tsales.updateSalesInformation(book);\n\t\t\t\t\t\n\t\t\t\t\t *// update inventory* \n\t\t\t\t\tinventory.updateInventory(book);}\n\t\t\t\n\t\t\t *// other BookStore methods* \n\t\t\t...}\n\tpublic class Book {\n\t```\n\t\tprivate String title;\n\t\tprivate String author;\n\t\tprivate String isbn;\n```\n// Book object constructors and get/set methods* \n\t\t...}"
            },
            {
              "BodyText": "However, in this example the Book object that is retrieved and passed to the method of the sales object could have its contents modified by the method. This could cause unexpected results when the book object is sent to the method for the inventory object to update the inventory."
            },
            {
              "BodyText": "In the Java programming language arguments to methods are passed by value, however in the case of objects a reference to the object is passed by value to the method. When an object reference is passed as a method argument a copy of the object reference is made within the method and therefore both references point to the same object. This allows the contents of the object to be modified by the method that holds the copy of the object reference. [REF-374]"
            },
            {
              "BodyText": "In this case the contents of the Book object could be modified by the method of the sales object prior to the call to update the inventory."
            },
            {
              "BodyText": "To prevent the contents of the Book object from being modified, a copy of the Book object should be made before the method call to the sales object. In the following example a copy of the Book object is made using the clone() method and the copy of the Book object is passed to the method of the sales object. This will prevent any changes being made to the original Book object."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tpublic void updateSalesAndInventoryForBookSold(String bookISBN) {\n```\n// Get book object from inventory using ISBN* \n\t\t\tBook book = inventory.getBookWithISBN(bookISBN);\n\t\t\t\n\t\t\t *// Create copy of book object to make sure contents are not changed* \n\t\t\tBook bookSold = (Book) book.clone();\n\t\t\t\n\t\t\t *// update sales information for book sold* \n\t\t\tsales.updateSalesInformation(bookSold);\n\t\t\t\n\t\t\t *// update inventory* \n\t\t\tinventory.updateInventory(book);}\n\t..."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Passing mutable objects to an untrusted method"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ04-J",
          "EntryName": "Provide mutable classes with copy functionality to safely allow passing instances to untrusted code"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-374",
          "Authors": [
            "Tony Sintes"
          ],
          "Title": "Does Java pass by reference or pass by value?",
          "Publication": "JavaWorld.com",
          "PublicationYear": "2000",
          "PublicationMonth": "05",
          "PublicationDay": "26",
          "URL": "https://web.archive.org/web/20000619025001/https://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-375",
          "Authors": [
            "Herbert Schildt"
          ],
          "Title": "Java: The Complete Reference, J2SE 5th Edition"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "375",
      "Name": "Returning a Mutable Object to an Untrusted Caller",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Sending non-cloned mutable data as a return value may result in that data being altered or deleted by the calling function.",
      "ExtendedDescription": "In situations where functions return references to mutable data, it is possible that the external code which called the function may make changes to the data sent. If this data was not previously cloned, the class will then be using modified data which may violate assumptions about its internal state.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Integrity"
          ],
          "Impact": [
            "Modify Memory"
          ],
          "Note": "Potentially data could be tampered with by another function which should not have been tampered with."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Declare returned data which should not be altered as constant or immutable."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Clone all mutable data before returning references to it. This is the preferred mitigation. This way, regardless of what changes are made to the data, a valid copy is retained for use by the class."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This class has a private list of patients, but provides a way to see the list :"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class ClinicalTrial {\n\t\tprivate PatientClass[] patientList = new PatientClass[50];\n\t\tpublic getPatients(...){\n\t\t\treturn patientList;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "While this code only means to allow reading of the patient list, the getPatients() method returns a reference to the class's original patient list instead of a reference to a copy of the list. Any caller of this method can arbitrarily modify the contents of the patient list even though it is a private member of the class."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Mutable object returned"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ04-J",
          "EntryName": "Provide mutable classes with copy functionality to safely allow passing instances to untrusted code"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ05-J",
          "EntryName": "Defensively copy private mutable class members before returning their references"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP34-PL",
          "EntryName": "Do not modify $_ in list or sorting functions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "377",
      "Name": "Insecure Temporary File",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Creating and using insecure temporary files can leave application and system data vulnerable to attack.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Files or Directories",
            "Modify Files or Directories"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code uses a temporary file for storing intermediate data gathered from the network before it is processed."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (tmpnam_r(filename)) {\n\t\t\tFILE* tmp = fopen(filename,\"wb+\");\n\t\t\twhile((recv(sock,recvbuf,DATA_SIZE, 0) > 0)&(amt!=0)) amt = fwrite(recvbuf,1,DATA_SIZE,tmp);\n\t}\n\t...\n```"
            },
            {
              "BodyText": "This otherwise unremarkable code is vulnerable to a number of different attacks because it relies on an insecure method for creating temporary files. The vulnerabilities introduced by this function and others are described in the following sections. The most egregious security problems related to temporary file creation have occurred on Unix-based operating systems, but Windows applications have parallel risks. This section includes a discussion of temporary file creation on both Unix and Windows systems. Methods and behaviors can vary between systems, but the fundamental risks introduced by each are reasonably constant."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-41954",
          "Description": "A library uses the Java File.createTempFile() method which creates a file with \"-rw-r--r--\" default permissions on Unix-like operating systems",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-41954"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Insecure Temporary File"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "CON33-C",
          "EntryName": "Avoid race conditions when using library functions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO00-J",
          "EntryName": "Do not operate on files in shared directories"
        }
      ],
      "RelatedAttackPatterns": [
        "149",
        "155"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 23, \"Creating Temporary Files Securely\" Page 682",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Temporary Files\", Page 538",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 11, \"File Squatting\", Page 662",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "\n\nApplications require temporary files so frequently that many different mechanisms exist for creating them in the C Library and Windows(R) API. Most of these functions are vulnerable to various forms of attacks.\n\n\nThe functions designed to aid in the creation of temporary files can be broken into two groups based whether they simply provide a filename or actually open a new file. - Group 1: \"Unique\" Filenames: The first group of C Library and WinAPI functions designed to help with the process of creating temporary files do so by generating a unique file name for a new temporary file, which the program is then supposed to open. This group includes C Library functions like tmpnam(), tempnam(), mktemp() and their C++ equivalents prefaced with an _ (underscore) as well as the GetTempFileName() function from the Windows API. This group of functions suffers from an underlying race condition on the filename chosen. Although the functions guarantee that the filename is unique at the time it is selected, there is no mechanism to prevent another process or an attacker from creating a file with the same name after it is selected but before the application attempts to open the file. Beyond the risk of a legitimate collision caused by another call to the same function, there is a high probability that an attacker will be able to create a malicious collision because the filenames generated by these functions are not sufficiently randomized to make them difficult to guess. If a file with the selected name is created, then depending on how the file is opened the existing contents or access permissions of the file may remain intact. If the existing contents of the file are malicious in nature, an attacker may be able to inject dangerous data into the application when it reads data back from the temporary file. If an attacker pre-creates the file with relaxed access permissions, then data stored in the temporary file by the application may be accessed, modified or corrupted by an attacker. On Unix based systems an even more insidious attack is possible if the attacker pre-creates the file as a link to another important file. Then, if the application truncates or writes data to the file, it may unwittingly perform damaging operations for the attacker. This is an especially serious threat if the program operates with elevated permissions. Finally, in the best case the file will be opened with the a call to open() using the O_CREAT and O_EXCL flags or to CreateFile() using the CREATE_NEW attribute, which will fail if the file already exists and therefore prevent the types of attacks described above. However, if an attacker is able to accurately predict a sequence of temporary file names, then the application may be prevented from opening necessary temporary storage causing a denial of service (DoS) attack. This type of attack would not be difficult to mount given the small amount of randomness used in the selection of the filenames generated by these functions. - Group 2: \"Unique\" Files: The second group of C Library functions attempts to resolve some of the security problems related to temporary files by not only generating a unique file name, but also opening the file. This group includes C Library functions like tmpfile() and its C++ equivalents prefaced with an _ (underscore), as well as the slightly better-behaved C Library function mkstemp(). The tmpfile() style functions construct a unique filename and open it in the same way that fopen() would if passed the flags \"wb+\", that is, as a binary file in read/write mode. If the file already exists, tmpfile() will truncate it to size zero, possibly in an attempt to assuage the security concerns mentioned earlier regarding the race condition that exists between the selection of a supposedly unique filename and the subsequent opening of the selected file. However, this behavior clearly does not solve the function's security problems. First, an attacker can pre-create the file with relaxed access-permissions that will likely be retained by the file opened by tmpfile(). Furthermore, on Unix based systems if the attacker pre-creates the file as a link to another important file, the application may use its possibly elevated permissions to truncate that file, thereby doing damage on behalf of the attacker. Finally, if tmpfile() does create a new file, the access permissions applied to that file will vary from one operating system to another, which can leave application data vulnerable even if an attacker is unable to predict the filename to be used in advance. Finally, mkstemp() is a reasonably safe way create temporary files. It will attempt to create and open a unique file based on a filename template provided by the user combined with a series of randomly generated characters. If it is unable to create such a file, it will fail and return -1. On modern systems the file is opened using mode 0600, which means the file will be secure from tampering unless the user explicitly changes its access permissions. However, mkstemp() still suffers from the use of predictable file names and can leave an application vulnerable to denial of service attacks if an attacker causes mkstemp() to fail by predicting and pre-creating the filenames to be used.\n"
        }
      ]
    },
    {
      "ID": "378",
      "Name": "Creation of Temporary File With Insecure Permissions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "377",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "If the temporary file can be read by the attacker, sensitive information may be in that file which could be revealed."
        },
        {
          "Scope": [
            "Authorization",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "If that file can be written to by the attacker, the file might be moved into a place to which the attacker does not have access. This will allow the attacker to gain selective resource access-control privileges."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "Depending on the data stored in the temporary file, there is the potential for an attacker to gain an additional input vector which is trusted as non-malicious. It may be possible to make arbitrary changes to data structures, user information, or even process ownership."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Many contemporary languages have functions which properly handle this condition. Older C temp file functions are especially susceptible."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that you use proper file permissions. This can be achieved by using a safe temp file function. Temporary files should be writable and readable only by the process that owns the file."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Randomize temporary file names. This can also be achieved by using a safe temp-file function. This will ensure that temporary files will not be created in predictable places."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-139",
          "Entries": [
            {
              "IntroText": "In the following code examples a temporary file is created and written to. After using the temporary file, the file is closed and deleted from the file system."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tFILE *stream;\n\tif( (stream = tmpfile()) == NULL ) {\n\t\t\tperror(\"Could not open new temporary file\\n\");\n\t\t\treturn (-1);\n\t}\n```\n// write data to tmp file* \n\t...\n\t// remove tmp file\n\trmtmp();"
            },
            {
              "BodyText": "However, within this C/C++ code the method tmpfile() is used to create and open the temp file. The tmpfile() method works the same way as the fopen() method would with read/write permission, allowing attackers to read potentially sensitive information contained in the temp file or modify the contents of the file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tFile temp = File.createTempFile(\"pattern\", \".suffix\");\n\t\ttemp.deleteOnExit();\n\t\tBufferedWriter out = new BufferedWriter(new FileWriter(temp));\n\t\tout.write(\"aString\");\n\t\tout.close();\n\t}\n\tcatch (IOException e) {\n\t}\n```"
            },
            {
              "BodyText": "Similarly, the createTempFile() method used in the Java code creates a temp file that may be readable and writable to all users."
            },
            {
              "BodyText": "Additionally both methods used above place the file into a default directory. On UNIX systems the default directory is usually \"/tmp\" or \"/var/tmp\" and on Windows systems the default directory is usually \"C:\\\\Windows\\\\Temp\", which may be easily accessible to attackers, possibly enabling them to read and modify the contents of the temp file."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24823",
          "Description": "A network application framework uses the Java function createTempFile(), which will create a file that is readable by other local users of the system",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24823"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Improper temp file opening"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "379",
      "Name": "Creation of Temporary File in Directory with Insecure Permissions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product creates a temporary file in a directory whose permissions allow unintended actors to determine the file's existence or otherwise access that file.",
      "ExtendedDescription": "On some operating systems, the fact that the temporary file exists may be apparent to any user with sufficient privileges to access that directory. Since the file is visible, the application that is using the temporary file could be known. If one has access to list the processes on the system, the attacker has gained information about what the user is doing at that time. By correlating this with the applications the user is running, an attacker could potentially discover what a user's actions are. From this, higher levels of security could be breached.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "377",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Since the file is visible and the application which is using the temp file could be known, the attacker has gained information about what the user is doing at that time."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Many contemporary languages have functions which properly handle this condition. Older C temp file functions are especially susceptible."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Try to store sensitive tempfiles in a directory which is not world readable -- i.e., per-user directories."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid using vulnerable temp file functions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-139",
          "Entries": [
            {
              "IntroText": "In the following code examples a temporary file is created and written to. After using the temporary file, the file is closed and deleted from the file system."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tFILE *stream;\n\tif( (stream = tmpfile()) == NULL ) {\n\t\t\tperror(\"Could not open new temporary file\\n\");\n\t\t\treturn (-1);\n\t}\n```\n// write data to tmp file* \n\t...\n\t// remove tmp file\n\trmtmp();"
            },
            {
              "BodyText": "However, within this C/C++ code the method tmpfile() is used to create and open the temp file. The tmpfile() method works the same way as the fopen() method would with read/write permission, allowing attackers to read potentially sensitive information contained in the temp file or modify the contents of the file."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tFile temp = File.createTempFile(\"pattern\", \".suffix\");\n\t\ttemp.deleteOnExit();\n\t\tBufferedWriter out = new BufferedWriter(new FileWriter(temp));\n\t\tout.write(\"aString\");\n\t\tout.close();\n\t}\n\tcatch (IOException e) {\n\t}\n```"
            },
            {
              "BodyText": "Similarly, the createTempFile() method used in the Java code creates a temp file that may be readable and writable to all users."
            },
            {
              "BodyText": "Additionally both methods used above place the file into a default directory. On UNIX systems the default directory is usually \"/tmp\" or \"/var/tmp\" and on Windows systems the default directory is usually \"C:\\\\Windows\\\\Temp\", which may be easily accessible to attackers, possibly enabling them to read and modify the contents of the temp file."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-27818",
          "Description": "A hotkey daemon written in Rust creates a domain socket file underneath /tmp, which is accessible by any user.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-27818"
        },
        {
          "Reference": "CVE-2021-21290",
          "Description": "A Java-based application for a rapid-development framework uses File.createTempFile() to create a random temporary file with insecure default permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21290"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Guessed or visible temporary file"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO15-C",
          "EntryName": "Ensure that file operations are performed in a secure directory"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Temporary Files\", Page 538",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "382",
      "Name": "J2EE Bad Practices: Use of System.exit()",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A J2EE application uses System.exit(), which also shuts down its container.",
      "ExtendedDescription": "It is never a good idea for a web application to attempt to shut down the application container. Access to a function that can shut down the application is an avenue for Denial of Service (DoS) attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "A call to System.exit() is probably part of leftover debug code or code imported from a non-J2EE application."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "The shutdown function should be a privileged function available only to a properly authorized administrative user"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Web applications should not call methods that cause the virtual machine to exit, such as System.exit()"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Web applications should also not throw any Throwables to the application server as this may adversely affect the container."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Non-web applications may have a main() method that contains a System.exit(), but generally should not call System.exit() from other locations in the code"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-199",
          "Entries": [
            {
              "IntroText": "Included in the doPost() method defined below is a call to System.exit() in the event of a specific exception."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tPublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\ttry {\n\t\t\t...\n\t\t} catch (ApplicationSpecificException ase) {\n\t\t\tlogger.error(\"Caught: \" + ase.toString());\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "J2EE Bad Practices: System.exit()"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR09-J",
          "EntryName": "Do not allow untrusted code to terminate the JVM"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "383",
      "Name": "J2EE Bad Practices: Direct Use of Threads",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Thread management in a Web application is forbidden in some circumstances and is always highly error prone.",
      "ExtendedDescription": "Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "695",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For EJB, use framework approaches for parallel execution, instead of using threads."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, a new Thread object is created and invoked directly from within the body of a doGet() method in a Java servlet."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n```\n// Perform servlet tasks.* \n\t\t\t...\n\t\t\t\n\t\t\t\n\t\t\t *// Create a new thread to handle background processing.* \n\t\t\tRunnable r = new Runnable() {\n\t\t\t```\n\t\t\t\t\tpublic void run() {\n```\n// Process and store request statistics.* \n\t\t\t\t\t\t\t...}};\n\t\t\t\n\t\t\tnew Thread(r).start();}"
            }
          ]
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "J2EE Bad Practices: Threads"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP3",
          "EntryName": "Use of an improper API"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "384",
      "Name": "Session Fixation",
      "Abstraction": "Compound",
      "Structure": "Composite",
      "Status": "Incomplete",
      "Description": "Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",
      "ExtendedDescription": "\n\nSuch a scenario is commonly observed when:\n\n\n  - A web application authenticates a user without first invalidating the existing session, thereby continuing to use the session already associated with the user.\n\n  - An attacker is able to force a known session identifier on a user so that, once the user authenticates, the attacker has access to the authenticated session.\n\n  - The application or container uses predictable session identifiers.\n\nIn the generic exploit of session fixation vulnerabilities, an attacker creates a new session on a web application and records the associated session identifier. The attacker then causes the victim to associate, and possibly authenticate, against the server using that session identifier, giving the attacker access to the user's account through the active session.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "Requires",
          "CweID": "346",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "472",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "441",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Invalidate any existing session identifiers prior to authorizing a new user session."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example shows a snippet of code from a J2EE web application where the application authenticates users with LoginContext.login() without first calling HttpSession.invalidate()."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void auth(LoginContext lc, HttpSession session) throws LoginException {\n\t\t...\n\t\tlc.login();\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "In order to exploit the code above, an attacker could first create a session (perhaps by logging into the application) from a public terminal, record the session identifier assigned by the application, and reset the browser to the login page. Next, a victim sits down at the same public terminal, notices the browser open to the login page of the site, and enters credentials to authenticate against the application. The code responsible for authenticating the victim continues to use the pre-existing session identifier, now the attacker simply uses the session identifier recorded earlier to access the victim's active session, providing nearly unrestricted access to the victim's account for the lifetime of the session. Even given a vulnerable application, the success of the specific attack described here is dependent on several factors working in the favor of the attacker: access to an unmonitored public terminal, the ability to keep the compromised session active and a victim interested in logging into the vulnerable application on the public terminal."
            },
            {
              "BodyText": "In most circumstances, the first two challenges are surmountable given a sufficient investment of time. Finding a victim who is both using a public terminal and interested in logging into the vulnerable application is possible as well, so long as the site is reasonably popular. The less well known the site is, the lower the odds of an interested victim using the public terminal and the lower the chance of success for the attack vector described above. The biggest challenge an attacker faces in exploiting session fixation vulnerabilities is inducing victims to authenticate against the vulnerable application using a session identifier known to the attacker."
            },
            {
              "BodyText": "In the example above, the attacker did this through a direct method that is not subtle and does not scale suitably for attacks involving less well-known web sites. However, do not be lulled into complacency; attackers have many tools in their belts that help bypass the limitations of this attack vector. The most common technique employed by attackers involves taking advantage of cross-site scripting or HTTP response splitting vulnerabilities in the target site [12]. By tricking the victim into submitting a malicious request to a vulnerable application that reflects JavaScript or other code back to the victim's browser, an attacker can create a cookie that will cause the victim to reuse a session identifier controlled by the attacker. It is worth noting that cookies are often tied to the top level domain associated with a given URL. If multiple applications reside on the same top level domain, such as bank.example.com and recipes.example.com, a vulnerability in one application can allow an attacker to set a cookie with a fixed session identifier that will be used in all interactions with any application on the domain example.com [29]."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following example shows a snippet of code from a J2EE web application where the application authenticates users with a direct post to the <code>j_security_check</code>, which typically does not invalidate the existing session before processing the login request."
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<form method=\"POST\" action=\"j_security_check\">\n\t\t<input type=\"text\" name=\"j_username\">\n\t\t<input type=\"text\" name=\"j_password\">\n\t</form>\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-2820",
          "Description": "Website software for game servers does not proprerly terminate user sessions, allowing for possible session fixation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2820"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Session Fixation"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A3",
          "EntryName": "Broken Authentication and Session Management",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "37",
          "EntryName": "Session Fixation"
        }
      ],
      "RelatedAttackPatterns": [
        "196",
        "21",
        "31",
        "39",
        "59",
        "60",
        "61"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.",
        "Comments": "While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine which weaknesses allow session fixation to occur, and map to those weaknesses. For example, predictable session identifiers might enable session fixation attacks to succeed; if this occurs, they might be better characterized as randomness/predictability weaknesses.",
        "Reasons": [
          "Other"
        ]
      },
      "Notes": [
        {
          "Type": "Other",
          "Note": "Other attack vectors include DNS poisoning and related network based attacks where an attacker causes the user to visit a malicious site by redirecting a request for a valid site. Network based attacks typically involve a physical presence on the victim's network or control of a compromised machine on the network, which makes them harder to exploit remotely, but their significance should not be overlooked. Less secure session management mechanisms, such as the default implementation in Apache Tomcat, allow session identifiers normally expected in a cookie to be specified on the URL as well, which enables an attacker to cause a victim to use a fixed session identifier simply by emailing a malicious URL."
        }
      ]
    },
    {
      "ID": "385",
      "Name": "Covert Timing Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Covert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information.",
      "ExtendedDescription": "\n\nIn some instances, knowing when data is transmitted between parties can provide a malicious user with privileged information. Also, externally monitoring the timing of operations can potentially reveal sensitive data. For example, a cryptographic operation can expose its internal state if the time it takes to perform the operation varies, based on the state.\n\n\nCovert channels are frequently classified as either storage or timing channels. Some examples of covert timing channels are the system's paging rate, the time a certain transaction requires to execute, and the time it takes to gain access to a shared bus.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "514",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Read Application Data",
            "Other"
          ],
          "Note": "Information exposure."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Whenever possible, specify implementation strategies that do not introduce time variances in operations."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Often one can artificially manipulate the time which operations take or -- when operations occur -- can remove information from the attacker."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "It is reasonable to add artificial or random delays so that the amount of CPU time consumed is independent of the action being taken by the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-193",
          "Entries": [
            {
              "IntroText": "In this example, the attacker observes how long an authentication takes when the user types in the correct password."
            },
            {
              "BodyText": "When the attacker tries their own values, they can first try strings of various length. When they find a string of the right length, the computation will take a bit longer, because the for loop will run at least once. Additionally, with this code, the attacker can possibly learn one character of the password at a time, because when they guess the first character right, the computation will take longer than a wrong guesses. Such an attack can break even the most sophisticated password with a few hundred guesses."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef validate_password(actual_pw, typed_pw): \n\t\t\tif len(actual_pw) <> len(typed_pw): \n\t\t\t\treturn 0\n\t\t\tfor i in len(actual_pw): \n\t\t\t\tif actual_pw[i] <> typed_pw[i]: \n\t\t\t\t\treturn 0\n\t\t\treturn 1\n```"
            },
            {
              "BodyText": "Note that in this example, the actual password must be handled in constant time as far as the attacker is concerned, even if the actual password is of an unusual length. This is one reason why it is good to use an algorithm that, among other things, stores a seeded cryptographic one-way hash of the password, then compare the hashes, which will always be of the same length."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Landwehr",
          "EntryName": "Timing"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Covert Timing Channel"
        }
      ],
      "RelatedAttackPatterns": [
        "462"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-1431",
          "Authors": [
            "Carl E. Landwehr",
            "Alan R. Bull",
            "John P. McDermott",
            "William S. Choi"
          ],
          "Title": "A Taxonomy of Computer Program Security Flaws, with Examples",
          "PublicationYear": "1993",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "URL": "https://cwe.mitre.org/documents/sources/ATaxonomyofComputerProgramSecurityFlawswithExamples%5BLandwehr93%5D.pdf",
          "URLDate": "2024-05-09"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10."
        }
      ]
    },
    {
      "ID": "386",
      "Name": "Symbolic Name not Mapping to Correct Object",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A constant symbolic reference to an object is used, even though the reference can resolve to a different object over time.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "706",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "367",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "610",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "486",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The attacker can gain access to otherwise unauthorized resources."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories",
            "Read Application Data",
            "Read Files or Directories",
            "Other"
          ],
          "Note": "Race conditions such as this kind may be employed to gain read or write access to resources not normally readable or writable by the user in question."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Other"
          ],
          "Note": "The resource in question, or other resources (through the corrupted one) may be changed in undesirable ways by a malicious user."
        },
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "If a file or other resource is written in this method, as opposed to a valid way, logging of the activity may not occur."
        },
        {
          "Scope": [
            "Non-Repudiation",
            "Integrity"
          ],
          "Impact": [
            "Modify Files or Directories"
          ],
          "Note": "In some cases it may be possible to delete files that a malicious user might not otherwise have access to -- such as log files."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Symbolic name not mapping to correct object"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "390",
      "Name": "Detection of Error Condition Without Action",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product detects a specific error, but takes no actions to handle the error.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "401",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State",
            "Alter Execution Logic"
          ],
          "Note": "An attacker could utilize an ignored error condition to place the system in an unexpected state that could lead to the execution of unintended logic and could cause other unintended behavior."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Properly handle each exception. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If a function returns an error, it is important to either fix the problem and try again, alert the user that an error has happened and let the program continue, or alert the user and close and cleanup the program."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Subject the product to extensive testing to discover some of the possible instances of where/how errors or return values are not handled. Consider testing techniques such as ad hoc, equivalence partitioning, robustness and fault tolerance, mutation, and fuzzing."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-201",
          "Entries": [
            {
              "IntroText": "The following example attempts to allocate memory for a character. After the call to malloc, an if statement is used to check whether the malloc function failed."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\n\tif (foo==NULL) {\n\t\t//We do nothing so we just ignore the error.\n\t}\n```"
            },
            {
              "BodyText": "The conditional successfully detects a NULL return value from malloc indicating a failure, however it does not do anything to handle the problem. Unhandled errors may have unexpected results and may cause the program to crash or terminate."
            },
            {
              "BodyText": "Instead, the if block should contain statements that either attempt to fix the problem or notify the user that an error has occurred and continue processing or perform some cleanup and gracefully terminate the program. The following example notifies the user that the malloc function did not allocate the required memory resources and returns an error code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\n\tif (foo==NULL) {\n\t\tprintf(\"Malloc failed to allocate memory resources\");\n\t\treturn -1;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following C++ example the method readFile() will read the file whose name is provided in the input parameter and will return the contents of the file in char string. The method calls open() and read() may result in errors if the file does not exist or does not contain any data to read. These errors will be thrown when the is_open() method and good() method indicate errors opening or reading the file. However, these errors are not handled within the catch statement. Catch statements that do not perform any processing will have unexpected results. In this case an empty char string will be returned, and the file will not be properly closed."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tchar* readfile (char *filename) {\n\t\t\ttry {\n\t\t\t\t\t// open input file\n\t\t\t\t\tifstream infile;\n\t\t\t\t\tinfile.open(filename);\n\t\t\t\t\tif (!infile.is_open()) {\n\t\t\t\t\t\tthrow \"Unable to open file \" + filename;\n\t\t\t\t\t}\n\t\t\t\t\t// get length of file\n\t\t\t\t\tinfile.seekg (0, ios::end);\n\t\t\t\t\tint length = infile.tellg();\n\t\t\t\t\tinfile.seekg (0, ios::beg);\n\t\t\t\t\t// allocate memory\n\t\t\t\t\tchar *buffer = new char [length];\n\t\t\t\t\t// read data from file\n\t\t\t\t\tinfile.read (buffer,length);\n\t\t\t\t\tif (!infile.good()) {\n\t\t\t\t\t\tthrow \"Unable to read from file \" + filename;\n\t\t\t\t\t}\n\t\t\t\t\tinfile.close();\n\t\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\t/* bug: insert code to handle this later */\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The catch statement should contain statements that either attempt to fix the problem or notify the user that an error has occurred and continue processing or perform some cleanup and gracefully terminate the program. The following C++ example contains two catch statements. The first of these will catch a specific error thrown within the try block, and the second catch statement will catch all other errors from within the catch block. Both catch statements will notify the user that an error has occurred, close the file, and rethrow to the block that called the readFile() method for further handling or possible termination of the program."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tchar* readFile (char *filename) {\n\t\t\ttry {\n\t\t\t\t\t// open input file\n\t\t\t\t\tifstream infile;\n\t\t\t\t\tinfile.open(filename);\n\t\t\t\t\tif (!infile.is_open()) {\n\t\t\t\t\t\tthrow \"Unable to open file \" + filename;\n\t\t\t\t\t}\n\t\t\t\t\t// get length of file\n\t\t\t\t\tinfile.seekg (0, ios::end);\n\t\t\t\t\tint length = infile.tellg();\n\t\t\t\t\tinfile.seekg (0, ios::beg);\n\t\t\t\t\t// allocate memory\n\t\t\t\t\tchar *buffer = new char [length];\n\t\t\t\t\t// read data from file\n\t\t\t\t\tinfile.read (buffer,length);\n\t\t\t\t\tif (!infile.good()) {\n\t\t\t\t\t\tthrow \"Unable to read from file \" + filename;\n\t\t\t\t\t}\n\t\t\t\t\tinfile.close();\n\t\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tcatch (char *str) {\n\t\t\t\tprintf(\"Error: %s \\n\", str);\n\t\t\t\tinfile.close();\n\t\t\t\tthrow str;\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\tprintf(\"Error occurred trying to read from file \\n\");\n\t\t\t\tinfile.close();\n\t\t\t\tthrow;\n\t\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the method readFile will read the file whose name is provided in the input parameter and will return the contents of the file in a String object. The constructor of the FileReader object and the read method call may throw exceptions and therefore must be within a try/catch block. While the catch statement in this example will catch thrown exceptions in order for the method to compile, no processing is performed to handle the thrown exceptions. Catch statements that do not perform any processing will have unexpected results. In this case, this will result in the return of a null String."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic String readFile(String filename) {\n\t\t\tString retString = null;\n\t\t\ttry {\n\t\t\t\t\t// initialize File and FileReader objects\n\t\t\t\t\tFile file = new File(filename);\n\t\t\t\t\tFileReader fr = new FileReader(file);\n\t\t\t\t\t// initialize character buffer\n\t\t\t\t\tlong fLen = file.length();\n\t\t\t\t\tchar[] cBuf = new char[(int) fLen];\n\t\t\t\t\t// read data from file\n\t\t\t\t\tint iRead = fr.read(cBuf, 0, (int) fLen);\n\t\t\t\t\t// close file\n\t\t\t\t\tfr.close();\n\t\t\t\t\tretString = new String(cBuf);\n\t\t\t} catch (Exception ex) {\n\t\t\t\t/* do nothing, but catch so it'll compile... */\n\t\t\t}\n\t\t\treturn retString;\n\t}\n```"
            },
            {
              "BodyText": "The catch statement should contain statements that either attempt to fix the problem, notify the user that an exception has been raised and continue processing, or perform some cleanup and gracefully terminate the program. The following Java example contains three catch statements. The first of these will catch the FileNotFoundException that may be thrown by the FileReader constructor called within the try/catch block. The second catch statement will catch the IOException that may be thrown by the read method called within the try/catch block. The third catch statement will catch all other exceptions thrown within the try block. For all catch statements the user is notified that the exception has been thrown and the exception is rethrown to the block that called the readFile() method for further processing or possible termination of the program. Note that with Java it is usually good practice to use the getMessage() method of the exception class to provide more information to the user about the exception raised."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic String readFile(String filename) throws FileNotFoundException, IOException, Exception {\n\t\t\tString retString = null;\n\t\t\ttry {\n\t\t\t\t\t// initialize File and FileReader objects\n\t\t\t\t\tFile file = new File(filename);\n\t\t\t\t\tFileReader fr = new FileReader(file);\n\t\t\t\t\t// initialize character buffer\n\t\t\t\t\tlong fLen = file.length();\n\t\t\t\t\tchar [] cBuf = new char[(int) fLen];\n\t\t\t\t\t// read data from file\n\t\t\t\t\tint iRead = fr.read(cBuf, 0, (int) fLen);\n\t\t\t\t\t// close file\n\t\t\t\t\tfr.close();\n\t\t\t\t\tretString = new String(cBuf);\n\t\t\t} catch (FileNotFoundException ex) {\n\t\t\t\tSystem.err.println (\"Error: FileNotFoundException opening the input file: \" + filename );\n\t\t\t\tSystem.err.println (\"\" + ex.getMessage() );\n\t\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t\t} catch (IOException ex) {\n\t\t\t\tSystem.err.println(\"Error: IOException reading the input file.\\n\" + ex.getMessage() );\n\t\t\t\tthrow new IOException(ex);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tSystem.err.println(\"Error: Exception reading the input file.\\n\" + ex.getMessage() );\n\t\t\t\tthrow new Exception(ex);\n\t\t\t}\n\t\t\treturn retString;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-21820",
          "Description": "A GPU data center manager detects an error due to a malformed request but does not act on it, leading to memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21820"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Improper error handling"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR00-J",
          "EntryName": "Do not suppress or ignore checked exceptions"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 11: Failure to Handle Errors Correctly.\" Page 183",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "391",
      "Name": "Unchecked Error Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "[PLANNED FOR DEPRECATION. SEE MAINTENANCE NOTES AND CONSIDER CWE-252, CWE-248, OR CWE-1069.] Ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "The choice between a language which has named or unnamed exceptions needs to be done. While unnamed exceptions exacerbate the chance of not properly dealing with an exception, named exceptions suffer from the up call version of the weak base class problem."
        },
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "A language can be used which requires, at compile time, to catch all serious exceptions. However, one must make sure to use the most current version of the API as new exceptions could be added."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Catch all relevant exceptions. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code excerpt ignores a rarely-thrown exception from doExchange()."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tdoExchange();\n\t}\n\tcatch (RareException e) {\n```\n// this can never happen* \n\t\t\t}"
            },
            {
              "BodyText": "If a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unchecked Return Value"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Empty Catch Block"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Uncaught exception"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A7",
          "EntryName": "Improper Error Handling",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR00-C",
          "EntryName": "Adopt and implement a consistent and comprehensive error-handling policy"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR33-C",
          "EntryName": "Detect and handle standard library errors",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR34-C",
          "EntryName": "Detect errors when converting a string to a number",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FLP32-C",
          "EntryName": "Prevent or detect domain and range errors in math functions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS54-C",
          "EntryName": "Detect and handle POSIX library errors",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP31-PL",
          "EntryName": "Do not suppress or ignore exceptions",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is slated for deprecation; it has multiple widespread interpretations by CWE analysts. It combines information from three different taxonomies, but each taxonomy is talking about a slightly different issue.",
        "Comments": "Consider CWE-252, CWE-1069, CWE-248, or other entries under CWE-754: Improper Check for Unusual or Exceptional Conditions or CWE-755: Improper Handling of Exceptional Conditions.",
        "Reasons": [
          "Potential Deprecation",
          "Frequent Misuse",
          "Frequent Misinterpretation"
        ],
        "Suggestions": [
          {
            "CweID": "252",
            "Comment": "Unchecked Return Value"
          },
          {
            "CweID": "1069",
            "Comment": "Empty Exception Block"
          },
          {
            "CweID": "248",
            "Comment": "Uncaught Exception"
          }
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry is slated for deprecation; it has multiple widespread interpretations by CWE analysts. It currently combines information from three different taxonomies, but each taxonomy is talking about a slightly different issue. CWE analysts might map to this entry based on any of these issues. 7PK has \"Empty Catch Block\" which has an association with empty exception block (CWE-1069); in this case, the exception has performed the check, but does not handle. In PLOVER there is \"Unchecked Return Value\" which is CWE-252, but unlike \"Empty Catch Block\" there isn't even a check of the issue - and \"Unchecked Error Condition\" implies lack of a check. For CLASP, \"Uncaught Exception\" (CWE-248) is associated with incorrect error propagation - uncovered in CWE 3.2 and earlier, at least. There are other issues related to error handling and checks."
        },
        {
          "Type": "Other",
          "Note": "\n\nWhen a programmer ignores an exception, they implicitly state that they are operating under one of two assumptions:\n\n\n  - This method call can never fail.\n\n  - It doesn't matter if this call fails.\n\n"
        }
      ]
    },
    {
      "ID": "392",
      "Name": "Missing Report of Error Condition",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product encounters an error but does not provide a status code or return value to indicate that an error has occurred.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ],
          "Note": "Errors that are not properly reported could place the system in an unexpected state that could lead to unintended behaviors."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-185",
          "Entries": [
            {
              "IntroText": "In the following snippet from a doPost() servlet method, the server returns \"200 OK\" (default) even if an error occurs."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n```\n// Something that may throw an exception.* \n\t\t\t...} catch (Throwable t) {\n\t```\n\t\tlogger.error(\"Caught: \" + t.toString());\n\t\treturn;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "[REF-1374]",
          "Description": "Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)",
          "Link": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards"
        },
        {
          "Reference": "CVE-2004-0063",
          "Description": "Function returns \"OK\" even if another function returns a different status code than expected, leading to accepting an invalid PIN number.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0063"
        },
        {
          "Reference": "CVE-2002-1446",
          "Description": "Error checking routine in PKCS#11 library returns \"OK\" status even when invalid signature is detected, allowing spoofed messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1446"
        },
        {
          "Reference": "CVE-2002-0499",
          "Description": "Kernel function truncates long pathnames without generating an error, leading to operation on wrong directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0499"
        },
        {
          "Reference": "CVE-2005-2459",
          "Description": "Function returns non-error value when a particular erroneous condition is encountered, leading to resultant NULL dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2459"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Error Status Code"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "TPS03-J",
          "EntryName": "Ensure that tasks executing in a thread pool do not fail silently"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP6",
          "EntryName": "Incorrect Exception Behavior"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1374",
          "Authors": [
            "Unciphered"
          ],
          "Title": "Randstorm: You Can't Patch a House of Cards",
          "PublicationYear": "2023",
          "PublicationMonth": "11",
          "PublicationDay": "14",
          "URL": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards",
          "URLDate": "2023-11-15"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "393",
      "Name": "Return of Wrong Status Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.",
      "ExtendedDescription": "This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Alter Execution Logic"
          ],
          "Note": "This weakness could place the system in a state that could lead unexpected logic to be executed or other unintended behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-186",
          "Entries": [
            {
              "IntroText": "In the following example, an HTTP 404 status code is returned in the event of an IOException encountered in a Java servlet. A 404 code is typically meant to indicate a non-existent resource and would be somewhat misleading in this case."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n```\n// something that might throw IOException* \n\t\t\t...} catch (IOException ioe) {\n\t```\n\t\tresponse.sendError(SC_NOT_FOUND);\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-1132",
          "Description": "DNS server returns wrong response code for non-existent AAAA record, which effectively says that the domain is inaccessible.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1132"
        },
        {
          "Reference": "CVE-2001-1509",
          "Description": "Hardware-specific implementation of system call causes incorrect results from geteuid.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1509"
        },
        {
          "Reference": "CVE-2001-1559",
          "Description": "Chain: System call returns wrong value (CWE-393), leading to a resultant NULL dereference (CWE-476).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1559"
        },
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Wrong Status Code"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP6",
          "EntryName": "Incorrect Exception Behavior"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be primary or resultant, but it is probably most often primary to other issues."
        }
      ]
    },
    {
      "ID": "394",
      "Name": "Unexpected Status Code or Return Value",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly check when a function or operation returns a value that is legitimate for the function, but is not expected by the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "754",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Alter Execution Logic"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-1395",
          "Description": "Certain packets (zero byte and other lengths) cause a recvfrom call to produce an unexpected return code that causes a server's listening loop to exit.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1395"
        },
        {
          "Reference": "CVE-2002-2124",
          "Description": "Unchecked return code from recv() leads to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2124"
        },
        {
          "Reference": "CVE-2005-2553",
          "Description": "Kernel function does not properly handle when a null is returned by a function call, causing it to call another function that it shouldn't.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2553"
        },
        {
          "Reference": "CVE-2005-1858",
          "Description": "Memory not properly cleared when read() function call returns fewer bytes than expected.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1858"
        },
        {
          "Reference": "CVE-2000-0536",
          "Description": "Bypass access restrictions when connecting from IP whose DNS reverse lookup does not return a hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0536"
        },
        {
          "Reference": "CVE-2001-0910",
          "Description": "Bypass access restrictions when connecting from IP whose DNS reverse lookup does not return a hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0910"
        },
        {
          "Reference": "CVE-2004-2371",
          "Description": "Game server doesn't check return values for functions that handle text strings and associated size values.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2371"
        },
        {
          "Reference": "CVE-2005-1267",
          "Description": "Resultant infinite loop when function call returns -1 value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1267"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unexpected Status Code or Return Value"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP00-PL",
          "EntryName": "Do not return undef",
          "MappingFit": "Imprecise"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Usually primary, but can be resultant from issues such as behavioral change or API abuse. This can produce resultant vulnerabilities."
        }
      ]
    },
    {
      "ID": "395",
      "Name": "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer.",
      "ExtendedDescription": "\n\nProgrammers typically catch NullPointerException under three circumstances:\n\n\n  - The program contains a null pointer dereference. Catching the resulting exception was easier than fixing the underlying problem.\n\n  - The program explicitly throws a NullPointerException to signal an error condition.\n\n  - The code is part of a test harness that supplies unexpected input to the classes under test.\n\nOf these three circumstances, only the last is acceptable.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFramework-based Fuzzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Do not extensively rely on catching exceptions (especially for validating user input) to handle errors. Handling exceptions can decrease the performance of an application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-202",
          "Entries": [
            {
              "IntroText": "The following code mistakenly catches a NullPointerException."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry { \n\t\t mysteryMethod(); \n\t } catch (NullPointerException npe) {\n\t }\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Catching NullPointerException"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR08-J",
          "EntryName": "Do not catch NullPointerException or any of its ancestors"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "396",
      "Name": "Declaration of Catch for Generic Exception",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.",
      "ExtendedDescription": "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of a language's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "221",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Python",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation",
            "Other"
          ],
          "Impact": [
            "Hide Activities",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code excerpt handles three types of exceptions in an identical fashion."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tdoExchange();\n\t}\n\tcatch (IOException e) {\n\t\tlogger.error(\"doExchange failed\", e);\n\t}\n\tcatch (InvocationTargetException e) {\n\t\t\tlogger.error(\"doExchange failed\", e);\n\t}\n\tcatch (SQLException e) {\n\t\t\tlogger.error(\"doExchange failed\", e);\n\t}\n```"
            },
            {
              "BodyText": "At first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\ttry {\n\t\tdoExchange();\n\t}\n\tcatch (Exception e) {\n\t\tlogger.error(\"doExchange failed\", e);\n\t}\n```"
            },
            {
              "BodyText": "However, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Overly-Broad Catch Block"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP5",
          "EntryName": "Ambiguous Exception Type"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-396"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-396"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 9: Catching Exceptions.\" Page 157",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-396",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-396",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "397",
      "Name": "Declaration of Throws for Generic Exception",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.",
      "ExtendedDescription": "Declaring a method to throw Exception or Throwable makes it difficult for callers to perform proper error handling and error recovery. Java's exception mechanism, for example, is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "221",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation",
            "Other"
          ],
          "Impact": [
            "Hide Activities",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-198",
          "Entries": [
            {
              "IntroText": "The following method throws three types of exceptions."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doExchange() throws IOException, InvocationTargetException, SQLException {\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "While it might seem tidier to write"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tpublic void doExchange() throws Exception {\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "doing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Early versions of C++ (C++98, C++03, C++11) included a feature known as Dynamic Exception Specification. This allowed functions to declare what type of exceptions it may throw. It is possible to declare a general class of exception to cover any derived exceptions that may be throw."
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tint myfunction() throw(std::exception) {\n\t\tif (0) throw out_of_range();\n\t\tthrow length_error();\n\t}\n```"
            },
            {
              "BodyText": "In the example above, the code declares that myfunction() can throw an exception of type \"std::exception\" thus hiding details about the possible derived exceptions that could potentially be thrown."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Overly-Broad Throws Declaration"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR07-J",
          "EntryName": "Do not throw RuntimeException, Exception, or Throwable"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP5",
          "EntryName": "Ambiguous Exception Type"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-397"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-397"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-397",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-397",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Applicable Platform",
          "Note": "For C++, this weakness only applies to C++98, C++03, and C++11. It relies on a feature known as Dynamic Exception Specification, which was part of early versions of C++ but was deprecated in C++11. It has been removed for C++17 and later."
        }
      ]
    },
    {
      "ID": "400",
      "Name": "Uncontrolled Resource Consumption",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
      "ExtendedDescription": "\n\nLimited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.\n\n\nThere are at least three distinct scenarios which can commonly lead to resource exhaustion:\n\n\n  - Lack of throttling for the number of allocated resources\n\n  - Losing all references to a resource before reaching the shutdown stage\n\n  - Not closing/returning a resource after processing\n\nResource exhaustion problems are often result due to an incorrect implementation of the following situations:\n\n  - Error conditions and other exceptional circumstances.\n\n  - Confusion over which part of the program is responsible for releasing the resource.\n\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Resource Exhaustion"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation"
        },
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "The most common result of resource exhaustion is denial of service. The product may slow down, crash due to unhandled errors, or lock out legitimate users."
        },
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "In some cases it may be possible to force the product to \"fail open\" in the event of resource exhaustion. The state of the product -- and possibly the security functionality - may then be compromised."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis typically has limited utility in recognizing resource exhaustion problems, except for program-independent system resources such as files, sockets, and processes. For system resources, automated static analysis may be able to detect circumstances in which resources are not released after they have expired. Automated analysis of configuration files may be able to detect settings that do not specify a maximum value.\n\n\nAutomated static analysis tools will not be appropriate for detecting exhaustion of custom resources, such as an intended security policy in which a bulletin board user is only allowed to make a limited number of posts per day.\n",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Certain automated dynamic analysis techniques may be effective in spotting resource exhaustion problems, especially with resources such as processes, memory, and connections. The technique may involve generating a large number of requests to the product within a short time frame.",
          "Effectiveness": "Moderate"
        },
        {
          "Method": "Fuzzing",
          "Description": "While fuzzing is typically geared toward finding low-level implementation bugs, it can inadvertently find resource exhaustion problems. This can occur when the fuzzer generates a large number of test cases but does not restart the targeted product in between test cases. If an individual test case produces a crash, but it does not do so reliably, then an inability to handle resource exhaustion may be the cause.",
          "Effectiveness": "Opportunistic"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nMitigation of resource exhaustion attacks requires that the target system either:\n\n\n  - recognizes the attack and denies that user further access for a given amount of time, or\n\n  - uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.\n\nThe first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.\n\nThe second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that protocols have specific limits of scale placed on them."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that all failures in resource allocation place the system into a safe posture."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tclass Worker implements Executor {\n\t\t\t...\n\t\t\tpublic void execute(Runnable r) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t...\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ie) {\n```\n// postpone response* \n\t\t\t\t\t\t\tThread.currentThread().interrupt();}}\n\t\t\t\n\t\t\tpublic Worker(Channel ch, int nworkers) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t\t\tprotected void activate() {\n\t\t\t\t\tRunnable loop = new Runnable() {\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\t\t\tRunnable r = ...;\n\t\t\t\t\t\t\t\t\t\t\tr.run();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tnew Thread(loop).start();\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "There are no limits to runnables. Potentially an attacker could cause resource problems very quickly."
            }
          ]
        },
        {
          "ID": "DX-25",
          "Entries": [
            {
              "IntroText": "This code allocates a socket and forks each time it receives a new connection."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsock=socket(AF_INET, SOCK_STREAM, 0);\n\twhile (1) {\n\t\tnewsock=accept(sock, ...);\n\t\tprintf(\"A connection has been accepted\\n\");\n\t\tpid = fork();\n\t}\n```"
            },
            {
              "BodyText": "The program does not track how many connections have been made, and it does not limit the number of connections. Because forking is a relatively expensive operation, an attacker would be able to cause the system to run out of CPU, processes, or memory by making a large number of connections. Alternatively, an attacker could consume all available connections, preventing others from accessing the system remotely."
            }
          ]
        },
        {
          "ID": "DX-50",
          "Entries": [
            {
              "IntroText": "In the following example a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method openSocketConnection establishes a server socket to accept requests from a client. When a client establishes a connection to this service the getNextMessage method is first used to retrieve from the socket the name of the file to store the data, the openFileToWrite method will validate the filename and open a file to write to on the local file system. The getNextMessage is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint writeDataFromSocketToFile(char *host, int port)\n\t{\n\t\t\tchar filename[FILENAME_SIZE];\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tint socket = openSocketConnection(host, port);\n\t\t\tif (socket < 0) {\n\t\t\t\tprintf(\"Unable to open socket connection\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t\t\tif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\n\t\t\t\t\tif (openFileToWrite(filename) > 0) {\n\t\t\t\t\t\t\twhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){\n\t\t\t\t\t\t\t\tif (!(writeToFile(buffer) > 0))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcloseFile();\n\t\t\t}\n\t\t\tcloseSocket(socket);\n\t}\n```"
            },
            {
              "BodyText": "This example creates a situation where data can be dumped to a file on the local file system without any limits on the size of the file. This could potentially exhaust file or disk resources and/or limit other clients' ability to access the service."
            }
          ]
        },
        {
          "ID": "DX-51",
          "Entries": [
            {
              "IntroText": "In the following example, the processMessage method receives a two dimensional character array containing the message to be processed. The two-dimensional character array contains the length of the message in the first character array and the message body in the second character array. The getMessageLength method retrieves the integer value of the length from the first character array. After validating that the message length is greater than zero, the body character array pointer points to the start of the second character array of the two-dimensional character array and memory is allocated for the new body character array."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */* \n\tint processMessage(char **message)\n\t{\n\t```\n\t\t\tchar *body;\n\t\t\tint length = getMessageLength(message[0]);\n\t\t\tif (length > 0) {\n\t\t\t\tbody = &message[1][0];\n\t\t\t\tprocessMessageBody(body);\n\t\t\t\treturn(SUCCESS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Unable to process message; invalid message length\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This example creates a situation where the length of the body character array can be very large and will consume excessive memory, exhausting system resources. This can be avoided by restricting the length of the second character array with a maximum length check"
            },
            {
              "BodyText": "Also, consider changing the type from 'int' to 'unsigned int', so that you are always guaranteed that the number is positive. This might not be possible if the protocol specifically requires allowing negative values, or if you cannot control the return value from getMessageLength(), but it could simplify the check to ensure the input is positive, and eliminate other errors such as signed-to-unsigned conversion errors (CWE-195) that may occur elsewhere in the code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int length = getMessageLength(message[0]);\n\tif ((length > 0) && (length < MAX_LENGTH)) {...}\n```"
            }
          ]
        },
        {
          "ID": "DX-52",
          "Entries": [
            {
              "IntroText": "In the following example, a server object creates a server socket and accepts client connections to the socket. For every client connection to the socket a separate thread object is generated using the ClientSocketThread class that handles request made by the client through the socket."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"
            },
            {
              "BodyText": "In this example there is no limit to the number of client connections and client threads that are created. Allowing an unlimited number of client connections and threads could potentially overwhelm the system and system resources."
            },
            {
              "BodyText": "The server should limit the number of client connections and the client threads that are created. This can be easily done by creating a thread pool object that limits the number of threads that are generated."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static final int SERVER_PORT = 4444;\n\tpublic static final int MAX_CONNECTIONS = 10;\n\t...\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\thasConnections = checkForMoreConnections();\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tExecutorService pool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\t\t\t\t\tpool.execute(t);\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example, the serve function receives an http request and an http response writer. It reads the entire request body."
            },
            {
              "Nature": "Bad",
              "Language": "Go",
              "ExampleCode": "```\n\tfunc serve(w http.ResponseWriter, r *http.Request) { \n\t\t var body []byte\n\t\t if r.Body != nil {\n\t\t\t if data, err := io.ReadAll(r.Body); err == nil {\n\t\t\t\t body = data\n\t\t\t }\n\t\t }\n\t }\n```"
            },
            {
              "BodyText": "Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. This example creates a situation where the length of the body supplied can be very large and will consume excessive memory, exhausting system resources. This can be avoided by ensuring the body does not exceed a predetermined length of bytes."
            },
            {
              "BodyText": "MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, the code could be changed to tell ResponseWriter to close the connection after the limit has been reached."
            },
            {
              "Nature": "Good",
              "Language": "Go",
              "ExampleCode": "```\n\tfunc serve(w http.ResponseWriter, r *http.Request) { \n\t\t var body []byte\n\t\t const MaxRespBodyLength = 1e6\n\t\t if r.Body != nil {\n\t\t\t r.Body = http.MaxBytesReader(w, r.Body, MaxRespBodyLength)\n\t\t\t if data, err := io.ReadAll(r.Body); err == nil {\n\t\t\t\t body = data\n\t\t\t }\n\t\t }\n\t }\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-21668",
          "Description": "Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21668"
        },
        {
          "Reference": "CVE-2020-7218",
          "Description": "Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-7218"
        },
        {
          "Reference": "CVE-2020-3566",
          "Description": "Resource exhaustion in distributed OS because of \"insufficient\" IGMP queue management, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-3566"
        },
        {
          "Reference": "CVE-2009-2874",
          "Description": "Product allows attackers to cause a crash via a large number of connections.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2874"
        },
        {
          "Reference": "CVE-2009-1928",
          "Description": "Malformed request triggers uncontrolled recursion, leading to stack exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1928"
        },
        {
          "Reference": "CVE-2009-2858",
          "Description": "Chain: memory leak (CWE-404) leads to resource exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2858"
        },
        {
          "Reference": "CVE-2009-2726",
          "Description": "Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2726"
        },
        {
          "Reference": "CVE-2009-2540",
          "Description": "Large integer value for a length property in an object causes a large amount of memory allocation.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2540"
        },
        {
          "Reference": "CVE-2009-2299",
          "Description": "Web application firewall consumes excessive memory when an HTTP request contains a large Content-Length value but no POST data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2299"
        },
        {
          "Reference": "CVE-2009-2054",
          "Description": "Product allows exhaustion of file descriptors when processing a large number of TCP packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2054"
        },
        {
          "Reference": "CVE-2008-5180",
          "Description": "Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5180"
        },
        {
          "Reference": "CVE-2008-2121",
          "Description": "TCP implementation allows attackers to consume CPU and prevent new connections using a TCP SYN flood attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2121"
        },
        {
          "Reference": "CVE-2008-2122",
          "Description": "Port scan triggers CPU consumption with processes that attempt to read data from closed sockets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2122"
        },
        {
          "Reference": "CVE-2008-1700",
          "Description": "Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1700"
        },
        {
          "Reference": "CVE-2007-4103",
          "Description": "Product allows resource exhaustion via a large number of calls that do not complete a 3-way handshake.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4103"
        },
        {
          "Reference": "CVE-2006-1173",
          "Description": "Mail server does not properly handle deeply nested multipart MIME messages, leading to stack exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1173"
        },
        {
          "Reference": "CVE-2007-0897",
          "Description": "Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0897"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Resource exhaustion (file descriptor, disk space, sockets, ...)"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "10",
          "EntryName": "Denial of Service"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "41",
          "EntryName": "XML Attribute Blowup"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER12-J",
          "EntryName": "Avoid memory and resource leaks during serialization"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC05-J",
          "EntryName": "Do not exhaust heap space"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP13",
          "EntryName": "Unrestricted Consumption"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 7.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 7.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.2"
        }
      ],
      "RelatedAttackPatterns": [
        "147",
        "227",
        "492"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-386",
          "Authors": [
            "Joao Antunes",
            "Nuno Ferreira Neves",
            "Paulo Verissimo"
          ],
          "Title": "Detection and Prediction of Resource-Exhaustion Vulnerabilities",
          "Publication": "Proceedings of the IEEE International Symposium on Software Reliability Engineering (ISSRE)",
          "PublicationYear": "2008",
          "PublicationMonth": "11",
          "URL": "http://homepages.di.fc.ul.pt/~nuno/PAPERS/ISSRE08.pdf"
        },
        {
          "ExternalReferenceID": "REF-387",
          "Authors": [
            "D.J. Bernstein"
          ],
          "Title": "Resource exhaustion",
          "URL": "http://cr.yp.to/docs/resources.html"
        },
        {
          "ExternalReferenceID": "REF-388",
          "Authors": [
            "Pascal Meunier"
          ],
          "Title": "Resource exhaustion",
          "Publication": "Secure Programming Educational Material",
          "PublicationYear": "2004",
          "URL": "http://homes.cerias.purdue.edu/~pmeunier/secprog/sanitized/class1/6.resource%20exhaustion.ppt"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 17, \"Protecting Against Denial of Service Attacks\" Page 517",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "CWE-400 is intended for incorrect behaviors in which the product is expected to track and restrict how many resources it consumes, but CWE-400 is often misused because it is conflated with the \"technical impact\" of vulnerabilities in which resource consumption occurs. It is sometimes used for low-information vulnerability reports. It is a level-1 Class (i.e., a child of a Pillar).",
        "Comments": "Closely analyze the specific mistake that is causing resource consumption, and perform a CWE mapping for that mistake. Consider children/descendants such as CWE-770: Allocation of Resources Without Limits or Throttling, CWE-771: Missing Reference to Active Allocated Resource, CWE-410: Insufficient Resource Pool, CWE-772: Missing Release of Resource after Effective Lifetime, CWE-834: Excessive Iteration, CWE-405: Asymmetric Resource Consumption (Amplification), and others.",
        "Reasons": [
          "Frequent Misuse"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "\"Resource consumption\" could be interpreted as a consequence instead of an insecure behavior, so this entry is being considered for modification. It appears to be referenced too frequently when more precise mappings are available. Some of its children, such as CWE-771, might be better considered as a chain."
        },
        {
          "Type": "Theoretical",
          "Note": "Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect the underlying weaknesses that enable these attacks (or consequences) to take place."
        },
        {
          "Type": "Other",
          "Note": "\n\nDatabase queries that take a long time to process are good DoS targets. An attacker would have to write a few lines of Perl code to generate enough traffic to exceed the site's ability to keep up. This would effectively prevent authorized users from using the site at all. Resources can be exploited simply by ensuring that the target machine must do much more work and consume more resources in order to service a request than the attacker must do to initiate a request.\n\n\nA prime example of this can be found in old switches that were vulnerable to \"macof\" attacks (so named for a tool developed by Dugsong). These attacks flooded a switch with random IP and MAC address combinations, therefore exhausting the switch's cache, which held the information of which port corresponded to which MAC addresses. Once this cache was exhausted, the switch would fail in an insecure way and would begin to act simply as a hub, broadcasting all traffic on all ports and allowing for basic sniffing attacks.\n"
        },
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "401",
      "Name": "Missing Release of Memory after Effective Lifetime",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
      "ExtendedDescription": "This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "772",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1305",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Memory Leak"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "\n\nMemory leaks have two common and sometimes overlapping causes:\n\n\n  - Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory\n\n"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "DoS: Instability",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "Most memory leaks result in general product reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker might be able to launch a denial of service attack (by crashing or hanging the program) or take advantage of other unexpected program behavior resulting from a low memory condition."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-41",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nChoose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n\n\nWhen using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].\n\n\nTo help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an abstraction library to abstract away risky APIs. Not a complete solution."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Build and Compilation"
          ],
          "Description": "The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",
          "EffectivenessNotes": "This is not a complete solution as it is not 100% effective."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following C function leaks a block of allocated memory if the call to read() does not return the expected number of bytes:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* getBlock(int fd) {\n\t\t\tchar* buf = (char*) malloc(BLOCK_SIZE);\n\t\t\tif (!buf) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (read(fd, buf, BLOCK_SIZE) != BLOCK_SIZE) {\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn buf;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-3119",
          "Description": "Memory leak because function does not free() an element of a data structure.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3119"
        },
        {
          "Reference": "CVE-2004-0427",
          "Description": "Memory leak when counter variable is not decremented.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0427"
        },
        {
          "Reference": "CVE-2002-0574",
          "Description": "chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0574"
        },
        {
          "Reference": "CVE-2005-3181",
          "Description": "Kernel uses wrong function to release a data structure, preventing data from being properly tracked by other code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3181"
        },
        {
          "Reference": "CVE-2004-0222",
          "Description": "Memory leak via unknown manipulations as part of protocol test suite.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0222"
        },
        {
          "Reference": "CVE-2001-0136",
          "Description": "Memory leak via a series of the same command.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0136"
        }
      ],
      "FunctionalAreas": [
        "Memory Management"
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Memory leak"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Memory Leak"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to deallocate data"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory when no longer needed",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC04-J",
          "EntryName": "Do not leak memory"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to Release Resource"
        },
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-14"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-390",
          "Authors": [
            "J. Whittaker",
            "H. Thompson"
          ],
          "Title": "How to Break Software Security",
          "PublicationYear": "2003",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-391",
          "Authors": [
            "iOS Developer Library"
          ],
          "Title": "Transitioning to ARC Release Notes",
          "PublicationYear": "2013",
          "PublicationMonth": "08",
          "PublicationDay": "08",
          "URL": "https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-14",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is often a resultant weakness due to improper handling of malformed data or early termination of sessions."
        },
        {
          "Type": "Terminology",
          "Note": "\"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict)."
        }
      ]
    },
    {
      "ID": "402",
      "Name": "Transmission of Private Resources into a New Sphere ('Resource Leak')",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product makes resources available to untrusted parties when those resources are only intended to be accessed by the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Resource Leak"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0740",
          "Description": "Server leaks a privileged file descriptor, allowing the server to be hijacked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0740"
        },
        {
          "Reference": "CVE-2004-1033",
          "Description": "File descriptor leak allows read of restricted files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1033"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Resource leaks"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "403",
      "Name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.",
      "ExtendedDescription": "When a new process is forked or executed, the child process inherits any open file descriptors. When the child process has fewer privileges than the parent process, this might introduce a vulnerability if the child process can access the file descriptor but does not have the privileges to access the associated file.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "402",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Unix",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "File descriptor leak",
          "Description": "While this issue is frequently called a file descriptor leak, the \"leak\" term is often used in two different ways - exposure of a resource, or consumption of a resource. Use of this term could cause confusion."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0740",
          "Description": "Server leaks a privileged file descriptor, allowing the server to be hijacked.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0740"
        },
        {
          "Reference": "CVE-2004-1033",
          "Description": "File descriptor leak allows read of restricted files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1033"
        },
        {
          "Reference": "CVE-2000-0094",
          "Description": "Access to restricted resource using modified file descriptor for stderr.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0094"
        },
        {
          "Reference": "CVE-2002-0638",
          "Description": "Open file descriptor used as alternate channel in complex race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0638"
        },
        {
          "Reference": "CVE-2003-0489",
          "Description": "Program does not fully drop privileges after creating a file descriptor, which allows access to the descriptor via a separate vulnerability.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0489"
        },
        {
          "Reference": "CVE-2003-0937",
          "Description": "User bypasses restrictions by obtaining a file descriptor then calling setuid program, which does not close the descriptor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0937"
        },
        {
          "Reference": "CVE-2004-2215",
          "Description": "Terminal manager does not properly close file descriptors, allowing attackers to access terminals of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2215"
        },
        {
          "Reference": "CVE-2006-5397",
          "Description": "Module opens a file for reading twice, allowing attackers to read files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5397"
        }
      ],
      "AffectedResources": [
        "System Process",
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "UNIX file descriptor leak"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Ensure files are properly closed when they are no longer needed"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-392",
          "Authors": [
            "Paul Roberts"
          ],
          "Title": "File descriptors and setuid applications",
          "PublicationYear": "2007",
          "PublicationMonth": "02",
          "PublicationDay": "05",
          "URL": "https://blogs.oracle.com/paulr/entry/file_descriptors_and_setuid_applications"
        },
        {
          "ExternalReferenceID": "REF-393",
          "Section": "Elevating Privileges Safely",
          "Authors": [
            "Apple"
          ],
          "Title": "Introduction to Secure Coding Guide",
          "URL": "https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/AccessControl.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "404",
      "Name": "Improper Resource Shutdown or Release",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not release or incorrectly releases a resource before it is made available for re-use.",
      "ExtendedDescription": "When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation, such as a set period of time or revocation.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "405",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "619",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "Improper release or shutdown of resources can be primary to resource exhaustion, performance, and information confidentiality problems to name a few."
        },
        {
          "Ordinality": "Resultant",
          "Description": "Improper release or shutdown of resources can be resultant from improper error handling or insufficient resource tracking."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Other"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)",
            "Varies by Context"
          ],
          "Note": "Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "When a resource containing sensitive information is not correctly shutdown, it may expose the sensitive data in a subsequent allocation."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "\n\nThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n\n\nResource clean up errors might be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n",
          "Effectiveness": "Moderate"
        },
        {
          "DetectionMethodID": "DM-12",
          "Method": "Manual Dynamic Analysis",
          "Description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the product under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free memory in a function. If you allocate memory that you intend to free upon completion of the function, you must be sure to free the memory at all exit points for that function including error conditions."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Memory should be allocated/freed using matching functions such as malloc/free, new/delete, and new[]/delete[]."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When releasing a complex object or structure, ensure that you properly dispose of all of its member components, not just the object itself."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-81",
          "Entries": [
            {
              "IntroText": "The following method never closes the new file handle. Given enough time, the Finalize() method for BufferReader should eventually call Close(), but there is no guarantee as to how long this action will take. In fact, there is no guarantee that Finalize() will ever be invoked. In a busy environment, the Operating System could use up all of the available file handles before the Close() function is called."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void processFile(string fName)\n\t{\n\t\tBufferReader fil = new BufferReader(new FileReader(fName));\n\t\tString line;\n\t\twhile ((line = fil.ReadLine()) != null)\n\t\t{\n\t\t\tprocessLine(line);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The good code example simply adds an explicit call to the Close() function when the system is done using the file. Within a simple example such as this the problem is easy to see and fix. In a real system, the problem may be considerably more obscure."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void processFile(string fName)\n\t{\n\t\tBufferReader fil = new BufferReader(new FileReader(fName));\n\t\tString line;\n\t\twhile ((line = fil.ReadLine()) != null)\n\t\t{\n\t\t\tprocessLine(line);\n\t\t}\n\t\tfil.Close();\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-82",
          "Entries": [
            {
              "IntroText": "This code attempts to open a connection to a database and catches any exceptions that may occur."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tConnection con = DriverManager.getConnection(some_connection_string);\n\t}\n\tcatch ( Exception e ) {\n\t\tlog( e );\n\t}\n```"
            },
            {
              "BodyText": "If an exception occurs after establishing the database connection and before the same connection closes, the pool of database connections may become exhausted. If the number of available connections is exceeded, other users cannot access this resource, effectively denying access to the application."
            }
          ]
        },
        {
          "ID": "DX-83",
          "Entries": [
            {
              "IntroText": "Under normal conditions the following C# code executes a database query, processes the results returned by the database, and closes the allocated SqlConnection object. But if an exception occurs while executing the SQL or processing the results, the SqlConnection object is not closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\tSqlConnection conn = new SqlConnection(connString);\n\tSqlCommand cmd = new SqlCommand(queryString);\n\tcmd.Connection = conn;\n\tconn.Open();\n\tSqlDataReader rdr = cmd.ExecuteReader();\n\tHarvestResults(rdr);\n\tconn.Connection.Close();\n\t...\n```"
            }
          ]
        },
        {
          "ID": "DX-84",
          "Entries": [
            {
              "IntroText": "The following C function does not close the file handle it opens if an error occurs. If the process is long-lived, the process can run out of file handles."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint decodeFile(char* fName) {\n\t\t\tchar buf[BUF_SZ];\n\t\t\tFILE* f = fopen(fName, \"r\");\n\t\t\tif (!f) {\n\t\t\t\tprintf(\"cannot open %s\\n\", fName);\n\t\t\t\treturn DECODE_FAIL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\twhile (fgets(buf, BUF_SZ, f)) {\n\t\t\t\t\t\tif (!checkChecksum(buf)) {\n\t\t\t\t\t\t\treturn DECODE_FAIL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdecodeBlock(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(f);\n\t\t\treturn DECODE_SUCCESS;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-85",
          "Entries": [
            {
              "IntroText": "In this example, the program does not use matching functions such as malloc/free, new/delete, and new[]/delete[] to allocate/deallocate the resource."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass A {\n\t\tvoid foo();\n\t};\n\tvoid A::foo(){\n\t\tint *ptr;\n\t\tptr = (int*)malloc(sizeof(int));\n\t\tdelete ptr;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-86",
          "Entries": [
            {
              "IntroText": "In this example, the program calls the delete[] function on non-heap memory."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass A{\n\t\tvoid foo(bool);\n\t};\n\tvoid A::foo(bool heap) {\n\t\tint localArray[2] = {\n\t\t\t11,22\n\t\t};\n\t\tint *p = localArray;\n\t\tif (heap){\n\t\t\tp = new int[2];\n\t\t}\n\t\tdelete[] p;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1127",
          "Description": "Does not shut down named pipe connections if malformed data is sent.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1127"
        },
        {
          "Reference": "CVE-2001-0830",
          "Description": "Sockets not properly closed when attacker repeatedly connects and disconnects from server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0830"
        },
        {
          "Reference": "CVE-2002-1372",
          "Description": "Chain: Return values of file/socket operations are not checked (CWE-252), allowing resultant consumption of file descriptors (CWE-772).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1372"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Improper resource shutdown or release"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Unreleased Resource"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory when no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO04-J",
          "EntryName": "Release resources when they are no longer needed"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to release resource"
        }
      ],
      "RelatedAttackPatterns": [
        "125",
        "130",
        "131",
        "494",
        "495",
        "496",
        "666"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 8: C++ Catastrophes.\" Page 143",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps memory leaks, asymmetric resource consumption, malformed input errors."
        }
      ]
    },
    {
      "ID": "405",
      "Name": "Asymmetric Resource Consumption (Amplification)",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly control situations in which an adversary can cause the product to consume or produce excessive resources without requiring the adversary to invest equivalent work or otherwise prove authorization, i.e., the adversary's influence is \"asymmetric.\"",
      "ExtendedDescription": "This can lead to poor performance due to \"amplification\" of resource consumption, typically in a non-linear fashion. This situation is worsened if the product allows malicious users or attackers to consume more resources than their access level permits.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Architecture",
          "Class": "Not Architecture-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Client Server",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Amplification",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Likelihood": [
            "High"
          ],
          "Note": "Sometimes this is a factor in \"flood\" attacks, but other types of amplification exist."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "An application must make resources available to a client commensurate with the client's access level."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "An application must, at all times, keep track of allocated resources and meter their usage appropriately."
        },
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Consider disabling resource-intensive algorithms on the server side, such as Diffie-Hellman key exchange.",
          "Effectiveness": "High",
          "EffectivenessNotes": "Business requirements may prevent disabling resource-intensive algorithms."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-113",
          "Entries": [
            {
              "IntroText": "This code listens on a port for DNS requests and sends the result to the requesting address."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\tsock.bind( (UDP_IP,UDP_PORT) )\n\twhile true:\n\t\t\tdata = sock.recvfrom(1024)\n\t\t\tif not data:\n\t\t\t\tbreak\n\t\t\t(requestIP, nameToResolve) = parseUDPpacket(data)\n\t\t\trecord = resolveName(nameToResolve)\n\t\t\tsendResponse(requestIP,record)\n```"
            },
            {
              "BodyText": "This code sends a DNS record to a requesting IP address. UDP allows the source IP address to be easily changed ('spoofed'), thus allowing an attacker to redirect responses to a target, which may be then be overwhelmed by the network traffic."
            }
          ]
        },
        {
          "ID": "DX-157",
          "Entries": [
            {
              "IntroText": "This function prints the contents of a specified file requested by a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction printFile($username,$filename){\n```\n//read file into string* \n\t\t\t$file = file_get_contents($filename);\n\t\t\tif ($file && isOwnerOf($username,$filename)){\n\t\t\t```\n\t\t\t\techo $file;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'You are not authorized to view this file';\n\t\t\t}\n\t\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "This code first reads a specified file into memory, then prints the file if the user is authorized to see its contents. The read of the file into memory may be resource intensive and is unnecessary if the user is not allowed to see the file anyway."
            }
          ]
        },
        {
          "ID": "DX-53",
          "Entries": [
            {
              "IntroText": "The DTD and the very brief XML below illustrate what is meant by an XML bomb. The ZERO entity contains one character, the letter A. The choice of entity name ZERO is being used to indicate length equivalent to that exponent on two, that is, the length of ZERO is 2^0. Similarly, ONE refers to ZERO twice, therefore the XML parser will expand ONE to a length of 2, or 2^1. Ultimately, we reach entity THIRTYTWO, which will expand to 2^32 characters in length, or 4 GB, probably consuming far more data than expected."
            },
            {
              "Nature": "Attack",
              "Language": "XML",
              "ExampleCode": "```\n\t<?xml version=\"1.0\"?>\n\t<!DOCTYPE MaliciousDTD [\n\t<!ENTITY ZERO \"A\">\n\t<!ENTITY ONE \"&ZERO;&ZERO;\">\n\t<!ENTITY TWO \"&ONE;&ONE;\">\n\t...\n\t<!ENTITY THIRTYTWO \"&THIRTYONE;&THIRTYONE;\">\n\t]>\n\t<data>&THIRTYTWO;</data>\n```"
            }
          ]
        },
        {
          "ID": "DX-158",
          "Entries": [
            {
              "IntroText": "This example attempts to check if an input string is a \"sentence\" [REF-1164]."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var bad_pattern = /^(\\w+\\s?)*$/i;\n var result = test_string.search(bad_pattern);"
            },
            {
              "BodyText": "The regular expression has a vulnerable backtracking clause inside (\\w+\\s?)*$ which can be triggered to cause a Denial of Service by processing particular phrases.\n\n\nTo fix the backtracking problem, backtracking is removed with the ?= portion of the expression which changes it to a lookahead and the \\2 which prevents the backtracking. The modified example is:"
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var good_pattern = /^((?=(\\w+))\\2\\s?)*$/i;\n var result = test_string.search(good_pattern);"
            },
            {
              "BodyText": "Note that [REF-1164] has a more thorough (and lengthy) explanation of everything going on within the RegEx."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "An adversary can cause significant resource consumption on a server by filtering the cryptographic algorithms offered by the client to the ones that are the most resource-intensive on the server side. After discovering which cryptographic algorithms are supported by the server, a malicious client can send the initial cryptographic handshake messages that contains only the resource-intensive algorithms. For some cryptographic protocols, these messages can be completely prefabricated, as the resource-intensive part of the handshake happens on the server-side first (such as TLS), rather than on the client side. In the case of cryptographic protocols where the resource-intensive part should happen on the client-side first (such as SSH), a malicious client can send a forged/precalculated computation result, which seems correct to the server, so the resource-intensive part of the handshake is going to happen on the server side. A malicious client is required to send only the initial messages of a cryptographic handshake to initiate the resource-consuming part of the cryptographic handshake. These messages are usually small, and generating them requires minimal computational effort, enabling a denial-of-service attack. An additional risk is the fact that higher key size increases the effectiveness of the attack. Cryptographic protocols where the clients have influence over the size of the used key (such as TLS 1.3 or SSH) are most at risk, as the client can enforce the highest key size supported by the server."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-0513",
          "Description": "Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0513"
        },
        {
          "Reference": "CVE-2003-1564",
          "Description": "Parsing library allows XML bomb",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1564"
        },
        {
          "Reference": "CVE-2004-2458",
          "Description": "Tool creates directories before authenticating user.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2458"
        },
        {
          "Reference": "CVE-2020-10735",
          "Description": "Python has \"quadratic complexity\" issue when converting string to int with many digits in unexpected bases",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10735"
        },
        {
          "Reference": "CVE-2020-5243",
          "Description": "server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5243"
        },
        {
          "Reference": "CVE-2013-5211",
          "Description": "composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-5211"
        },
        {
          "Reference": "CVE-2002-20001",
          "Description": "Diffie-Hellman (DHE) Key Agreement Protocol allows attackers to send arbitrary numbers that are not public keys, which causes the server to perform expensive, unnecessary computation of modular exponentiation.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-20001"
        },
        {
          "Reference": "CVE-2022-40735",
          "Description": "The Diffie-Hellman Key Agreement Protocol allows use of long exponents, which are more computationally expensive than using certain \"short exponents\" with particular properties.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-40735"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Asymmetric resource consumption (amplification)"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "41",
          "EntryName": "XML Attribute Blowup"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "TPS00-J",
          "EntryName": "Use thread pools to enable graceful degradation of service during traffic bursts"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO04-J",
          "EntryName": "Release resources when they are no longer needed"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1164",
          "Authors": [
            "Ilya Kantor"
          ],
          "Title": "Catastrophic backtracking",
          "PublicationYear": "2020",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://javascript.info/regexp-catastrophic-backtracking"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "406",
      "Name": "Insufficient Control of Network Message Volume (Network Amplification)",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not sufficiently monitor or control transmitted network traffic volume, so that an actor can cause the product to transmit more traffic than should be allowed for that actor.",
      "ExtendedDescription": "In the absence of a policy to restrict asymmetric resource consumption, the application or system cannot distinguish between legitimate transmissions and traffic intended to serve as an amplifying attack on target systems. Systems can often be configured to restrict the amount of traffic sent out on behalf of a client, based on the client's origin or access level. This is usually defined in a resource allocation policy. In the absence of a mechanism to keep track of transmissions, the system or application can be easily abused to transmit asymmetrically greater traffic than the request or client should be permitted to.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation"
        },
        {
          "Phase": "Architecture and Design",
          "Note": "If the application uses UDP, then it could potentially be subject to spoofing attacks that use the inherent weaknesses of UDP to perform traffic amplification, although this problem can exist in other protocols or contexts."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Amplification",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "System resources can be quickly consumed leading to poor application performance or system crash. This may affect network performance and could be used to attack other systems and applications relying on network performance."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "An application must make network resources available to a client commensurate with the client's access level."
        },
        {
          "Phase": [
            "Policy"
          ],
          "Description": "Define a clear policy for network resource allocation and consumption."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "An application must, at all times, keep track of network resources and meter their usage appropriately."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-113",
          "Entries": [
            {
              "IntroText": "This code listens on a port for DNS requests and sends the result to the requesting address."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\tsock.bind( (UDP_IP,UDP_PORT) )\n\twhile true:\n\t\t\tdata = sock.recvfrom(1024)\n\t\t\tif not data:\n\t\t\t\tbreak\n\t\t\t(requestIP, nameToResolve) = parseUDPpacket(data)\n\t\t\trecord = resolveName(nameToResolve)\n\t\t\tsendResponse(requestIP,record)\n```"
            },
            {
              "BodyText": "This code sends a DNS record to a requesting IP address. UDP allows the source IP address to be easily changed ('spoofed'), thus allowing an attacker to redirect responses to a target, which may be then be overwhelmed by the network traffic."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-0513",
          "Description": "Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0513"
        },
        {
          "Reference": "CVE-1999-1379",
          "Description": "DNS query with spoofed source address causes more traffic to be returned to spoofed address than was sent by the attacker.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1379"
        },
        {
          "Reference": "CVE-2000-0041",
          "Description": "Large datagrams are sent in response to malformed datagrams.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0041"
        },
        {
          "Reference": "CVE-1999-1066",
          "Description": "Game server sends a large amount.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1066"
        },
        {
          "Reference": "CVE-2013-5211",
          "Description": "composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-5211"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Network Amplification"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be resultant from weaknesses that simplify spoofing attacks."
        },
        {
          "Type": "Theoretical",
          "Note": "Network amplification, when performed with spoofing, is normally a multi-channel attack from attacker (acting as user) to amplifier, and amplifier to victim."
        }
      ]
    },
    {
      "ID": "407",
      "Name": "Inefficient Algorithmic Complexity",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "An algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Quadratic Complexity",
          "Description": "Used when the algorithmic complexity is related to the square of the number of inputs (N^2)"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "The typical consequence is CPU consumption, but memory consumption and consumption of other resources can also occur."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-158",
          "Entries": [
            {
              "IntroText": "This example attempts to check if an input string is a \"sentence\" [REF-1164]."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var bad_pattern = /^(\\w+\\s?)*$/i;\n var result = test_string.search(bad_pattern);"
            },
            {
              "BodyText": "The regular expression has a vulnerable backtracking clause inside (\\w+\\s?)*$ which can be triggered to cause a Denial of Service by processing particular phrases.\n\n\nTo fix the backtracking problem, backtracking is removed with the ?= portion of the expression which changes it to a lookahead and the \\2 which prevents the backtracking. The modified example is:"
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var good_pattern = /^((?=(\\w+))\\2\\s?)*$/i;\n var result = test_string.search(good_pattern);"
            },
            {
              "BodyText": "Note that [REF-1164] has a more thorough (and lengthy) explanation of everything going on within the RegEx."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-32617",
          "Description": "C++ library for image metadata has \"quadratic complexity\" issue with unnecessarily repetitive parsing each time an invalid character is encountered",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-32617"
        },
        {
          "Reference": "CVE-2020-10735",
          "Description": "Python has \"quadratic complexity\" issue when converting string to int with many digits in unexpected bases",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-10735"
        },
        {
          "Reference": "CVE-2020-5243",
          "Description": "server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5243"
        },
        {
          "Reference": "CVE-2014-1474",
          "Description": "Perl-based email address parser has \"quadratic complexity\" issue via a string that does not contain a valid address",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1474"
        },
        {
          "Reference": "CVE-2003-0244",
          "Description": "CPU consumption via inputs that cause many hash table collisions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0244"
        },
        {
          "Reference": "CVE-2003-0364",
          "Description": "CPU consumption via inputs that cause many hash table collisions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0364"
        },
        {
          "Reference": "CVE-2002-1203",
          "Description": "Product performs unnecessary processing before dropping an invalid packet.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1203"
        },
        {
          "Reference": "CVE-2001-1501",
          "Description": "CPU and memory consumption using many wildcards.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1501"
        },
        {
          "Reference": "CVE-2004-2527",
          "Description": "Product allows attackers to cause multiple copies of a program to be loaded more quickly than the program can detect that other copies are running, then exit. This type of error should probably have its own category, where teardown takes more time than initialization.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2527"
        },
        {
          "Reference": "CVE-2006-6931",
          "Description": "Network monitoring system allows remote attackers to cause a denial of service (CPU consumption and detection outage) via crafted network traffic, aka a \"backtracking attack.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6931"
        },
        {
          "Reference": "CVE-2006-3380",
          "Description": "Wiki allows remote attackers to cause a denial of service (CPU consumption) by performing a diff between large, crafted pages that trigger the worst case algorithmic complexity.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3380"
        },
        {
          "Reference": "CVE-2006-3379",
          "Description": "Wiki allows remote attackers to cause a denial of service (CPU consumption) by performing a diff between large, crafted pages that trigger the worst case algorithmic complexity.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3379"
        },
        {
          "Reference": "CVE-2005-2506",
          "Description": "OS allows attackers to cause a denial of service (CPU consumption) via crafted Gregorian dates.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2506"
        },
        {
          "Reference": "CVE-2005-1792",
          "Description": "Memory leak by performing actions faster than the software can clear them.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1792"
        }
      ],
      "FunctionalAreas": [
        "Cryptography"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Algorithmic Complexity"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-395",
          "Authors": [
            "Scott A. Crosby",
            "Dan S. Wallach"
          ],
          "Title": "Algorithmic Complexity Attacks",
          "Publication": "Proceedings of the 12th USENIX Security Symposium",
          "PublicationYear": "2003",
          "PublicationMonth": "08",
          "URL": "https://www.usenix.org/legacy/events/sec03/tech/full_papers/crosby/crosby.pdf"
        },
        {
          "ExternalReferenceID": "REF-1164",
          "Authors": [
            "Ilya Kantor"
          ],
          "Title": "Catastrophic backtracking",
          "PublicationYear": "2020",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://javascript.info/regexp-catastrophic-backtracking"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "408",
      "Name": "Incorrect Behavior Order: Early Amplification",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product allows an entity to perform a legitimate but expensive operation before authentication or authorization has taken place.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "696",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Amplification",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "System resources, CPU and memory, can be quickly consumed. This can lead to poor system performance or system crash."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-157",
          "Entries": [
            {
              "IntroText": "This function prints the contents of a specified file requested by a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction printFile($username,$filename){\n```\n//read file into string* \n\t\t\t$file = file_get_contents($filename);\n\t\t\tif ($file && isOwnerOf($username,$filename)){\n\t\t\t```\n\t\t\t\techo $file;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'You are not authorized to view this file';\n\t\t\t}\n\t\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "This code first reads a specified file into memory, then prints the file if the user is authorized to see its contents. The read of the file into memory may be resource intensive and is unnecessary if the user is not allowed to see the file anyway."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-2458",
          "Description": "Tool creates directories before authenticating user.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2458"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Early Amplification"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps authentication errors."
        }
      ]
    },
    {
      "ID": "409",
      "Name": "Improper Handling of Highly Compressed Data (Data Amplification)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not handle or incorrectly handles a compressed input with a very high compression ratio that produces a large output.",
      "ExtendedDescription": "An example of data amplification is a \"decompression bomb,\" a small ZIP file that can produce a large amount of data when it is decompressed.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Amplification",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "System resources, CPU and memory, can be quickly consumed. This can lead to poor system performance or system crash."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-53",
          "Entries": [
            {
              "IntroText": "The DTD and the very brief XML below illustrate what is meant by an XML bomb. The ZERO entity contains one character, the letter A. The choice of entity name ZERO is being used to indicate length equivalent to that exponent on two, that is, the length of ZERO is 2^0. Similarly, ONE refers to ZERO twice, therefore the XML parser will expand ONE to a length of 2, or 2^1. Ultimately, we reach entity THIRTYTWO, which will expand to 2^32 characters in length, or 4 GB, probably consuming far more data than expected."
            },
            {
              "Nature": "Attack",
              "Language": "XML",
              "ExampleCode": "```\n\t<?xml version=\"1.0\"?>\n\t<!DOCTYPE MaliciousDTD [\n\t<!ENTITY ZERO \"A\">\n\t<!ENTITY ONE \"&ZERO;&ZERO;\">\n\t<!ENTITY TWO \"&ONE;&ONE;\">\n\t...\n\t<!ENTITY THIRTYTWO \"&THIRTYONE;&THIRTYONE;\">\n\t]>\n\t<data>&THIRTYTWO;</data>\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-1955",
          "Description": "XML bomb in web server module",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1955"
        },
        {
          "Reference": "CVE-2003-1564",
          "Description": "Parsing library allows XML bomb",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1564"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Data Amplification"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "IDS04-J",
          "EntryName": "Limit the size of files passed to ZipInputStream"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "410",
      "Name": "Insufficient Resource Pool",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.",
      "ExtendedDescription": "Frequently the consequence is a \"flood\" of connection or sessions.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "400",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity",
            "Other"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Other"
          ],
          "Note": "Floods often cause a crash or other problem besides denial of the resource itself; these are likely examples of *other* vulnerabilities, not an insufficient resource pool."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not perform resource-intensive transactions for unauthenticated users and/or invalid requests."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider implementing a velocity check mechanism which would detect abusive behavior."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Consider load balancing as an option to handle heavy loads."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Make sure that resource handles are properly closed when no longer needed."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify the system's resource intensive operations and consider protecting them from abuse (e.g. malicious automated script which runs the resources out)."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following snippet from a Tomcat configuration file, a JDBC connection pool is defined with a maximum of 5 simultaneous connections (with a 60 second timeout). In this case, it may be trivial for an attacker to instigate a denial of service (DoS) by using up all of the available connections in the pool."
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<Resource name=\"jdbc/exampledb\"\n\tauth=\"Container\"\n\ttype=\"javax.sql.DataSource\"\n\tremoveAbandoned=\"true\"\n\tremoveAbandonedTimeout=\"30\"\n\tmaxActive=\"5\"\n\tmaxIdle=\"5\"\n\tmaxWait=\"60000\"\n\tusername=\"testuser\"\n\tpassword=\"testpass\"\n\tdriverClassName=\"com.mysql.jdbc.Driver\"\n\turl=\"jdbc:mysql://localhost/exampledb\"/>\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1363",
          "Description": "Large number of locks on file exhausts the pool and causes crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1363"
        },
        {
          "Reference": "CVE-2001-1340",
          "Description": "Product supports only one connection and does not disconnect a user who does not provide credentials.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1340"
        },
        {
          "Reference": "CVE-2002-0406",
          "Description": "Large number of connections without providing credentials allows connection exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0406"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient Resource Pool"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "TPS00-J",
          "EntryName": "Use thread pools to enable graceful degradation of service during traffic bursts"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 17, \"Protecting Against Denial of Service Attacks\" Page 517",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "412",
      "Name": "Unrestricted Externally Accessible Lock",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product properly checks for the existence of a lock, but the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control.",
      "ExtendedDescription": "This prevents the product from acting on associated resources or performing other behaviors that are controlled by the presence of the lock. Relevant locks might include an exclusive lock or mutex, or modifying a shared resource that is treated as a lock. If the lock can be held for an indefinite period of time, then the denial of service could be permanent.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "410",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "When an attacker can control a lock, the program may wait indefinitely until the attacker releases the lock, causing a denial of service to other users of the program. This is especially problematic if there is a blocking operation on the lock."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "White Box",
          "Description": "Automated code analysis techniques might not be able to reliably detect this weakness, since the application's behavior and general security model dictate which resource locks are critical. Interpretation of the weakness might require knowledge of the environment, e.g. if the existence of a file is used as a lock, but the file is created in a world-writable directory."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Use any access control that is offered by the functionality that is offering the lock."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Use unpredictable names or identifiers for the locks. This might not always be possible or feasible."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider modifying your code to use non-blocking synchronization methods."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-69",
          "Entries": [
            {
              "IntroText": "This code tries to obtain a lock for a file, then writes to it."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction writeToLog($message){\n\t\t$logfile = fopen(\"logFile.log\", \"a\");\n```\n//attempt to get logfile lock* \n\t\tif (flock($logfile, LOCK_EX)) {\n\t\t```\n\t\t\tfwrite($logfile,$message);\n```\n// unlock logfile* \n\t\t\tflock($logfile, LOCK_UN);}\n\t\telse {\n\t\t```\n\t\t\tprint \"Could not obtain lock on logFile.log, message not recorded\\n\";\n\t\t}\n\t}\n\tfclose($logFile);\n```"
            },
            {
              "BodyText": "PHP by default will wait indefinitely until a file lock is released. If an attacker is able to obtain the file lock, this code will pause execution, possibly leading to denial of service for other users. Note that in this case, if an attacker can perform an flock() on the file, they may already have privileges to destroy the log file. However, this still impacts the execution of other programs that depend on flock()."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-0682",
          "Description": "Program can not execute when attacker obtains a mutex.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0682"
        },
        {
          "Reference": "CVE-2002-1914",
          "Description": "Program can not execute when attacker obtains a lock on a critical output file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1914"
        },
        {
          "Reference": "CVE-2002-1915",
          "Description": "Program can not execute when attacker obtains a lock on a critical output file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1915"
        },
        {
          "Reference": "CVE-2002-0051",
          "Description": "Critical file can be opened with exclusive read access by user, preventing application of security policy. Possibly related to improper permissions, large-window race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0051"
        },
        {
          "Reference": "CVE-2000-0338",
          "Description": "Chain: predictable file names used for locking, allowing attacker to create the lock beforehand. Resultant from permissions and randomness.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0338"
        },
        {
          "Reference": "CVE-2000-1198",
          "Description": "Chain: Lock files with predictable names. Resultant from randomness.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1198"
        },
        {
          "Reference": "CVE-2002-1869",
          "Description": "Product does not check if it can write to a log file, allowing attackers to avoid logging by accessing the file using an exclusive lock. Overlaps unchecked error condition. This is not quite CWE-412, but close.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1869"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unrestricted Critical Resource Lock"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Deadlock"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A9",
          "EntryName": "Denial of Service",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK00-J",
          "EntryName": "Use private final lock objects to synchronize classes that may interact with untrusted code"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK07-J",
          "EntryName": "Avoid deadlock by requesting and releasing locks in the same order"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP22",
          "EntryName": "Unrestricted lock"
        }
      ],
      "RelatedAttackPatterns": [
        "25"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This overlaps Insufficient Resource Pool when the \"pool\" is of size 1. It can also be resultant from race conditions, although the timing window could be quite large in some cases."
        }
      ]
    },
    {
      "ID": "413",
      "Name": "Improper Resource Locking",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not lock or does not correctly lock a resource when the product must have exclusive access to the resource.",
      "ExtendedDescription": "When a resource is not properly locked, an attacker could modify the resource while it is being operated on by the product. This might violate the product's assumption that the resource will not change, potentially leading to unexpected behaviors.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "DoS: Instability",
            "DoS: Crash, Exit, or Restart"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a non-conflicting privilege scheme."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Use synchronization when locking a resource."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This Java example shows a simple BankAccount class with deposit and withdraw methods."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// variable for bank account balance* \n\t\t\tprivate double accountBalance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount* \n\t\t\tpublic BankAccount() {\n\t\t\t```\n\t\t\t\taccountBalance = 0;\n\t\t\t}\n```\n// method to deposit amount into BankAccount* \n\t\t\tpublic void deposit(double depositAmount) {\n\t\t\t```\n\t\t\t\t\tdouble newBalance = accountBalance + depositAmount;\n\t\t\t\t\taccountBalance = newBalance;\n\t\t\t}\n```\n// method to withdraw amount from BankAccount* \n\t\t\tpublic void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t\tdouble newBalance = accountBalance - withdrawAmount;\n\t\t\t\t\taccountBalance = newBalance;\n\t\t\t}\n```\n// other methods for accessing the BankAccount object* \n\t\t\t...}"
            },
            {
              "BodyText": "However, the deposit and withdraw methods have shared access to the account balance private class variable. This can result in a race condition if multiple threads attempt to call the deposit and withdraw methods simultaneously where the account balance is modified by one thread before another thread has completed modifying the account balance. For example, if a thread attempts to withdraw funds using the withdraw method before another thread that is depositing funds using the deposit method completes the deposit then there may not be sufficient funds for the withdraw transaction."
            },
            {
              "BodyText": "To prevent multiple threads from having simultaneous access to the account balance variable the deposit and withdraw methods should be synchronized using the synchronized modifier."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n\t\t\t...\n```\n// synchronized method to deposit amount into BankAccount* \n\t\t\tpublic synchronized void deposit(double depositAmount) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n```\n// synchronized method to withdraw amount from BankAccount* \n\t\t\tpublic synchronized void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "An alternative solution is to use a lock object to ensure exclusive access to the bank account balance variable. As shown below, the deposit and withdraw methods use the lock object to set a lock to block access to the BankAccount object from other threads until the method has completed updating the bank account balance variable."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n\t\t\t...\n```\n// lock object for thread access to methods* \n\t\t\tprivate ReentrantLock balanceChangeLock;\n\t\t\t\n\t\t\t\n\t\t\t *// condition object to temporarily release lock to other threads* \n\t\t\tprivate Condition sufficientFundsCondition;\n\t\t\t\n\t\t\t\n\t\t\t *// method to deposit amount into BankAccount* \n\t\t\tpublic void deposit(double amount) {\n\t\t\t```\n```\n// set lock to block access to BankAccount from other threads* \n\t\t\t\t\tbalanceChangeLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t```\n\t\t\t\t\t\t\tdouble newBalance = balance + amount;\n\t\t\t\t\t\t\tbalance = newBalance;\n```\n// inform other threads that funds are available* \n\t\t\t\t\t\t\tsufficientFundsCondition.signalAll();\n\t\t\t\t\t\t\t} catch (Exception e) {...}\n\t\t\t\t\tfinally {\n\t\t\t\t\t```\n\t\t\t\t\t\t// unlock lock object\n\t\t\t\t\t\tbalanceChangeLock.unlock();\n\t\t\t\t\t}\n\t\t\t}\n```\n// method to withdraw amount from bank account* \n\t\t\tpublic void withdraw(double amount) {\n\t\t\t```\n```\n// set lock to block access to BankAccount from other threads* \n\t\t\t\t\tbalanceChangeLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t```\n\t\t\t\t\t\t\twhile (balance < amount) {\n```\n// temporarily unblock access* \n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t *// until sufficient funds are available* \n\t\t\t\t\t\t\t\t\tsufficientFundsCondition.await();}\n\t\t\t\t\t\t\tdouble newBalance = balance - amount;\n\t\t\t\t\t\t\tbalance = newBalance;\n\t\t\t\t\t\t\t} catch (Exception e) {...}\n\t\t\t\t\tfinally {\n\t\t\t\t\t```\n\t\t\t\t\t\t// unlock lock object\n\t\t\t\t\t\tbalanceChangeLock.unlock();\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-20141",
          "Description": "Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-20141"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Insufficient Resource Locking"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA00-J",
          "EntryName": "Ensure visibility when accessing shared primitive variables"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "VNA02-J",
          "EntryName": "Ensure that compound operations on shared variables are atomic"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK00-J",
          "EntryName": "Use private final lock objects to synchronize classes that may interact with untrusted code"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "414",
      "Name": "Missing Lock Check",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A product does not check to see if a lock is present before performing sensitive operations on a resource.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "DoS: Instability",
            "DoS: Crash, Exit, or Restart"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "Implement a reliable lock mechanism."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-1056",
          "Description": "Product does not properly check if a lock is present, allowing other attackers to access functionality.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1056"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Lock Check"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP19",
          "EntryName": "Missing Lock"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "415",
      "Name": "Double Free",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
      "ExtendedDescription": "When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "825",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1341",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "666",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "416",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "123",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Double-free"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Doubly freeing memory may result in a write-what-where condition, allowing an attacker to execute arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Choose a language that provides automatic memory management."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a static analysis tool to find double free instances."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-149",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a double free vulnerability."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t char* ptr = (char*)malloc (SIZE);\n\t ...\n\t if (abrt) { \n\t\t free(ptr); \n\t }\n\t ...\n\t free(ptr); \n```"
            },
            {
              "BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"
            },
            {
              "BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"
            },
            {
              "BodyText": "Although some double free vulnerabilities are not much more complicated than this example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "While contrived, this code should be exploitable on Linux distributions that do not ship with heap-chunk check summing turned on."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#include <stdio.h>\n\t#include <unistd.h>\n\t#define BUFSIZE1 512\n\t#define BUFSIZE2 ((BUFSIZE1/2) - 8)\n\tint main(int argc, char **argv) {\n\t\tchar *buf1R1;\n\t\tchar *buf2R1;\n\t\tchar *buf1R2;\n\t\tbuf1R1 = (char *) malloc(BUFSIZE2);\n\t\tbuf2R1 = (char *) malloc(BUFSIZE2);\n\t\tfree(buf1R1);\n\t\tfree(buf2R1);\n\t\tbuf1R2 = (char *) malloc(BUFSIZE1);\n\t\tstrncpy(buf1R2, argv[1], BUFSIZE1-1);\n\t\tfree(buf2R1);\n\t\tfree(buf1R2);\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-5051",
          "Description": "Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5051"
        },
        {
          "Reference": "CVE-2004-0642",
          "Description": "Double free resultant from certain error conditions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0642"
        },
        {
          "Reference": "CVE-2004-0772",
          "Description": "Double free resultant from certain error conditions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0772"
        },
        {
          "Reference": "CVE-2005-1689",
          "Description": "Double free resultant from certain error conditions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1689"
        },
        {
          "Reference": "CVE-2003-0545",
          "Description": "Double free from invalid ASN.1 encoding.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0545"
        },
        {
          "Reference": "CVE-2003-1048",
          "Description": "Double free from malformed GIF.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1048"
        },
        {
          "Reference": "CVE-2005-0891",
          "Description": "Double free from malformed GIF.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0891"
        },
        {
          "Reference": "CVE-2002-0059",
          "Description": "Double free from malformed compressed data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0059"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "DFREE - Double-Free Vulnerability"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Double Free"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Doubly freeing memory"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM00-C",
          "EntryName": "Allocate and free memory in the same module, at the same level of abstraction"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM01-C",
          "EntryName": "Store a new value in pointers immediately after free()"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM30-C",
          "EntryName": "Do not access freed memory",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory exactly once"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP12",
          "EntryName": "Faulty Memory Release"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 8: C++ Catastrophes.\" Page 143",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Double Frees\", Page 379",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is usually resultant from another weakness, such as an unhandled error or race condition between threads. It could also be primary to weaknesses such as buffer overflows."
        },
        {
          "Type": "Theoretical",
          "Note": "It could be argued that Double Free would be most appropriately located as a child of \"Use after Free\", but \"Use\" and \"Release\" are considered to be distinct operations within vulnerability theory, therefore this is more accurately \"Release of a Resource after Expiration or Release\", which doesn't exist yet."
        }
      ]
    },
    {
      "ID": "416",
      "Name": "Use After Free",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Stable",
      "Diagram": "/data/images/CWE-416-Diagram.png",
      "Description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "825",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "120",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "123",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant",
          "Description": "If the product accesses a previously-freed pointer, then it means that a separate weakness or error already occurred previously, such as a race condition, an unexpected or poorly handled error condition, confusion over which part of the program is responsible for freeing the memory, performing the free too soon, etc."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Dangling pointer",
          "Description": "a pointer that no longer points to valid memory, often after it has been freed"
        },
        {
          "Term": "UAF",
          "Description": "commonly used acronym for Use After Free"
        },
        {
          "Term": "Use-After-Free"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory"
          ],
          "Note": "The use of previously freed memory may corrupt valid data, if the memory area in question has been allocated and used properly elsewhere."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If chunk consolidation occurs after the use of previously freed data, the process may crash when invalid data is used as chunk information."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If malicious data is entered before chunk consolidation can take place, it may be possible to take advantage of a write-what-where primitive to execute arbitrary code. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Language Selection",
          "Description": "Choose a language that provides automatic memory management."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "If a bug causes an attempted access of this pointer, then a NULL dereference could still lead to a crash or other unexpected behavior, but it will reduce or eliminate the risk of code execution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#include <stdio.h>\n\t#include <unistd.h>\n\t#define BUFSIZER1 512\n\t#define BUFSIZER2 ((BUFSIZER1/2) - 8)\n\tint main(int argc, char **argv) {\n\t\tchar *buf1R1;\n\t\tchar *buf2R1;\n\t\tchar *buf2R2;\n\t\tchar *buf3R2;\n\t\tbuf1R1 = (char *) malloc(BUFSIZER1);\n\t\tbuf2R1 = (char *) malloc(BUFSIZER1);\n\t\tfree(buf2R1);\n\t\tbuf2R2 = (char *) malloc(BUFSIZER2);\n\t\tbuf3R2 = (char *) malloc(BUFSIZER2);\n\t\tstrncpy(buf2R1, argv[1], BUFSIZER1-1);\n\t\tfree(buf1R1);\n\t\tfree(buf2R2);\n\t\tfree(buf3R2);\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code illustrates a use after free error:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\tif (err) {\n\t\tabrt = 1;\n\t\tfree(ptr);\n\t}\n\t...\n\tif (abrt) {\n\t\tlogError(\"operation aborted before commit\", ptr);\n\t}\n```"
            },
            {
              "BodyText": "When an error occurs, the pointer is immediately freed. However, this pointer is later incorrectly used in the logError function."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-20141",
          "Description": "Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-20141"
        },
        {
          "Reference": "CVE-2022-2621",
          "Description": "Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2621"
        },
        {
          "Reference": "CVE-2021-0920",
          "Description": "Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-0920"
        },
        {
          "Reference": "CVE-2020-6819",
          "Description": "Chain: race condition (CWE-362) leads to use-after-free (CWE-416), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6819"
        },
        {
          "Reference": "CVE-2010-4168",
          "Description": "Use-after-free triggered by closing a connection while data is still being transmitted.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4168"
        },
        {
          "Reference": "CVE-2010-2941",
          "Description": "Improper allocation for invalid data leads to use-after-free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2941"
        },
        {
          "Reference": "CVE-2010-2547",
          "Description": "certificate with a large number of Subject Alternate Names not properly handled in realloc, leading to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2547"
        },
        {
          "Reference": "CVE-2010-1772",
          "Description": "Timers are not disabled when a related object is deleted",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1772"
        },
        {
          "Reference": "CVE-2010-1437",
          "Description": "Access to a \"dead\" object that is being cleaned up",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1437"
        },
        {
          "Reference": "CVE-2010-1208",
          "Description": "object is deleted even with a non-zero reference count, and later accessed",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1208"
        },
        {
          "Reference": "CVE-2010-0629",
          "Description": "use-after-free involving request containing an invalid version number",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0629"
        },
        {
          "Reference": "CVE-2010-0378",
          "Description": "unload of an object that is currently being accessed by other functionality",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0378"
        },
        {
          "Reference": "CVE-2010-0302",
          "Description": "incorrectly tracking a reference count leads to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0302"
        },
        {
          "Reference": "CVE-2010-0249",
          "Description": "use-after-free related to use of uninitialized memory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0249"
        },
        {
          "Reference": "CVE-2010-0050",
          "Description": "HTML document with incorrectly-nested tags",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0050"
        },
        {
          "Reference": "CVE-2009-3658",
          "Description": "Use after free in ActiveX object by providing a malformed argument to a method",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3658"
        },
        {
          "Reference": "CVE-2009-3616",
          "Description": "use-after-free by disconnecting during data transfer, or a message containing incorrect data types",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3616"
        },
        {
          "Reference": "CVE-2009-3553",
          "Description": "disconnect during a large data transfer causes incorrect reference count, leading to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3553"
        },
        {
          "Reference": "CVE-2009-2416",
          "Description": "use-after-free found by fuzzing",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2416"
        },
        {
          "Reference": "CVE-2009-1837",
          "Description": "Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1837"
        },
        {
          "Reference": "CVE-2009-0749",
          "Description": "realloc generates new buffer and pointer, but previous pointer is still retained, leading to use after free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0749"
        },
        {
          "Reference": "CVE-2010-3328",
          "Description": "Use-after-free in web browser, probably resultant from not initializing memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3328"
        },
        {
          "Reference": "CVE-2008-5038",
          "Description": "use-after-free when one thread accessed memory that was freed by another thread",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5038"
        },
        {
          "Reference": "CVE-2008-0077",
          "Description": "assignment of malformed values to certain properties triggers use after free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0077"
        },
        {
          "Reference": "CVE-2006-4434",
          "Description": "mail server does not properly handle a long header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4434"
        },
        {
          "Reference": "CVE-2010-2753",
          "Description": "chain: integer overflow leads to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2753"
        },
        {
          "Reference": "CVE-2006-4997",
          "Description": "freed pointer dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4997"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        },
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Use After Free"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Using freed memory"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM00-C",
          "EntryName": "Allocate and free memory in the same module, at the same level of abstraction"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM01-C",
          "EntryName": "Store a new value in pointers immediately after free()"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM30-C",
          "EntryName": "Do not access freed memory",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP15",
          "EntryName": "Faulty Resource Use"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        },
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 8: C++ Catastrophes.\" Page 143",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "419",
      "Name": "Unprotected Primary Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a primary channel for administration or restricted functionality, but it does not properly protect the channel.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not expose administrative functionnality on the user UI."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect the administrative/restricted functionality with a strong authentication mechanism."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unprotected Primary Channel"
        }
      ],
      "RelatedAttackPatterns": [
        "383"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "420",
      "Name": "Unprotected Alternate Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product protects a primary channel, but it does not use the same level of protection for an alternate channel.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Identify all alternate channels and use the same protection mechanisms that are used for the primary channels."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-176",
          "Entries": [
            {
              "IntroText": "Register SECURE_ME is located at address 0xF00. A mirror of this register called COPY_OF_SECURE_ME is at location 0x800F00. The register SECURE_ME is protected from malicious agents and only allows access to select, while COPY_OF_SECURE_ME is not. \n\n\n Access control is implemented using an allowlist (as indicated by acl_oh_allowlist). The identity of the initiator of the transaction is indicated by the one hot input, incoming_id. This is checked against the acl_oh_allowlist (which contains a list of initiators that are allowed to access the asset). \n\n\n Though this example is shown in Verilog, it will apply to VHDL as well."
            },
            {
              "Nature": "Informative",
              "Language": "Verilog",
              "ExampleCode": "module foo_bar(data_out, data_in, incoming_id, address, clk, rst_n);\n output [31:0] data_out;\n input [31:0] data_in, incoming_id, address;\n input clk, rst_n;\n wire write_auth, addr_auth;\n reg [31:0] data_out, acl_oh_allowlist, q;\n assign write_auth = | (incoming_id & acl_oh_allowlist) ? 1 : 0; \n always @*\n\n```\n\t acl_oh_allowlist <= 32'h8312; \n assign addr_auth = (address == 32'hF00) ? 1: 0;\n always @ (posedge clk or negedge rst_n)\n\t if (!rst_n)\n\t\t begin\n\t\t\t q <= 32'h0;\n\t\t\t data_out <= 32'h0;\n\t\t end\n\t else\n\t\t begin\n\t\t\t q <= (addr_auth & write_auth) ? data_in: q;\n\t\t\t data_out <= q;\n\t\t end\n\t end\n endmodule\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "assign addr_auth = (address == 32'hF00) ? 1: 0;"
            },
            {
              "BodyText": "The bugged line of code is repeated in the Bad example above. The weakness arises from the fact that the SECURE_ME register can be modified by writing to the shadow register COPY_OF_SECURE_ME. The address of COPY_OF_SECURE_ME should also be included in the check. That buggy line of code should instead be replaced as shown in the Good Code Snippet below."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "assign addr_auth = (address == 32'hF00 || address == 32'h800F00) ? 1: 0;"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-8004",
          "Description": "When the internal flash is protected by blocking access on the Data Bus (DBUS), it can still be indirectly accessed through the Instruction Bus (IBUS).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8004"
        },
        {
          "Reference": "CVE-2002-0567",
          "Description": "DB server assumes that local clients have performed authentication, allowing attacker to directly connect to a process to load libraries and execute commands; a socket interface also exists (another alternate channel), so attack can be remote.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0567"
        },
        {
          "Reference": "CVE-2002-1578",
          "Description": "Product does not restrict access to underlying database, so attacker can bypass restrictions by directly querying the database.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1578"
        },
        {
          "Reference": "CVE-2003-1035",
          "Description": "User can avoid lockouts by using an API instead of the GUI to conduct brute force password guessing.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1035"
        },
        {
          "Reference": "CVE-2002-1863",
          "Description": "FTP service can not be disabled even when other access controls would require it.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1863"
        },
        {
          "Reference": "CVE-2002-0066",
          "Description": "Windows named pipe created without authentication/access control, allowing configuration modification.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0066"
        },
        {
          "Reference": "CVE-2004-1461",
          "Description": "Router management interface spawns a separate TCP connection after authentication, allowing hijacking by attacker coming from the same IP address.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1461"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unprotected Alternate Channel"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be primary to authentication errors, and resultant from unhandled error conditions."
        }
      ]
    },
    {
      "ID": "421",
      "Name": "Race Condition During Access to Alternate Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product opens an alternate channel to communicate with an authorized user, but the channel is accessible to other actors.",
      "ExtendedDescription": "This creates a race condition that allows an attacker to access the channel before the authorized user does.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "420",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-0351",
          "Description": "FTP \"Pizza Thief\" vulnerability. Attacker can connect to a port that was intended for use by another client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0351"
        },
        {
          "Reference": "CVE-2003-0230",
          "Description": "Product creates Windows named pipe during authentication that another attacker can hijack by connecting to it.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0230"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Alternate Channel Race Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-354",
          "Authors": [
            "Blake Watts"
          ],
          "Title": "Discovering and Exploiting Named Pipe Security Flaws for Fun and Profit",
          "PublicationYear": "2002",
          "PublicationMonth": "04",
          "URL": "https://www.blakewatts.com/blog/discovering-and-exploiting-named-pipe-security-flaws-for-fun-and-profit",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 13: Race Conditions.\" Page 205",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "422",
      "Name": "Unprotected Windows Messaging Channel ('Shatter')",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not properly verify the source of a message in the Windows Messaging System while running at elevated privileges, creating an alternate channel through which an attacker can directly send a message to the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "420",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "360",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Always verify and authenticate the source of the message."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0971",
          "Description": "Bypass GUI and access restricted dialog box.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0971"
        },
        {
          "Reference": "CVE-2002-1230",
          "Description": "Gain privileges via Windows message.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1230"
        },
        {
          "Reference": "CVE-2003-0350",
          "Description": "A control allows a change to a pointer for a callback function using Windows message.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0350"
        },
        {
          "Reference": "CVE-2003-0908",
          "Description": "Product launches Help functionality while running with raised privileges, allowing command execution using Windows message to access \"open file\" dialog.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0908"
        },
        {
          "Reference": "CVE-2004-0213",
          "Description": "Attacker uses Shatter attack to bypass GUI-enforced protection for CVE-2003-0908.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0213"
        },
        {
          "Reference": "CVE-2004-0207",
          "Description": "User can call certain API functions to modify certain properties of privileged programs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0207"
        }
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unprotected Windows Messaging Channel ('Shatter')"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP30",
          "EntryName": "Missing endpoint authentication"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-402",
          "Authors": [
            "Paget"
          ],
          "Title": "Exploiting design flaws in the Win32 API for privilege escalation. Or... Shatter Attacks - How to break Windows",
          "PublicationYear": "2002",
          "PublicationMonth": "08",
          "URL": "http://web.archive.org/web/20060115174629/http://security.tombom.co.uk/shatter.html"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Design Review.\" Page 34",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 12, \"Shatter Attacks\", Page 694",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps privilege errors and UI errors."
        },
        {
          "Type": "Research Gap",
          "Note": "\n\nPossibly under-reported, probably under-studied. It is suspected that a number of publicized vulnerabilities that involve local privilege escalation on Windows systems may be related to Shatter attacks, but they are not labeled as such.\n\n\nAlternate channel attacks likely exist in other operating systems and messaging models, e.g. in privileged X Windows applications, but examples are not readily available.\n"
        }
      ]
    },
    {
      "ID": "423",
      "Name": "DEPRECATED: Proxied Trusted Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because it was a duplicate of CWE-441. All content has been transferred to CWE-441.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "424",
      "Name": "Improper Protection of Alternate Path",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not sufficiently protect all possible paths that a user can take to access restricted functionality or resources.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "638",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Deploy different layers of protection to implement security in depth."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29238",
          "Description": "Access-control setting in web-based document collaboration tool is not properly implemented by the code, which prevents listing hidden directories but does not prevent direct requests to files in those directories.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29238"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Alternate Path Errors"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP35",
          "EntryName": "Insecure resource access"
        }
      ],
      "RelatedAttackPatterns": [
        "127",
        "554"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "425",
      "Name": "Direct Request ('Forced Browsing')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.",
      "ExtendedDescription": "Web applications susceptible to direct request attacks often make the false assumption that such resources can only be reached through a given navigation path and so only apply authorization at certain points in the path.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "862",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "862",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "288",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "424",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "471",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "98",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "forced browsing",
          "Description": "The \"forced browsing\" term could be misinterpreted to include weaknesses such as CSRF or XSS, so its use is discouraged."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data",
            "Execute Unauthorized Code or Commands",
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Description": "Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider using MVC based frameworks such as Struts."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "If forced browsing is possible, an attacker may be able to directly access a sensitive page by entering a URL similar to the following."
            },
            {
              "Nature": "Attack",
              "Language": "JSP",
              "ExampleCode": "```\n\thttp://somesite.com/someapplication/admin.jsp\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29238",
          "Description": "Access-control setting in web-based document collaboration tool is not properly implemented by the code, which prevents listing hidden directories but does not prevent direct requests to files in those directories.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29238"
        },
        {
          "Reference": "CVE-2022-23607",
          "Description": "Python-based HTTP library did not scope cookies to a particular domain such that \"supercookies\" could be sent to any domain on redirect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-23607"
        },
        {
          "Reference": "CVE-2004-2144",
          "Description": "Bypass authentication via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2144"
        },
        {
          "Reference": "CVE-2005-1892",
          "Description": "Infinite loop or infoleak triggered by direct requests.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1892"
        },
        {
          "Reference": "CVE-2004-2257",
          "Description": "Bypass auth/auth via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2257"
        },
        {
          "Reference": "CVE-2005-1688",
          "Description": "Direct request leads to infoleak by error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1688"
        },
        {
          "Reference": "CVE-2005-1697",
          "Description": "Direct request leads to infoleak by error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1697"
        },
        {
          "Reference": "CVE-2005-1698",
          "Description": "Direct request leads to infoleak by error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1698"
        },
        {
          "Reference": "CVE-2005-1685",
          "Description": "Authentication bypass via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1685"
        },
        {
          "Reference": "CVE-2005-1827",
          "Description": "Authentication bypass via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1827"
        },
        {
          "Reference": "CVE-2005-1654",
          "Description": "Authorization bypass using direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1654"
        },
        {
          "Reference": "CVE-2005-1668",
          "Description": "Access privileged functionality using direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1668"
        },
        {
          "Reference": "CVE-2002-1798",
          "Description": "Upload arbitrary files via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1798"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Direct Request aka 'Forced Browsing'"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A10",
          "EntryName": "Failure to Restrict URL Access",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A1",
          "EntryName": "Unvalidated Input",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2004",
          "EntryID": "A2",
          "EntryName": "Broken Access Control",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "34",
          "EntryName": "Predictable Resource Location"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP30",
          "EntryName": "Missing endpoint authentication"
        }
      ],
      "RelatedAttackPatterns": [
        "127",
        "143",
        "144",
        "668",
        "87"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Overlaps Modification of Assumed-Immutable Data (MAID), authorization errors, container errors; often primary to other weaknesses such as XSS and SQL injection."
        },
        {
          "Type": "Theoretical",
          "Note": "\"Forced browsing\" is a step-based manipulation involving the omission of one or more steps, whose order is assumed to be immutable. The application does not verify that the first step was performed successfully before the second step. The consequence is typically \"authentication bypass\" or \"path disclosure,\" although it can be primary to all kinds of weaknesses, especially in languages such as PHP, which allow external modification of assumed-immutable variables."
        }
      ]
    },
    {
      "ID": "426",
      "Name": "Untrusted Search Path",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Stable",
      "Description": "The product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control.",
      "ExtendedDescription": "\n\nThis might allow attackers to execute their own programs, access unauthorized data files, or modify configuration in unexpected ways. If the product uses a search path to locate critical resources such as programs, then an attacker could modify that search path to point to a malicious program, which the targeted product would then execute. The problem extends to any type of critical resource that the product trusts.\n\n\nSome of the most common variants of untrusted search path are:\n\n\n  - In various UNIX and Linux-based systems, the PATH environment variable may be consulted to locate executable programs, and LD_PRELOAD may be used to locate a separate library.\n\n  - In various Microsoft-based systems, the PATH environment variable is consulted to locate a DLL, if the DLL is not found in other paths that appear earlier in the search order.\n\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "642",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "673",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "427",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "428",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Untrusted Path"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "There is the potential for arbitrary code execution with privileges of the vulnerable program."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The program could be redirected to the wrong files, potentially triggering a crash or hang when the targeted file is too large or does not have the expected format."
        },
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ],
          "Note": "The program could send the output of unauthorized files to the attacker."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-11",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and look for library functions and system calls that suggest when a search path is being used. One pattern is when the program performs multiple accesses of the same file but in different directories, with repeated failures until the proper filename is found. Library calls such as getenv() or their equivalent can be checked to see if any path-related variables are being accessed.\n"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Analysis",
          "Description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Hard-code the search path to a set of known-safe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE-426 and CWE-428."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When invoking other programs, specify those programs using fully-qualified pathnames. While this is an effective approach, code that uses fully-qualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the full-qualified paths in a centralized, easily-modifiable location within the source code, and having the code refer to these paths."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any application-specific search paths."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of it, while execl() and execv() require a full path."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-67",
          "Entries": [
            {
              "IntroText": "This program is intended to execute a command that lists the contents of a restricted directory, then performs other actions. Assume that it runs with setuid privileges in order to bypass the permissions check by the operating system."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define DIR \"/restricted/directory\"\n\tchar cmd[500];\n\tsprintf(cmd, \"ls -l %480s\", DIR);\n```\n/* Raise privileges to those needed for accessing DIR. */* \n\t\n\tRaisePrivileges(...);\n\tsystem(cmd);\n\tDropPrivileges(...);\n\t..."
            },
            {
              "BodyText": "This code may look harmless at first, since both the directory and the command are set to fixed values that the attacker can't control. The attacker can only see the contents for DIR, which is the intended program behavior. Finally, the programmer is also careful to limit the code that executes with raised privileges."
            },
            {
              "BodyText": "However, because the program does not modify the PATH environment variable, the following attack would work:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "- The user sets the PATH to reference a directory under the attacker's control, such as \"/my/dir/\".\n\n  - The attacker creates a malicious program called \"ls\", and puts that program in /my/dir\n\n  - The user executes the program.\n\n  - When system() is executed, the shell consults the PATH to find the ls program\n\n  - The program finds the attacker's malicious program, \"/my/dir/ls\". It doesn't find \"/bin/ls\" because PATH does not contain \"/bin/\".\n\n  - The program executes the attacker's malicious program with the raised privileges."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code from a system utility uses the system property APPHOME to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tString home = System.getProperty(\"APPHOME\");\n\tString cmd = home + INITCMD;\n\tjava.lang.Runtime.getRuntime().exec(cmd);\n\t...\n```"
            },
            {
              "BodyText": "The code above allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property APPHOME to point to a different path containing a malicious version of INITCMD. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property APPHOME, then they can fool the application into running malicious code and take control of the system."
            }
          ]
        },
        {
          "ID": "DX-68",
          "Entries": [
            {
              "IntroText": "This code prints all of the running processes belonging to the current user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//assume getCurrentUser() returns a username that is guaranteed to be alphanumeric (avoiding CWE-78)* \n\t$userName = getCurrentUser();\n\t$command = 'ps aux | grep ' . $userName;\n\tsystem($command);"
            },
            {
              "BodyText": "If invoked by an unauthorized web user, it is providing a web page of potentially sensitive information on the underlying system, such as command-line arguments (CWE-497). This program is also potentially vulnerable to a PATH based attack (CWE-426), as an attacker may be able to create malicious versions of the ps or grep commands. While the program does not explicitly raise privileges to run the system commands, the PHP interpreter may by default be running with higher privileges than users."
            }
          ]
        },
        {
          "ID": "DX-29",
          "Entries": [
            {
              "IntroText": "The following code is from a web application that allows users access to an interface through which they can update their password on the system. In this environment, user passwords can be managed using the Network Information System (NIS), which is commonly used on UNIX systems. When performing NIS updates, part of the process for updating passwords is to run a make command in the /var/yp directory. Performing NIS updates requires extra privileges."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tSystem.Runtime.getRuntime().exec(\"make\");\n\t...\n```"
            },
            {
              "BodyText": "The problem here is that the program does not specify an absolute path for make and does not clean its environment prior to executing the call to Runtime.exec(). If an attacker can modify the $PATH variable to point to a malicious binary called make and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's make will now be run with these privileges, possibly giving the attacker complete control of the system."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1120",
          "Description": "Application relies on its PATH environment variable to find and execute program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1120"
        },
        {
          "Reference": "CVE-2008-1810",
          "Description": "Database application relies on its PATH environment variable to find and execute program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1810"
        },
        {
          "Reference": "CVE-2007-2027",
          "Description": "Chain: untrusted search path enabling resultant format string by loading malicious internationalization messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2027"
        },
        {
          "Reference": "CVE-2008-3485",
          "Description": "Untrusted search path using malicious .EXE in Windows environment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3485"
        },
        {
          "Reference": "CVE-2008-2613",
          "Description": "setuid program allows compromise using path that finds and loads a malicious library.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2613"
        },
        {
          "Reference": "CVE-2008-1319",
          "Description": "Server allows client to specify the search path, which can be modified to point to a program that the client has uploaded.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1319"
        }
      ],
      "FunctionalAreas": [
        "Program Invocation",
        "Code Libraries"
      ],
      "AffectedResources": [
        "System Process"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Untrusted Search Path"
        },
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Relative path library search"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ENV03-C",
          "EntryName": "Sanitize the environment when invoking external programs"
        }
      ],
      "RelatedAttackPatterns": [
        "38"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-18",
          "Authors": [
            "Secure Software, Inc."
          ],
          "Title": "The CLASP Application Security Process",
          "PublicationYear": "2005",
          "URL": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 10, Process Attributes, page 603",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-176",
          "Section": "Chapter 8, \"Canonical Representation Issues.\" Page 229",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "1st Edition",
          "PublicationYear": "2001",
          "PublicationMonth": "11",
          "PublicationDay": "13",
          "Publisher": "Microsoft Press"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Section": "Chapter 12, \"Trust Management and Input Validation.\" Pages 317-320",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 11, \"Don't Trust the PATH - Use Full Path Names\" Page 385",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "427",
      "Name": "Uncontrolled Search Path Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.",
      "ExtendedDescription": "\n\nAlthough this weakness can occur with any type of resource, it is frequently introduced when a product uses a directory search path to find executables or code libraries, but the path contains a directory that can be modified by an attacker, such as \"/tmp\" or the current working directory.\n\n\nIn Windows-based systems, when the LoadLibrary or LoadLibraryEx function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled:\n\n\n  - the directory from which the program has been loaded\n\n  - the current working directory\n\nIn some cases, the attack can be conducted remotely, such as when SMB or WebDAV network shares are used.\n\nOne or more locations in that path could include the Windows drive root or its subdirectories. This often exists in Linux-based code assuming the controlled nature of the root directory (/) or its subdirectories (/etc, etc), or a code that recursively accesses the parent directory. In Windows, the drive root and some of its subdirectories have weak permissions by default, which makes them uncontrolled.\n\n\nIn some Unix-based systems, a PATH might be created that contains an empty element, e.g. by splicing an empty variable into the PATH. This empty element can be interpreted as equivalent to the current working directory, which might be an untrusted search element.\n\n\nIn software package management frameworks (e.g., npm, RubyGems, or PyPi), the framework may identify dependencies on third-party libraries or other packages, then consult a repository that contains the desired package. The framework may search a public repository before a private repository. This could be exploited by attackers by placing a malicious package in the public repository that has the same name as a package from the private repository. The search path might not be directly under control of the developer relying on the framework, but this search order effectively contains an untrusted element.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "DLL preloading",
          "Description": "This term is one of several that are used to describe exploitation of untrusted search path elements in Windows systems, which received wide attention in August 2010. From a weakness perspective, the term is imprecise because it can apply to both CWE-426 and CWE-427."
        },
        {
          "Term": "Binary planting",
          "Description": "This term is one of several that are used to describe exploitation of untrusted search path elements in Windows systems, which received wide attention in August 2010. From a weakness perspective, the term is imprecise because it can apply to both CWE-426 and CWE-427."
        },
        {
          "Term": "Insecure library loading",
          "Description": "This term is one of several that are used to describe exploitation of untrusted search path elements in Windows systems, which received wide attention in August 2010. From a weakness perspective, the term is imprecise because it can apply to both CWE-426 and CWE-427."
        },
        {
          "Term": "Dependency confusion",
          "Description": "As of February 2021, this term is used to describe CWE-427 in the context of managing installation of software package dependencies, in which attackers release packages on public sites where the names are the same as package names used by private repositories, and the search for the dependent package tries the public site first, downloading untrusted code. It may also be referred to as a \"substitution attack.\""
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Hard-code the search path to a set of known-safe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE-426 and CWE-428."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "When invoking other programs, specify those programs using fully-qualified pathnames. While this is an effective approach, code that uses fully-qualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the full-qualified paths in a centralized, easily-modifiable location within the source code, and having the code refer to these paths."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any application-specific search paths."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory. Since this is a denylist approach, it might not be a complete solution."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of finding the program using the PATH environment variable, while execl() and execv() require a full path."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-29",
          "Entries": [
            {
              "IntroText": "The following code is from a web application that allows users access to an interface through which they can update their password on the system. In this environment, user passwords can be managed using the Network Information System (NIS), which is commonly used on UNIX systems. When performing NIS updates, part of the process for updating passwords is to run a make command in the /var/yp directory. Performing NIS updates requires extra privileges."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tSystem.Runtime.getRuntime().exec(\"make\");\n\t...\n```"
            },
            {
              "BodyText": "The problem here is that the program does not specify an absolute path for make and does not clean its environment prior to executing the call to Runtime.exec(). If an attacker can modify the $PATH variable to point to a malicious binary called make and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's make will now be run with these privileges, possibly giving the attacker complete control of the system."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In versions of Go prior to v1.19, the LookPath function would follow the conventions of the runtime OS and look for a program in the directiories listed in the current path [REF-1325]."
            },
            {
              "BodyText": "Therefore, Go would prioritize searching the current directory when the provided command name does not contain a directory separator and continued to search for programs even when the specified program name is empty."
            },
            {
              "BodyText": "Consider the following where an application executes a git command to run on the system."
            },
            {
              "Nature": "Bad",
              "Language": "Go",
              "ExampleCode": "```\n\tfunc ExecuteGitCommand(name string, arg []string) error { \n\t\t c := exec.Command(name, arg...)\n\t\t var err error\n\t\t c.Path, err = exec.LookPath(name)\n\t\t if err != nil {\n\t\t\t return err\n\t\t }\n\t }\n```"
            },
            {
              "BodyText": "An attacker could create a malicious repository with a file named ..exe and another file named git.exe. If git.exe is not found in the system PATH, then ..exe would execute [REF-1326]."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In February 2021 [REF-1169], a researcher was able to demonstrate the ability to breach major technology companies by using \"dependency confusion\" where the companies would download and execute untrusted packages."
            },
            {
              "BodyText": "The researcher discovered the names of some internal, private packages by looking at dependency lists in public source code, such as package.json. The researcher then created new, untrusted packages with the same name as the internal packages, then uploaded them to package hosting services. These services included the npm registry for Node, PyPi for Python, and RubyGems. In affected companies, their dependency resolution would search the public hosting services first before consulting their internal service, causing the untrusted packages to be automatically downloaded and executed."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-25815",
          "Description": "chain: a change in an underlying package causes the gettext function to use implicit initialization with a hard-coded path (CWE-1419) under the user-writable C:\\ drive, introducing an untrusted search path element (CWE-427) that enables spoofing of messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-25815"
        },
        {
          "Reference": "CVE-2022-4826",
          "Description": "Go-based git extension on Windows can search for and execute a malicious \"..exe\" in a repository because Go searches the current working directory if git.exe is not found in the PATH",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-4826"
        },
        {
          "Reference": "CVE-2020-26284",
          "Description": "A Static Site Generator built in Go, when running on Windows, searches the current working directory for a command, possibly allowing code execution using a malicious .exe or .bat file with the name being searched",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-26284"
        },
        {
          "Reference": "CVE-2022-24765",
          "Description": "Windows-based fork of git creates a \".git\" folder in the C: drive, allowing local attackers to create a .git folder with a malicious config file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24765"
        },
        {
          "Reference": "CVE-2019-1552",
          "Description": "SSL package searches under \"C:/usr/local\" for configuration files and other critical data, but C:/usr/local might be world-writable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1552"
        },
        {
          "Reference": "CVE-2010-3402",
          "Description": "\"DLL hijacking\" issue in document editor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3402"
        },
        {
          "Reference": "CVE-2010-3397",
          "Description": "\"DLL hijacking\" issue in encryption software.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3397"
        },
        {
          "Reference": "CVE-2010-3138",
          "Description": "\"DLL hijacking\" issue in library used by multiple media players.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3138"
        },
        {
          "Reference": "CVE-2010-3152",
          "Description": "\"DLL hijacking\" issue in illustration program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3152"
        },
        {
          "Reference": "CVE-2010-3147",
          "Description": "\"DLL hijacking\" issue in address book.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3147"
        },
        {
          "Reference": "CVE-2010-3135",
          "Description": "\"DLL hijacking\" issue in network monitoring software.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3135"
        },
        {
          "Reference": "CVE-2010-3131",
          "Description": "\"DLL hijacking\" issue in web browser.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3131"
        },
        {
          "Reference": "CVE-2010-1795",
          "Description": "\"DLL hijacking\" issue in music player/organizer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1795"
        },
        {
          "Reference": "CVE-2002-1576",
          "Description": "Product uses the current working directory to find and execute a program, which allows local users to gain privileges by creating a symlink that points to a malicious version of the program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1576"
        },
        {
          "Reference": "CVE-1999-1461",
          "Description": "Product trusts the PATH environmental variable to find and execute a program, which allows local users to obtain root access by modifying the PATH to point to a malicous version of that program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1461"
        },
        {
          "Reference": "CVE-1999-1318",
          "Description": "Software uses a search path that includes the current working directory (.), which allows local users to gain privileges via malicious programs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1318"
        },
        {
          "Reference": "CVE-2003-0579",
          "Description": "Admin software trusts the user-supplied -uv.install command line option to find and execute the uv.install program, which allows local users to gain privileges by providing a pathname that is under control of the user.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0579"
        },
        {
          "Reference": "CVE-2000-0854",
          "Description": "When a document is opened, the directory of that document is first used to locate DLLs , which could allow an attacker to execute arbitrary commands by inserting malicious DLLs into the same directory as the document.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0854"
        },
        {
          "Reference": "CVE-2001-0943",
          "Description": "Database trusts the PATH environment variable to find and execute programs, which allows local users to modify the PATH to point to malicious programs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0943"
        },
        {
          "Reference": "CVE-2001-0942",
          "Description": "Database uses an environment variable to find and execute a program, which allows local users to execute arbitrary programs by changing the environment variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0942"
        },
        {
          "Reference": "CVE-2001-0507",
          "Description": "Server uses relative paths to find system files that will run in-process, which allows local users to gain privileges via a malicious file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0507"
        },
        {
          "Reference": "CVE-2002-2017",
          "Description": "Product allows local users to execute arbitrary code by setting an environment variable to reference a malicious program.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2017"
        },
        {
          "Reference": "CVE-1999-0690",
          "Description": "Product includes the current directory in root's PATH variable.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0690"
        },
        {
          "Reference": "CVE-2001-0912",
          "Description": "Error during packaging causes product to include a hard-coded, non-standard directory in search path.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0912"
        },
        {
          "Reference": "CVE-2001-0289",
          "Description": "Product searches current working directory for configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0289"
        },
        {
          "Reference": "CVE-2005-1705",
          "Description": "Product searches current working directory for configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1705"
        },
        {
          "Reference": "CVE-2005-1307",
          "Description": "Product executable other program from current working directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1307"
        },
        {
          "Reference": "CVE-2002-2040",
          "Description": "Untrusted path.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2040"
        },
        {
          "Reference": "CVE-2005-2072",
          "Description": "Modification of trusted environment variable leads to untrusted path vulnerability.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2072"
        },
        {
          "Reference": "CVE-2005-1632",
          "Description": "Product searches /tmp for modules before other paths.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1632"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Uncontrolled Search Path Element"
        }
      ],
      "RelatedAttackPatterns": [
        "38",
        "471"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-409",
          "Authors": [
            "Georgi Guninski"
          ],
          "Title": "Double clicking on MS Office documents from Windows Explorer may execute arbitrary programs in some cases",
          "Publication": "Bugtraq",
          "PublicationYear": "2000",
          "PublicationMonth": "09",
          "PublicationDay": "18",
          "URL": "https://seclists.org/bugtraq/2000/Sep/331",
          "URLDate": "2023-01-30"
        },
        {
          "ExternalReferenceID": "REF-410",
          "Authors": [
            "Mitja Kolsek"
          ],
          "Title": "ACROS Security: Remote Binary Planting in Apple iTunes for Windows (ASPR #2010-08-18-1)",
          "Publication": "Bugtraq",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "18",
          "URL": "https://lists.openwall.net/bugtraq/2010/08/18/4",
          "URLDate": "2023-01-30"
        },
        {
          "ExternalReferenceID": "REF-411",
          "Authors": [
            "Taeho Kwon",
            "Zhendong Su"
          ],
          "Title": "Automatic Detection of Vulnerable Dynamic Component Loadings",
          "URL": "https://dl.acm.org/doi/10.1145/1831708.1831722",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-412",
          "Title": "Dynamic-Link Library Search Order",
          "PublicationYear": "2010",
          "PublicationMonth": "09",
          "PublicationDay": "02",
          "Publisher": "Microsoft",
          "URL": "https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-413",
          "Title": "Dynamic-Link Library Security",
          "PublicationYear": "2010",
          "PublicationMonth": "09",
          "PublicationDay": "02",
          "Publisher": "Microsoft",
          "URL": "https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-security",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-414",
          "Title": "An update on the DLL-preloading remote attack vector",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "31",
          "Publisher": "Microsoft",
          "URL": "https://msrc.microsoft.com/blog/2010/08/an-update-on-the-dll-preloading-remote-attack-vector/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-415",
          "Title": "Insecure Library Loading Could Allow Remote Code Execution",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "23",
          "Publisher": "Microsoft",
          "URL": "https://learn.microsoft.com/en-us/security-updates/securityadvisories/2010/2269637#insecure-library-loading-could-allow-remote-code-execution",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-416",
          "Authors": [
            "HD Moore"
          ],
          "Title": "Application DLL Load Hijacking",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "23",
          "URL": "https://www.rapid7.com/blog/?p=5325",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-417",
          "Authors": [
            "Oliver Lavery"
          ],
          "Title": "DLL Hijacking: Facts and Fiction",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "26",
          "URL": "https://threatpost.com/dll-hijacking-facts-and-fiction-082610/74384/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1168",
          "Authors": [
            "Catalin Cimpanu"
          ],
          "Title": "Microsoft warns enterprises of new 'dependency confusion' attack technique",
          "Publication": "ZDNet",
          "PublicationYear": "2021",
          "PublicationMonth": "02",
          "PublicationDay": "10",
          "URL": "https://www.zdnet.com/article/microsoft-warns-enterprises-of-new-dependency-confusion-attack-technique/"
        },
        {
          "ExternalReferenceID": "REF-1169",
          "Authors": [
            "Alex Birsan"
          ],
          "Title": "Dependency Confusion: How I Hacked Into Apple, Microsoft and Dozens of Other Companies",
          "PublicationYear": "2021",
          "PublicationMonth": "02",
          "PublicationDay": "09",
          "URL": "https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610"
        },
        {
          "ExternalReferenceID": "REF-1170",
          "Authors": [
            "Microsoft"
          ],
          "Title": "3 Ways to Mitigate Risk When Using Private Package Feeds",
          "PublicationYear": "2021",
          "PublicationMonth": "02",
          "PublicationDay": "09",
          "URL": "https://azure.microsoft.com/mediahandler/files/resourcefiles/3-ways-to-mitigate-risk-using-private-package-feeds/3%20Ways%20to%20Mitigate%20Risk%20When%20Using%20Private%20Package%20Feeds%20-%20v1.0.pdf"
        },
        {
          "ExternalReferenceID": "REF-1325",
          "Title": "exec package - os/exec - Go Packages",
          "PublicationYear": "2023",
          "PublicationMonth": "04",
          "PublicationDay": "04",
          "URL": "https://pkg.go.dev/os/exec",
          "URLDate": "2023-04-21"
        },
        {
          "ExternalReferenceID": "REF-1326",
          "Authors": [
            "Brian M. Carlson"
          ],
          "Title": "Git LFS Changelog",
          "PublicationYear": "2022",
          "PublicationMonth": "04",
          "PublicationDay": "19",
          "URL": "https://github.com/git-lfs/git-lfs/commit/032dca8ee69c193208cd050024c27e82e11aef81",
          "URLDate": "2023-04-21"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Unlike untrusted search path (CWE-426), which inherently involves control over the definition of a control sphere (i.e., modification of a search path), this entry concerns a fixed control sphere in which some part of the sphere may be under attacker control (i.e., the search path cannot be modified by an attacker, but one element of the path can be under attacker control)."
        },
        {
          "Type": "Theoretical",
          "Note": "This weakness is not a clean fit under CWE-668 or CWE-610, which suggests that the control sphere model might need enhancement or clarification."
        }
      ]
    },
    {
      "ID": "428",
      "Name": "Unquoted Search Path or Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.",
      "ExtendedDescription": "If a malicious individual has access to the file system, it is possible to elevate privileges by inserting such a file as \"C:\\Program.exe\" to be run by a privileged program making use of WinExec.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Name": "Windows NT",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Operating_System",
          "Name": "macOS",
          "Prevalence": "Rarely"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Properly quote the full search path before executing a program on the system."
        },
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"
        },
        {
          "MitigationID": "MIT-20",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tUINT errCode = WinExec( \"C:\\\\Program Files\\\\Foo\\\\Bar\", SW_SHOW );\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1185",
          "Description": "Small handful of others. Program doesn't quote the \"C:\\Program Files\\\" path when calling a program to be executed - or any other path with a directory or file whose name contains a space - so attacker can put a malicious program.exe into C:.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1185"
        },
        {
          "Reference": "CVE-2005-2938",
          "Description": "CreateProcess() and CreateProcessAsUser() can be misused by applications to allow \"program.exe\" style attacks in C:",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2938"
        },
        {
          "Reference": "CVE-2000-1128",
          "Description": "Applies to \"Common Files\" folder, with a malicious common.exe, instead of \"Program Files\"/program.exe.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1128"
        }
      ],
      "FunctionalAreas": [
        "Program Invocation"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unquoted Search Path or Element"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 11, \"Process Loading\", Page 654",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Applicable Platform",
          "Note": "\n\nThis weakness could apply to any OS that supports spaces in filenames, especially any OS that make it easy for a user to insert spaces into filenames or folders, such as Windows. While spaces are technically supported in Unix, the practice is generally avoided. .\n"
        },
        {
          "Type": "Maintenance",
          "Note": "\n\nThis weakness primarily involves the lack of quoting, which is not explicitly stated as a part of CWE-116. CWE-116 also describes output in light of structured messages, but the generation of a filename or search path (as in this weakness) might not be considered a structured message.\n\n\nAn additional complication is the relationship to control spheres. Unlike untrusted search path (CWE-426), which inherently involves control over the definition of a control sphere, this entry concerns a fixed control sphere in which some part of the sphere may be under attacker control. This is not a clean fit under CWE-668 or CWE-610, which suggests that the control sphere model needs enhancement or clarification.\n"
        }
      ]
    },
    {
      "ID": "430",
      "Name": "Deployment of Wrong Handler",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The wrong \"handler\" is assigned to process an object.",
      "ExtendedDescription": "An example of deploying the wrong handler would be calling a servlet to reveal source code of a .JSP file, or automatically \"determining\" type of the object even if it is contradictory to an explicitly specified type.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "433",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "434",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant",
          "Description": "This weakness is usually resultant from other weaknesses."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Perform a type check before interpreting an object."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Reject any inconsistent types, such as a file with a .GIF extension that appears to consist of PHP code."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-0004",
          "Description": "Source code disclosure via manipulated file extension that causes parsing by wrong DLL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0004"
        },
        {
          "Reference": "CVE-2002-0025",
          "Description": "Web browser does not properly handle the Content-Type header field, causing a different application to process the document.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0025"
        },
        {
          "Reference": "CVE-2000-1052",
          "Description": "Source code disclosure by directly invoking a servlet.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1052"
        },
        {
          "Reference": "CVE-2002-1742",
          "Description": "Arbitrary Perl functions can be loaded by calling a non-existent function that activates a handler.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1742"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Improper Handler Deployment"
        }
      ],
      "RelatedAttackPatterns": [
        "11"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"File Handlers\", Page 74",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "431",
      "Name": "Missing Handler",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A handler is not available or implemented.",
      "ExtendedDescription": "When an exception is thrown and not caught, the process has given up an opportunity to decide if a given failure or event is worth a change in execution.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "433",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Handle all possible situations (e.g. error condition)."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If an operation can throw an Exception, implement a handler for that specific exception."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "If a Servlet does not catch all exceptions, it may reveal debugging information that will help an adversary form a plan of attack. In the following method a DNS lookup failure will cause the Servlet to throw an exception."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n\t\tString ip = req.getRemoteAddr();\n\t\tInetAddress addr = InetAddress.getByName(ip);\n\t\t...\n\t\tout.println(\"hello \" + addr.getHostName());\n\t}\n```"
            },
            {
              "BodyText": "When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-25302",
          "Description": "SDK for OPC Unified Architecture (OPC UA) is missing a handler for when a cast fails, allowing for a crash",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25302"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Missing Handler"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP4",
          "EntryName": "Unchecked Status Condition"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"File Handlers\", Page 74",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "432",
      "Name": "Dangerous Signal Handler not Disabled During Sensitive Operations",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a signal handler that shares state with other signal handlers, but it does not properly mask or prevent those signal handlers from being invoked while the original signal handler is still running.",
      "ExtendedDescription": "During the execution of a signal handler, it can be interrupted by another handler when a different signal is sent. If the two handlers share state - such as global variables - then an attacker can corrupt the state by sending another signal before the first handler has completed execution.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "364",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Turn off dangerous handlers when performing sensitive operations."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG00-C",
          "EntryName": "Mask signals handled by noninterruptible signal handlers"
        },
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Dangerous handler not cleared/disabled during sensitive operations"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "433",
      "Name": "Unparsed Raw Web Content Delivery",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.",
      "ExtendedDescription": "If code is stored in a file with an extension such as \".inc\" or \".pl\", and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "219",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Perform a type check before interpreting files."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Do not store sensitive information in files which may be misinterpreted."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-104",
          "Entries": [
            {
              "IntroText": "The following code uses an include file to store database credentials:"
            },
            {
              "BodyText": "database.inc"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\t$dbName = 'usersDB';\n\t$dbPassword = 'skjdh#67nkjd3$3$';\n\t?>\n```"
            },
            {
              "BodyText": "login.php"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\tinclude('database.inc');\n\t$db = connectToDB($dbName, $dbPassword);\n\t$db.authenticateUser($username, $password);\n\t?>\n```"
            },
            {
              "BodyText": "If the server does not have an explicit handler set for .inc files it may send the contents of database.inc to an attacker without pre-processing, if the attacker requests the file directly. This will expose the database name and password."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1886",
          "Description": "\".inc\" file stored under web document root and returned unparsed by the server",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1886"
        },
        {
          "Reference": "CVE-2002-2065",
          "Description": "\".inc\" file stored under web document root and returned unparsed by the server",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2065"
        },
        {
          "Reference": "CVE-2005-2029",
          "Description": "\".inc\" file stored under web document root and returned unparsed by the server",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2029"
        },
        {
          "Reference": "CVE-2001-0330",
          "Description": "direct request to .pl file leaves it unparsed",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0330"
        },
        {
          "Reference": "CVE-2002-0614",
          "Description": ".inc file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0614"
        },
        {
          "Reference": "CVE-2004-2353",
          "Description": "unparsed config.conf file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2353"
        },
        {
          "Reference": "CVE-2007-3365",
          "Description": "Chain: uppercase file extensions causes web server to return script source code instead of executing the script.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3365"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unparsed Raw Web Content Delivery"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"File Handlers\", Page 74",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This overlaps direct requests (CWE-425), alternate path (CWE-424), permissions (CWE-275), and sensitive file under web root (CWE-219)."
        }
      ]
    },
    {
      "ID": "434",
      "Name": "Unrestricted Upload of File with Dangerous Type",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-434-Diagram.png",
      "Description": "The product allows the upload or transfer of dangerous file types that are automatically processed within its environment.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "351",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "436",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "430",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This can be primary when there is no check for the file type at all."
        },
        {
          "Ordinality": "Resultant",
          "Description": "This can be resultant when use of double extensions (e.g. \".php.gif\") bypasses a check."
        },
        {
          "Ordinality": "Resultant",
          "Description": "This can be resultant from client-side enforcement (CWE-602); some products will include web script in web clients to check the filename, without verifying on the server side."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "ASP.NET",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Sometimes"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Unrestricted File Upload",
          "Description": "Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Arbitrary code execution is possible if an uploaded file is interpreted and executed as code by the recipient. This is especially true for web-server extensions such as .asp and .php because these file types are often treated as automatically executable, even when file system permissions do not specify execution. For example, in Unix environments, programs typically cannot run unless the execute bit is set, but PHP programs may be executed by the web server without directly invoking them on the operating system."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]"
        },
        {
          "MitigationID": "MIT-21",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Enforcement by Conversion",
          "Description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]"
        },
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n\n\nFor example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that \"filename.php.gif\" is fed to the PHP interpreter.[REF-422] [REF-423]"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided."
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-22",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Sandbox or Jail",
          "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code intends to allow a user to upload a picture to the web server. The HTML code that drives the form on the user end has an input field of type \"file\"."
            },
            {
              "Nature": "Good",
              "Language": "HTML",
              "ExampleCode": "```\n\t<form action=\"upload_picture.php\" method=\"post\" enctype=\"multipart/form-data\">\n\tChoose a file to upload:\n\t<input type=\"file\" name=\"filename\"/>\n\t<br/>\n\t<input type=\"submit\" name=\"submit\" value=\"Submit\"/>\n\t</form>\n```"
            },
            {
              "BodyText": "Once submitted, the form above sends the file to upload_picture.php on the web server. PHP stores the file in a temporary location until it is retrieved (or discarded) by the server side code. In this example, the file is moved to a more permanent pictures/ directory."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n// Define the target location where the picture being* \n\t\n\t\n\t *// uploaded is going to be saved.* \n\t$target = \"pictures/\" . basename($_FILES['uploadedfile']['name']);\n\t\n\t\n\t *// Move the uploaded file to the new location.* \n\tif(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target))\n\t{\n\t```\n\t\techo \"The picture has been successfully uploaded.\";\n\t}\n\telse\n\t{\n\t\techo \"There was an error uploading the picture, please try again.\";\n\t}\n```"
            },
            {
              "BodyText": "The problem with the above code is that there is no check regarding type of file being uploaded. Assuming that pictures/ is available in the web document root, an attacker could upload a file with the name:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tmalicious.php\n```"
            },
            {
              "BodyText": "Since this filename ends in \".php\" it can be executed by the web server. In the contents of this uploaded file, the attacker could use:"
            },
            {
              "Nature": "Attack",
              "Language": "PHP",
              "ExampleCode": "```\n\t<?php\n\t\tsystem($_GET['cmd']);\n\t?>\n```"
            },
            {
              "BodyText": "Once this file has been installed, the attacker can enter arbitrary commands to execute using a URL such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\thttp://server.example.com/upload_dir/malicious.php?cmd=ls%20-l\n```"
            },
            {
              "BodyText": "which runs the \"ls -l\" command - or any other type of command that the attacker wants to specify."
            }
          ]
        },
        {
          "ID": "DX-22",
          "Entries": [
            {
              "IntroText": "The following code demonstrates the unrestricted upload of a file with a Java servlet and a path traversal vulnerability. The action attribute of an HTML form is sending the upload file request to the Java servlet."
            },
            {
              "Nature": "Good",
              "Language": "HTML",
              "ExampleCode": "```\n\t<form action=\"FileUploadServlet\" method=\"post\" enctype=\"multipart/form-data\">\n\tChoose a file to upload:\n\t<input type=\"file\" name=\"filename\"/>\n\t<br/>\n\t<input type=\"submit\" name=\"submit\" value=\"Submit\"/>\n\t</form>\n```"
            },
            {
              "BodyText": "When submitted the Java servlet's doPost method will receive the request, extract the name of the file from the Http request header, read the file contents from the request and output the file to the local upload directory."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class FileUploadServlet extends HttpServlet {\n\t\t\t...\n\t\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\t\tresponse.setContentType(\"text/html\");\n\t\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\t\tString contentType = request.getContentType();\n\t\t\t\t\t// the starting position of the boundary header\n\t\t\t\t\tint ind = contentType.indexOf(\"boundary=\");\n\t\t\t\t\tString boundary = contentType.substring(ind+9);\n\t\t\t\t\tString pLine = new String();\n\t\t\t\t\tString uploadLocation = new String(UPLOAD_DIRECTORY_STRING); //Constant value\n\t\t\t\t\t// verify that content type is multipart form data\n\t\t\t\t\tif (contentType != null && contentType.indexOf(\"multipart/form-data\") != -1) {\n\t\t\t\t\t\t\t// extract the filename from the Http header\n\t\t\t\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream()));\n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\tpLine = br.readLine();\n\t\t\t\t\t\t\tString filename = pLine.substring(pLine.lastIndexOf(\"\\\\\"), pLine.lastIndexOf(\"\\\"\"));\n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\t// output the file to the local upload directory\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(uploadLocation+filename, true));\n\t\t\t\t\t\t\t\t\tfor (String line; (line=br.readLine())!=null; ) {\n\t\t\t\t\t\t\t\t\t\tif (line.indexOf(boundary) == -1) {\n\t\t\t\t\t\t\t\t\t\t\tbw.write(line);\n\t\t\t\t\t\t\t\t\t\t\tbw.newLine();\n\t\t\t\t\t\t\t\t\t\t\tbw.flush();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} //end of for loop\n\t\t\t\t\t\t\t\t\tbw.close();\n\t\t\t\t\t\t\t} catch (IOException ex) {...}\n\t\t\t\t\t\t\t// output successful upload response HTML page\n\t\t\t\t\t}\n\t\t\t\t\t// output unsuccessful upload response HTML page\n\t\t\t\t\telse\n\t\t\t\t\t{...}\n\t\t\t}\n\t\t\t\t...\n\t}\n```"
            },
            {
              "BodyText": "This code does not perform a check on the type of the file being uploaded (CWE-434). This could allow an attacker to upload any executable file or other file with malicious code."
            },
            {
              "BodyText": "Additionally, the creation of the BufferedWriter object is subject to relative path traversal (CWE-23). Since the code does not check the filename that is provided in the header, an attacker can use \"../\" sequences to write to files outside of the intended directory. Depending on the executing environment, the attacker may be able to specify arbitrary files to write to, leading to a wide variety of consequences, from code execution, XSS (CWE-79), or system crash."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-5227",
          "Description": "PHP-based FAQ management app does not check the MIME type for uploaded images",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-5227"
        },
        {
          "Reference": "CVE-2001-0901",
          "Description": "Web-based mail product stores \".shtml\" attachments that could contain SSI",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0901"
        },
        {
          "Reference": "CVE-2002-1841",
          "Description": "PHP upload does not restrict file types",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1841"
        },
        {
          "Reference": "CVE-2005-1868",
          "Description": "upload and execution of .php file",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1868"
        },
        {
          "Reference": "CVE-2005-1881",
          "Description": "upload file with dangerous extension",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1881"
        },
        {
          "Reference": "CVE-2005-0254",
          "Description": "program does not restrict file types",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0254"
        },
        {
          "Reference": "CVE-2004-2262",
          "Description": "improper type checking of uploaded files",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2262"
        },
        {
          "Reference": "CVE-2006-4558",
          "Description": "Double \"php\" extension leaves an active php extension in the generated filename.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4558"
        },
        {
          "Reference": "CVE-2006-6994",
          "Description": "ASP program allows upload of .asp files by bypassing client-side checks",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6994"
        },
        {
          "Reference": "CVE-2005-3288",
          "Description": "ASP file upload",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3288"
        },
        {
          "Reference": "CVE-2006-2428",
          "Description": "ASP file upload",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2428"
        }
      ],
      "FunctionalAreas": [
        "File Processing"
      ],
      "AffectedResources": [
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unrestricted File Upload"
        },
        {
          "TaxonomyName": "OWASP Top Ten 2007",
          "EntryID": "A3",
          "EntryName": "Malicious File Execution",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-434"
        }
      ],
      "RelatedAttackPatterns": [
        "1"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-422",
          "Authors": [
            "Richard Stanway (r1CH)"
          ],
          "Title": "Dynamic File Uploads, Security and You",
          "URL": "https://web.archive.org/web/20090208005456/http://shsc.info/FileUploadSecurity",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-423",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "8 Basic Rules to Implement Secure File Uploads",
          "PublicationYear": "2009",
          "PublicationMonth": "12",
          "PublicationDay": "28",
          "URL": "https://www.sans.org/blog/8-basic-rules-to-implement-secure-file-uploads/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-424",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "Top 25 Series - Rank 8 - Unrestricted Upload of Dangerous File Type",
          "PublicationYear": "2010",
          "PublicationMonth": "02",
          "PublicationDay": "25",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-8-unrestricted-upload-of-dangerous-file-type/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 17, \"File Uploading\", Page 1068",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-434",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "\n\nThis can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184).\n\n\nThis can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.\n"
        }
      ]
    },
    {
      "ID": "435",
      "Name": "Improper Interaction Between Multiple Correctly-Behaving Entities",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "An interaction error occurs when two entities have correct behavior when running independently of each other, but when they are integrated as components in a larger system or process, they introduce incorrect behaviors that may cause resultant weaknesses.",
      "ExtendedDescription": "When a system or process combines multiple independent components, this often produces new, emergent behaviors at the system level. However, if the interactions between these components are not fully accounted for, some of the emergent behaviors can be incorrect or even insecure.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Interaction Error"
        },
        {
          "Term": "Emergent Fault"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The paper \"Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection\" [REF-428] shows that OSes varied widely in how they manage unusual packets, which made it difficult or impossible for intrusion detection systems to properly detect certain attacker manipulations that took advantage of these OS differences."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0485",
          "Description": "Anti-virus product allows bypass via Content-Type and Content-Disposition headers that are mixed case, which are still processed by some clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0485"
        },
        {
          "Reference": "CVE-2003-0411",
          "Description": "chain: Code was ported from a case-sensitive Unix platform to a case-insensitive Windows platform where filetype handlers treat .jsp and .JSP as different extensions. JSP source code may be read because .JSP defaults to the filetype \"text\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0411"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Interaction Errors"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-428",
          "Authors": [
            "Thomas H. Ptacek",
            "Timothy N. Newsham"
          ],
          "Title": "Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection",
          "PublicationYear": "1998",
          "PublicationMonth": "01",
          "URL": "https://insecure.org/stf/secnet_ids/secnet_ids.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-568",
          "Authors": [
            "Taimur Aslam",
            "Ivan Krsul",
            "Eugene H. Spafford"
          ],
          "Title": "Use of A Taxonomy of Security Faults",
          "PublicationYear": "1995",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "https://csrc.nist.gov/csrc/media/publications/conference-paper/1996/10/22/proceedings-of-the-19th-nissc-1996/documents/paper057/paper.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar. However, sometimes this weakness is forced to be used due to the lack of in-depth weakness research. See Research Gaps.",
        "Comments": "Where feasible, consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "\n\nWeaknesses related to this Pillar appear to be under-studied, especially with respect to classification schemes. Input from academic and other communities could help identify and resolve gaps or organizational difficulties within CWE.\n"
        },
        {
          "Type": "Relationship",
          "Note": "The \"Interaction Error\" term, in CWE and elsewhere, is only intended to describe products that behave according to specification. When one or more of the products do not comply with specifications, then it is more likely to be API Abuse (CWE-227) or an interpretation conflict (CWE-436). This distinction can be blurred in real world scenarios, especially when \"de facto\" standards do not comply with specifications, or when there are no standards but there is widespread adoption. As a result, it can be difficult to distinguish these weaknesses during mapping and classification."
        }
      ]
    },
    {
      "ID": "436",
      "Name": "Interpretation Conflict",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "Product A handles inputs or steps differently than Product B, which causes A to perform incorrect actions based on its perception of B's state.",
      "ExtendedDescription": "This is generally found in proxies, firewalls, anti-virus software, and other intermediary devices that monitor, allow, deny, or modify traffic based on how the client or server is expected to behave.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "435",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The paper \"Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection\" [REF-428] shows that OSes varied widely in how they manage unusual packets, which made it difficult or impossible for intrusion detection systems to properly detect certain attacker manipulations that took advantage of these OS differences."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Null characters have different interpretations in Perl and C, which have security consequences when Perl invokes C functions. Similar problems have been reported in ASP [REF-429] and PHP."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-1215",
          "Description": "Bypass filters or poison web cache using requests with multiple Content-Length headers, a non-standard behavior.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1215"
        },
        {
          "Reference": "CVE-2002-0485",
          "Description": "Anti-virus product allows bypass via Content-Type and Content-Disposition headers that are mixed case, which are still processed by some clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0485"
        },
        {
          "Reference": "CVE-2002-1978",
          "Description": "FTP clients sending a command with \"PASV\" in the argument can cause firewalls to misinterpret the server's error as a valid response, allowing filter bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1978"
        },
        {
          "Reference": "CVE-2002-1979",
          "Description": "FTP clients sending a command with \"PASV\" in the argument can cause firewalls to misinterpret the server's error as a valid response, allowing filter bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1979"
        },
        {
          "Reference": "CVE-2002-0637",
          "Description": "Virus product bypass with spaces between MIME header fields and the \":\" separator, a non-standard message that is accepted by some clients.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0637"
        },
        {
          "Reference": "CVE-2002-1777",
          "Description": "AV product detection bypass using inconsistency manipulation (file extension in MIME Content-Type vs. Content-Disposition field).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1777"
        },
        {
          "Reference": "CVE-2005-3310",
          "Description": "CMS system allows uploads of files with GIF/JPG extensions, but if they contain HTML, Internet Explorer renders them as HTML instead of images.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3310"
        },
        {
          "Reference": "CVE-2005-4260",
          "Description": "Interpretation conflict allows XSS via invalid \"<\" when a \">\" is expected, which is treated as \">\" by many web browsers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4260"
        },
        {
          "Reference": "CVE-2005-4080",
          "Description": "Interpretation conflict (non-standard behavior) enables XSS because browser ignores invalid characters in the middle of tags.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4080"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Multiple Interpretation Error (MIE)"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "27",
          "EntryName": "HTTP Response Smuggling"
        }
      ],
      "RelatedAttackPatterns": [
        "105",
        "273",
        "34"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-427",
          "Authors": [
            "Steve Christey"
          ],
          "Title": "On Interpretation Conflict Vulnerabilities",
          "Publication": "Bugtraq",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "03",
          "URL": "https://seclists.org/bugtraq/2005/Nov/30",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-428",
          "Authors": [
            "Thomas H. Ptacek",
            "Timothy N. Newsham"
          ],
          "Title": "Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection",
          "PublicationYear": "1998",
          "PublicationMonth": "01",
          "URL": "https://insecure.org/stf/secnet_ids/secnet_ids.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-429",
          "Authors": [
            "Brett Moore"
          ],
          "Title": "0x00 vs ASP file upload scripts",
          "PublicationYear": "2004",
          "PublicationMonth": "07",
          "PublicationDay": "13",
          "URL": "http://www.security-assessment.com/Whitepapers/0x00_vs_ASP_File_Uploads.pdf"
        },
        {
          "ExternalReferenceID": "REF-430",
          "Authors": [
            "Rain Forest Puppy"
          ],
          "Title": "Poison NULL byte",
          "Publication": "Phrack"
        },
        {
          "ExternalReferenceID": "REF-431",
          "Authors": [
            "David F. Skoll"
          ],
          "Title": "Re: Corsaire Security Advisory - Multiple vendor MIME RFC2047 encoding",
          "Publication": "Bugtraq",
          "PublicationYear": "2004",
          "PublicationMonth": "09",
          "PublicationDay": "15",
          "URL": "http://marc.info/?l=bugtraq&m=109525864717484&w=2"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "437",
      "Name": "Incomplete Model of Endpoint Features",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A product acts as an intermediary or monitor between two or more endpoints, but it does not have a complete model of an endpoint's features, behaviors, or state, potentially causing the product to perform incorrect actions based on this incomplete model.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "436",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Unexpected State",
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "HTTP request smuggling is an attack against an intermediary such as a proxy. This attack works because the proxy expects the client to parse HTTP headers one way, but the client parses them differently."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Anti-virus products that reside on mail servers can suffer from this issue if they do not know how a mail client will handle a particular attachment. The product might treat an attachment type as safe, not knowing that the client's configuration treats it as executable."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Extra Unhandled Features"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be related to interaction errors, although in some cases, one of the endpoints is not performing correctly according to specification."
        }
      ]
    },
    {
      "ID": "439",
      "Name": "Behavioral Change in New Version or Environment",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A's behavior or functionality changes with a new version of A, or a new environment, which is not known (or manageable) by B.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "435",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Functional change"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1976",
          "Description": "Linux kernel 2.2 and above allow promiscuous mode using a different method than previous versions, and ifconfig is not aware of the new method (alternate path property).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1976"
        },
        {
          "Reference": "CVE-2005-1711",
          "Description": "Product uses defunct method from another product that does not return an error code and allows detection avoidance.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1711"
        },
        {
          "Reference": "CVE-2003-0411",
          "Description": "chain: Code was ported from a case-sensitive Unix platform to a case-insensitive Windows platform where filetype handlers treat .jsp and .JSP as different extensions. JSP source code may be read because .JSP defaults to the filetype \"text\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0411"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "CHANGE Behavioral Change"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "440",
      "Name": "Expected Behavior Violation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A feature, API, or function does not perform according to its specification.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The provided code is extracted from the Control and Status Register (CSR), csr_regfile, module within the Hack@DAC'21 OpenPiton System-on-Chip (SoC). This module is designed to implement CSR registers in accordance with the RISC-V specification. The mie (machine interrupt enable) register is a 64-bit register [REF-1384], where bits correspond to different interrupt sources. As the name suggests, mie is a machine-level register that determines which interrupts are enabled. Note that in the example below the mie_q and mie_d registers represent the conceptual mie reigster in the RISC-V specification. The mie_d register is the value to be stored in the mie register while the mie_q register holds the current value of the mie register [REF-1385]."
            },
            {
              "BodyText": "The mideleg (machine interrupt delegation) register, also 64-bit wide, enables the delegation of specific interrupt sources from machine privilege mode to lower privilege levels. By setting specific bits in the mideleg register, the handling of certain interrupts can be delegated to lower privilege levels without engaging the machine-level privilege mode. For example, in supervisor mode, the mie register is limited to a specific register called the sie (supervisor interrupt enable) register. If delegated, an interrupt becomes visible in the sip (supervisor interrupt pending) register and can be enabled or blocked using the sie register. If no delegation occurs, the related bits in sip and sie are set to zero."
            },
            {
              "BodyText": "The sie register value is computed based on the current value of mie register, i.e., mie_q, and the mideleg register."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "module csr_regfile #(...)(...);\n ...\n // ---------------------------\n // CSR Write and update logic\n // ---------------------------\n ...\n\n```\n\t if (csr_we) begin\n\t\t unique case (csr_addr.address)\n\t\t ...\n\t\t\t riscv::CSR_SIE: begin\n\t\t\t\t // the mideleg makes sure only delegate-able register\n\t\t\t\t //(and therefore also only implemented registers) are written\n```\nmie_d = (mie_q & ~mideleg_q) | (csr_wdata & mideleg_q) | utval_q;** \n\t\t\t\t end\n\t\t\t ...\n\t\t\t endcase\n\t\t end\n\t endmodule"
            },
            {
              "BodyText": "The above code snippet illustrates an instance of a vulnerable implementation of the sie register update logic, where users can tamper with the mie_d register value through the utval (user trap value) register. This behavior violates the RISC-V specification."
            },
            {
              "BodyText": "The code shows that the value of utval, among other signals, is used in updating the mie_d value within the sie update logic. While utval is a register accessible to users, it should not influence or compromise the integrity of sie. Through manipulation of the utval register, it becomes feasible to manipulate the sie register's value. This opens the door for potential attacks, as an adversary can gain control over or corrupt the sie value. Consequently, such manipulation empowers an attacker to enable or disable critical supervisor-level interrupts, resulting in various security risks such as privilege escalation or denial-of-service attacks."
            },
            {
              "BodyText": "A fix to this issue is to remove the utval from the right-hand side of the assignment. That is the value of the mie_d should be updated as shown in the good code example [REF-1386]."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "module csr_regfile #(...)(...);\n ...\n // ---------------------------\n // CSR Write and update logic\n // ---------------------------\n ...\n\n```\n\t if (csr_we) begin\n\t\t unique case (csr_addr.address)\n\t\t ...\n\t\t\t riscv::CSR_SIE: begin\n\t\t\t\t // the mideleg makes sure only delegate-able register\n\t\t\t\t //(and therefore also only implemented registers) are written\n```\nmie_d = (mie_q & ~mideleg_q) | (csr_wdata & mideleg_q);** \n\t\t\t\t end\n\t\t\t ...\n\t\t\t endcase\n\t\t end\n\t endmodule"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2003-0187",
          "Description": "Program uses large timeouts on unconfirmed connections resulting from inconsistency in linked lists implementations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0187"
        },
        {
          "Reference": "CVE-2003-0465",
          "Description": "\"strncpy\" in Linux kernel acts different than libc on x86, leading to expected behavior difference - sort of a multiple interpretation error?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0465"
        },
        {
          "Reference": "CVE-2005-3265",
          "Description": "Buffer overflow in product stems the use of a third party library function that is expected to have internal protection against overflows, but doesn't.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3265"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Expected behavior violation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1384",
          "Title": "The RISC-V Instruction Set Manual Volume II: Privileged Architecture page 28",
          "PublicationYear": "2021",
          "URL": "https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf",
          "URLDate": "2024-01-16"
        },
        {
          "ExternalReferenceID": "REF-1385",
          "Title": "csr_regfile.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/b9ecdf6068445d76d6bee692d163fededf7a9d9b/piton/design/chip/tile/ariane/src/csr_regfile.sv",
          "URLDate": "2024-01-16"
        },
        {
          "ExternalReferenceID": "REF-1386",
          "Title": "Fix for csr_regfile.sv",
          "PublicationYear": "2021",
          "URL": "https://github.com/HACK-EVENT/hackatdac21/blob/2341c625a28d2fb87d370e32c45b68bd711cc43b/piton/design/chip/tile/ariane/src/csr_regfile.sv#L519C4-L522C20",
          "URLDate": "2024-01-16"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Theoretical",
          "Note": "The behavior of an application that is not consistent with the expectations of the developer may lead to incorrect use of the software."
        }
      ]
    },
    {
      "ID": "441",
      "Name": "Unintended Proxy or Intermediary ('Confused Deputy')",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product receives a request, message, or directive from an upstream component, but the product does not sufficiently preserve the original source of the request before forwarding the request to an external actor that is outside of the product's control sphere. This causes the product to appear to be the source of the request, leading it to act as a proxy or other intermediary between the upstream component and the external actor.",
      "ExtendedDescription": "\n\nIf an attacker cannot directly contact a target, but the product has access to the target, then the attacker can send a request to the product and have it be forwarded to the target. The request would appear to be coming from the product's system, not the attacker's system. As a result, the attacker can bypass access controls (such as firewalls) or hide the source of malicious requests, since the requests would not be coming directly from the attacker.\n\n\nSince proxy functionality and message-forwarding often serve a legitimate purpose, this issue only becomes a vulnerability when:\n\n\n  - The product runs with different privileges or on a different system, or otherwise has different levels of access than the upstream component;\n\n  - The attacker is prevented from making the request directly to the target; and\n\n  - The attacker can create a request that the proxy does not explicitly intend to be forwarded on the behalf of the requester. Such a request might point to an unexpected hostname, port number, hardware IP, or service. Or, the request might be sent to an allowed service, but the request could contain disallowed directives, commands, or resources.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "668",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Architecture",
          "Class": "Not Architecture-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Confused Deputy",
          "Description": "This weakness is sometimes referred to as the \"Confused deputy\" problem, in which an attacker misused the authority of one victim (the \"confused deputy\") when targeting another victim."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation",
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Hide Activities",
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Enforce the use of strong mutual authentication mechanism between the two parties."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Whenever a product is an intermediary or proxy for transactions between two other components, the proxy core should not drop the identity of the initiator of the transaction. The immutability of the identity of the initiator must be maintained and should be forwarded all the way to the target."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "A SoC contains a microcontroller (running ring-3 (least trusted ring) code), a Memory Mapped Input Output (MMIO) mapped IP core (containing design-house secrets), and a Direct Memory Access (DMA) controller, among several other compute elements and peripherals. The SoC implements access control to protect the registers in the IP core (which registers store the design-house secrets) from malicious, ring-3 (least trusted ring) code executing on the microcontroller. The DMA controller, however, is not blocked off from accessing the IP core for functional reasons."
            },
            {
              "Nature": "Bad",
              "Language": "Other",
              "ExampleCode": "The code in ring-3 (least trusted ring) of the microcontroller attempts to directly read the protected registers in IP core through MMIO transactions. However, this attempt is blocked due to the implemented access control. Now, the microcontroller configures the DMA core to transfer data from the protected registers to a memory region that it has access to. The DMA core, which is acting as an intermediary in this transaction, does not preserve the identity of the microcontroller and, instead, initiates a new transaction with its own identity. Since the DMA core has access, the transaction (and hence, the attack) is successful."
            },
            {
              "BodyText": "The weakness here is that the intermediary or the proxy agent did not ensure the immutability of the identity of the microcontroller initiating the transaction."
            },
            {
              "Nature": "Good",
              "Language": "Other",
              "ExampleCode": "The DMA core forwards this transaction with the identity of the code executing on the microcontroller, which is the original initiator of the end-to-end transaction. Now the transaction is blocked, as a result of forwarding the identity of the true initiator which lacks the permission to access the confidential MMIO mapped IP core."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-0017",
          "Description": "FTP bounce attack. The design of the protocol allows an attacker to modify the PORT command to cause the FTP server to connect to other machines besides the attacker's.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0017"
        },
        {
          "Reference": "CVE-1999-0168",
          "Description": "RPC portmapper could redirect service requests from an attacker to another entity, which thinks the requests came from the portmapper.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0168"
        },
        {
          "Reference": "CVE-2005-0315",
          "Description": "FTP server does not ensure that the IP address in a PORT command is the same as the FTP user's session, allowing port scanning by proxy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0315"
        },
        {
          "Reference": "CVE-2002-1484",
          "Description": "Web server allows attackers to request a URL from another server, including other ports, which allows proxied scanning.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1484"
        },
        {
          "Reference": "CVE-2004-2061",
          "Description": "CGI script accepts and retrieves incoming URLs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2061"
        },
        {
          "Reference": "CVE-2001-1484",
          "Description": "Bounce attack allows access to TFTP from trusted side.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1484"
        },
        {
          "Reference": "CVE-2010-1637",
          "Description": "Web-based mail program allows internal network scanning using a modified POP3 port number.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1637"
        },
        {
          "Reference": "CVE-2009-0037",
          "Description": "URL-downloading library automatically follows redirects to file:// and scp:// URLs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0037"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unintended proxy/intermediary"
        },
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Proxied Trusted Channel"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "32",
          "EntryName": "Routing Detour"
        }
      ],
      "RelatedAttackPatterns": [
        "219",
        "465"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-432",
          "Authors": [
            "Norm Hardy"
          ],
          "Title": "The Confused Deputy (or why capabilities might have been invented)",
          "PublicationYear": "1988",
          "URL": "http://www.cap-lore.com/CapTheory/ConfusedDeputy.html"
        },
        {
          "ExternalReferenceID": "REF-1125",
          "Authors": [
            "moparisthebest"
          ],
          "Title": "Validation Vulnerabilities",
          "PublicationYear": "2015",
          "PublicationMonth": "06",
          "PublicationDay": "05",
          "URL": "https://mailarchive.ietf.org/arch/msg/acme/s6Q5PdJP48LEUwgzrVuw_XPKCsM/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness has a chaining relationship with CWE-668 (Exposure of Resource to Wrong Sphere) because the proxy effectively provides the attacker with access to the target's resources that the attacker cannot directly obtain."
        },
        {
          "Type": "Maintenance",
          "Note": "This could possibly be considered as an emergent resource."
        },
        {
          "Type": "Theoretical",
          "Note": "It could be argued that the \"confused deputy\" is a fundamental aspect of most vulnerabilities that require an active attacker. Even for common implementation issues such as buffer overflows, SQL injection, OS command injection, and path traversal, the vulnerable program already has the authorization to run code or access files. The vulnerability arises when the attacker causes the program to run unexpected code or access unexpected files."
        }
      ]
    },
    {
      "ID": "443",
      "Name": "DEPRECATED: HTTP response splitting",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This weakness can be found at CWE-113.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "444",
      "Name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product acts as an intermediary HTTP agent\n         (such as a proxy or firewall) in the data flow between two\n         entities such as a client and server, but it does not\n         interpret malformed HTTP requests or responses in ways that\n         are consistent with how the messages will be processed by\n         those entities that are at the ultimate destination.",
      "ExtendedDescription": "\n\nHTTP requests or responses (\"messages\") can be malformed or unexpected in ways that cause web servers or clients to interpret the messages in different ways than intermediary HTTP agents such as load balancers, reverse proxies, web caching proxies, application firewalls, etc. For example, an adversary may be able to add duplicate or different header fields that a client or server might interpret as one set of messages, whereas the intermediary might interpret the same sequence of bytes as a different set of messages. For example, discrepancies can arise in how to handle duplicate headers like two Transfer-encoding (TE) or two Content-length (CL), or the malicious HTTP message will have different headers for TE and CL.\n\n\nThe inconsistent parsing and interpretation of messages can allow the adversary to \"smuggle\" a message to the client/server without the intermediary being aware of it.\n\n\nThis weakness is usually the result of the usage of outdated or incompatible HTTP protocol versions in the HTTP agents.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "436",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "436",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "HTTP Request Smuggling"
        },
        {
          "Term": "HTTP Response Smuggling"
        },
        {
          "Term": "HTTP Smuggling"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Non-Repudiation",
            "Access Control"
          ],
          "Impact": [
            "Unexpected State",
            "Hide Activities",
            "Bypass Protection Mechanism"
          ],
          "Note": "An attacker could create HTTP messages to exploit a number of weaknesses including 1) the message can trick the web server to associate a URL with another URL's webpage and caching the contents of the webpage (web cache poisoning attack), 2) the message can be structured to bypass the firewall protection mechanisms and gain unauthorized access to a web application, and 3) the message can invoke a script or a page that returns client credentials (similar to a Cross Site Scripting attack)."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use a web server that employs a strict HTTP parsing procedure, such as Apache [REF-433]."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use only SSL communication."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Terminate the client session after each request."
        },
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "Turn all pages to non-cacheable."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, a malformed HTTP request is sent to a website that includes a proxy server and a web server with the intent of poisoning the cache to associate one webpage with another malicious webpage."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "POST http://www.website.com/foobar.html HTTP/1.1\n Host: www.website.com\n Connection: Keep-Alive\n Content-Type: application/x-www-form-urlencoded\n Content-Length: 0\n Content-Length: 54\n\n GET /poison.html HTTP/1.1\n Host: www.website.com\n Bla: GET http://www.website.com/page_to_poison.html HTTP/1.1\n Host: www.website.com\n Connection: Keep-Alive"
            },
            {
              "BodyText": "When this request is sent to the proxy server, the proxy server parses the first four lines of the POST request and encounters the two \"Content-Length\" headers. The proxy server ignores the first header, so it assumes the request has a body of length 54 bytes. Therefore, it treats the data in the next three lines that contain exactly 54 bytes as the first request's body:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "GET /poison.html HTTP/1.1\n Host: www.website.com\n Bla:"
            },
            {
              "BodyText": "The proxy then parses the remaining bytes, which it treats as the client's second request:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "GET http://www.website.com/page_to_poison.html HTTP/1.1\n Host: www.website.com\n Connection: Keep-Alive"
            },
            {
              "BodyText": "The original request is forwarded by the proxy server to the web server. Unlike the proxy, the web server uses the first \"Content-Length\" header and considers that the first POST request has no body."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "POST http://www.website.com/foobar.html HTTP/1.1\n Host: www.website.com\n Connection: Keep-Alive\n Content-Type: application/x-www-form-urlencoded\n Content-Length: 0\n\n *Content-Length: 54 (ignored by server)*"
            },
            {
              "BodyText": "Because the web server has assumed the original POST request was length 0, it parses the second request that follows, i.e. for GET /poison.html:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "GET /poison.html HTTP/1.1\n Host: www.website.com\n Bla: GET http://www.website.com/page_to_poison.html HTTP/1.1\n Host: www.website.com\n Connection: Keep-Alive"
            },
            {
              "BodyText": "Note that the \"Bla:\" header is treated as a regular header, so it is not parsed as a separate GET request."
            },
            {
              "BodyText": "The requests the web server sees are \"POST /foobar.html\" and \"GET /poison.html\", so it sends back two responses with the contents of the \"foobar.html\" page and the \"poison.html\" page, respectively. The proxy matches these responses to the two requests it thinks were sent by the client - \"POST /foobar.html\" and \"GET /page_to_poison.html\". If the response is cacheable, the proxy caches the contents of \"poison.html\" under the URL \"page_to_poison.html\", and the cache is poisoned! Any client requesting \"page_to_poison.html\" from the proxy would receive the \"poison.html\" page."
            },
            {
              "BodyText": "When a website includes both a proxy server and a web server, some protection against this type of attack can be achieved by installing a web application firewall, or using a web server that includes a stricter HTTP parsing procedure or make all webpages non-cacheable."
            },
            {
              "BodyText": "Additionally, if a web application includes a Java servlet for processing requests, the servlet can check for multiple \"Content-Length\" headers and if they are found the servlet can return an error response thereby preventing the poison page to be cached, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { \n```\n// Set up response writer object* \n\t\t\t...\n\t\t\ttry { \n\t\t\t```\n```\n// check for multiple content length headers* \n\t\t\t\t\tEnumeration contentLengthHeaders = request.getHeaders(\"Content-Length\"); \n\t\t\t\t\tint count = 0; \n\t\t\t\t\twhile (contentLengthHeaders.hasMoreElements()) { \n\t\t\t\t\t```\n\t\t\t\t\t\tcount++; \n\t\t\t\t\t} \n\t\t\t\t\tif (count > 1) { \n```\n// output error response* } \n\t\t\t\t\telse { \n\t\t\t\t\t```\n```\n// process request* } \n\t\t\t\t\t} catch (Exception ex) {...}}"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example, a malformed HTTP request is sent to a website that includes a web server with a firewall with the intent of bypassing the web server firewall to smuggle malicious code into the system."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tPOST /page.asp HTTP/1.1\n\tHost: www.website.com\n\tConnection: Keep-Alive\n\tContent-Length: 49223\n\tzzz...zzz [\"z\" x 49152]\n\tPOST /page.asp HTTP/1.0\n\tConnection: Keep-Alive\n\tContent-Length: 30\n\tPOST /page.asp HTTP/1.0\n\tBla: POST /page.asp?cmd.exe HTTP/1.0\n\tConnection: Keep-Alive\n```"
            },
            {
              "BodyText": "When this request is sent to the web server, the first POST request has a content-length of 49,223 bytes, and the firewall treats the line with 49,152 copies of \"z\" and the lines with an additional lines with 71 bytes as its body (49,152+71=49,223). The firewall then continues to parse what it thinks is the second request starting with the line with the third POST request."
            },
            {
              "BodyText": "Note that there is no CRLF after the \"Bla: \" header so the POST in the line is parsed as the value of the \"Bla:\" header. Although the line contains the pattern identified with a worm (\"cmd.exe\"), it is not blocked, since it is considered part of a header value. Therefore, \"cmd.exe\" is smuggled through the firewall."
            },
            {
              "BodyText": "When the request is passed through the firewall the web server the first request is ignored because the web server does not find an expected \"Content-Type: application/x-www-form-urlencoded\" header, and starts parsing the second request."
            },
            {
              "BodyText": "This second request has a content-length of 30 bytes, which is exactly the length of the next two lines up to the space after the \"Bla:\" header. And unlike the firewall, the web server processes the final POST as a separate third request and the \"cmd.exe\" worm is smuggled through the firewall to the web server."
            },
            {
              "BodyText": "To avoid this attack a Web server firewall product must be used that is designed to prevent this type of attack."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The interpretation of HTTP responses can be manipulated if response headers include a space between the header name and colon, or if HTTP 1.1 headers are sent through a proxy configured for HTTP 1.0, allowing for HTTP response smuggling. This can be exploited in web browsers and other applications when used in combination with various proxy servers. For instance, the HTTP response interpreted by the front-end/client HTTP agent/entity - in this case the web browser - can interpret a single response from an adversary-compromised web server as being two responses from two different web sites. In the Example below, notice the extra space after the Content-Length and Set-Cookie headers."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "HTTP/1.1 200 OK\n Date: Fri, 08 Aug 2016 08:12:31 GMT\n Server: Apache (Unix)\n Connection: Keep-Alive\n Content-Encoding: gzip\n Content-Type: text/html\n\n **Content-Length :**  2345\n Transfer-Encoding: chunked\n\n **Set-Cookie :**  token=\"Malicious Code\"\n\n <HTML> ... \"Malicious Code\""
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24766",
          "Description": "SSL/TLS-capable proxy allows HTTP smuggling when used in tandem with HTTP/1.0 services, due to inconsistent interpretation and input sanitization of HTTP messages within the body of another message",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24766"
        },
        {
          "Reference": "CVE-2021-37147",
          "Description": "Chain: caching proxy server has improper input validation (CWE-20) of headers, allowing HTTP response smuggling (CWE-444) using an \"LF line ending\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37147"
        },
        {
          "Reference": "CVE-2020-8287",
          "Description": "Node.js platform allows request smuggling via two Transfer-Encoding headers",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8287"
        },
        {
          "Reference": "CVE-2006-6276",
          "Description": "Web servers allow request smuggling via inconsistent HTTP headers.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6276"
        },
        {
          "Reference": "CVE-2005-2088",
          "Description": "HTTP server allows request smuggling with both a \"Transfer-Encoding: chunked\" header and a Content-Length header",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2088"
        },
        {
          "Reference": "CVE-2005-2089",
          "Description": "HTTP server allows request smuggling with both a \"Transfer-Encoding: chunked\" header and a Content-Length header",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2089"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "HTTP Request Smuggling"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "26",
          "EntryName": "HTTP Request Smuggling"
        },
        {
          "TaxonomyName": "WASC",
          "EntryID": "27",
          "EntryName": "HTTP Response Smuggling"
        }
      ],
      "RelatedAttackPatterns": [
        "273",
        "33"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-433",
          "Authors": [
            "Chaim Linhart",
            "Amit Klein",
            "Ronen Heled",
            "Steve Orrin"
          ],
          "Title": "HTTP Request Smuggling",
          "URL": "https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1273",
          "Authors": [
            "Robert Auger"
          ],
          "Title": "HTTP Response Smuggling",
          "PublicationYear": "2011",
          "PublicationMonth": "02",
          "PublicationDay": "01",
          "URL": "http://projects.webappsec.org/w/page/13246930/HTTP%20Response%20Smuggling"
        },
        {
          "ExternalReferenceID": "REF-1274",
          "Authors": [
            "Dzevad Alibegovic"
          ],
          "Title": "HTTP Request Smuggling: Complete Guide to Attack Types and Prevention",
          "PublicationYear": "2021",
          "PublicationMonth": "08",
          "PublicationDay": "23",
          "URL": "https://brightsec.com/blog/http-request-smuggling-hrs/"
        },
        {
          "ExternalReferenceID": "REF-1275",
          "Authors": [
            "Busra Demir"
          ],
          "Title": "A Pentester's Guide to HTTP Request Smuggling",
          "PublicationYear": "2020",
          "PublicationMonth": "10",
          "PublicationDay": "15",
          "URL": "https://www.cobalt.io/blog/a-pentesters-guide-to-http-request-smuggling"
        },
        {
          "ExternalReferenceID": "REF-1276",
          "Authors": [
            "Edi Kogan",
            "Daniel Kerman"
          ],
          "Title": "HTTP Desync Attacks in the Wild and How to Defend Against Them",
          "PublicationYear": "2019",
          "PublicationMonth": "10",
          "PublicationDay": "29",
          "URL": "https://www.imperva.com/blog/http-desync-attacks-and-defence-methods/"
        },
        {
          "ExternalReferenceID": "REF-1277",
          "Authors": [
            "James Kettle"
          ],
          "Title": "HTTP Desync Attacks: Request Smuggling Reborn",
          "PublicationYear": "2019",
          "PublicationMonth": "08",
          "PublicationDay": "07",
          "URL": "https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1278",
          "Authors": [
            "PortSwigger"
          ],
          "Title": "HTTP request smuggling",
          "URL": "https://portswigger.net/web-security/request-smuggling",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Theoretical",
          "Note": "Request smuggling can be performed due to a multiple interpretation error, where the target is an intermediary or monitor, via a consistency manipulation (Transfer-Encoding and Content-Length headers)."
        }
      ]
    },
    {
      "ID": "446",
      "Name": "UI Discrepancy for Security Feature",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The user interface does not correctly enable or configure a security feature, but the interface provides feedback that causes the user to believe that the feature is in a secure state.",
      "ExtendedDescription": "When the user interface does not properly reflect what the user asks of it, then it can lead the user into a false sense of security. For example, the user might check a box to enable a security option to enable encrypted communications, but the product does not actually enable the encryption. Alternately, the user might provide a \"restrict ALL\" access control rule, but the product only implements \"restrict SOME\".",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1446",
          "Description": "UI inconsistency; visited URLs list not cleared when \"Clear History\" option is selected.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1446"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "User interface inconsistency"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry is likely a loose composite that could be broken down into the different types of errors that cause the user interface to have incorrect interactions with the underlying security feature."
        }
      ]
    },
    {
      "ID": "447",
      "Name": "Unimplemented or Unsupported Feature in UI",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A UI function for a security feature appears to be supported and gives feedback to the user that suggests that it is supported, but the underlying functionality is not implemented.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "446",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "671",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Perform functionality testing before deploying the application."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-0127",
          "Description": "GUI configuration tool does not enable a security option when a checkbox is selected, although that option is honored when manually set in the configuration file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0127"
        },
        {
          "Reference": "CVE-2001-0863",
          "Description": "Router does not implement a specific keyword when it is used in an ACL, allowing filter bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0863"
        },
        {
          "Reference": "CVE-2001-0865",
          "Description": "Router does not implement a specific keyword when it is used in an ACL, allowing filter bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0865"
        },
        {
          "Reference": "CVE-2004-0979",
          "Description": "Web browser does not properly modify security setting when the user sets it.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0979"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Unimplemented or unsupported feature in UI"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "This issue needs more study, as there are not many examples. It is not clear whether it is primary or resultant."
        }
      ]
    },
    {
      "ID": "448",
      "Name": "Obsolete Feature in UI",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "A UI function is obsolete and the product does not warn the user.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "446",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Remove the obsolete feature from the UI. Warn the user that the feature is no longer supported."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Obsolete feature in UI"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "449",
      "Name": "The UI Performs the Wrong Action",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The UI performs the wrong action with respect to the user's request.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "446",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation",
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Perform extensive functionality testing of the UI. The UI should behave as specified."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2001-1387",
          "Description": "Network firewall accidentally implements one command line option as if it were another, possibly leading to behavioral infoleak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1387"
        },
        {
          "Reference": "CVE-2001-0081",
          "Description": "Command line option correctly suppresses a user prompt but does not properly disable a feature, although when the product prompts the user, the feature is properly disabled.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0081"
        },
        {
          "Reference": "CVE-2002-1977",
          "Description": "Product does not \"time out\" according to user specification, leaving sensitive data available after it has expired.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1977"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "The UI performs the wrong action"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "450",
      "Name": "Multiple Interpretations of UI Input",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The UI has multiple interpretations of user input but does not prompt the user when it selects the less secure interpretation.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "357",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"
        },
        {
          "MitigationID": "MIT-20",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "Multiple Interpretations of UI Input"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "451",
      "Name": "User Interface (UI) Misrepresentation of Critical Information",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The user interface (UI) does not properly represent critical information to the user, allowing the information - or its source - to be obscured or spoofed. This is often a component in phishing attacks.",
      "ExtendedDescription": "\n\nIf an attacker can cause the UI to display erroneous data, or to otherwise convince the user to display information that appears to come from a trusted source, then the attacker could trick the user into performing the wrong action. This is often a component in phishing attacks, but other kinds of problems exist. For example, if the UI is used to monitor the security state of a system or network, then omitting or obscuring an important indicator could prevent the user from detecting and reacting to a security-critical event.\n\n\nUI misrepresentation can take many forms:\n\n\n  - Incorrect indicator: incorrect information is displayed, which prevents the user from understanding the true state of the product or the environment the product is monitoring, especially of potentially-dangerous conditions or operations. This can be broken down into several different subtypes.\n\n  - Overlay: an area of the display is intended to give critical information, but another process can modify the display by overlaying another element on top of it. The user is not interacting with the expected portion of the user interface. This is the problem that enables clickjacking attacks, although many other types of attacks exist that involve overlay.\n\n  - Icon manipulation: the wrong icon, or the wrong color indicator, can be influenced (such as making a dangerous .EXE executable look like a harmless .GIF)\n\n  - Timing: the product is performing a state transition or context switch that is presented to the user with an indicator, but a race condition can cause the wrong indicator to be used before the product has fully switched context. The race window could be extended indefinitely if the attacker can trigger an error.\n\n  - Visual truncation: important information could be truncated from the display, such as a long filename with a dangerous extension that is not displayed in the GUI because the malicious portion is truncated. The use of excessive whitespace can also cause truncation, or place the potentially-dangerous indicator outside of the user's field of view (e.g. \"filename.txt .exe\"). A different type of truncation can occur when a portion of the information is removed due to reasons other than length, such as the accidental insertion of an end-of-input marker in the middle of an input, such as a NUL byte in a C-style string.\n\n  - Visual distinction: visual information might be presented in a way that makes it difficult for the user to quickly and correctly distinguish between critical and unimportant segments of the display.\n\n  - Homographs: letters from different character sets, fonts, or languages can appear very similar (i.e. may be visually equivalent) in a way that causes the human user to misread the text (for example, to conduct phishing attacks to trick a user into visiting a malicious web site with a visually-similar name as a trusted site). This can be regarded as a type of visual distinction issue.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "221",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "346",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation",
            "Access Control"
          ],
          "Impact": [
            "Hide Activities",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Perform data validation (e.g. syntax, length, etc.) before interpreting the data."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Output Encoding",
          "Description": "Create a strategy for presenting information, and plan for how to display unusual characters."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2004-2227",
          "Description": "Web browser's filename selection dialog only shows the beginning portion of long filenames, which can trick users into launching executables with dangerous extensions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2227"
        },
        {
          "Reference": "CVE-2001-0398",
          "Description": "Attachment with many spaces in filename bypasses \"dangerous content\" warning and uses different icon. Likely resultant.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0398"
        },
        {
          "Reference": "CVE-2001-0643",
          "Description": "Misrepresentation and equivalence issue.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0643"
        },
        {
          "Reference": "CVE-2005-0593",
          "Description": "Lock spoofing from several different weaknesses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0593"
        },
        {
          "Reference": "CVE-2004-1104",
          "Description": "Incorrect indicator: web browser can be tricked into presenting the wrong URL",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1104"
        },
        {
          "Reference": "CVE-2005-0143",
          "Description": "Incorrect indicator: Lock icon displayed when an insecure page loads a binary file loaded from a trusted site.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0143"
        },
        {
          "Reference": "CVE-2005-0144",
          "Description": "Incorrect indicator: Secure \"lock\" icon is presented for one channel, while an insecure page is being simultaneously loaded in another channel.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0144"
        },
        {
          "Reference": "CVE-2004-0761",
          "Description": "Incorrect indicator: Certain redirect sequences cause security lock icon to appear in web browser, even when page is not encrypted.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0761"
        },
        {
          "Reference": "CVE-2004-2219",
          "Description": "Incorrect indicator: Spoofing via multi-step attack that causes incorrect information to be displayed in browser address bar.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2219"
        },
        {
          "Reference": "CVE-2004-0537",
          "Description": "Overlay: Wide \"favorites\" icon can overlay and obscure address bar",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0537"
        },
        {
          "Reference": "CVE-2005-2271",
          "Description": "Visual distinction: Web browsers do not clearly associate a Javascript dialog box with the web page that generated it, allowing spoof of the source of the dialog. \"origin validation error\" of a sort?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2271"
        },
        {
          "Reference": "CVE-2005-2272",
          "Description": "Visual distinction: Web browsers do not clearly associate a Javascript dialog box with the web page that generated it, allowing spoof of the source of the dialog. \"origin validation error\" of a sort?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2272"
        },
        {
          "Reference": "CVE-2005-2273",
          "Description": "Visual distinction: Web browsers do not clearly associate a Javascript dialog box with the web page that generated it, allowing spoof of the source of the dialog. \"origin validation error\" of a sort?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2273"
        },
        {
          "Reference": "CVE-2005-2274",
          "Description": "Visual distinction: Web browsers do not clearly associate a Javascript dialog box with the web page that generated it, allowing spoof of the source of the dialog. \"origin validation error\" of a sort?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2274"
        },
        {
          "Reference": "CVE-2001-1410",
          "Description": "Visual distinction: Browser allows attackers to create chromeless windows and spoof victim's display using unprotected Javascript method.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1410"
        },
        {
          "Reference": "CVE-2002-0197",
          "Description": "Visual distinction: Chat client allows remote attackers to spoof encrypted, trusted messages with lines that begin with a special sequence, which makes the message appear legitimate.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0197"
        },
        {
          "Reference": "CVE-2005-0831",
          "Description": "Visual distinction: Product allows spoofing names of other users by registering with a username containing hex-encoded characters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0831"
        },
        {
          "Reference": "CVE-2003-1025",
          "Description": "Visual truncation: Special character in URL causes web browser to truncate the user portion of the \"user@domain\" URL, hiding real domain in the address bar.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1025"
        },
        {
          "Reference": "CVE-2005-0243",
          "Description": "Visual truncation: Chat client does not display long filenames in file dialog boxes, allowing dangerous extensions via manipulations including (1) many spaces and (2) multiple file extensions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0243"
        },
        {
          "Reference": "CVE-2005-1575",
          "Description": "Visual truncation: Web browser file download type can be hidden using whitespace.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1575"
        },
        {
          "Reference": "CVE-2004-2530",
          "Description": "Visual truncation: Visual truncation in chat client using whitespace to hide dangerous file extension.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2530"
        },
        {
          "Reference": "CVE-2005-0590",
          "Description": "Visual truncation: Dialog box in web browser allows user to spoof the hostname via a long \"user:pass\" sequence in the URL, which appears before the real hostname.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0590"
        },
        {
          "Reference": "CVE-2004-1451",
          "Description": "Visual truncation: Null character in URL prevents entire URL from being displayed in web browser.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1451"
        },
        {
          "Reference": "CVE-2004-2258",
          "Description": "Miscellaneous -- [step-based attack, GUI] -- Password-protected tab can be bypassed by switching to another tab, then back to original tab.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2258"
        },
        {
          "Reference": "CVE-2005-1678",
          "Description": "Miscellaneous -- Dangerous file extensions not displayed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1678"
        },
        {
          "Reference": "CVE-2002-0722",
          "Description": "Miscellaneous -- Web browser allows remote attackers to misrepresent the source of a file in the File Download dialog box.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0722"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "PLOVER",
          "EntryName": "UI Misrepresentation of Critical Information"
        }
      ],
      "RelatedAttackPatterns": [
        "154",
        "163",
        "164",
        "173",
        "98"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-434",
          "Section": "7.16. Foil Semantic Attacks",
          "Authors": [
            "David Wheeler"
          ],
          "Title": "Secure Programming for Linux and Unix HOWTO",
          "PublicationYear": "2003",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "URL": "http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/semantic-attacks.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry should be broken down into more precise entries. See extended description."
        },
        {
          "Type": "Research Gap",
          "Note": "Misrepresentation problems are frequently studied in web browsers, but there are no known efforts for classifying these kinds of problems in terms of the shortcomings of the interface. In addition, many misrepresentation issues are resultant."
        }
      ]
    }
  ]
}