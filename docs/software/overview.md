# Overview


1. [How AI is Changing Software Engineering](./introduction.md) how software is changing

 an overview of Software Engineering and how it has evolved with AI and Generative AI.

It looks at the early days of Software Engineering and the transition from WaterFall to Agile - and the emphasis on communication over code and documentation.

Then it looks at how AI gave us Software 2.0 where "AI is eating software", and how Generative AI gave us Software 1.0 Redux where "AI is feeding software" (and Vibe Coding).

Andrej Karpathy quotes are used throughout as a consistent commentary from someone who has been formative in this space.

Key Takeaways

Accelerated Innovation: AI compresses idea-to-prototype cycles from weeks to minutes, fundamentally changing development velocity.

Inverted Priorities: Upstream artifacts (requirements, architecture, contracts) become primary deliverables, while code becomes a generated byproduct.

Evolved Skill Sets: Success now requires mastering requirements engineering, system architecture, and human-AI collaboration alongside traditional coding skills.

New Paradigms: We're witnessing both Software 2.0 (AI eating software) and Software 1.0 Redux (AI feeding traditional development), each suited to different problem domains.


2. [Software Assurance](./software_assurance.md) covers the immutable principles 

This section provides a brief overview of Software Assurance fundamentals that are independent of the Software Development Life Cycle (SDLC) Methodology or what entity is creating the software:

Software Assurance
Verification and Validation
Architecture
Laws of Software Architecture
Quality Attributes Drive the Architecture Design
It also covers the what, how, and why for the how, of Software Engineering.

Takeaways

The key artifact that distinguishes verification activities from validation activities is the software requirements.

It is important to understand the what independent of the how (requirements vs design).

It is important to understand the why for the how (e.g. ADRs) aka

"Why is more important than how."

Everything in software architecture is a trade-off.

Quality Attributes drive the architecture design.

3. [Software Artifacts](./software_artifacts.md) covers the artifacts of software engineering
    This section builds on [How AI is Changing Software Engineering](./introduction.md) and [Software Assurance](./software_assurance.md) to focus on the Software Engineering artifacts, which are becoming the core deliverable, the **active contracts** that guide code generation and system behavior. 


## Key Principles for AI-Era Artifacts

!!! success "Best Practices"

    1. **Precision Over Brevity** - AI needs explicit, unambiguous specifications
    2. **Machine-Readable Formats** - Use structured data (JSON, YAML, Markdown with frontmatter)
    3. **Version Everything** - Track changes to specifications alongside generated code
    4. **Automate Validation** - Ensure AI outputs meet specification requirements
    5. **Maintain Traceability** - Link generated code back to originating specifications

These artifacts serve as the foundation for AI-driven development, transforming from passive documentation into active contracts that guide intelligent code generation and system evolution.


4. [AI Coding Tools](software/code/code_assistant_agents.md)
It covers both Coding Assistants and Autonomous Coding Agents

This page gives a comparison of AI Coding Tools by Autonomy Levels.
It starts by defining Autonomy Levels for AI Coding Tools.
Then it categorizes and compares these AI Coding Tools based on these Autonomy Levels to focus on the Software Engineering artifacts, which are becoming the core deliverable, the **active contracts** that guide code generation and system behavior. 

Tools at Level 5 are omitted from the table as no productized examples currently exist; this level remains theoretical and experimental.)*

This comparison underscores that as we progress from Level 1 to Level 4, AI tools take on more of the coding burden — from merely completing the next line of code to handling whole features. Developers today can mix and match these tools to suit their needs, but it’s crucial to understand each tool’s autonomy and limits to use them effectively. The field is evolving rapidly, and what is Level 3 today may become Level 4 tomorrow. Keeping an eye on these autonomy levels helps set expectations and guides us in adopting AI tools that truly enhance productivity while maintaining quality and control in software development.

!!! tip

    See also [Feature Comparison and Analysis of Leading AI IDEs: Cursor,
    Windsurf, Roo Code, and GitHub Copilot, May 27, 2025](../../assets/docs/IDEs_Feature_Comparison.pdf).

    
1. [Leaderboards](software/code/leaderboards.md)  is a list of benchmarks for LLMs that are used to help with coding.

