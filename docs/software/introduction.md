# Overview

!!! abstract "Overview"

    There is a LOT more to Software Engineering than Code Generation. 
Software 2.0
    https://karpathy.medium.com/software-2-0-a64152b37c35 
Andrej Karpathy, 2017
Software (1.0) is eating the world, and now AI (Software 2.0) is eating software.

Software 1.0 is code we write. Software 2.0 is code written by the optimization based on an evaluation criterion (such as “classify this training data correctly”). It is likely that any setting where the program is not obvious but one can repeatedly evaluate the performance of it (e.g. — did you classify some images correctly? do you win games of Go?) will be subject to this transition, because the optimization can find much better code than what a human can write.



## Context

I started my career as a software engineer working on embedded devices (High security PinPads). 
After years of programming, I began to find it tedious and repetitive and wanted something different. I wanted to 
Since then, I've worked across all part of the stack, and all parts of the SDLC.



## Natural Language

“The hottest new programming language is English”
https://x.com/karpathy/status/1617979122625712128?lang=en


## Design Thinking Double Diamond

<figure markdown>
![](../assets/images/doublediamondprocess.png)
</figure>

!!! tip

    See also the Design Council's new [Systemic Design Framework](https://medium.com/design-council/developing-our-new-systemic-design-framework-e0f74fe118f7) that builds on the Double Diamond.

    **AI Assisted Software Engineering can result in significantly shorter feedback and learning cycles.**


## Leveraging AI to Improve Software Engineering

Tracy Bannon's excellent talk [Applying AI to the SDLC: New Ideas and Gotchas! - Leveraging AI to Improve Software Engineering](https://www.infoq.com/presentations/ai-sdlc/) includes a model for where AI can be used with DevSecOps.

<figure markdown>
![](../assets/images/ai_devsecops.png)
</figure>

## Software Engineering Artifacts

Software engineering artifacts are tangible byproducts created during the software development lifecycle, providing documentation, guidance, or records of decisions. Common artifacts include:

### 1. Research

* Technical Research documentation

### 2. Requirements & Specifications

* User stories
* Functional & non-functional requirements
* Use-case diagrams and scenarios
* Feature backlog

### 3. Architecture and Design

* Architecture diagrams (UML diagrams, component diagrams)
* Architectural Decision Records (ADRs)
* System design documents
* Interface design documents (API specifications)

### 4. Implementation

* Source code
* Code repositories (e.g., Git)
* Pull requests and code reviews
* Refactoring documentation (e.g., Refactoring plans, commit histories)
* Legacy refactoring documentation

### 5. Testing & Quality Assurance

* Test plans and test cases
* Unit test suites
* Integration test suites
* Performance and load tests
* Regression testing documentation
* Bug and issue tracking (e.g., Jira tickets, GitHub Issues)
* Quality metrics and reports (coverage reports, linting reports)

### 6. Security

* Threat modeling artifacts
* Security test reports (penetration tests, vulnerability scans)
* Security code reviews
* Audit reports

### 7. Deployment & Operations

* Deployment scripts and Infrastructure as Code (IaC) artifacts
* CI/CD pipeline configurations
* Release notes
* Monitoring dashboards and alerts
* Operational documentation (runbooks, disaster recovery plans)

### 8. Maintenance & Evolution

* Change logs
* Incident management records
* Maintenance logs
* Post-mortem reports

### 9. Documentation & Communication

* Project plans and schedules
* Meeting notes and decisions
* User documentation and manuals
* API documentation (e.g., Swagger/OpenAPI specs)

These artifacts help in achieving clarity, communication, traceability, and accountability throughout the software development lifecycle (SDLC), ensuring higher software quality and maintainability.

